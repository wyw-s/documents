(window.webpackJsonp=window.webpackJsonp||[]).push([[337],{1030:function(t,a,s){"use strict";s.r(a);var r=s(1),e=Object(r.a)({},(function(){var t=this,a=t.$createElement,s=t._self._c||a;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("blockquote",[s("p",[t._v("尽管开发者将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。\n在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。")])]),t._v(" "),s("h2",{attrs:{id:"分词-词法分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#分词-词法分析"}},[t._v("#")]),t._v(" 分词/词法分析")]),t._v(" "),s("blockquote",[s("p",[t._v("这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元。例如，考虑程序 var a = 2;。这段程序通常会被分解成为下面这些词法单元： var、 a、 =、 2 、 ;空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。")])]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法\n单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析。")])]),t._v(" "),s("h2",{attrs:{id:"解析-语法分析"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#解析-语法分析"}},[t._v("#")]),t._v(" 解析/语法分析")]),t._v(" "),s("blockquote",[s("p",[t._v("这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree， AST）。var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下来是一个叫作 Identifier（它的值是 a）的子节点，以及一个叫作 AssignmentExpression的子节点。 AssignmentExpression 节点有一个叫作 NumericLiteral（它的值是 2）的子节点。")])]),t._v(" "),s("h2",{attrs:{id:"代码生成"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#代码生成"}},[t._v("#")]),t._v(" 代码生成")]),t._v(" "),s("blockquote",[s("p",[t._v("将 AST 转换为可执行代码的过程被称为代码生成。")])]),t._v(" "),s("p",[t._v("简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指\n令，用来创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中。")]),t._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),s("p",[t._v("比起那些编译过程只有三个步骤的语言的编译器， JavaScript 引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等，JavaScript 引擎不会有大量的（像其他语言编译器那么多的）时间用来进行优化，因为与其他语言不同， JavaScript 的编译过程不是发生在构建之前的。对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。因此，JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。")])])])}),[],!1,null,null,null);a.default=e.exports}}]);