(window.webpackJsonp=window.webpackJsonp||[]).push([[347],{1111:function(t,o,e){"use strict";e.r(o);var n=e(1),s=Object(n.a)({},(function(){var t=this,o=t.$createElement,e=t._self._c||o;return e("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[e("blockquote",[e("p",[t._v("​\t当一个请求url的"),e("strong",[t._v("协议、域名、端口")]),t._v("三者之间任意一个与当前页面url不同即为跨域；")])]),t._v(" "),e("ol",[e("li",[t._v("API跨域可以通过服务器上nginx反向代理；")]),t._v(" "),e("li",[t._v("本地webpack dev server可以设置 proxy；")]),t._v(" "),e("li",[t._v("new Image, 设src 的时候，图片需要设置Cors\ncors需要后台配合设置HTTP响应头，如果请求不是简单请求（1. method：get，post，2. content-type：三种表单自带的content-type，3. 没有自定义的HTTP header），浏览器会先发送option预检请求，后端需要响应option请求，然后浏览器才会发送正式请求，cors通过白名单的形式允许指定的域发送请求；")]),t._v(" "),e("li",[t._v("jsonp是浏览器会放过 img script标签引入资源的方式。所以可以通过后端返回一段执行js函数的脚本，将数据作为参数传入。然后在前端执行这段脚本。双方约定一个函数的名称。\n联调的时候会需要跨域，线上前端站点域和后台接口不一致也需要跨域，开发时跨域可以通过代理服务器来转发请求，因为跨域本身是浏览器对请求的限制，常见的跨域处理还有JSONP和cors，jsonp是利用脚本资源请求本身就可以跨域的特性，通过与请求一起发送回调函数名，后台返回script脚本直接执行回调，但是由于资源请求是get类型，请求参数长度有限制，也不能进行post请求。cors需要后台配合设置HTTP响应头，如果请求不是简单请求（1. method：get，post，2. content-type：三种表单自带的content-type，3. 没有自定义的HTTP header），浏览器会先发送option预检请求，后端需要响应option请求，然后浏览器才会发送正式请求，cors通过白名单的形式允许指定的域发送请求\n同源策略只是浏览器客户端的防护机制，当发现非同源HTTP请求时会拦截响应，但服务器依然处理了这个请求。\n服务器端不拦截，所以在同源服务器下做代理，可以实现跨域。\n我之前这么看的node中间层处理跨域。")])])])}),[],!1,null,null,null);o.default=s.exports}}]);