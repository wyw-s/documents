<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://wangyawei.top/rss.xml" rel="self" type="application/rss+xml"/>
    <title>Mr. Almost</title>
    <link>https://wangyawei.top/</link>
    <description>Smoking the same cigarettes, tapping the same computers, writing the same code  </description>
    <language>zh-CN</language>
    <pubDate>Fri, 24 Sep 2021 17:37:12 GMT</pubDate>
    <lastBuildDate>Fri, 24 Sep 2021 17:37:12 GMT</lastBuildDate>
    <generator>@mr-hope/vuepress-plugin-feed</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>Copyright by Mr. Almost</copyright>
    <category>DOCKER</category>
    <category>EXPRESS</category>
    <category>JAVA</category>
    <category>JENKINS</category>
    <category>KOA</category>
    <category>LINUX</category>
    <category>MYSQL</category>
    <category>NGINX</category>
    <category>ES6</category>
    <category>nodejs</category>
    <category>TOMCAT</category>
    <category>设计模式</category>
    <category>AJAX</category>
    <category>CSS</category>
    <category>HTML</category>
    <category>es6</category>
    <category>javascript</category>
    <category>JQUERY</category>
    <category>NPM</category>
    <category>REACT</category>
    <category>vue</category>
    <category>WEBPACK</category>
    <category>面试题</category>
    <category>issues</category>
    <category>other</category>
    <category>GIT</category>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/guide/</link>
      <guid>https://wangyawei.top/guide/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>完成这个文档笔记，也刚好把自己以前记的笔记做一次整理，虽然也花了不少时间，不过也算是完成了吧，在写这个文档笔记之前也调研了其它的文档笔记，但是在网上得到了反馈有很多都是我们的尤大大写的这个<code>vuepress</code>专为文档设计而提供的解决方案，又由于看的说明文档可以自己以vue的方式开发自定义主题，所以最后就选择了，vuepress。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>Home</title>
      <link>https://wangyawei.top/</link>
      <guid>https://wangyawei.top/</guid>
      <source url="https://wangyawei.top/rss.xml">Home</source>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/backEnd/docker/</link>
      <guid>https://wangyawei.top/views/backEnd/docker/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>DOCKER</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些自己平时积累的docker相关的知识；</p>
</blockquote>
<h2 id="参考资料"> 参考资料：</h2>
<h4 id=""> </h4>
]]></content:encoded>
    </item>
    <item>
      <title>docker安装</title>
      <link>https://wangyawei.top/views/backEnd/docker/docker-note-0/</link>
      <guid>https://wangyawei.top/views/backEnd/docker/docker-note-0/</guid>
      <source url="https://wangyawei.top/rss.xml">docker安装</source>
      <category>DOCKER</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="win版docker安装"> win版Docker安装</h2>
<blockquote>
<p>Docker 并非是一个通用的容器工具，它依赖于已存在并运行的 Linux 内核环境。Docker 实质上是在已经运行的 Linux 下制造了一个隔离的文件环境，因此它执行的效率几乎等同于所部署的 Linux 主机。因此，Docker 必须部署在 Linux 内核的系统上。如果其他系统想部署 Docker 就必须安装一个虚拟 Linux 环境。在 Windows 上部署 Docker 的方法都是先安装一个虚拟机，并在安装 Linux 系统的的虚拟机中运行 Docker。</p>
</blockquote>
<ol>
<li>安装 Hyper-V;
<ul>
<li>Hyper-V 是微软开发的虚拟机，类似于 VMWare 或 VirtualBox，仅适用于 Windows 10。这是 Docker Desktop for Windows 所使用的虚拟机。</li>
<li>安装步骤请查看另一篇文章：<code>win10 使用hyper-v</code></li>
</ul>
</li>
<li>下载；<a href="https://hub.docker.com/editions/community/docker-ce-desktop-windows" target="_blank" rel="noopener noreferrer">官方下载地址</a></li>
<li>双击安装；</li>
<li>安装成功后，桌面会有docker鲸鱼的图标；</li>
<li>双击鲸鱼图标启动；</li>
<li>通知栏上会出现个小鲸鱼的图标<img src="https://www.runoob.com/wp-content/uploads/2017/12/1513582421-4552-whale-x-win.png" alt="img" />，这表示 Docker 正在运行。</li>
</ol>
<div><p>提示</p>
<p><em>如果启动中遇到因 WSL 2 导致地错误，请安装</em> <a href="https://docs.microsoft.com/zh-cn/windows/wsl/install-win10" target="_blank" rel="noopener noreferrer">WSL 2</a><em>。</em></p>
</div>
<p><strong>测试docker是否安装成功；</strong></p>
<div><pre><code><span># 使用 docker -v</span>
PS C:<span>\</span>Users<span>\</span>ASUS<span>></span> docker -v
Docker version <span>20.10</span>.6, build 370c289
PS C:<span>\</span>Users<span>\</span>ASUS<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>测试hello world</strong></p>
<div><pre><code><span># docker run hello-world 来载入测试镜像测试。以下表示成功</span>
PS C:<span>\</span>Users<span>\</span>ASUS<span>></span> docker run hello-world
Unable to <span>find</span> image <span>'hello-world:latest'</span> locally
latest: Pulling from library/hello-world
b8dfde127a29: Pull complete
Digest: sha256:5122f6204b6a3596e048758cabba3c46b1c937a46b5be6225b835d091b90e46c
Status: Downloaded newer image <span>for</span> hello-world:latest

Hello from Docker<span>!</span>
This message shows that your installation appears to be working correctly.

To generate this message, Docker took the following steps:
 <span>1</span>. The Docker client contacted the Docker daemon.
 <span>2</span>. The Docker daemon pulled the <span>"hello-world"</span> image from the Docker Hub.
    <span>(</span>amd64<span>)</span>
 <span>3</span>. The Docker daemon created a new container from that image <span>which</span> runs the
    executable that produces the output you are currently reading.
 <span>4</span>. The Docker daemon streamed that output to the Docker client, <span>which</span> sent it
    to your terminal.

To try something <span>more</span> ambitious, you can run an Ubuntu container with:
 $ docker run -it ubuntu <span>bash</span>

Share images, automate workflows, and <span>more</span> with a <span>free</span> Docker ID:
 https://hub.docker.com/

For <span>more</span> examples and ideas, visit:
 https://docs.docker.com/get-started/

PS C:<span>\</span>Users<span>\</span>ASUS<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div>]]></content:encoded>
      <enclosure url="https://www.runoob.com/wp-content/uploads/2017/12/1513582421-4552-whale-x-win.png" type="image/png"/>
    </item>
    <item>
      <title>容器的使用</title>
      <link>https://wangyawei.top/views/backEnd/docker/docker-note-02/</link>
      <guid>https://wangyawei.top/views/backEnd/docker/docker-note-02/</guid>
      <source url="https://wangyawei.top/rss.xml">容器的使用</source>
      <category>DOCKER</category>
      <pubDate>Tue, 08 Jun 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="获取镜像"> 获取镜像</h2>
<blockquote>
<p>如果我们本地没有 ubuntu 镜像，我们可以使用 docker pull 命令来载入 ubuntu 镜像：</p>
</blockquote>
<div><pre><code>PS C:<span>\</span>Users<span>\</span>ASUS<span>></span> docker <span>ps</span>
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
PS C:<span>\</span>Users<span>\</span>ASUS<span>></span> docker pull ubuntu
Using default tag: latest
latest: Pulling from library/ubuntu
345e3491a907: Pull complete
57671312ef6f: Pull complete
5e9250ddb7d0: Pull complete
Digest: sha256:adf73ca014822ad8237623d388cedf4d5346aa72c270c5acc01431cc93e18e2d
Status: Downloaded newer image <span>for</span> ubuntu:latest
docker.io/library/ubuntu:latest
PS C:<span>\</span>Users<span>\</span>ASUS<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="启动容器"> 启动容器</h2>
<blockquote>
<p>以下命令使用 ubuntu 镜像启动一个容器，参数为以命令行模式进入该容器：</p>
</blockquote>
<div><pre><code><span># docker run -it ubuntu /bin/bash </span>
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker run -it ubuntu /bin/bash
root@aa996b05499f:/<span># ls</span>
bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@aa996b05499f:/<span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>参数说明：</p>
<ul>
<li><strong>-i</strong>: 交互式操作。</li>
<li><strong>-t</strong>: 终端。</li>
<li><strong>ubuntu</strong>: ubuntu 镜像。</li>
<li><strong>/bin/bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</li>
</ul>
<div><pre><code><span># exit 退出终端</span>
root@aa996b05499f:/<span># exit</span>
<span>exit</span>
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="启动已停止运行的容器"> 启动已停止运行的容器</h3>
<p>查看所有容器；</p>
<div><pre><code><span># docker ps -a</span>
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>ps</span> -a
CONTAINER ID   IMAGE                    COMMAND                  CREATED          STATUS                      PORTS     NAMES
aa996b05499f   ubuntu                   <span>"/bin/bash"</span>              <span>17</span> minutes ago   Exited <span>(</span><span>0</span><span>)</span> <span>6</span> seconds ago              hopeful_goodall
c1110cbddef9   ubuntu:latest            <span>"/bin/bash"</span>              <span>4</span> hours ago      Up <span>4</span> hours                            myUbantu
0fb0e9c06a91   ubuntu:15.10             <span>"/bin/sh -c 'while t…"</span>   <span>16</span> hours ago     Exited <span>(</span><span>137</span><span>)</span> <span>15</span> hours ago             blissful_bassi
8a725ffa2d7b   ubuntu:15.10             <span>"/bin/bash"</span>              <span>16</span> hours ago     Exited <span>(</span><span>0</span><span>)</span> <span>16</span> hours ago               competent_taussig
4f3d7da2824d   ubuntu:15.10             <span>"/bin/echo 'Hello wo…"</span>   <span>16</span> hours ago     Exited <span>(</span><span>0</span><span>)</span> <span>4</span> minutes ago              relaxed_wright
1621b955ca78   hello-world              <span>"/hello"</span>                 <span>16</span> hours ago     Exited <span>(</span><span>0</span><span>)</span> <span>4</span> minutes ago              vigilant_ramanujan
05cb3af84499   docker/getting-started   <span>"/docker-entrypoint.…"</span>   <span>25</span> hours ago     Exited <span>(</span><span>0</span><span>)</span> <span>25</span> hours ago               strange_davinci
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>启动一个已停止的容器：</p>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker start aa996b05499f
aa996b05499f
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>ps</span>
CONTAINER ID   IMAGE           COMMAND       CREATED          STATUS         PORTS     NAMES
aa996b05499f   ubuntu          <span>"/bin/bash"</span>   <span>18</span> minutes ago   Up <span>8</span> seconds             hopeful_goodall
c1110cbddef9   ubuntu:latest   <span>"/bin/bash"</span>   <span>4</span> hours ago      Up <span>4</span> hours               myUbantu
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="后台运行"> 后台运行;</h3>
<p>在大部分的场景下，我们希望 docker 的服务是在后台运行的，我们可以过 <strong>-d</strong> 指定容器的运行模式。</p>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker run -itd --name ubuntu-test ubuntu /bin/bash
7af0632382d0a7307b9d8cdae5012cd0bf86aa8e32c14e2a1ab36d3049e7ee3b
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>ps</span>
CONTAINER ID   IMAGE           COMMAND       CREATED          STATUS         PORTS     NAMES
7af0632382d0   ubuntu          <span>"/bin/bash"</span>   <span>2</span> minutes ago    Up <span>2</span> minutes             ubuntu-test
aa996b05499f   ubuntu          <span>"/bin/bash"</span>   <span>22</span> minutes ago   Up <span>4</span> minutes             hopeful_goodall
c1110cbddef9   ubuntu:latest   <span>"/bin/bash"</span>   <span>4</span> hours ago      Up <span>4</span> hours               myUbantu
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p>**注：**加了 <strong>-d</strong> 参数默认不会进入容器，想要进入容器需要使用指令 <strong>docker exec</strong>。</p>
</blockquote>
<h2 id="停止一个容器"> 停止一个容器;</h2>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker stop 7af0632382d0
7af0632382d0
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>ps</span>
CONTAINER ID   IMAGE           COMMAND       CREATED          STATUS         PORTS     NAMES
aa996b05499f   ubuntu          <span>"/bin/bash"</span>   <span>24</span> minutes ago   Up <span>6</span> minutes             hopeful_goodall
c1110cbddef9   ubuntu:latest   <span>"/bin/bash"</span>   <span>4</span> hours ago      Up <span>4</span> hours               myUbantu
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="重启一个容器"> 重启一个容器</h2>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>ps</span>
CONTAINER ID   IMAGE           COMMAND       CREATED          STATUS         PORTS     NAMES
7af0632382d0   ubuntu          <span>"/bin/bash"</span>   <span>5</span> minutes ago    Up <span>6</span> seconds             ubuntu-test
aa996b05499f   ubuntu          <span>"/bin/bash"</span>   <span>25</span> minutes ago   Up <span>7</span> minutes             hopeful_goodall
c1110cbddef9   ubuntu:latest   <span>"/bin/bash"</span>   <span>4</span> hours ago      Up <span>4</span> hours               myUbantu
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="进入容器"> 进入容器</h2>
<blockquote>
<p>在使用 <strong>-d</strong> 参数时，容器启动后会进入后台。此时想要进入容器，可以通过以下指令进入：</p>
</blockquote>
<ul>
<li><strong>docker attach</strong></li>
<li><strong>docker exec</strong>：推荐大家使用 docker exec 命令，因为此退出容器终端，不会导致容器的停止。</li>
</ul>
<p><strong>attach 命令</strong></p>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>ps</span>
CONTAINER ID   IMAGE           COMMAND       CREATED          STATUS         PORTS     NAMES
7af0632382d0   ubuntu          <span>"/bin/bash"</span>   <span>5</span> minutes ago    Up <span>6</span> seconds             ubuntu-test
aa996b05499f   ubuntu          <span>"/bin/bash"</span>   <span>25</span> minutes ago   Up <span>7</span> minutes             hopeful_goodall
c1110cbddef9   ubuntu:latest   <span>"/bin/bash"</span>   <span>4</span> hours ago      Up <span>4</span> hours               myUbantu
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker attach 7af0632382d0
root@7af0632382d0:/<span># ls</span>
bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@7af0632382d0:/<span># exit</span>
<span>exit</span>
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>ps</span>
CONTAINER ID   IMAGE           COMMAND       CREATED          STATUS          PORTS     NAMES
aa996b05499f   ubuntu          <span>"/bin/bash"</span>   <span>29</span> minutes ago   Up <span>11</span> minutes             hopeful_goodall
c1110cbddef9   ubuntu:latest   <span>"/bin/bash"</span>   <span>4</span> hours ago      Up <span>4</span> hours                myUbantu
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><blockquote>
<p><strong>注意：</strong> 如果从这个容器退出，会导致容器的停止。</p>
</blockquote>
<p><strong>exec 命令</strong></p>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>exec</span> -it 7af0632382d0 /bin/bash
Error response from daemon: Container 7af0632382d0a7307b9d8cdae5012cd0bf86aa8e32c14e2a1ab36d3049e7ee3b is not running
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>exec</span> -it aa996b05499f /bin/bash
root@aa996b05499f:/<span># ls</span>
bin  boot  dev  etc  home  lib  lib32  lib64  libx32  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@aa996b05499f:/<span># exit</span>
<span>exit</span>
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>ps</span>
CONTAINER ID   IMAGE           COMMAND       CREATED          STATUS          PORTS     NAMES
aa996b05499f   ubuntu          <span>"/bin/bash"</span>   <span>31</span> minutes ago   Up <span>13</span> minutes             hopeful_goodall
c1110cbddef9   ubuntu:latest   <span>"/bin/bash"</span>   <span>4</span> hours ago      Up <span>4</span> hours                myUbantu
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>
<p><strong>注意：</strong> 如果从这个容器退出，容器不会停止，这就是为什么推荐大家使用 <strong>docker exec</strong> 的原因。</p>
</blockquote>
<h2 id="导出和导入容器"> 导出和导入容器</h2>
<h3 id="导出容器"> <strong>导出容器</strong></h3>
<blockquote>
<p>如果要导出本地某个容器，可以使用 <strong>docker export</strong> 命令。</p>
</blockquote>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>ps</span>
CONTAINER ID   IMAGE           COMMAND       CREATED          STATUS          PORTS     NAMES
aa996b05499f   ubuntu          <span>"/bin/bash"</span>   <span>31</span> minutes ago   Up <span>13</span> minutes             hopeful_goodall
c1110cbddef9   ubuntu:latest   <span>"/bin/bash"</span>   <span>4</span> hours ago      Up <span>4</span> hours                myUbantu
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>export</span> aa996b05499f <span>></span> ubuntu.tar
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ ll
total <span>97096</span>
drwxrwxrwx <span>1</span> wangyawei wangyawei      <span>512</span> Jun  <span>6</span> <span>15</span>:20  ./
dr-xr-xr-x <span>1</span> wangyawei wangyawei      <span>512</span> May <span>26</span> <span>22</span>:03  <span>..</span>/
drwxrwxrwx <span>1</span> wangyawei wangyawei      <span>512</span> Feb <span>10</span> <span>16</span>:16  .AutoSignMachine/
drwxrwxrwx <span>1</span> wangyawei wangyawei      <span>512</span> May <span>21</span> <span>21</span>:56  .Ld2VirtualBox/
drwxrwxrwx <span>1</span> wangyawei wangyawei      <span>512</span> Mar  <span>2</span>  <span>2018</span>  .QtWebEngineProcess/
-rwxrwxrwx <span>1</span> wangyawei wangyawei <span>75085824</span> Jun  <span>6</span> <span>15</span>:20  ubuntu.tar* <span># 导出的文件</span>
<span>'/mnt/c/Users/ASUS/AppData/Roaming/Microsoft/Windows/Start Menu'</span>/
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><blockquote>
<p>这样将导出容器快照到本地文件。</p>
</blockquote>
<h3 id="导入容器快照"> <strong>导入容器快照</strong></h3>
<blockquote>
<p>可以使用 docker import 从容器快照文件中再导入为镜像，以下实例将快照文件 ubuntu.tar 导入到镜像 test/ubuntu:v1:</p>
</blockquote>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ <span>cat</span> ubuntu.tar <span>|</span> docker <span>import</span> - test/ubuntu:v1
sha256:e5b44748d7b698029a4919b2e9e11a5eae9e56d9360dd0ef35a3dc35e36f9579
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker images
REPOSITORY               TAG       IMAGE ID       CREATED          SIZE
test/ubuntu              v1        e5b44748d7b6   <span>12</span> seconds ago   <span>72</span>.7MB
ubuntu                   latest    7e0aa2d69a15   <span>6</span> weeks ago      <span>72</span>.7MB
docker/getting-started   latest    3ba8f2ff0727   <span>2</span> months ago     <span>27</span>.9MB
hello-world              latest    d1165f221234   <span>3</span> months ago     <span>13</span>.3kB
ubuntu                   <span>15.10</span>     9b9cb95443b5   <span>4</span> years ago      137MB
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="删除容器"> 删除容器</h2>
<blockquote>
<p>删除容器使用 <strong>docker rm</strong> 命令：</p>
</blockquote>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>ps</span>
CONTAINER ID   IMAGE           COMMAND       CREATED          STATUS          PORTS     NAMES
aa996b05499f   ubuntu          <span>"/bin/bash"</span>   <span>47</span> minutes ago   Up <span>29</span> minutes             hopeful_goodall
c1110cbddef9   ubuntu:latest   <span>"/bin/bash"</span>   <span>5</span> hours ago      Up <span>5</span> hours                myUbantu
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>rm</span> -f c1110cbddef9
c1110cbddef9
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>ps</span>
CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS          PORTS     NAMES
aa996b05499f   ubuntu    <span>"/bin/bash"</span>   <span>48</span> minutes ago   Up <span>30</span> minutes             hopeful_goodall
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>运行web应用</title>
      <link>https://wangyawei.top/views/backEnd/docker/docker-note-03/</link>
      <guid>https://wangyawei.top/views/backEnd/docker/docker-note-03/</guid>
      <source url="https://wangyawei.top/rss.xml">运行web应用</source>
      <category>DOCKER</category>
      <pubDate>Tue, 08 Jun 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>使用 docker 构建一个 web 应用程序。我们将在docker容器中运行一个 Python Flask 应用来运行一个web应用。</p>
</blockquote>
<h2 id="hello-world"> hello world</h2>
<p>拉取一个镜像并运行</p>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker pull training/webapp
Using default tag: latest
latest: Pulling from training/webapp
Image docker.io/training/webapp:latest uses outdated schema1 manifest format. Please upgrade to a schema2 image <span>for</span> better future compatibility. More information at https://docs.docker.com/registry/spec/deprecated-schema-v1/
e190868d63f8: Pull complete
909cd34c6fd7: Pull complete
0b9bfabab7c1: Pull complete
a3ed95caeb02: Pull complete
10bbbc0fc0ff: Pull complete
fca59b508e9f: Pull complete
e7ae2541b15b: Pull complete
9dd97ef58ce9: Pull complete
a4c1b0cb7af7: Pull complete
Digest: sha256:06e9c1983bd6d5db5fba376ccd63bfa529e8d02f23d5079b8f74a616308fb11d
Status: Downloaded newer image <span>for</span> training/webapp:latest
docker.io/training/webapp:latest
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker run -d -P training/webapp python app.py
fd47761291acb8c593446fafc242fae0083b55a9267736176954151503d04b41
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>参数说明:</p>
<ul>
<li>**-d:**让容器在后台运行。</li>
<li>**-P:**将容器内部使用的网络端口随机映射到我们使用的主机上。</li>
</ul>
<h2 id="查看-web-应用容器"> 查看 WEB 应用容器</h2>
<blockquote>
<p>使用 docker ps 来查看我们正在运行的容器：</p>
</blockquote>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>ps</span>
CONTAINER ID   IMAGE             COMMAND           CREATED             STATUS             PORTS
   NAMES
fd47761291ac   training/webapp   <span>"python app.py"</span>   <span>2</span> minutes ago       Up <span>2</span> minutes       <span>0.0</span>.0.0:49153-<span>></span><span>5000</span>/tcp, :::49153-<span>></span><span>5000</span>/tcp   unruffled_jennings
aa996b05499f   ubuntu            <span>"/bin/bash"</span>       About an hour ago   Up About an hour
   hopeful_goodall
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>
<p>这里多了个端口信息：0.0.0.0:49153-&gt;5000/tcp；</p>
<p>Docker 开放了 5000 端口（默认 Python Flask 端口）映射到主机端口 49153上。这时我们可以通过浏览器访问：<code>http://127.0.0.1:49153/</code>WEB应用；</p>
</blockquote>
<p>我们也可以通过 -p 参数来设置不一样的端口：</p>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker run -d -p <span>5000</span>:5000 training/webapp python app.py
8075924b1921aa542481db7b599fdf1bf63011cdd2ba21fa87a4d70eaf665abf
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>ps</span>
CONTAINER ID   IMAGE             COMMAND           CREATED             STATUS             PORTS
   NAMES
8075924b1921   training/webapp   <span>"python app.py"</span>   <span>8</span> seconds ago       Up <span>3</span> seconds       <span>0.0</span>.0.0:5000-<span>></span><span>5000</span>/tcp, :::5000-<span>></span><span>5000</span>/tcp     reverent_moore
fd47761291ac   training/webapp   <span>"python app.py"</span>   <span>5</span> minutes ago       Up <span>5</span> minutes       <span>0.0</span>.0.0:49153-<span>></span><span>5000</span>/tcp, :::49153-<span>></span><span>5000</span>/tcp   unruffled_jennings
aa996b05499f   ubuntu            <span>"/bin/bash"</span>       About an hour ago   Up About an hour
   hopeful_goodall
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>容器内部的 5000 端口映射到我们本地主机的 5000 端口上。</p>
</blockquote>
<h2 id="网络端口的快捷方式"> 网络端口的快捷方式</h2>
<blockquote>
<p>通过 <strong>docker ps</strong> 命令可以查看到容器的端口映射，<strong>docker</strong> 还提供了另一个快捷方式 <strong>docker port</strong>，使用 <strong>docker port</strong> 可以查看指定 （ID 或者名字）容器的某个确定端口映射到宿主机的端口号。</p>
</blockquote>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>ps</span>
CONTAINER ID   IMAGE             COMMAND           CREATED             STATUS             PORTS
   NAMES
8075924b1921   training/webapp   <span>"python app.py"</span>   <span>8</span> seconds ago       Up <span>3</span> seconds       <span>0.0</span>.0.0:5000-<span>></span><span>5000</span>/tcp, :::5000-<span>></span><span>5000</span>/tcp     reverent_moore
fd47761291ac   training/webapp   <span>"python app.py"</span>   <span>5</span> minutes ago       Up <span>5</span> minutes       <span>0.0</span>.0.0:49153-<span>></span><span>5000</span>/tcp, :::49153-<span>></span><span>5000</span>/tcp   unruffled_jennings
aa996b05499f   ubuntu            <span>"/bin/bash"</span>       About an hour ago   Up About an hour
   hopeful_goodall
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker port 8075924b1921
<span>5000</span>/tcp -<span>></span> <span>0.0</span>.0.0:5000
<span>5000</span>/tcp -<span>></span> :::5000
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker port  reverent_moore
<span>5000</span>/tcp -<span>></span> <span>0.0</span>.0.0:5000
<span>5000</span>/tcp -<span>></span> :::5000
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="查看日志"> 查看日志</h2>
<blockquote>
<p>docker logs [ID或者名字] 可以查看容器内部的标准输出。</p>
</blockquote>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker logs -f 8075924b1921
 * Running on http://0.0.0.0:5000/ <span>(</span>Press CTRL+C to quit<span>)</span>
<span>172.17</span>.0.1 - - <span>[</span>06/Jun/2021 08:06:29<span>]</span> <span>"GET / HTTP/1.1"</span> <span>200</span> -
<span>172.17</span>.0.1 - - <span>[</span>06/Jun/2021 08:06:29<span>]</span> <span>"GET /favicon.ico HTTP/1.1"</span> <span>404</span> -
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>-f:</strong> 让 <strong>docker logs</strong> 像使用 <strong>tail -f</strong> 一样来输出容器内部的标准输出。</p>
<p>从上面，我们可以看到应用程序使用的是 5000 端口并且能够查看到应用程序的访问日志。</p>
<h2 id="查看容器进程"> 查看容器进程</h2>
<blockquote>
<p>们还可以使用 docker top name/id 来查看容器内部运行的进程</p>
</blockquote>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>top</span> 8075924b1921
<span>UID</span>                 PID                 <span>PPID</span>                C                   STIME               TTY                 TIME
       CMD
root                <span>2800</span>                <span>2779</span>                <span>0</span>                   08:05               ?                   00:00:00            python app.py
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="检查应用程序"> 检查应用程序</h2>
<blockquote>
<p>使用 <strong>docker inspect</strong> name/id  来查看 Docker 的底层信息。它会返回一个 JSON 文件记录着 Docker 容器的配置和状态信息。</p>
</blockquote>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker inspect 8075924b1921
<span>[</span>
    <span>{</span>
        <span>"Id"</span><span>:</span> <span>"8075924b1921aa542481db7b599fdf1bf63011cdd2ba21fa87a4d70eaf665abf"</span>,
        <span>"Created"</span><span>:</span> <span>"2021-06-06T08:05:16.6358518Z"</span>,
        <span>"Path"</span><span>:</span> <span>"python"</span>,
        <span>"Args"</span><span>:</span> <span>[</span>
            <span>"app.py"</span>
        <span>]</span>,
        <span>"State"</span><span>:</span> <span>{</span>
            <span>"Status"</span><span>:</span> <span>"running"</span>,
            <span>"Running"</span><span>:</span> true,
            <span>"Paused"</span><span>:</span> false,
            <span>"Restarting"</span><span>:</span> false,
            <span>"OOMKilled"</span><span>:</span> false,
            <span>"Dead"</span><span>:</span> false,
            <span>"Pid"</span><span>:</span> <span>2800</span>,
            <span>"ExitCode"</span><span>:</span> <span>0</span>,
            <span>"Error"</span><span>:</span> <span>""</span>,
            <span>"StartedAt"</span><span>:</span> <span>"2021-06-06T08:05:21.0384116Z"</span>,
            <span>"FinishedAt"</span><span>:</span> <span>"0001-01-01T00:00:00Z"</span>
        <span>}</span>,
        <span>"Image"</span><span>:</span> <span>"sha256:6fae60ef344644649a39240b94d73b8ba9c67f898ede85cf8e947a887b3e6557"</span>,
        <span>"ResolvConfPath"</span><span>:</span> <span>"/var/lib/docker/containers/8075924b1921aa542481db7b599fdf1bf63011cdd2ba21fa87a4d70eaf665abf/resolv.conf"</span>,
    <span>}</span>
<span>]</span>
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h2 id="停止应用容器"> 停止应用容器</h2>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker stop 8075924b1921
8075924b1921
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ <span>ps</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="重启应用容器"> 重启应用容器</h2>
<p>已经停止的容器，我们可以使用命令 docker start 来启动。</p>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker start 8075924b1921
8075924b1921
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>docker ps -l 查询最后一次创建的容器：</p>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>ps</span> -l
CONTAINER ID   IMAGE             COMMAND           CREATED          STATUS          PORTS                                       NAMES
8075924b1921   training/webapp   <span>"python app.py"</span>   <span>18</span> minutes ago   Up <span>38</span> seconds   <span>0.0</span>.0.0:5000-<span>></span><span>5000</span>/tcp, :::5000-<span>></span><span>5000</span>/tcp   reverent_moore
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="移除web应用容器"> 移除WEB应用容器</h2>
<blockquote>
<p>我们可以使用 docker rm 命令来删除不需要的容器, <strong>删除之前请先停止该容器</strong></p>
</blockquote>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>rm</span> 8075924b1921
8075924b1921
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>删除容器时，容器必须是停止状态，否则会报如下错误</p>
</blockquote>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker <span>rm</span> 8075924b1921
Error response from daemon: You cannot remove a running container 8075924b1921aa542481db7b599fdf1bf63011cdd2ba21fa87a4d70eaf665abf. Stop the container before attempting removal or force remove
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>创建镜像</title>
      <link>https://wangyawei.top/views/backEnd/docker/docker-note-04/</link>
      <guid>https://wangyawei.top/views/backEnd/docker/docker-note-04/</guid>
      <source url="https://wangyawei.top/rss.xml">创建镜像</source>
      <category>DOCKER</category>
      <pubDate>Tue, 08 Jun 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>当运行容器时，使用的镜像如果在本地中不存在，docker 就会自动从 docker 镜像仓库中下载，默认是从 Docker Hub 公共镜像源下载。</p>
</blockquote>
<h2 id="查看本机镜像"> 查看本机镜像</h2>
<blockquote>
<p>我们可以使用 <strong>docker images</strong> 来列出本地主机上的镜像。</p>
</blockquote>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker images
REPOSITORY               TAG       IMAGE ID       CREATED        SIZE
ubuntu                   latest    7e0aa2d69a15   <span>6</span> weeks ago    <span>72</span>.7MB
docker/getting-started   latest    3ba8f2ff0727   <span>2</span> months ago   <span>27</span>.9MB
hello-world              latest    d1165f221234   <span>3</span> months ago   <span>13</span>.3kB
ubuntu                   <span>15.10</span>     9b9cb95443b5   <span>4</span> years ago    137MB
training/webapp          latest    6fae60ef3446   <span>6</span> years ago    349MB
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>各个选项说明:</p>
<ul>
<li>**REPOSITORY：**表示镜像的仓库源</li>
<li>**TAG：**镜像的标签</li>
<li>**IMAGE ID：**镜像ID</li>
<li>**CREATED：**镜像创建时间</li>
<li>**SIZE：**镜像大小</li>
</ul>
<p>同一仓库源可以有多个 TAG，代表这个仓库源的不同个版本，如 ubuntu 仓库源里，有 15.10、14.04 等多个不同的版本，我们使用 REPOSITORY:TAG 来定义不同的镜像。</p>
<p>所以，我们如果要使用版本为15.10的ubuntu系统镜像来运行容器时，命令如下：</p>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker run -t -i ubuntu:15.10 /bin/bash
root@7a90e165a7c9:/<span># ls</span>
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@7a90e165a7c9:/<span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>参数说明：</p>
<ul>
<li><strong>-i</strong>: 交互式操作。</li>
<li><strong>-t</strong>: 终端。</li>
<li><strong>ubuntu:15.10</strong>: 这是指用 ubuntu 15.10 版本镜像为基础来启动容器。</li>
<li><strong>/bin/bash</strong>：放在镜像名后的是命令，这里我们希望有个交互式 Shell，因此用的是 /bin/bash。</li>
</ul>
<div><p>提示</p>
<p>如果你不指定一个镜像的版本标签，例如你只使用 ubuntu，docker 将默认使用 ubuntu:latest 镜像。</p>
</div>
<h2 id="获取新镜像"> 获取新镜像</h2>
<blockquote>
<p>当我们在本地主机上使用一个不存在的镜像时 Docker 就会自动下载这个镜像。如果我们想预先下载这个镜像，我们可以使用 docker pull 命令来下载它。</p>
</blockquote>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker pull ubuntu:13.10
<span>13.10</span>: Pulling from library/ubuntu
Image docker.io/library/ubuntu:13.10 uses outdated schema1 manifest format. Please upgrade to a schema2 image <span>for</span> better future compatibility. More information at https://docs.docker.com/registry/spec/deprecated-schema-v1/
a3ed95caeb02: Pull complete
0d8710fc57fd: Pull complete
5037c5cd623d: Pull complete
83b53423b49f: Pull complete
e9e8bd3b94ab: Pull complete
7db00e6b6e5e: Pull complete
Digest: sha256:403105e61e2d540187da20d837b6a6e92efc3eb4337da9c04c191fb5e28c44dc
Status: Downloaded newer image <span>for</span> ubuntu:13.10
docker.io/library/ubuntu:13.10
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>下载完成后，我们可以直接使用这个镜像来运行容器。</p>
<h2 id="查找镜像"> 查找镜像</h2>
<blockquote>
<p>我们可以从 Docker Hub 网站来搜索镜像，Docker Hub 网址为： <strong>https://hub.docker.com/</strong>，我们也可以使用 docker search 命令来搜索镜像。比如我们需要一个 httpd 的镜像来作为我们的 web 服务。我们可以通过 docker search 命令搜索 httpd 来寻找适合我们的镜像。</p>
</blockquote>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker search httpd
NAME                                    DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED
httpd                                   The Apache HTTP Server Project                  <span>3529</span>      <span>[</span>OK<span>]</span>
centos/httpd-24-centos7                 Platform <span>for</span> running Apache httpd <span>2.4</span> or bui…   <span>40</span>
centos/httpd                                                                            <span>34</span>                   <span>[</span>OK<span>]</span>
arm32v7/httpd                           The Apache HTTP Server Project                  <span>9</span>
salim1983hoop/httpd24                   Dockerfile running apache config                <span>2</span>                    <span>[</span>OK<span>]</span>
solsson/httpd-openidc                   mod_auth_openidc on official httpd image, ve…   <span>2</span>                    <span>[</span>OK<span>]</span>
hypoport/httpd-cgi                      httpd-cgi                                       <span>2</span>                    <span>[</span>OK<span>]</span>
publici/httpd                           httpd:latest                                    <span>1</span>                    <span>[</span>OK<span>]</span>
clearlinux/httpd                        httpd HyperText Transfer Protocol <span>(</span>HTTP<span>)</span> ser…   <span>1</span>
jonathanheilmann/httpd-alpine-rewrite   httpd:alpine with enabled mod_rewrite           <span>1</span>                    <span>[</span>OK<span>]</span>
lead4good/httpd-fpm                     httpd server <span>which</span> connects via fcgi proxy h…   <span>1</span>                    <span>[</span>OK<span>]</span>
dockerpinata/httpd                                                                      <span>1</span>
manageiq/httpd                          Container with httpd, built on CentOS <span>for</span> Ma…   <span>1</span>                    <span>[</span>OK<span>]</span>
inanimate/httpd-ssl                     A play container with httpd, ssl enabled, an…   <span>1</span>                    <span>[</span>OK<span>]</span>
dariko/httpd-rproxy-ldap                Apache httpd reverse proxy with LDAP authent…   <span>1</span>                    <span>[</span>OK<span>]</span>
centos/httpd-24-centos8                                                                 <span>0</span>
appertly/httpd                          Customized Apache HTTPD that uses a PHP-FPM …   <span>0</span>                    <span>[</span>OK<span>]</span>
amd64/httpd                             The Apache HTTP Server Project                  <span>0</span>
e2eteam/httpd                                                                           <span>0</span>
manageiq/httpd_configmap_generator      Httpd Configmap Generator                       <span>0</span>                    <span>[</span>OK<span>]</span>
trollin/httpd                                                                           <span>0</span>
manasip/httpd                                                                           <span>0</span>
ysli/httpd                              Httpd <span>for</span> DeepWeb                               <span>0</span>                    <span>[</span>OK<span>]</span>
itsziget/httpd24                        Extended HTTPD Docker image based on the off…   <span>0</span>                    <span>[</span>OK<span>]</span>
interlutions/httpd                      httpd docker image with debian-based config …   <span>0</span>                    <span>[</span>OK<span>]</span>
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><strong>NAME:</strong> 镜像仓库源的名称</p>
<p><strong>DESCRIPTION:</strong> 镜像的描述</p>
<p><strong>OFFICIAL:</strong> 是否 docker 官方发布</p>
<p><strong>stars:</strong> 类似 Github 里面的 star，表示点赞、喜欢的意思。</p>
<p><strong>AUTOMATED:</strong> 自动构建。</p>
<h2 id="拉取镜像"> 拉取镜像</h2>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$  docker pull httpd
Using default tag: latest
latest: Pulling from library/httpd
69692152171a: Pull complete
7284b4e0cc7b: Pull complete
3678b2d55ccd: Pull complete
aeb67982a725: Pull complete
06954f8169fd: Pull complete
Digest: sha256:48bae0ac5d0d75168f1c1282c0eb21b43302cb1b5c5dc9fa3b4a758ccfb36fe9
Status: Downloaded newer image <span>for</span> httpd:latest
docker.io/library/httpd:latest
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker run httpd
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>下载完成后，我们就可以使用这个镜像了。</p>
<h2 id="创建镜像"> 创建镜像</h2>
<p>当我们从 docker 镜像仓库中下载的镜像不能满足我们的需求时，我们可以通过以下两种方式对镜像进行更改。</p>
<ul>
<li>1、从已经创建的容器中更新镜像，并且提交这个镜像</li>
<li>2、使用 Dockerfile 指令来创建一个新的镜像</li>
</ul>
<h3 id="更新镜像"> 更新镜像</h3>
<p>更新镜像之前，我们需要使用镜像来创建一个容器。</p>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker run -t -i ubuntu:15.10 /bin/bash
root@f601f176aa29:/<span># apt-get update</span>
Ign http://archive.ubuntu.com wily InRelease
Ign http://archive.ubuntu.com wily-updates InRelease
Ign http://archive.ubuntu.com wily-security InRelease
Ign http://archive.ubuntu.com wily Release.gpg
Ign http://archive.ubuntu.com wily-updates Release.gpg
Ign http://archive.ubuntu.com wily-security Release.gpg
Ign http://archive.ubuntu.com wily Release
Ign http://archive.ubuntu.com wily-updates Release
Ign http://archive.ubuntu.com wily-security Release
<span>..</span><span>..</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>使用<code>docker ps -a</code>找到创建的容器的id。我们可以通过命令 docker commit 来提交容器副本。</p>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker commit -m<span>=</span><span>"has update"</span> -a<span>=</span><span>"runoob"</span>  f601f176aa29 runoob/ubuntu:v2
sha256:3a9b73618178c6f0ce4ec1c287de0787b84fddedfa3eff058af358723b3b19e9
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>各个参数说明：</p>
<ul>
<li><strong>-m:</strong> 提交的描述信息</li>
<li><strong>-a:</strong> 指定镜像作者</li>
<li>**e218edb10161：**容器 ID</li>
<li><strong>runoob/ubuntu:v2:</strong> 指定要创建的目标镜像名</li>
</ul>
<p>我们可以使用 <strong>docker images</strong> 命令来查看我们的新镜像 <strong>runoob/ubuntu:v2</strong>：</p>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker images
REPOSITORY               TAG       IMAGE ID       CREATED         SIZE
runoob/ubuntu            v2        3a9b73618178   <span>4</span> minutes ago   137MB <span># 此处</span>
httpd                    latest    39c2d1c93266   <span>11</span> days ago     138MB
ubuntu                   latest    7e0aa2d69a15   <span>6</span> weeks ago     <span>72</span>.7MB
docker/getting-started   latest    3ba8f2ff0727   <span>2</span> months ago    <span>27</span>.9MB
hello-world              latest    d1165f221234   <span>3</span> months ago    <span>13</span>.3kB
ubuntu                   <span>15.10</span>     9b9cb95443b5   <span>4</span> years ago     137MB
training/webapp          latest    6fae60ef3446   <span>6</span> years ago     349MB
ubuntu                   <span>13.10</span>     7f020f7bf345   <span>6</span> years ago     185MB
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>使用我们的新镜像 <strong>runoob/ubuntu</strong> 来启动一个容器</p>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ docker run -t -i runoob/ubuntu:v2 /bin/bash
root@28c174d9b40f:/<span># ls</span>
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@28c174d9b40f:/<span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="构建镜像"> 构建镜像</h3>
<blockquote>
<p>我们使用命令 <strong>docker build</strong> ， 从零开始来创建一个新的镜像。为此，我们需要创建一个 Dockerfile 文件，其中包含一组指令来告诉 Docker 如何构建我们的镜像。</p>
</blockquote>
<div><pre><code>wangyawei@yaweidediannao:/mnt/c/Users/ASUS$ <span>cat</span> Dockerfile
FROM    centos:7
MAINTAINER      Fisher <span>"fisher@sudops.com"</span>
RUN     <span>useradd</span> <span>"runoob"</span>
RUN     /bin/echo <span>'runoob:123456'</span> <span>|</span>chpasswd
RUN     /bin/echo -e <span>"LANG=<span title="\&quot;">\"</span>en_US.UTF-8<span title="\&quot;">\"</span>"</span> <span>></span>/etc/default/local
EXPOSE  <span>22</span>
EXPOSE  <span>80</span>
CMD     /usr/sbin/sshd -D
wangyawei@yaweidediannao:/mnt/c/Users/ASUS$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>每一个指令都会在镜像上创建一个新的层，每一个指令的<strong>前缀都必须是大写</strong>的。</p>
<p>第一条FROM，指定使用哪个镜像源</p>
<p>RUN 指令告诉docker 在镜像内执行命令，安装了什么。。。</p>
</blockquote>
<p>构建镜像；</p>
<div><pre><code>wangyawei@yaweidediannao:~/test$ docker build -t runoob/centos:7 <span>.</span>
<span>[</span>+<span>]</span> Building <span>34</span>.4s <span>(</span><span>8</span>/8<span>)</span> FINISHED
 <span>=</span><span>></span> <span>[</span>internal<span>]</span> load build definition from Dockerfile                                                                                                   <span>0</span>.1s
 <span>=</span><span>></span> <span>=</span><span>></span> transferring dockerfile: 286B                                                                                                                   <span>0</span>.0s
 <span>=</span><span>></span> <span>[</span>internal<span>]</span> load .dockerignore                                                                                                                      <span>0</span>.0s
 <span>=</span><span>></span> <span>=</span><span>></span> transferring context: 2B                                                                                                                        <span>0</span>.0s
 <span>=</span><span>></span> <span>[</span>internal<span>]</span> load metadata <span>for</span> docker.io/library/centos:7                                                                                           <span>16</span>.9s
 <span>=</span><span>></span> <span>[</span><span>1</span>/4<span>]</span> FROM docker.io/library/centos:7@sha256:0f4ec88e21daf75124b8a9e5ca03c37a5e937e0e108a255d890492430789b60e                                     <span>14</span>.5s
 <span>=</span><span>></span> <span>=</span><span>></span> resolve docker.io/library/centos:7@sha256:0f4ec88e21daf75124b8a9e5ca03c37a5e937e0e108a255d890492430789b60e                                      <span>0</span>.0s
 <span>=</span><span>></span> <span>=</span><span>></span> sha256:0f4ec88e21daf75124b8a9e5ca03c37a5e937e0e108a255d890492430789b60e <span>1</span>.20kB / <span>1</span>.20kB                                                         <span>0</span>.0s
 <span>=</span><span>></span> <span>=</span><span>></span> sha256:e4ca2ed0202e76be184e75fb26d14bf974193579039d5573fb2348664deef76e 529B / 529B                                                             <span>0</span>.0s
 <span>=</span><span>></span> <span>=</span><span>></span> sha256:8652b9f0cb4c0599575e5a003f5906876e10c1ceb2ab9fe1786712dac14a50cf <span>2</span>.75kB / <span>2</span>.75kB                                                         <span>0</span>.0s
 <span>=</span><span>></span> <span>=</span><span>></span> sha256:2d473b07cdd5f0912cd6f1a703352c82b512407db6b05b43f2553732b55df3bc <span>76</span>.10MB / <span>76</span>.10MB                                                       <span>9</span>.6s
 <span>=</span><span>></span> <span>=</span><span>></span> extracting sha256:2d473b07cdd5f0912cd6f1a703352c82b512407db6b05b43f2553732b55df3bc                                                              <span>4</span>.6s
 <span>=</span><span>></span> <span>[</span><span>2</span>/4<span>]</span> RUN     <span>useradd</span> <span>"runoob"</span>                                                                                                                     <span>1</span>.6s
 <span>=</span><span>></span> <span>[</span><span>3</span>/4<span>]</span> RUN     /bin/echo <span>'runoob:123456'</span> <span>|</span>chpasswd                                                                                                  <span>0</span>.6s
 <span>=</span><span>></span> <span>[</span><span>4</span>/4<span>]</span> RUN     /bin/echo -e <span>"LANG="</span>en_US.UTF-8<span>""</span> <span>></span>/etc/default/local                                                                                <span>0</span>.5s
 <span>=</span><span>></span> exporting to image                                                                                                                                 <span>0</span>.1s
 <span>=</span><span>></span> <span>=</span><span>></span> exporting layers                                                                                                                                <span>0</span>.1s
 <span>=</span><span>></span> <span>=</span><span>></span> writing image sha256:bfc14340e7fa9da9a815afcc55a7d7c5d3a661965f1d693fe84468fab99b5739                                                           <span>0</span>.0s
 <span>=</span><span>></span> <span>=</span><span>></span> naming to docker.io/runoob/centos:7                                                                                                             <span>0</span>.0s

Use <span>'docker scan'</span> to run Snyk tests against images to <span>find</span> vulnerabilities and learn how to fix them
wangyawei@yaweidediannao:~/test$ docker images
REPOSITORY               TAG       IMAGE ID       CREATED          SIZE
runoob/centos            <span>7</span>         bfc14340e7fa   <span>56</span> seconds ago   204MB <span># 创建的镜像</span>
runoob/ubuntu            v2        3a9b73618178   <span>44</span> minutes ago   137MB
httpd                    latest    39c2d1c93266   <span>11</span> days ago      138MB
ubuntu                   latest    7e0aa2d69a15   <span>6</span> weeks ago      <span>72</span>.7MB
docker/getting-started   latest    3ba8f2ff0727   <span>2</span> months ago     <span>27</span>.9MB
hello-world              latest    d1165f221234   <span>3</span> months ago     <span>13</span>.3kB
ubuntu                   <span>15.10</span>     9b9cb95443b5   <span>4</span> years ago      137MB
training/webapp          latest    6fae60ef3446   <span>6</span> years ago      349MB
ubuntu                   <span>13.10</span>     7f020f7bf345   <span>6</span> years ago      185MB
wangyawei@yaweidediannao:~/test$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>参数说明：</p>
<ul>
<li><strong>-t</strong> ：指定要创建的目标镜像名</li>
<li><strong>.</strong> ：Dockerfile 文件所在目录，可以指定Dockerfile 的绝对路径</li>
</ul>
<h3 id="创建容器"> 创建容器</h3>
<div><pre><code>wangyawei@yaweidediannao:~/test$ docker run -t -i runoob/centos:7  /bin/bash
<span>[</span>root@1b9dbb4f6ced /<span>]</span><span># ls</span>
anaconda-post.log  bin  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
<span>[</span>root@1b9dbb4f6ced /<span>]</span><span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="设置镜像标签"> 设置镜像标签</h3>
<blockquote>
<p>我们可以使用 docker tag 命令，为镜像添加一个新的标签。</p>
</blockquote>
<div><pre><code>wangyawei@yaweidediannao:~/test$ docker tag bfc14340e7fa runoob/centos:dev
wangyawei@yaweidediannao:~/test$ docker images
REPOSITORY               TAG       IMAGE ID       CREATED          SIZE
runoob/centos            <span>7</span>         bfc14340e7fa   <span>8</span> minutes ago    204MB  <span># 老标签</span>
runoob/centos            dev       bfc14340e7fa   <span>8</span> minutes ago    204MB  <span># 新标签</span>
runoob/ubuntu            v2        3a9b73618178   <span>51</span> minutes ago   137MB
httpd                    latest    39c2d1c93266   <span>11</span> days ago      138MB
ubuntu                   latest    7e0aa2d69a15   <span>6</span> weeks ago      <span>72</span>.7MB
docker/getting-started   latest    3ba8f2ff0727   <span>2</span> months ago     <span>27</span>.9MB
hello-world              latest    d1165f221234   <span>3</span> months ago     <span>13</span>.3kB
ubuntu                   <span>15.10</span>     9b9cb95443b5   <span>4</span> years ago      137MB
training/webapp          latest    6fae60ef3446   <span>6</span> years ago      349MB
ubuntu                   <span>13.10</span>     7f020f7bf345   <span>6</span> years ago      185MB
wangyawei@yaweidediannao:~/test$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>hello world</title>
      <link>https://wangyawei.top/views/backEnd/docker/docker-note-1/</link>
      <guid>https://wangyawei.top/views/backEnd/docker/docker-note-1/</guid>
      <source url="https://wangyawei.top/rss.xml">hello world</source>
      <category>DOCKER</category>
      <pubDate>Tue, 08 Jun 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Docker 允许你在容器内运行应用程序， 使用 <strong>docker run</strong> 命令来在容器内运行一个应用程序。</p>
</blockquote>
<h2 id="输出hello-world"> 输出hello world</h2>
<div><pre><code>PS C:<span>\</span>Users<span>\</span>ASUS<span>></span> docker run ubuntu:15.10 /bin/echo <span>"Hello world"</span>
Unable to <span>find</span> image <span>'ubuntu:15.10'</span> locally
<span>15.10</span>: Pulling from library/ubuntu
7dcf5a444392: Pull complete
759aa75f3cee: Pull complete
3fa871dc8a2b: Pull complete
224c42ae46e7: Pull complete
Digest: sha256:02521a2d079595241c6793b2044f02eecf294034f31d6e235ac4b2b54ffc41f3
Status: Downloaded newer image <span>for</span> ubuntu:15.10
Hello world
PS C:<span>\</span>Users<span>\</span>ASUS<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>各个参数解析：</p>
<ul>
<li><strong>docker:</strong> Docker 的二进制执行文件。</li>
<li><strong>run:</strong> 与前面的 docker 组合来运行一个容器。</li>
<li><strong>ubuntu:15.10</strong> 指定要运行的镜像，<strong>Docker 首先从本地主机上查找镜像是否存在</strong>，如果不存在，Docker 就会从镜像仓库 Docker Hub 下载公共镜像。</li>
<li><strong>/bin/echo &quot;Hello world&quot;:</strong> 在启动的容器里执行的命令</li>
</ul>
<blockquote>
<p>以上命令完整的意思可以解释为：Docker 以 ubuntu15.10 镜像创建一个新容器，然后在容器里执行 bin/echo &quot;Hello world&quot;，然后输出结果。</p>
</blockquote>
<h2 id="交互式的容器"> 交互式的容器</h2>
<blockquote>
<p>我们通过 docker 的两个参数 -i -t，让 docker 运行的容器实现**&quot;对话&quot;**的能力：</p>
</blockquote>
<div><pre><code>PS C:<span>\</span>Users<span>\</span>ASUS<span>></span> docker run -i -t ubuntu:15.10 /bin/bash
root@8a725ffa2d7b:/<span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>各个参数解析：</p>
<ul>
<li><strong>-t:</strong> 在新容器内指定一个伪终端或终端。</li>
<li><strong>-i:</strong> 允许你对容器内的标准输入 (STDIN) 进行交互。</li>
</ul>
<blockquote>
<p>注意第二行 <strong>root@8a725ffa2d7b:/#</strong>，此时我们已进入一个 ubuntu15.10 系统的容器;</p>
</blockquote>
<div><pre><code><span># 在容器中运行命令 cat /proc/version 和 ls 分别查看当前系统的版本信息和当前目录下的文件列表</span>
root@8a725ffa2d7b:/<span># cat /proc/version</span>
Linux version <span>5.4</span>.72-microsoft-standard-WSL2 <span>(</span>oe-user@oe-host<span>)</span> <span>(</span>gcc version <span>8.2</span>.0 <span>(</span>GCC<span>))</span> <span>#1 SMP Wed Oct 28 23:40:43 UTC 2020</span>
root@8a725ffa2d7b:/<span># ls</span>
bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
root@8a725ffa2d7b:/<span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>通过运行 exit 命令或者使用 CTRL+D 来退出容器。</p>
<div><pre><code>root@8a725ffa2d7b:/<span># exit</span>
<span>exit</span>
PS C:<span>\</span>Users<span>\</span>ASUS<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>
<p>意第三行中 <strong>PS C:\Users\ASUS&gt;</strong> 表明我们已经退出了当前的容器，返回到当前的主机中。</p>
</blockquote>
<h2 id="后台模式"> 后台模式</h2>
<blockquote>
<p>使用命令创建一个以进程方式运行的容器</p>
</blockquote>
<div><pre><code>PS C:<span>\</span>Users<span>\</span>ASUS<span>></span> docker run -d ubuntu:15.10 /bin/sh -c <span>"while true; do echo hello world; sleep 1; done"</span>
0fb0e9c06a91be59d233afa078a9edbdcb10e9702fb6531ad777654ad8676a51
PS C:<span>\</span>Users<span>\</span>ASUS<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>在输出中，我们看到一串长字符</p>
<p>0fb0e9c06a91be59d233afa078a9edbdcb10e9702fb6531ad777654ad8676a51</p>
<p>这个长字符串叫做容器 ID，对每个容器来说都是唯一的，我们可以通过容器 ID 来查看对应的容器发生了什么。</p>
<p>首先，我们需要确认容器有在运行，可以通过 <strong>docker ps</strong> 来查看：</p>
<div><pre><code>PS C:<span>\</span>Users<span>\</span>ASUS<span>></span> docker <span>ps</span>
CONTAINER ID   IMAGE          COMMAND                  CREATED              STATUS              PORTS     NAMES
0fb0e9c06a91   ubuntu:15.10   <span>"/bin/sh -c 'while t…"</span>   About a minute ago   Up About a minute             blissful_bassi
PS C:<span>\</span>Users<span>\</span>ASUS<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>输出详情介绍：</p>
<p><strong>CONTAINER ID:</strong> 容器 ID。</p>
<p><strong>IMAGE:</strong> 使用的镜像。</p>
<p><strong>COMMAND:</strong> 启动容器时运行的命令。</p>
<p><strong>CREATED:</strong> 容器的创建时间。</p>
<p><strong>STATUS:</strong> 容器状态。</p>
<p>状态有7种：</p>
<ul>
<li>created（已创建）</li>
<li>restarting（重启中）</li>
<li>running 或 Up（运行中）</li>
<li>removing（迁移中）</li>
<li>paused（暂停）</li>
<li>exited（停止）</li>
<li>dead（死亡）</li>
</ul>
<p><strong>PORTS:</strong> 容器的端口信息和使用的连接类型（tcp\udp）。</p>
<p><strong>NAMES:</strong> 自动分配的容器名称。</p>
<p>在宿主主机内使用 <strong>docker logs</strong> 命令，查看容器内的标准输出：</p>
<div><pre><code>PS C:<span>\</span>Users<span>\</span>ASUS<span>></span> docker logs 0fb0e9c06a91
hello world
hello world
hello world
hello world
hello world
hello world
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="停止容器"> 停止容器</h2>
<blockquote>
<p>我们使用 <strong>docker stop ID</strong>  命令来停止容器:</p>
</blockquote>
<div><pre><code>PS C:<span>\</span>Users<span>\</span>ASUS<span>></span> docker stop 0fb0e9c06a91
0fb0e9c06a91
PS C:<span>\</span>Users<span>\</span>ASUS<span>></span> docker <span>ps</span>
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
PS C:<span>\</span>Users<span>\</span>ASUS<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/backEnd/express/</link>
      <guid>https://wangyawei.top/views/backEnd/express/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>EXPRESS</category>
      <pubDate>Sun, 11 Jul 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些自己平时积累的<strong>express</strong>相关的知识；</p>
</blockquote>
<h2 id="目录"> 目录</h2>
<ul>
<li><a href="./express-note-01.html">框架简介</a></li>
<li><a href="./express-note-02.html">安装</a></li>
<li><a href="./express-note-03.html">初始化项目</a></li>
<li><a href="./express-note-04.html">工程结构</a></li>
<li><a href="./express-note-05.html">路由控制</a></li>
<li><a href="./express-note-06.html">模板引擎</a></li>
<li><a href="./express-note-07.html">片段视图</a></li>
<li><a href="./express-note-08.html">视图助手</a></li>
<li>案例一
<ul>
<li><a href="./express-note-09.html">建立微博网站</a></li>
<li><a href="./express-note-10.html">用户注册和登录  </a></li>
<li><a href="./express-note-11.html">发表微博</a></li>
<li><a href="./express-note-12.html">应用部署</a></li>
</ul>
</li>
</ul>
<h2 id="参考资料"> 参考资料</h2>
<p>《nodejs开发指南》-- 郭家宝</p>
<p>《nodejs+webpack开发实战》-- 夏磊</p>
<h2 id="版权说明"> 版权说明</h2>
<p>以上案例中，大部分的内容均来自与 nodejs开发指南 ，作为学习如果你对以上内容感兴趣，请阅读纸书，如果以上内容侵犯了版权，请与本人联系，会马上删除。</p>
]]></content:encoded>
    </item>
    <item>
      <title>框架简介</title>
      <link>https://wangyawei.top/views/backEnd/express/express-note-01/</link>
      <guid>https://wangyawei.top/views/backEnd/express/express-note-01/</guid>
      <source url="https://wangyawei.top/rss.xml">框架简介</source>
      <category>EXPRESS</category>
      <pubDate>Sun, 11 Jul 2021 10:31:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>npm 提供了大量的第三方模块，其中不乏有许多 Web 框架 ，而Express就是一个简洁而灵活的nodejs Web应用框架，提供了一系列强大特性来帮助我们创建各种web应用。使用Express可以快速搭建一个完整功能的网站。</p>
</blockquote>
<p><strong>实现的功能</strong></p>
<ul>
<li>路由控制；</li>
<li>模板解析支持；</li>
<li>动态视图；</li>
<li>用户会话；</li>
<li>CSRF 保护；</li>
<li>静态文件服务；</li>
<li>错误控制器；</li>
<li>访问日志；</li>
<li>缓存；</li>
<li>插件支持。</li>
</ul>
<p><strong>核心特性</strong></p>
<ul>
<li>通过设置中间件来处理HTTP请求。</li>
<li>通过路由来执行不同的HTTP请求操作。</li>
<li>通过模板来渲染HTML页面。</li>
</ul>
<div><p>提示</p>
<p>Express 不是一个无所不能的全能框架，它只是一个轻量级的 Web 框 架，多数功能只是对 HTTP 协议中常用操作的封装，更多的功能需要插件或者整合其他模块来完成  。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>安装</title>
      <link>https://wangyawei.top/views/backEnd/express/express-note-02/</link>
      <guid>https://wangyawei.top/views/backEnd/express/express-note-02/</guid>
      <source url="https://wangyawei.top/rss.xml">安装</source>
      <category>EXPRESS</category>
      <pubDate>Sun, 11 Jul 2021 10:31:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>如果一个包是某个工程的依赖，那么我们需要在工程的目录下使用本地模式安装这个包，如果要通过命令行调用这个包中的命令，则需要用全局模式安装，因此我们使用本地模式安装 Express 即可。  当然你也可以采用全局模式安装。</p>
</blockquote>
<h2 id="express-3-x"> <code>express@3.x</code></h2>
<blockquote>
<p>适用于3.x及以前的版本。</p>
</blockquote>
<div><pre><code><span># 全局安装</span>
<span>npm</span> <span>install</span> -g express@3.21.2
<span># 或</span>
<span>npm</span> <span>install</span> express@3.21.2 -S
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code>WANGYAWEI@yaweidediannao MINGW64 /e/projectCenter/heroList <span>(</span>dev<span>)</span>
$ express -V
<span>3.21</span>.2
WANGYAWEI@yaweidediannao MINGW64 /e/projectCenter/heroList <span>(</span>dev<span>)</span>
$ express -h

  Usage: express <span>[</span>options<span>]</span> <span>[</span>dir<span>]</span>

  Options:

    -h, --help          output usage information
    -V, --version       output the version number
    -s, --sessions      <span>add</span> session support
    -e, --ejs           <span>add</span> ejs engine support <span>(</span>defaults to jade<span>)</span>
    -J, --jshtml        <span>add</span> jshtml engine support <span>(</span>defaults to jade<span>)</span>
    -H, --hogan         <span>add</span> hogan.js engine support
    -c, --css <span>&lt;</span>engine<span>></span>  <span>add</span> stylesheet <span>&lt;</span>engine<span>></span> support <span>(</span>less<span>|</span>stylus<span>)</span> <span>(</span>defaults to plain css<span>)</span>
    -f, --force         force on non-empty directory
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><blockquote>
<p>以上内容表示安装成功；</p>
</blockquote>
<h2 id="express-4-x"> <code>express@4.x</code></h2>
<blockquote>
<p>如果你安装的是4.x及以上版本，你会发现你输入<code>express -h</code>后提示<code>bash: express: command not found</code>，这是因为在<code>express@3.21.2</code>版本以后，也就是<code>express@4.x</code>版中，命令行工具被移走了，<code>express</code>不在支持命令行功能，需要你安装<code>express-generator</code>;</p>
</blockquote>
<div><pre><code><span># 全局安装</span>
<span>npm</span> <span>install</span> -g express
<span># 或</span>
<span>npm</span> <span>install</span> express -S

<span># 安装 express生成器</span>
<span>npm</span> <span>install</span> express-generator -g
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code>PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>></span> express -v
express <span>:</span> 无法将“express”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再
试一次。
所在位置 行:1 字符: <span>1</span>
+ ~~~~~~~
    + CategoryInfo          <span>:</span> ObjectNotFound: <span>(</span>express:String<span>)</span> <span>[</span><span>]</span>, CommandNotFoundException
    + FullyQualifiedErrorId <span>:</span> CommandNotFoundException

PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>></span> <span>npm</span> <span>install</span> express-generator -g
<span>npm</span> WARN deprecated mkdirp@0.5.1: Legacy versions of mkdirp are no longer supported. Please update to mkdirp <span>1</span>.x. <span>(</span>Note that the API surface has changed to use Promises <span>in</span> <span>1</span>.x.<span>)</span>
C:<span>\</span>Program Files<span>\</span>nodejs<span>\</span>express -<span>></span> C:<span>\</span>Program Files<span>\</span>nodejs<span>\</span>node_modules<span>\</span>express-generator<span>\</span>bin<span>\</span>express-cli.js
+ express-generator@4.16.1
added <span>10</span> packages from <span>13</span> contributors <span>in</span> <span>3</span>.022s
PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>></span> express -v

  Usage: express <span>[</span>options<span>]</span> <span>[</span>dir<span>]</span>

  Options:

        --version        output the version number
    -e, --ejs            <span>add</span> ejs engine support
        --pug            <span>add</span> pug engine support
        --hbs            <span>add</span> handlebars engine support
    -H, --hogan          <span>add</span> hogan.js engine support
    -v, --view <span>&lt;</span>engine<span>></span>  <span>add</span> view <span>&lt;</span>engine<span>></span> support <span>(</span>dust<span>|</span>ejs<span>|</span>hbs<span>|</span>hjs<span>|</span>jade<span>|</span>pug<span>|</span>twig<span>|</span>vash<span>)</span> <span>(</span>defaults to jade<span>)</span>
        --no-view        use static html instead of view engine
    -c, --css <span>&lt;</span>engine<span>></span>   <span>add</span> stylesheet <span>&lt;</span>engine<span>></span> support <span>(</span>less<span>|</span>stylus<span>|</span>compass<span>|</span>sass<span>)</span> <span>(</span>defaults to plain css<span>)</span>
        --git            <span>add</span> .gitignore
    -f, --force          force on non-empty directory
    -h, --help           output usage information

  error: option `-v, --view <span>&lt;</span>engine<span>></span>' argument missing

PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>></span> express --version
<span>4.16</span>.1
PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><blockquote>
<p>全局安装我们可以使用<code>express</code>提供的“快速开始”功能，快速的生成web项目文件。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>初始化项目</title>
      <link>https://wangyawei.top/views/backEnd/express/express-note-03/</link>
      <guid>https://wangyawei.top/views/backEnd/express/express-note-03/</guid>
      <source url="https://wangyawei.top/rss.xml">初始化项目</source>
      <category>EXPRESS</category>
      <pubDate>Mon, 12 Jul 2021 08:41:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要介绍下怎么开始一个express项目；请确认你已经安装了nodejs！<strong>无特殊说明则以下示例代码及后面的文章使用的是<code>express@4.16.1</code>，项目结构由express自动生成的，也就是方法2;</strong></p>
</blockquote>
<h2 id="方法1"> 方法1</h2>
<ol>
<li>
<p>新建应用目录，然后进入该目录并将其作为工作目录。</p>
<div><pre><code><span>mkdir</span> express-example
<span>cd</span> express-example
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>npm 初始化: 会在根目录生成 <code>package.json</code>文件。</p>
<div><pre><code><span>npm</span> init -y
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>安装<code>express</code></p>
<div><pre><code><span>npm</span> <span>install</span> express --save
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>开始编码：新建<code>app.js</code>，代码如下</p>
<div><pre><code><span>// 导入express模块</span>
<span>const</span> express <span>=</span> <span>require</span><span>(</span><span>'express'</span><span>)</span><span>;</span>
<span>// 创建应用 注意 express.createServer() 这种创建的方式已经过时了(大约8年前就被官方弃用了)，我当前的版本是4.17.1</span>
<span>const</span> app <span>=</span> <span>express</span><span>(</span><span>)</span><span>;</span>

<span>// 设置路由</span>
app<span>.</span><span>get</span><span>(</span><span>'/'</span><span>,</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>=></span> <span>{</span>
    <span>// 设置响应类型</span>
    res<span>.</span><span>set</span><span>(</span><span>'Content-Type'</span><span>,</span> <span>'text/plain'</span><span>)</span>
    <span>// 输出响应</span>
    res<span>.</span><span>send</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>req<span>.</span>headers<span>,</span> <span>null</span><span>,</span> <span>4</span><span>)</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>// 开启监听</span>
app<span>.</span><span>listen</span><span>(</span><span>8000</span><span>,</span> <span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'listen on 8000'</span><span>)</span>
    <span>}</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div></li>
<li>
<p>目录结构</p>
<div><pre><code>express-example
├── app.js
├── package-lock.json
└── package.json
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>启动服务</p>
<div><pre><code>PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span>express--example<span>\</span>zc<span>></span> node app.js
listen on <span>8000</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>浏览器访问</p>
<div><pre><code><span># 浏览器访问：http://localhost:8000/</span>
<span>{</span>
    <span>"host"</span><span>:</span> <span>"localhost:8000"</span>,
    <span>"connection"</span><span>:</span> <span>"keep-alive"</span>,
    <span>"cache-control"</span><span>:</span> <span>"max-age=0"</span>,
    <span>"sec-ch-ua"</span><span>:</span> <span>"<span title="\&quot;">\"</span> Not;A Brand<span title="\&quot;">\"</span>;v=<span title="\&quot;">\"</span>99<span title="\&quot;">\"</span>, <span title="\&quot;">\"</span>Google Chrome<span title="\&quot;">\"</span>;v=<span title="\&quot;">\"</span>91<span title="\&quot;">\"</span>, <span title="\&quot;">\"</span>Chromium<span title="\&quot;">\"</span>;v=<span title="\&quot;">\"</span>91<span title="\&quot;">\"</span>"</span>,
    <span>"sec-ch-ua-mobile"</span><span>:</span> <span>"?0"</span>,
    <span>"upgrade-insecure-requests"</span><span>:</span> <span>"1"</span>,
    <span>"user-agent"</span><span>:</span> <span>"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.124 Safari/537.36"</span>,
    <span>"accept"</span><span>:</span> <span>"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9"</span>,
    <span>"sec-fetch-site"</span><span>:</span> <span>"none"</span>,
    <span>"sec-fetch-mode"</span><span>:</span> <span>"navigate"</span>,
    <span>"sec-fetch-user"</span><span>:</span> <span>"?1"</span>,
    <span>"sec-fetch-dest"</span><span>:</span> <span>"document"</span>,
    <span>"accept-encoding"</span><span>:</span> <span>"gzip, deflate, br"</span>,
    <span>"accept-language"</span><span>:</span> <span>"zh-CN,zh;q=0.9"</span>,
    <span>"if-none-match"</span><span>:</span> <span>"W/<span title="\&quot;">\"</span>33a-S4giK0tKs+4sciW3Ad0JtevYSGM<span title="\&quot;">\"</span>"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></li>
</ol>
<h2 id="方法2"> 方法2</h2>
<blockquote>
<p>借助全局安装的express工具，直接生成一个express模板项目；</p>
</blockquote>
<p><strong>命令</strong>：<code>express -v ejs qwer</code></p>
<div><pre><code>PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span>express--example<span>></span> express -v ejs qwer

   create <span>:</span> qwer<span>\</span>
   create <span>:</span> qwer<span>\</span>public<span>\</span>
   create <span>:</span> qwer<span>\</span>public<span>\</span>javascripts<span>\</span>
   create <span>:</span> qwer<span>\</span>public<span>\</span>images<span>\</span>
   create <span>:</span> qwer<span>\</span>public<span>\</span>stylesheets<span>\</span>
   create <span>:</span> qwer<span>\</span>public<span>\</span>stylesheets<span>\</span>style.css
   create <span>:</span> qwer<span>\</span>routes<span>\</span>
   create <span>:</span> qwer<span>\</span>routes<span>\</span>index.js
   create <span>:</span> qwer<span>\</span>routes<span>\</span>users.js
   create <span>:</span> qwer<span>\</span>views<span>\</span>
   create <span>:</span> qwer<span>\</span>views<span>\</span>error.ejs
   create <span>:</span> qwer<span>\</span>views<span>\</span>index.ejs
   create <span>:</span> qwer<span>\</span>package.json
   create <span>:</span> qwer<span>\</span>bin<span>\</span>
   create <span>:</span> qwer<span>\</span>bin<span>\</span>www

     <span>></span> <span>cd</span> qwer

   <span>install</span> dependencies:
     <span>></span> <span>npm</span> <span>install</span>

     <span>></span> SET <span>DEBUG</span><span>=</span>qwer:* <span>&amp;</span> <span>npm</span> start

PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span>express--example<span>></span>cd qwer
PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span>express--example<span>\</span>qwer<span>></span> <span>npm</span> <span>install</span>
<span>npm</span> notice created a lockfile as package-lock.json. You should commit this file.
added <span>54</span> packages from <span>38</span> contributors and audited <span>55</span> packages <span>in</span> <span>8</span>.856s
found <span>0</span> vulnerabilities

PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span>express--example<span>\</span>qwer<span>></span> <span>npm</span> start

<span>></span> qwer@0.0.0 start C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span>express--example<span>\</span>qwer
<span>></span> SET <span>DEBUG</span><span>=</span>qwer:* <span>&amp;&amp;</span> node ./bin/www

  qwer:server Listening on port <span>3000</span> +0ms
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><div><p>提示</p>
<p><code>SET DEBUG=qwer:* &amp; npm start</code>这一步需要在<code>package.json</code>文件中设置，然后再执行<code>npm start</code>;</p>
<div><pre><code><span>"scripts"</span><span>:</span> <span>{</span>
    <span>"start"</span><span>:</span> <span>"SET DEBUG=qwer:* &amp;&amp; node ./bin/www"</span>
<span>}</span><span>,</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></div>
]]></content:encoded>
    </item>
    <item>
      <title>工程结构</title>
      <link>https://wangyawei.top/views/backEnd/express/express-note-04/</link>
      <guid>https://wangyawei.top/views/backEnd/express/express-note-04/</guid>
      <source url="https://wangyawei.top/rss.xml">工程结构</source>
      <category>EXPRESS</category>
      <pubDate>Mon, 12 Jul 2021 20:32:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里简单说下用express生成器创建的工程结构。除了 package.json，它还生成了其他文件。</p>
</blockquote>
<h2 id="目录结构"> <strong>目录结构</strong></h2>
<div><pre><code>express--example
├── app.js
├── bin
│   └── www
├── package-lock.json
├── package.json
├── public
│   ├── images
│   ├── javascripts
│   └── stylesheets
│       └── style.css
├── routes
│   ├── index.js
│   └── users.js
└── views
    ├── error.ejs
    └── index.ejs
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="bin-www"> bin/www</h2>
<p>www 是项目的启动文件，内容如下：</p>
<div><pre><code><span>#!/usr/bin/env node</span>

<span>/**
 * Module dependencies.
 */</span>

<span>var</span> app <span>=</span> <span>require</span><span>(</span><span>'../app'</span><span>)</span><span>;</span>
<span>var</span> debug <span>=</span> <span>require</span><span>(</span><span>'debug'</span><span>)</span><span>(</span><span>'qwer:server'</span><span>)</span><span>;</span>
<span>var</span> http <span>=</span> <span>require</span><span>(</span><span>'http'</span><span>)</span><span>;</span>

<span>/**
 * Get port from environment and store in Express.
 */</span>

<span>var</span> port <span>=</span> <span>normalizePort</span><span>(</span>process<span>.</span>env<span>.</span><span>PORT</span> <span>||</span> <span>'3000'</span><span>)</span><span>;</span>
app<span>.</span><span>set</span><span>(</span><span>'port'</span><span>,</span> port<span>)</span><span>;</span>

<span>/**
 * Create HTTP server.
 */</span>

<span>var</span> server <span>=</span> http<span>.</span><span>createServer</span><span>(</span>app<span>)</span><span>;</span>

<span>/**
 * Listen on provided port, on all network interfaces.
 */</span>

server<span>.</span><span>listen</span><span>(</span>port<span>)</span><span>;</span>
server<span>.</span><span>on</span><span>(</span><span>'error'</span><span>,</span> onError<span>)</span><span>;</span>
server<span>.</span><span>on</span><span>(</span><span>'listening'</span><span>,</span> onListening<span>)</span><span>;</span>

<span>/**
 * Normalize a port into a number, string, or false.
 */</span>

<span>function</span> <span>normalizePort</span><span>(</span><span>val</span><span>)</span> <span>{</span>
  <span>var</span> port <span>=</span> <span>parseInt</span><span>(</span>val<span>,</span> <span>10</span><span>)</span><span>;</span>

  <span>if</span> <span>(</span><span>isNaN</span><span>(</span>port<span>)</span><span>)</span> <span>{</span>
    <span>// named pipe</span>
    <span>return</span> val<span>;</span>
  <span>}</span>

  <span>if</span> <span>(</span>port <span>>=</span> <span>0</span><span>)</span> <span>{</span>
    <span>// port number</span>
    <span>return</span> port<span>;</span>
  <span>}</span>

  <span>return</span> <span>false</span><span>;</span>
<span>}</span>

<span>/**
 * Event listener for HTTP server "error" event.
 */</span>

<span>function</span> <span>onError</span><span>(</span><span>error</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>error<span>.</span>syscall <span>!==</span> <span>'listen'</span><span>)</span> <span>{</span>
    <span>throw</span> error<span>;</span>
  <span>}</span>

  <span>var</span> bind <span>=</span> <span>typeof</span> port <span>===</span> <span>'string'</span>
    <span>?</span> <span>'Pipe '</span> <span>+</span> port
    <span>:</span> <span>'Port '</span> <span>+</span> port<span>;</span>

  <span>// handle specific listen errors with friendly messages</span>
  <span>switch</span> <span>(</span>error<span>.</span>code<span>)</span> <span>{</span>
    <span>case</span> <span>'EACCES'</span><span>:</span>
      console<span>.</span><span>error</span><span>(</span>bind <span>+</span> <span>' requires elevated privileges'</span><span>)</span><span>;</span>
      process<span>.</span><span>exit</span><span>(</span><span>1</span><span>)</span><span>;</span>
      <span>break</span><span>;</span>
    <span>case</span> <span>'EADDRINUSE'</span><span>:</span>
      console<span>.</span><span>error</span><span>(</span>bind <span>+</span> <span>' is already in use'</span><span>)</span><span>;</span>
      process<span>.</span><span>exit</span><span>(</span><span>1</span><span>)</span><span>;</span>
      <span>break</span><span>;</span>
    <span>default</span><span>:</span>
      <span>throw</span> error<span>;</span>
  <span>}</span>
<span>}</span>

<span>/**
 * Event listener for HTTP server "listening" event.
 */</span>

<span>function</span> <span>onListening</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> addr <span>=</span> server<span>.</span><span>address</span><span>(</span><span>)</span><span>;</span>
  <span>var</span> bind <span>=</span> <span>typeof</span> addr <span>===</span> <span>'string'</span>
    <span>?</span> <span>'pipe '</span> <span>+</span> addr
    <span>:</span> <span>'port '</span> <span>+</span> addr<span>.</span>port<span>;</span>
  <span>debug</span><span>(</span><span>'Listening on '</span> <span>+</span> bind<span>)</span><span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br></div></div><blockquote>
<p>以上内容主要是引入 app.js和http模块， 然后创建一个服务器并启动；</p>
</blockquote>
<h2 id="app-js"> app.js</h2>
<p>app.js 是工程的入口，内容如下：</p>
<div><pre><code><span>// 用于处理HTTP Error</span>
<span>var</span> createError <span>=</span> <span>require</span><span>(</span><span>'http-errors'</span><span>)</span><span>;</span>
<span>// 引入express框架</span>
<span>var</span> express <span>=</span> <span>require</span><span>(</span><span>'express'</span><span>)</span><span>;</span>
<span>var</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span><span>;</span>
<span>// cookie解析器</span>
<span>var</span> cookieParser <span>=</span> <span>require</span><span>(</span><span>'cookie-parser'</span><span>)</span><span>;</span>
<span>// 请求日志中间件</span>
<span>var</span> logger <span>=</span> <span>require</span><span>(</span><span>'morgan'</span><span>)</span><span>;</span>

<span>// 引入路由中间件</span>
<span>var</span> indexRouter <span>=</span> <span>require</span><span>(</span><span>'./routes/index'</span><span>)</span><span>;</span>
<span>var</span> usersRouter <span>=</span> <span>require</span><span>(</span><span>'./routes/users'</span><span>)</span><span>;</span>

<span>// 创建app应用的实例</span>
<span>var</span> app <span>=</span> <span>express</span><span>(</span><span>)</span><span>;</span>

<span>// 设置视图模板文件位置</span>
app<span>.</span><span>set</span><span>(</span><span>'views'</span><span>,</span> path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>'views'</span><span>)</span><span>)</span><span>;</span>
<span>// 设置视图模板引擎</span>
app<span>.</span><span>set</span><span>(</span><span>'view engine'</span><span>,</span> <span>'ejs'</span><span>)</span><span>;</span>

<span>// 使用预定义的 dev 格式输出，</span>
app<span>.</span><span>use</span><span>(</span><span>logger</span><span>(</span><span>'dev'</span><span>)</span><span>)</span><span>;</span>
<span>// parse application/json 的传入请求</span>
app<span>.</span><span>use</span><span>(</span>express<span>.</span><span>json</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>// parse application/x-www-form-urlencoded 解析文件上传</span>
app<span>.</span><span>use</span><span>(</span>express<span>.</span><span>urlencoded</span><span>(</span><span>{</span> extended<span>:</span> <span>false</span> <span>}</span><span>)</span><span>)</span><span>;</span>
<span>// 解析cookie，挂载到req.cookies上</span>
app<span>.</span><span>use</span><span>(</span><span>cookieParser</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>// 托管静态资源 html、js、css</span>
app<span>.</span><span>use</span><span>(</span>express<span>.</span><span>static</span><span>(</span>path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>'public'</span><span>)</span><span>)</span><span>)</span><span>;</span>

<span>// 加载路由中间件</span>
app<span>.</span><span>use</span><span>(</span><span>'/'</span><span>,</span> indexRouter<span>)</span><span>;</span>
app<span>.</span><span>use</span><span>(</span><span>'/users'</span><span>,</span> usersRouter<span>)</span><span>;</span>

<span>// 捕获404并转发到错误处理程序</span>
app<span>.</span><span>use</span><span>(</span><span>function</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>{</span>
  <span>next</span><span>(</span><span>createError</span><span>(</span><span>404</span><span>)</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>// 错误处理程序</span>
app<span>.</span><span>use</span><span>(</span><span>function</span><span>(</span><span>err<span>,</span> req<span>,</span> res<span>,</span> next</span><span>)</span> <span>{</span>
  <span>// 设置局部，只提供开发中的错误</span>
  <span>// app.locals对象是一个javascript对象，它的属性就是程序本地的变量。</span>
  <span>// 一旦设定，app.locals的各属性值将贯穿程序的整个生命周期，与其相反的是 res.locals ，它只在这次请求的生命周期中有效。</span>
  <span>// 在程序中，你可以在渲染模板时使用这些本地变量.</span>
  res<span>.</span>locals<span>.</span>message <span>=</span> err<span>.</span>message<span>;</span>
  res<span>.</span>locals<span>.</span>error <span>=</span> req<span>.</span>app<span>.</span><span>get</span><span>(</span><span>'env'</span><span>)</span> <span>===</span> <span>'development'</span> <span>?</span> err <span>:</span> <span>{</span><span>}</span><span>;</span>

  <span>// 渲染错误页面</span>
  res<span>.</span><span>status</span><span>(</span>err<span>.</span>status <span>||</span> <span>500</span><span>)</span><span>;</span>
  res<span>.</span><span>render</span><span>(</span><span>'error'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

module<span>.</span>exports <span>=</span> app<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><blockquote>
<p>通过以上内容我们可以得出，express使用了很多的中间件；</p>
</blockquote>
<h2 id="routes-index-js"> routes/index.js</h2>
<p>routes/index.js 是路由文件，相当于控制器，用于组织展示的内容：</p>
<div><pre><code><span>var</span> express <span>=</span> <span>require</span><span>(</span><span>'express'</span><span>)</span><span>;</span>
<span>var</span> router <span>=</span> express<span>.</span><span>Router</span><span>(</span><span>)</span><span>;</span>

<span>/* GET home page. */</span>
router<span>.</span><span>get</span><span>(</span><span>'/'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>{</span>
  res<span>.</span><span>render</span><span>(</span><span>'index'</span><span>,</span> <span>{</span> title<span>:</span> <span>'Express'</span> <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

module<span>.</span>exports <span>=</span> router<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>
<p>app.js 中通过 app.use('/', indexRouter);将“/ ”路径映射到 router 函数下。其中只有一个语句 res.render('index', { title: 'Express' })，功能是调用模板解析引擎，翻译名为 index 的模板，并传入一个对象作为参数，这个对象只有一个属性，即 title: 'Express'。</p>
</blockquote>
<h2 id="views-index-ejs"> views/index.ejs</h2>
<blockquote>
<p>index.ejs 是模板文件，即 routes/index.js 中调用的模板，内容是：</p>
</blockquote>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span><span>></span></span>
  <span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>&lt;%= title %><span><span><span>&lt;/</span>title</span><span>></span></span>
    <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>'</span>stylesheet<span>'</span></span> <span>href</span><span><span>=</span><span>'</span>/stylesheets/style.css<span>'</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>h1</span><span>></span></span>&lt;%= title %><span><span><span>&lt;/</span>h1</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>Welcome to &lt;%= title %><span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>
<p>它的基础是 HTML 语言，其中包含了形如 &lt;%= title %&gt; 的标签，功能是显示引用的变量，即 res.render 函数第二个参数传入的对象的属性。</p>
</blockquote>
<h2 id="public"> public</h2>
<p>这个文件夹主要是用于存放静态资源的，比如：html、css、js、img等；</p>
<div><pre><code><span>// 此文件夹中的静态资源需要express来托管；即需要在app.js中引用</span>
app<span>.</span><span>use</span><span>(</span>express<span>.</span><span>static</span><span>(</span>path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>'public'</span><span>)</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>路由控制</title>
      <link>https://wangyawei.top/views/backEnd/express/express-note-05/</link>
      <guid>https://wangyawei.top/views/backEnd/express/express-note-05/</guid>
      <source url="https://wangyawei.top/rss.xml">路由控制</source>
      <category>EXPRESS</category>
      <pubDate>Tue, 13 Jul 2021 08:31:48 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要介绍下，路由相关的内容，路由工作原理及匹配规则；</p>
</blockquote>
<h2 id="工作原理"> 工作原理</h2>
<blockquote>
<p>当通过浏览器访问 app.js 建立的服务器时，会看到一个简单的页面，实际上浏览器会向服务器发送以下请求：</p>
</blockquote>
<div><pre><code><span>GET</span> <span>/</span> <span>HTTP</span><span>/</span><span>1.1</span>
Host<span>:</span> localhost<span>:</span><span>3000</span>
Connection<span>:</span> keep<span>-</span>alive
Cache<span>-</span>Control<span>:</span> max<span>-</span>age<span>=</span><span>0</span>
sec<span>-</span>ch<span>-</span>ua<span>:</span> <span>" Not;A Brand"</span><span>;</span>v<span>=</span><span>"99"</span><span>,</span> <span>"Google Chrome"</span><span>;</span>v<span>=</span><span>"91"</span><span>,</span> <span>"Chromium"</span><span>;</span>v<span>=</span><span>"91"</span>
sec<span>-</span>ch<span>-</span>ua<span>-</span>mobile<span>:</span> <span>?</span><span>0</span>
Upgrade<span>-</span>Insecure<span>-</span>Requests<span>:</span> <span>1</span>
User<span>-</span>Agent<span>:</span> Mozilla<span>/</span><span>5.0</span> <span>(</span>Windows <span>NT</span> <span>10.0</span><span>;</span> Win64<span>;</span> x64<span>)</span> AppleWebKit<span>/</span><span>537.36</span> <span>(</span><span>KHTML</span><span>,</span> like Gecko<span>)</span> Chrome<span>/</span><span>91.0</span><span>.4472</span><span>.124</span> Safari<span>/</span><span>537.36</span>
Accept<span>:</span> text<span>/</span>html<span>,</span>application<span>/</span>xhtml<span>+</span>xml<span>,</span>application<span>/</span>xml<span>;</span>q<span>=</span><span>0.9</span><span>,</span>image<span>/</span>avif<span>,</span>image<span>/</span>webp<span>,</span>image<span>/</span>apng<span>,</span><span>*</span><span>/*;q=0.8,application/signed-exchange;v=b3;q=0.9
Sec-Fetch-Site: none
Sec-Fetch-Mode: navigate
Sec-Fetch-User: ?1
Sec-Fetch-Dest: document
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.9
If-None-Match: W/"cf-sMq3uu/Hzh7Qc54TveG8DxiBA2U"
</span></code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><blockquote>
<p>其中第一行是请求的方法、路径和 HTTP 协议版本，后面若干行是 HTTP 请求头。 app 会解析请求的路径，调用相应的逻辑。 app.js 中有一行内容是 app.use('/', indexRouter)，它的作用是规定路径为“/”的请求由 indexRouter 函数处理。 indexRouter会再次匹配get和/最后通过 res.render('index', { title: 'Express' }) 调用视图模板 index，传递 title变量。最终视图模板生成 HTML 页面，返回给浏览器，返回的内容是：</p>
</blockquote>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span><span>></span></span>
  <span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Express<span><span><span>&lt;/</span>title</span><span>></span></span>
    <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>'</span>stylesheet<span>'</span></span> <span>href</span><span><span>=</span><span>'</span>/stylesheets/style.css<span>'</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>h1</span><span>></span></span>Express<span><span><span>&lt;/</span>h1</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>Welcome to Express<span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>
<p>浏览器在接收到内容以后，经过分析发现要获取 /stylesheets/style.css，因此会再次向服务器发起请求。 app.js 中并没有一个路由规则指派到 /stylesheets/style.css，但 app 通过app.use(express.static(path.join(__dirname, 'public'))); 配置了静态文件服务器，因此/stylesheets/style.css 会定向到 app.js 所在目录的子目录中的文件 public/stylesheets/style.css，向客户端返回以下信息：</p>
</blockquote>
<div><pre><code><span>body <span>{</span></span>
  <span><span>padding</span><span>:</span> <span>50</span><span>px</span><span>;</span></span>
  <span><span>font</span><span>:</span> <span>14</span><span>px</span> <span>"Lucida Grande"</span><span>,</span> Helvetica<span>,</span> Arial<span>,</span> sans-serif<span>;</span></span>
<span>}</span>

<span>a <span>{</span></span>
  <span><span>color</span><span>:</span> <span>#00B7FF</span><span>;</span></span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="创建路由规则"> 创建路由规则</h2>
<blockquote>
<p>当我们在浏览器中访问譬如 http://localhost:3000/abc 这样不存在的页面时，服务器会在响应头中返回 404 Not Found 错误</p>
</blockquote>
<p>这是因为 /abc 是一个不存在的路由规则，而且它也不是一个 public 目录下的文件，所以Express返回了404 Not Found的错误。</p>
<p><strong>创建一个地址为 /hello 的页面</strong></p>
<ul>
<li>
<p>在routes文件下新建hello.js文件，内容如下：</p>
<div><pre><code><span>var</span> express <span>=</span> <span>require</span><span>(</span><span>'express'</span><span>)</span><span>;</span>
<span>var</span> router <span>=</span> express<span>.</span><span>Router</span><span>(</span><span>)</span><span>;</span>

router<span>.</span><span>get</span><span>(</span><span>'/'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>{</span>
    res<span>.</span><span>send</span><span>(</span><span>'The time is '</span> <span>+</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

module<span>.</span>exports <span>=</span> router<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
<li>
<p>修改app.js文件并添加以下代码：</p>
<div><pre><code><span>var</span> helloRouter <span>=</span> <span>require</span><span>(</span><span>'./routes/hello'</span><span>)</span><span>;</span>
app<span>.</span><span>use</span><span>(</span><span>'/hello'</span><span>,</span> helloRouter<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>重启服务器，并打开浏览器访问；</p>
<div><pre><code>$ <span>curl</span> localhost:3000/hello
The <span>time</span> is Mon Jul <span>12</span> <span>2021</span> <span>23</span>:33:18 GMT+0800 <span>(</span>GMT+08:00<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>服务器在开始监听之前，设置好了所有的路由规则，当请求到达时直接分配到响应函数。</p>
</blockquote>
</li>
</ul>
<h2 id="路径匹配"> 路径匹配</h2>
<blockquote>
<p>express不仅可以为固定的路径设置路由规则， Express 还支持更高级的路径匹配模式。  如我们想要展示一个用户的个人页面，路径为 /[username]，可以用下面的方法定义路由规则：</p>
</blockquote>
<div><pre><code><span>var</span> express <span>=</span> <span>require</span><span>(</span><span>'express'</span><span>)</span><span>;</span>
<span>var</span> router <span>=</span> express<span>.</span><span>Router</span><span>(</span><span>)</span><span>;</span>

router<span>.</span><span>get</span><span>(</span><span>'/:username'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>{</span>
    res<span>.</span><span>write</span><span>(</span><span>'&lt;h1>The time is '</span> <span>+</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span> <span>+</span> <span>'&lt;/h1>'</span><span>)</span><span>;</span>
    res<span>.</span><span>end</span><span>(</span><span>'&lt;h2>user :'</span> <span>+</span> req<span>.</span>params<span>.</span>username <span>+</span> <span>'&lt;/h2>'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

module<span>.</span>exports <span>=</span> router<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>修改以后重启服务，访问 http://localhost:3000/hello/xiaoming，</p>
<div><pre><code>$ <span>curl</span> localhost:3000/hello/xiaoming
<span>&lt;</span>h<span><span>1</span>></span>The <span>time</span> is Tue Jul <span>13</span> <span>2021</span> 07:46:10 GMT+0800 <span>(</span>GMT+08:00<span>)</span><span>&lt;</span>/h<span><span>1</span>></span><span>&lt;</span>h<span><span>2</span>></span>user :xiaoming<span>&lt;</span>/h<span><span>2</span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>路径规则 /:username 会被自动编译为正则表达式。路径参数可以在响应函数中通过 req.params 的属性访问，当然你也可以直接写js表达式。例：<code>app.get(/\/([^\/]+)?/,callback)</code>。这样的好处在于可以定义更加复杂的路径规则，而不同之处是匹配的参数是匿名的，因此需要通过 req.params[0]、 req.params[1] 这样的形式访问。</p>
</blockquote>
<h2 id="rest-风格的路由规则"> REST 风格的路由规则</h2>
<blockquote>
<p>REST 的意思是 表征状态转移（Representational State Transfer），它是一种基于 HTTP 协议的网络应用的接口风格，充分利用 HTTP 的方法实现统一风格接口的服务。</p>
</blockquote>
<p><strong>HTTP 协议定义了以下8种标准的方法:</strong></p>
<ul>
<li>GET：请求获取指定资源。</li>
<li>HEAD：请求指定资源的响应头。</li>
<li>POST：向指定资源提交数据。</li>
<li>PUT：请求服务器存储一个资源。</li>
<li>DELETE：请求服务器删除指定资源。</li>
<li>TRACE：回显服务器收到的请求，主要用于测试或诊断。</li>
<li>CONNECT： HTTP/1.1 协议中预留给能够将连接改为管道方式的代理服务器。</li>
<li>OPTIONS：返回服务器支持的HTTP请求方法。</li>
</ul>
<p>其中我们经常用到的是 GET、 POST、 PUT 和 DELETE 方法。根据 REST 设计模式，这4种方法通常分别用于实现以下功能：</p>
<ul>
<li>GET：获取</li>
<li>POST：新增</li>
<li>PUT：更新</li>
<li>DELETE：删除</li>
</ul>
<p>这是因为这4种方法有不同的特点，按照定义，它们的特点如下：</p>
<table>
<thead>
<tr>
<th>请求方式</th>
<th>安全</th>
<th>幂等</th>
</tr>
</thead>
<tbody>
<tr>
<td>GET</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>POST</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>PUT</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>DELETE</td>
<td>否</td>
<td>是</td>
</tr>
</tbody>
</table>
<blockquote>
<p>所谓安全是指没有副作用，即请求不会对资源产生变动，连续访问多次所获得的结果不受访问者的影响。而幂等指的是重复请求多次与一次请求的效果是一样的，比如获取和更新操作是幂等的，这与新增不同。删除也是幂等的，即重复删除一个资源，和删除一次是一样的。</p>
</blockquote>
<p>Express 对每种 HTTP 请求方法都设计了不同的路由绑定函数，向这个路径发起其他方式的请求不会被响应。  详细内容请<a href="https://www.expressjs.com.cn/4x/api.html" target="_blank" rel="noopener noreferrer">查阅官方文档</a></p>
<h2 id="控制权转移"> 控制权转移</h2>
<blockquote>
<p>Express 支持同一路径绑定多个路由响应函数</p>
</blockquote>
<div><pre><code>app<span>.</span><span>all</span><span>(</span><span>'/article'</span><span>,</span> <span>function</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>{</span>
  res<span>.</span><span>send</span><span>(</span><span>'all methods captured'</span><span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span><span>'all methods captured'</span><span>)</span>
<span>}</span><span>)</span><span>;</span>
app<span>.</span><span>get</span><span>(</span><span>'/article'</span><span>,</span> <span>function</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>{</span>
  res<span>.</span><span>send</span><span>(</span><span>'article: '</span> <span>+</span> <span>'123'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>
<p>但当你访问被这两条同样的规则匹配到的路径时，会发现请求总是被前一条路由规则捕获，后面的规则会被忽略。原因是 Express 在处理路由规则时，会优先匹配先定义的路由规则，因此后面相同的规则被屏蔽。Express 提供了路由控制权转移的方法，即回调函数的第三个参数next，通过调用next()，会将路由控制权转移给后面的规则，</p>
</blockquote>
<div><pre><code>app<span>.</span><span>all</span><span>(</span><span>'/article'</span><span>,</span> <span>function</span> <span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'all methods captured'</span><span>)</span>
  <span>next</span><span>(</span><span>)</span>
<span>}</span><span>)</span><span>;</span>
app<span>.</span><span>get</span><span>(</span><span>'/article'</span><span>,</span> <span>function</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>{</span>
  res<span>.</span><span>send</span><span>(</span><span>'article: '</span> <span>+</span> <span>'123'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>
<p>当访问被匹配到的路径时，会发现终端中打印了 all methods captured，而且浏览器中显示了 article: 123。这说明请求先被第一条路由规则捕获，完成 console.log 使用 next() 转移控制权，又被第二条规则捕获，向浏览器返回了信息。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>模板引擎</title>
      <link>https://wangyawei.top/views/backEnd/express/express-note-06/</link>
      <guid>https://wangyawei.top/views/backEnd/express/express-note-06/</guid>
      <source url="https://wangyawei.top/rss.xml">模板引擎</source>
      <category>EXPRESS</category>
      <pubDate>Wed, 14 Jul 2021 23:06:48 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>模板引擎（Template Engine）是一个从页面模板根据一定的规则生成 HTML 的工具。  功能是将页面模板和要显示的数据结合起来生成 HTML 页面。它既可以运行在服务器端又可以运行在客户端，大多数时候它都在服务器端直接被解析为 HTML，解析
完成后再传输给客户端，因此客户端甚至无法判断页面是否是模板引擎生成的 。</p>
</blockquote>
<h2 id="使用模板引擎"> 使用模板引擎</h2>
<blockquote>
<p>基于 JavaScript 的模板引擎有许多种实现，我们推荐使用 ejs （Embedded JavaScript），因为它十分简单，而且与 Express 集成良好。由于它是标准 JavaScript 实现的，因此它不仅可以运行在服务器端，还可以运行在浏览器中。</p>
</blockquote>
<p><strong>在<code>app.js</code>中使用模板引擎：</strong></p>
<div><pre><code>app<span>.</span><span>set</span><span>(</span><span>'views'</span><span>,</span> path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>'views'</span><span>)</span><span>)</span><span>;</span>
app<span>.</span><span>set</span><span>(</span><span>'view engine'</span><span>,</span> <span>'ejs'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>以上内容表明要使用的模板引擎是 ejs，页面模板在 views 子目录下。在 routes/index.js 的<code>router.get</code>函数中通过如下语句调用模板引擎：</p>
</blockquote>
<div><pre><code>res<span>.</span><span>render</span><span>(</span><span>'index'</span><span>,</span> <span>{</span> title<span>:</span> <span>'Express'</span> <span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p><code>res.render</code> 的功能是调用模板引擎，并将其产生的页面直接返回给客户端。它接受两个参数，第一个是模板的名称，即 views 目录下的模板文件名，不包含文件的扩展名；第二个参数是传递给模板的数据，用于模板翻译。<code>index.ejs</code>内容如下：</p>
</blockquote>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span><span>></span></span>
  <span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span><span><span>&lt;%=</span><span> title </span><span>%></span></span><span><span><span>&lt;/</span>title</span><span>></span></span>
    <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>'</span>stylesheet<span>'</span></span> <span>href</span><span><span>=</span><span>'</span>/stylesheets/style.css<span>'</span></span> <span>/></span></span>
  <span><span><span>&lt;/</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>h1</span><span>></span></span><span><span>&lt;%=</span><span> title </span><span>%></span></span><span><span><span>&lt;/</span>h1</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>Welcome to <span><span>&lt;%=</span><span> title </span><span>%></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
  <span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>
<p>上面代码其中有两处 &lt;%= title %&gt;，用于模板变量显示，它们在模板翻译时会被替换成 Express，因为 <code>res.render</code> 传递了 <code>{ title: 'Express' }</code>。</p>
</blockquote>
<p><strong>ejs 的标签系统非常简单，它只有以下3种标签。</strong></p>
<ul>
<li><code>&lt;% code %&gt;</code>： JavaScript 代码。</li>
<li><code>&lt;%= code %&gt;</code>：显示替换过 HTML 特殊字符的内容。</li>
<li><code>&lt;%- code %&gt;</code>：显示原始 HTML 内容。</li>
<li><code>&lt;%# code %&gt;</code>：注释标签，不执行、不输出内容。</li>
<li><code>&lt;%%</code>：输出字符串 '&lt;%'</li>
</ul>
<h2 id="页面布局"> 页面布局</h2>
<blockquote>
<p>如果你也在看《nodejs 开发指南》那么你也会遇到我这个问题，《nodejs 开发指南》的作者使用的是<code>express@2.5.8</code>，而<code>layout.js</code>布局文件在<code>express@3.0</code>中就已经被移除<a href="https://github.com/expressjs/express/wiki/Migrating-from-2.x-to-3.x" target="_blank" rel="noopener noreferrer">官方文档</a>，所以在4.x中就不存在layout.js文件了。那么我们要怎么布局呢？这里我推荐<code>express-ejs-layouts</code>或<code>nunjucks</code>;</p>
</blockquote>
<p><strong>为什么要使用布局模板：</strong></p>
<ul>
<li>描述了整个页面的框架结构，每个单独的页面都继承自这个框架，替换掉 &lt;%- body %&gt; 部分；</li>
<li>保持整个网站的一致风格， HTML 页面的<head>部分以及页眉页脚中的大量内容是重复的，因此我们可以把它们放在 layout.ejs 中；</li>
</ul>
<p><strong>这里我使用<code>express-ejs-layouts</code></strong></p>
<ul>
<li>
<p>下载：</p>
<div><pre><code><span>npm</span> <span>install</span> express-ejs-layouts
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>使用：</p>
<div><pre><code><span>...</span>
<span>+</span> <span>var</span> expressLayouts <span>=</span> <span>require</span><span>(</span><span>'express-ejs-layouts'</span><span>)</span><span>;</span>

app<span>.</span><span>set</span><span>(</span><span>'views'</span><span>,</span> path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>'views'</span><span>)</span><span>)</span><span>;</span>
app<span>.</span><span>set</span><span>(</span><span>'view engine'</span><span>,</span> <span>'ejs'</span><span>)</span><span>;</span>
<span>+</span> app<span>.</span><span>use</span><span>(</span>expressLayouts<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>新建<code>layout.ejs</code>文件，内容如下：</p>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span><span><span>&lt;%=</span><span> title </span><span>%></span></span><span><span><span>&lt;/</span>title</span><span>></span></span>
    <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>"</span>stylesheet<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>text/css<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>/stylesheets/style.css<span>"</span></span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span>&lt;%-</span><span> body </span><span>%></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
<li>
<p><code>index.ejs</code>文件修改为：</p>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span><span><span>&lt;%=</span><span> title </span><span>%></span></span><span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span>Welcome to <span><span>&lt;%=</span><span> title </span><span>%></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>#<span>"</span></span><span>></span></span>a标签<span><span><span>&lt;/</span>a</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span>删除两侧的空格符 <span><span>&lt;%_</span><span> title </span><span>_%></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span>注释标签，不执行、不输出内容 <span><span>&lt;%</span><span># title </span><span>%></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span>输出字符串 &lt;%% <span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>启动服务，并访问 http://localhost:3000/</p>
<p><img src="./assets/image-20210714224215290.png" alt="image-20210714224215290" /></p>
<blockquote>
<p>由上图我们可以看到h1标签的字体颜色发生了改变，说明我们使用成功；</p>
</blockquote>
</li>
</ul>
<p>另一种情况是，一个网站可能需要不止一种页面布局，例如网站分前台展示和后台管理系统，两者的页面结构有很大的区别，一套页面布局不能满足需求。这时我们可以在页面模板翻译时指定页面布局，即设置 layout 属性，例如：</p>
<div><pre><code>router<span>.</span><span>get</span><span>(</span><span>'/'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>{</span>
    res<span>.</span><span>render</span><span>(</span><span>'index'</span><span>,</span> <span>{</span> 
        title<span>:</span> <span>'用户列表后台管理系统'</span><span>,</span>
        layout<span>:</span> <span>'userlist'</span>
     <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>
<p>新建<code>routes/userlist.js</code>文件，内容如下：</p>
<div><pre><code><span>var</span> express <span>=</span> <span>require</span><span>(</span><span>'express'</span><span>)</span><span>;</span>
<span>var</span> router <span>=</span> express<span>.</span><span>Router</span><span>(</span><span>)</span><span>;</span>

router<span>.</span><span>get</span><span>(</span><span>'/'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>{</span>
    res<span>.</span><span>render</span><span>(</span><span>'index'</span><span>,</span> <span>{</span> 
        title<span>:</span> <span>'用户列表后台管理系统'</span><span>,</span>
        layout<span>:</span> <span>'userlist'</span>
     <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

module<span>.</span>exports <span>=</span> router<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
<li>
<p>新建<code>views/userlist.ejs</code>文件，内容如下：</p>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span><span><span>&lt;%=</span><span> title </span><span>%></span></span><span><span><span>&lt;/</span>title</span><span>></span></span>
    <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>"</span>stylesheet<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>text/css<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>/stylesheets/style.css<span>"</span></span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span>&lt;%-</span><span> body </span><span>%></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
<li>
<p>修改<code>app.js</code>添加如下代码:</p>
<div><pre><code><span>var</span> userlistRouter <span>=</span> <span>require</span><span>(</span><span>'./routes/userlist'</span><span>)</span><span>;</span>
app<span>.</span><span>use</span><span>(</span><span>'/userlist'</span><span>,</span> userlistRouter<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>重启服务，浏览器访问：http://localhost:3000/userlist</p>
<p><img src="./assets/image-20210714230357958.png" alt="image-20210714230357958" /></p>
<blockquote>
<p>上述代码会在翻译 userlist 页面模板时套用 userlist.ejs 作为页面布局 ;</p>
</blockquote>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>片段视图</title>
      <link>https://wangyawei.top/views/backEnd/express/express-note-07/</link>
      <guid>https://wangyawei.top/views/backEnd/express/express-note-07/</guid>
      <source url="https://wangyawei.top/rss.xml">片段视图</source>
      <category>EXPRESS</category>
      <pubDate>Wed, 14 Jul 2021 00:10:48 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Express 的视图系统还支持片段视图（partials），它就是一个页面的片段，通常是重复的内容，用于迭代显示。通过它你可以将相对独立的页面块分割出去，而且可以避免显式地使用 for 循环。<strong>但是在3.x版本及以后就移除掉了这个功能，所以这个时候你就需要替代方案</strong>。这里我只介绍4.x版本使用的<code>include</code>，另外一中方法请移步至：<a href="https://yijiebuyi.com/blog/e503a402ffac43ca1cbaba9d4317b54d.html" target="_blank" rel="noopener noreferrer">NodeJS - Express 3.0下ejs模板使用 partial展现 片段视图</a></p>
</blockquote>
<p><strong>让我们看一个例子，在 userlist.js 中新增以下内容：</strong></p>
<div><pre><code>router<span>.</span><span>get</span><span>(</span><span>'/list'</span><span>,</span> <span>function</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>{</span>
    res<span>.</span><span>render</span><span>(</span><span>'list'</span><span>,</span> <span>{</span>
        title<span>:</span> <span>'List'</span><span>,</span>
        items<span>:</span> <span>[</span><span>1991</span><span>,</span> <span>'byvoid'</span><span>,</span> <span>'express'</span><span>,</span> <span>'Node.js'</span><span>]</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>在 views 目录下新建 views/list.ejs，内容是：</strong></p>
<div><pre><code><span><span><span>&lt;</span>ul</span><span>></span></span>
    <span><span>&lt;%</span><span> items<span>.</span><span>forEach</span><span>(</span><span>function</span><span>(</span><span>user</span><span>)</span><span>{</span> </span><span>%></span></span>
        <span><span>&lt;%-</span><span> <span>include</span><span>(</span><span>'./listitem'</span><span>,</span> <span>{</span> listitem<span>:</span> user <span>}</span><span>)</span><span>;</span> </span><span>%></span></span>
    <span><span>&lt;%</span><span> <span>}</span><span>)</span><span>;</span> </span><span>%></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>同时新建 views/listitem.ejs，内容是：</strong></p>
<div><pre><code><span><span><span>&lt;</span>li</span><span>></span></span><span><span>&lt;%=</span><span> listitem </span><span>%></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>浏览器访问：http://localhost:3000/userlist/list</strong>,浏览器会响应如下内容：</p>
<div><pre><code><span>&lt;</span><span>!</span>DOCTYPE html<span>></span>
<span>&lt;</span>html<span>></span>
<span>&lt;</span>head<span>></span>
    <span>&lt;</span>title<span>></span>List<span>&lt;</span>/title<span>></span>
    <span>&lt;</span>link <span>rel</span><span>=</span><span>"stylesheet"</span> <span>type</span><span>=</span><span>"text/css"</span> <span>href</span><span>=</span><span>"/stylesheets/style.css"</span><span>></span>
<span>&lt;</span>/head<span>></span>
<span>&lt;</span>body<span>></span>
    <span>&lt;</span>ul<span>></span>
    
      <span>&lt;</span>li<span>></span><span>199</span><span><span>1</span>&lt;</span>/li<span>></span>
    
      <span>&lt;</span>li<span>></span>byvoid<span>&lt;</span>/li<span>></span>
    
      <span>&lt;</span>li<span>></span>express<span>&lt;</span>/li<span>></span>
    
      <span>&lt;</span>li<span>></span>Node.js<span>&lt;</span>/li<span>></span>
    
  <span>&lt;</span>/ul<span>></span>
<span>&lt;</span>/body<span>></span>
<span>&lt;</span>/html<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><blockquote>
<p>include是<code>ejs</code>提供的指令，通过 <code>include</code> 指令将相对于模板路径中的模板片段包含进来。(需要提供 'filename' 参数。) 例如，如果存在 &quot;./views/list.ejs&quot; 和 &quot;./views/listitem.ejs&quot; 两个模板文件，你可以通过 <code>&lt;%- include('./listitem'); %&gt;</code> 代码包含后者。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>视图助手</title>
      <link>https://wangyawei.top/views/backEnd/express/express-note-08/</link>
      <guid>https://wangyawei.top/views/backEnd/express/express-note-08/</guid>
      <source url="https://wangyawei.top/rss.xml">视图助手</source>
      <category>EXPRESS</category>
      <pubDate>Thu, 15 Jul 2021 08:33:10 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Express 提供了一种叫做视图助手的工具，它的功能是允许在视图中访问一个全局的函数或对象，不用每次调用视图解析的时候单独传入。</p>
</blockquote>
<p><strong>视图助手有两类</strong></p>
<ol>
<li>静态视图助手。</li>
<li>动态视图助手。</li>
</ol>
<h2 id="静态视图助手"> 静态视图助手</h2>
<blockquote>
<p>可以是任何类型的对象，包括接受任意参数的函数，但访问到的对象必须是与用户请求无关的。</p>
</blockquote>
<p><strong>修改<code>app.js</code>，新增如下内容：</strong></p>
<div><pre><code>app<span>.</span>locals<span>.</span>title <span>=</span> <span>'my app'</span><span>;</span>
app<span>.</span>locals<span>.</span>email <span>=</span> <span>'123@qq.com'</span><span>;</span>
app<span>.</span>locals<span>.</span><span>eat</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>'鸡腿'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>修改<code>views/index.ejs</code>，内容如下：</strong></p>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span><span><span>&lt;%=</span><span> title </span><span>%></span></span><span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span><span><span>&lt;%=</span><span> email </span><span>%></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>修改<code>routes/index.js</code>，内容如下：</strong></p>
<div><pre><code>res<span>.</span><span>render</span><span>(</span><span>'index'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>浏览器访问：http://localhost:3000/ 响应结果如下：</p>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>my app<span><span><span>&lt;/</span>title</span><span>></span></span>
    <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>"</span>stylesheet<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>text/css<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>/stylesheets/style.css<span>"</span></span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>h1</span><span>></span></span>my app<span><span><span>&lt;/</span>h1</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>123@qq.com<span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>鸡腿<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><p>注意</p>
<p>如果你在使用<code>res.render('index')</code>时传入了<code>res.render('index', {title: ’express‘})</code>，那么静态视图设置的值会被替换。</p>
</div>
<div><p>提示</p>
<p>静态视图助手在<code>2.x</code>版本和<code>3.x</code>版本的使用是不同的:</p>
<div><pre><code><span>// 2.x版本</span>
app<span>.</span><span>helpers</span><span>(</span><span>{</span>
    <span>title</span><span>:</span> <span>function</span><span>(</span><span>obj</span><span>)</span> <span>{</span>
    	<span>return</span> util<span>.</span><span>inspect</span><span>(</span>obj<span>,</span> <span>true</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span><span>;</span>
<span>// 3.x版本</span>
app<span>.</span><span>locals</span><span>(</span><span>{</span>
  title<span>:</span> config<span>.</span>title
<span>}</span><span>)</span><span>;</span>
<span>// 4.x版本</span>
app<span>.</span>locals<span>.</span>title <span>=</span> <span>'my app'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></div>
<h2 id="动态视图助手"> 动态视图助手</h2>
<blockquote>
<p>该视图变量、方法与请求有关，一般用来解析请求信息，如用户登录信息，请求地址等，可以访问到 req 和 res 对象。</p>
</blockquote>
<p>修改<code>app.js</code>，内容如下：</p>
<div><pre><code>app<span>.</span><span>use</span><span>(</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
  res<span>.</span>locals<span>.</span>req <span>=</span> utils<span>.</span><span>inspect</span><span>(</span>req<span>,</span> <span>true</span><span>)</span><span>;</span>
  res<span>.</span>locals<span>.</span>res <span>=</span> res<span>;</span>
  <span>next</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>)</span>

<span>// 或 在路由中设置：</span>

router<span>.</span><span>get</span><span>(</span><span>'/'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>{</span>
  res<span>.</span>locals<span>.</span>req <span>=</span> utils<span>.</span><span>inspect</span><span>(</span>req<span>.</span>headers<span>)</span><span>;</span>
  res<span>.</span><span>render</span><span>(</span><span>'index'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>修改<code>views/index.ejs</code>，内容如下：</p>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span><span><span>&lt;%=</span><span> title </span><span>%></span></span><span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span><span><span>&lt;%=</span><span> email </span><span>%></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span><span><span>&lt;%=</span><span> <span>eat</span><span>(</span><span>)</span> </span><span>%></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>pre</span><span>></span></span><span><span>&lt;%=</span><span> req </span><span>%></span></span><span><span><span>&lt;/</span>pre</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>浏览器访问：http://localhost:3000/，响应内容呢如下：</p>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>my app<span><span><span>&lt;/</span>title</span><span>></span></span>
    <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>"</span>stylesheet<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>text/css<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>/stylesheets/style.css<span>"</span></span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>h1</span><span>></span></span>my app<span><span><span>&lt;/</span>h1</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>123@qq.com<span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>鸡腿<span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;</span>pre</span><span>></span></span>IncomingMessage {
      _readableState: ReadableState {
        objectMode: false,
        highWaterMark: 16384,
        buffer: BufferList { head: null, tail: null, length: 0 },
        length: 0,
        .....以下省略
    }<span><span><span>&lt;/</span>pre</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><div><p>提示</p>
<p>动态视图助手在<code>2.x</code>版本的使用是不同的，3.x版本的使用和4.x相同:</p>
<div><pre><code><span>// 2.x</span>
app<span>.</span><span>dynamicHelpers</span><span>(</span><span>{</span>
    <span>headers</span><span>:</span> <span>function</span><span>(</span><span>req<span>,</span> res</span><span>)</span> <span>{</span>
    	<span>return</span> req<span>.</span>headers<span>;</span>
    <span>}</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></div>
<blockquote>
<p>视图助手的本质其实就是给所有视图注册了全局变量，因此无需每次在调用模板引擎时传递数据对象。当我们在后面使用 session 时会发现它是非常有用的。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>建立微博网站</title>
      <link>https://wangyawei.top/views/backEnd/express/express-note-09/</link>
      <guid>https://wangyawei.top/views/backEnd/express/express-note-09/</guid>
      <source url="https://wangyawei.top/rss.xml">建立微博网站</source>
      <category>EXPRESS</category>
      <pubDate>Fri, 16 Jul 2021 21:26:10 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要是对前面的知识的简单实践，现在让我们动手开始创建一个微博网站吧。项目使用的是<code>express@4.16.1</code>。</p>
</blockquote>
<h2 id="功能分析"> 功能分析</h2>
<blockquote>
<p>开发中的一个大忌就是没有想清楚要做什么就开始动手，因此我们准备在动手实践之前先规划一下网站的功能。首先，微博应该以用户为中心，因此需要有用户的注册和登录功能。微博网站最核心的功能是信息的发表，这个功能涉及许多方面，包括数据库访问、前端显示等。一个完整的微博系统应该支持信息的评论、转发、圈点用户等功能，但出于学习目的，我们不能一一实现所有功能，只是实现一个微博社交网站的雏形 ；</p>
</blockquote>
<h2 id="路由规划"> 路由规划</h2>
<blockquote>
<p>在完成功能设计以后，下一个要做的事情就是路由规划了。路由规划，或者说控制器规划是整个网站的骨架部分，因为它处于整个架构的枢纽位置，相当于各个接口之间的粘合剂，所以应该优先考虑。</p>
</blockquote>
<p><strong>根据功能设计，我们把路由按照以下方案规划。</strong></p>
<ul>
<li>/：首页</li>
<li>/u/[user]：用户的主页</li>
<li>/post：发表信息</li>
<li>/reg：用户注册</li>
<li>/login：用户登录</li>
<li>/logout：用户登出</li>
</ul>
<p><strong>打开 routes/index.js，部分修改为：</strong></p>
<div><pre><code><span>/* GET home page. */</span>
router<span>.</span><span>get</span><span>(</span><span>'/'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>{</span>
  res<span>.</span><span>render</span><span>(</span><span>'index'</span><span>,</span> <span>{</span> title<span>:</span> <span>'晚上好'</span> <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

router<span>.</span><span>get</span><span>(</span><span>'/u/:user'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>{</span>
  res<span>.</span><span>end</span><span>(</span><span>'开始1'</span><span>)</span>
<span>}</span><span>)</span><span>;</span>

router<span>.</span><span>post</span><span>(</span><span>'/post'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>{</span>
  res<span>.</span><span>end</span><span>(</span><span>'开始2'</span><span>)</span>
<span>}</span><span>)</span><span>;</span>

router<span>.</span><span>get</span><span>(</span><span>'/reg'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>{</span>
  res<span>.</span><span>set</span><span>(</span><span>'Content-Type'</span><span>,</span> <span>'text/plain'</span><span>)</span>
  res<span>.</span><span>send</span><span>(</span><span>'开始3'</span><span>)</span>
<span>}</span><span>)</span><span>;</span>

router<span>.</span><span>post</span><span>(</span><span>'/reg'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>{</span>
  res<span>.</span><span>end</span><span>(</span><span>'开始4'</span><span>)</span>
<span>}</span><span>)</span><span>;</span>

router<span>.</span><span>get</span><span>(</span><span>'/login'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>{</span>
  res<span>.</span><span>end</span><span>(</span><span>'开始5'</span><span>)</span>
<span>}</span><span>)</span><span>;</span>

router<span>.</span><span>post</span><span>(</span><span>'/login'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>{</span>
  res<span>.</span><span>end</span><span>(</span><span>'开始6'</span><span>)</span>
<span>}</span><span>)</span><span>;</span>

router<span>.</span><span>get</span><span>(</span><span>'/logout'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>{</span>
  res<span>.</span><span>end</span><span>(</span><span>'开始7'</span><span>)</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>其中 /post、 /login 和 /reg 由于要接受表单信息，因此使用 app.post 注册路由。 /login和 /reg 还要显示用户注册时要填写的表单，所以要以 app.get 注册。</p>
<h2 id="界面设计"> 界面设计</h2>
<blockquote>
<p>开发网站的时候必须时刻意识到网站是为用户开发的，因而用户界面是非常重要的。TwitterBootstrap 是由 Twitter 的设计师和工程师发起的开源项目，它提供了一套与 Twitter 风格一致的简洁、优雅的 Web UI，包含了完全由 HTML、 CSS、 JavaScript 实现的用户交互工具。可以让你轻松地使用Twitter Bootstrap 制作出优美的界面。</p>
</blockquote>
<h2 id="使用-bootstrap"> 使用 Bootstrap</h2>
<blockquote>
<p>现在我们就用 Bootstrap 开始设计我们的界面。从https://v4.bootcss.com/下载bootstrap.zip，解压后可以看到以下文件：</p>
</blockquote>
<div><pre><code>PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span>bootstrap-4.6.0-dist<span>></span> treee
bootstrap-4.6.0-dist
├── css
│   ├── bootstrap-grid.css
│   ├── bootstrap-grid.css.map
│   ├── bootstrap-grid.min.css
│   ├── bootstrap-grid.min.css.map
│   ├── bootstrap-reboot.css
│   ├── bootstrap-reboot.css.map
│   ├── bootstrap-reboot.min.css
│   ├── bootstrap-reboot.min.css.map
│   ├── bootstrap.css
│   ├── bootstrap.css.map
│   ├── bootstrap.min.css
│   └── bootstrap.min.css.map
└── js
    ├── bootstrap.bundle.js
    ├── bootstrap.bundle.js.map
    ├── bootstrap.bundle.min.js
    ├── bootstrap.bundle.min.js.map
    ├── bootstrap.js
    ├── bootstrap.js.map
    ├── bootstrap.min.js
    └── bootstrap.min.js.map
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><blockquote>
<p>其中所有的 JavaScript 和 CSS 文件都提供了开发版和产品版，前者是原始的代码，后者经过压缩，文件名中带有 min。将 bootstrap.css复制到 public/stylesheets 中，将 bootstrap.js 复制到 public/javascripts 目录中，然后从http://jquery.com/下载一份最新版的 jquery.js 也放入 public/javascripts 目录中。接下来，修改 views/layout.ejs：</p>
</blockquote>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>IE=edge<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>"</span>stylesheet<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>text/css<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>stylesheets/bootstrap.min.css<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>link</span> <span>rel</span><span><span>=</span><span>"</span>stylesheet<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>text/css<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>stylesheets/style.css<span>"</span></span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>

<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>navbar fixed-top navbar-expand-lg navbar-dark bg-dark<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>a</span> <span>class</span><span><span>=</span><span>"</span>navbar-brand<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>/<span>"</span></span><span>></span></span>Microblog<span><span><span>&lt;/</span>a</span><span>></span></span>
        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>collapse navbar-collapse<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>ul</span> <span>class</span><span><span>=</span><span>"</span>navbar-nav<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>nav-item active<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>a</span> <span>class</span><span><span>=</span><span>"</span>nav-link<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>/<span>"</span></span><span>></span></span>首页<span><span><span>&lt;/</span>a</span><span>></span></span>
                <span><span><span>&lt;/</span>li</span><span>></span></span>
                <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>nav-item<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>a</span> <span>class</span><span><span>=</span><span>"</span>nav-link<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>/login<span>"</span></span><span>></span></span>登入<span><span><span>&lt;/</span>a</span><span>></span></span>
                <span><span><span>&lt;/</span>li</span><span>></span></span>
                <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>nav-item<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>a</span> <span>class</span><span><span>=</span><span>"</span>nav-link<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>/reg<span>"</span></span><span>></span></span>注册<span><span><span>&lt;/</span>a</span><span>></span></span>
                <span><span><span>&lt;/</span>li</span><span>></span></span>
            <span><span><span>&lt;/</span>ul</span><span>></span></span>
        <span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>container<span>"</span></span><span>></span></span>
        <span><span>&lt;%-</span><span> body </span><span>%></span></span>
        <span><span><span>&lt;</span>hr</span> <span>/></span></span>
        <span><span><span>&lt;</span>footer</span><span>></span></span>
            <span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://www.byvoid.com/<span>"</span></span> <span>target</span><span><span>=</span><span>"</span>_blank<span>"</span></span><span>></span></span>BYVoid<span><span><span>&lt;/</span>a</span><span>></span></span> 2012<span><span><span>&lt;/</span>p</span><span>></span></span>
        <span><span><span>&lt;/</span>footer</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>javascripts/jquery-3.6.0.min.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>javascripts/bootstrap.min.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><blockquote>
<p>上面代码是使用 Bootstrap部件实现的一个简单页面框架，整个页面分为顶部工具栏、正文和页脚三部分，其中正文和页脚包含在名为 container 的 div 标签中。最后我们设计首页，修改 views/index.ejs：</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>jumbotron bd-example<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>h1</span><span>></span></span>欢迎来到 Microblog<span><span><span>&lt;/</span>h1</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>Microblog 是一个基于 Node.js 的微博系统。 <span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;</span>p</span><span>></span></span>
        <span><span><span>&lt;</span>button</span> <span>type</span><span><span>=</span><span>"</span>button<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>btn btn-primary<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>/login<span>"</span></span><span>></span></span>登录<span><span><span>&lt;/</span>button</span> <span>></span></span>
        <span><span><span>&lt;</span>button</span> <span>type</span><span><span>=</span><span>"</span>button<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>btn btn-light<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>/reg<span>"</span></span><span>></span></span>立即注册<span><span><span>&lt;/</span>button</span> <span>></span></span>
    <span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>row<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>col-4<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>h2</span><span>></span></span>Carbo 说<span><span><span>&lt;/</span>h2</span><span>></span></span>
        <span><span><span>&lt;</span>p</span><span>></span></span>东风破早梅 向暖一枝开 冰雪无人见 春从天上来<span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>col-4<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>h2</span><span>></span></span>BYVoid 说<span><span><span>&lt;/</span>h2</span><span>></span></span>
        <span><span><span>&lt;</span>p</span><span>></span></span>
            Open Chinese Convert（ OpenCC）是一个开源的中文简繁转换项目，
            致力于制作高质量的基于统计预料的简繁转换词库。
            还提供函数库(libopencc)、命令行简繁转换工具、人工校对工具、词典生成程序、
            在线转换服务及图形用户界面。 <span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>col-4<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>h2</span><span>></span></span>佛振 说<span><span><span>&lt;/</span>h2</span><span>></span></span>
        <span><span><span>&lt;</span>p</span><span>></span></span>中州韵输入法引擎 / Rime Input Method Engine 取意历史上通行的中州韵，
            愿写就一部汇集音韵学智慧的输入法经典之作。
            项目网站设在 http://code.google.com/p/rimeime/
            创造应用价值是一方面，更要坚持对好技术的追求，希望能写出灵动而易于扩展的代码，
            使其成为一款个性十足的开源输入法。 <span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><blockquote>
<p>到此为止，简单的UI界面设计完毕！</p>
</blockquote>
<p><img src="./assets/image-20210716211716757.png" alt="image-20210716211716757" /></p>
<div><p>提示</p>
<p>nodejs开发指南的作者使用的是bootstrap@2.x版本的，而我这里的演示是4.6版本的，版本的升级也就意味着功能的变动，不过这里主要是类名的变动，稍微改动下就可以了。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>用户注册和登录</title>
      <link>https://wangyawei.top/views/backEnd/express/express-note-10/</link>
      <guid>https://wangyawei.top/views/backEnd/express/express-note-10/</guid>
      <source url="https://wangyawei.top/rss.xml">用户注册和登录</source>
      <category>EXPRESS</category>
      <pubDate>Sat, 17 Jul 2021 14:49:10 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这一节我们要实现用户会话的功能，包括用户注册和登录状态的维护。为了实现这些功能，我们需要引入会话机制来记录
用户状态，还要访问数据库来保存和读取用户信息。</p>
</blockquote>
<h2 id="访问数据库"> 访问数据库</h2>
<blockquote>
<p>我们选用 MongoDB 作为网站的数据库系统，它是一个开源的 NoSQL 数据库，相比MySQL 那样的关系型数据库，它更为轻巧、灵活，非常适合在数据规模很大、事务性不强的场合下使用。</p>
</blockquote>
<h3 id="nosql"> NoSQL</h3>
<blockquote>
<p>NoSQL 是 1998 年被提出的，它曾经是一个轻量、开源、不提供SQL功能的关系数据库。但现在 NoSQL 被认为是 Not Only SQL 的简称，主要指非关系型、分布式、不提供 ACID的数据库系统。</p>
</blockquote>
<h3 id="mongodb"> MongoDB</h3>
<blockquote>
<p>MongoDB 是一个对象数据库，它没有表、行等概念，也没有固定的模式和结构，所有的数据以文档的形式存储。所谓文档就是一个关联数组式的对象，它的内部由属性组成，一个属性对应的值可能是一个数、字符串、日期、数组，甚至是一个嵌套的文档。下面是一个MongoDB 文档的示例：</p>
</blockquote>
<div><pre><code><span>{</span> 
    <span>"_id"</span> <span>:</span> ObjectId( <span>"4f7fe8432b4a1077a7c551e8"</span> )<span>,</span>
    <span>"uid"</span> <span>:</span> <span>2004</span><span>,</span>
    <span>"username"</span> <span>:</span> <span>"byvoid"</span><span>,</span>
    <span>"net9"</span> <span>:</span> <span>{</span> <span>"nickname"</span> <span>:</span> <span>"BYVoid"</span><span>,</span>
    <span>"surname"</span> <span>:</span> <span>"Kuo"</span><span>,</span>
    <span>"givenname"</span> <span>:</span> <span>"Carbo"</span><span>,</span>
    <span>"fullname"</span> <span>:</span> <span>"Carbo Kuo"</span><span>,</span>
    <span>"emails"</span> <span>:</span> <span>[</span> <span>"byvoid@byvoid.com"</span><span>,</span> <span>"byvoid.kcp@gmail.com"</span> <span>]</span><span>,</span>
    <span>"website"</span> <span>:</span> <span>"http://www.byvoid.com"</span><span>,</span>
    <span>"address"</span> <span>:</span> <span>"Zijing 2#, Tsinghua University"</span> <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>
<p>上面文档中 uid 是一个整数属性， username 是字符串属性， _id 是文档对象的标识符，格式为特定的 ObjectId。 net9 是一个嵌套的文档，其内部结构与一般文档无异。</p>
</blockquote>
<div><p>提示</p>
<p>MongoDB 的数据格式就是 JSON，准确地说， MongoDB 的数据格式是 BSON （Binary JSON），它是 JSON 的一个扩展。</p>
</div>
<h3 id="连接数据库"> 连接数据库</h3>
<blockquote>
<p>首先确保已在本地安装好了 MongoDB，如果没有，请去https://www.runoob.com/mongodb/mongodb-window-install.html查看如何安装。</p>
</blockquote>
<p>在项目中安装mongodb包</p>
<div><pre><code><span>npm</span> <span>install</span> mongodb
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>{</span>
  <span>"name"</span><span>:</span> <span>"qwer"</span><span>,</span>
  <span>"version"</span><span>:</span> <span>"0.0.0"</span><span>,</span>
  <span>"private"</span><span>:</span> <span>true</span><span>,</span>
  <span>"scripts"</span><span>:</span> <span>{</span>
    <span>"start"</span><span>:</span> <span>"SET DEBUG=qwer:* &amp;&amp; nodemon ./bin/www"</span>
  <span>}</span><span>,</span>
  <span>"dependencies"</span><span>:</span> <span>{</span>
    <span>"cookie-parser"</span><span>:</span> <span>"~1.4.4"</span><span>,</span>
    <span>"debug"</span><span>:</span> <span>"~2.6.9"</span><span>,</span>
    <span>"ejs"</span><span>:</span> <span>"~2.6.1"</span><span>,</span>
    <span>"express"</span><span>:</span> <span>"~4.16.1"</span><span>,</span>
    <span>"express-ejs-layouts"</span><span>:</span> <span>"^2.5.1"</span><span>,</span>
    <span>"http-errors"</span><span>:</span> <span>"~1.6.3"</span><span>,</span>
    <span>"mongodb"</span><span>:</span> <span>"^4.0.0"</span><span>,</span>
    <span>"morgan"</span><span>:</span> <span>"~1.9.1"</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>项目根目录下新建<code>config.js</code>文件：</strong></p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
    cookieSecret<span>:</span> <span>'microblogbyvoid'</span><span>,</span>
    db<span>:</span> <span>'microblog'</span><span>,</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p>db 是数据库的名称。 cookieSecret 用于 Cookie 加密与数据库无关，我们留作后用。</p>
</blockquote>
<p>**项目根目录中创建<code>models/db.js</code>，并添加以下内容：</p>
<div><pre><code><span>const</span> MongoClient <span>=</span> <span>require</span><span>(</span><span>"mongodb"</span><span>)</span><span>.</span>MongoClient<span>;</span>
<span>const</span> config <span>=</span> <span>require</span><span>(</span><span>'../config'</span><span>)</span><span>;</span>
<span>const</span> url <span>=</span> <span><span>`</span><span>mongodb://localhost:27017</span><span>`</span></span><span>;</span>

module<span>.</span>exports <span>=</span> <span>{</span>
    db<span>:</span> <span>null</span><span>,</span>
    <span>open</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>this</span><span>.</span>db<span>)</span> <span>{</span>
            <span>return</span> Promise<span>.</span><span>resolve</span><span>(</span><span>this</span><span>.</span>db<span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span> <span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>
            MongoClient<span>.</span><span>connect</span><span>(</span>url<span>,</span> <span>(</span><span>err<span>,</span> client</span><span>)</span> <span>=></span> <span>{</span>
                <span>if</span> <span>(</span>err<span>)</span> <span>{</span>
                    <span>return</span> <span>reject</span><span>(</span><span>new</span> <span>Error</span><span>(</span>err<span>)</span><span>)</span><span>;</span>
                <span>}</span>
                <span>this</span><span>.</span>db <span>=</span> client<span>.</span><span>db</span><span>(</span>config<span>.</span>db<span>)</span><span>;</span>
                console<span>.</span><span>log</span><span>(</span><span>'连接数据库 microblog 成功'</span><span>)</span>
                <span>resolve</span><span>(</span><span>this</span><span>.</span>db<span>)</span><span>;</span>
            <span>}</span><span>)</span>
        <span>}</span><span>)</span>
    <span>}</span><span>,</span>
    <span>close</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>this</span><span>.</span>db<span>)</span> <span>{</span>
            <span>this</span><span>.</span>db<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><blockquote>
<p>创建并到处数据库连接;</p>
</blockquote>
<h2 id="会话支持"> 会话支持</h2>
<blockquote>
<p>后面会用到会话中间件，默认情况下是把用户信息存储在内存中，但我们既然已经有了 MongoDB，不妨把会话信息存储在数据库中，便于持久维护。</p>
</blockquote>
<p><strong>下载：<code>connect-mongo</code></strong></p>
<div><pre><code><span>npm</span> <span>install</span> connect-mongo express-session
</code></pre>
<div><span>1</span><br></div></div><p>使用：</p>
<div><pre><code><span>const</span> session <span>=</span> <span>require</span><span>(</span><span>'express-session'</span><span>)</span><span>;</span>
<span>const</span> MongoStore <span>=</span> <span>require</span><span>(</span><span>'connect-mongo'</span><span>)</span><span>;</span>
app<span>.</span><span>use</span><span>(</span>express<span>.</span><span>session</span><span>(</span><span>{</span>
  secret<span>:</span> config<span>.</span>cookieSecret<span>,</span>
  store<span>:</span> MongoStore<span>.</span><span>create</span><span>(</span><span>{</span>
    db<span>:</span> config<span>.</span>db
  <span>}</span><span>)</span>
<span>}</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p>使用<code>express-session</code> 会话支持，设置它的 store 参数为 MongoStore 实例，把会话信息存储到数据库中，以避免丢失</p>
</blockquote>
<h3 id="注册和登入"> 注册和登入</h3>
<blockquote>
<p>准备好了数据库访问和会话存储的相关信息，接下来开始实现网站的第一个功能，用户注册和登入。</p>
</blockquote>
<h4 id="注册页面"> 注册页面</h4>
<p>首先来设计用户注册页面的表单，创建 <code>views/reg.ejs</code> 文件，内容是：</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>d-flex justify-content-center mt-4<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>card<span>"</span></span> <span><span>style</span><span><span>=</span><span>"</span><span><span>width</span><span>:</span> 28rem<span>;</span></span><span>"</span></span></span><span>></span></span>
        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>card-header h5<span>"</span></span><span>></span></span>   
            用户注册
        <span><span><span>&lt;/</span>div</span><span>></span></span>
        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>card-body<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>form</span> <span>method</span><span><span>=</span><span>"</span>post<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>form-group<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>label</span> <span>for</span><span><span>=</span><span>"</span>username<span>"</span></span><span>></span></span>用户名<span><span><span>&lt;/</span>label</span><span>></span></span>
                    <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>form-control<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>username<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>small</span> <span>class</span><span><span>=</span><span>"</span>form-text text-muted<span>"</span></span><span>></span></span>你的账户名称，用于登录和显示。<span><span><span>&lt;/</span>small</span><span>></span></span>
                <span><span><span>&lt;/</span>div</span><span>></span></span>
                <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>form-group<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>label</span> <span>for</span><span><span>=</span><span>"</span>password<span>"</span></span><span>></span></span>密码<span><span><span>&lt;/</span>label</span><span>></span></span>
                    <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>password<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>form-control<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>password<span>"</span></span><span>></span></span>
                <span><span><span>&lt;/</span>div</span><span>></span></span>
                <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>form-group<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>label</span> <span>for</span><span><span>=</span><span>"</span>password<span>"</span></span><span>></span></span>重复输入密码<span><span><span>&lt;/</span>label</span><span>></span></span>
                    <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>password<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>form-control<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>passwordRepeat<span>"</span></span><span>></span></span>
                <span><span><span>&lt;/</span>div</span><span>></span></span>
                <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>d-flex justify-content-center<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>button</span> <span>type</span><span><span>=</span><span>"</span>submit<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>btn btn-primary<span>"</span></span><span>></span></span>注册<span><span><span>&lt;/</span>button</span><span>></span></span>
                <span><span><span>&lt;/</span>div</span><span>></span></span>
            <span><span><span>&lt;/</span>form</span><span>></span></span>
        <span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p><strong>修改<code>routes/index.js</code>，添加以下内容：</strong></p>
<div><pre><code><span>// 注册</span>
router<span>.</span><span>get</span><span>(</span><span>'/reg'</span><span>,</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>=></span> <span>{</span>
  res<span>.</span><span>render</span><span>(</span><span>'reg'</span><span>,</span> <span>{</span>
    title<span>:</span> <span>'用户注册'</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h4 id="浏览器访问"> 浏览器访问</h4>
<p><img src="./assets/image-20210717185031638.png" alt="image-20210717185031638" /></p>
<h3 id="注册响应"> 注册响应</h3>
<p>在 <code>routes/index.js</code> 中添加 <code>/reg</code>的 <code>POST</code> 响应函数：</p>
<div><pre><code>router<span>.</span><span>post</span><span>(</span><span>'/reg'</span><span>,</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> <span>{</span> passwordRepeat<span>,</span> password<span>,</span> username <span>}</span> <span>=</span> req<span>.</span>body<span>;</span>
  <span>if</span> <span>(</span><span>!</span>username<span>.</span><span>trim</span><span>(</span><span>)</span><span>)</span> <span>{</span>
    req<span>.</span><span>flash</span><span>(</span><span>'error'</span><span>,</span> <span>'请输入用户名'</span><span>)</span><span>;</span>
    <span>return</span> res<span>.</span><span>redirect</span><span>(</span><span>'/reg'</span><span>)</span><span>;</span>
  <span>}</span>
  <span>//检验用户两次输入的密码是否一致</span>
  <span>if</span> <span>(</span>passwordRepeat <span>!==</span> password<span>)</span> <span>{</span>
    req<span>.</span><span>flash</span><span>(</span><span>'error'</span><span>,</span> <span>'两次输入的密码不一致'</span><span>)</span><span>;</span>
    <span>return</span> res<span>.</span><span>redirect</span><span>(</span><span>'/reg'</span><span>)</span><span>;</span>
  <span>}</span>
  <span>const</span> newUser <span>=</span> <span>new</span> <span>User</span><span>(</span><span>{</span>
    name<span>:</span> username<span>,</span>
    password<span>,</span>
  <span>}</span><span>)</span><span>;</span>

  <span>//检查用户名是否已经存在</span>
  User<span>.</span><span>find</span><span>(</span><span>{</span> name<span>:</span> newUser<span>.</span>name <span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>result</span> <span>=></span> <span>{</span>
    <span>// 用户不存在则注册</span>
    <span>if</span> <span>(</span><span>!</span>result<span>)</span> <span>{</span>
      newUser<span>.</span><span>save</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        req<span>.</span>session<span>.</span>user <span>=</span> newUser<span>;</span>
        req<span>.</span><span>flash</span><span>(</span><span>'success'</span><span>,</span> <span>'注册成功'</span><span>)</span><span>;</span>
        res<span>.</span><span>redirect</span><span>(</span><span>'/'</span><span>)</span><span>;</span>
      <span>}</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      req<span>.</span><span>flash</span><span>(</span><span>'error'</span><span>,</span> <span>'Username already exists.'</span><span>)</span><span>;</span>
      res<span>.</span><span>redirect</span><span>(</span><span>'/reg'</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>
    req<span>.</span><span>flash</span><span>(</span><span>'error'</span><span>,</span> err<span>)</span><span>;</span>
    res<span>.</span><span>redirect</span><span>(</span><span>'/reg'</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><blockquote>
<ol>
<li>req.body：POST 请求信息解析过后的对象（请求体）；</li>
<li>req.flash：由<code>connect-flash</code>提供的存储消息的会话的特殊区域，通过它保存的变量只会在用户当前
和下一次的请求中被访问，之后会被清除，通过它我们可以很方便地实现页面的通知
和错误信息显示功能。</li>
<li>res.redirect：重定向功能，通知浏览器转向相应页面。</li>
<li>User：我们设计的用户对象，在后面会详细介绍，这里先假设它的接口都是可用的，使用前需要通过 const User = require('../models/user.js') 引用。</li>
<li>User.get：通过用户名获取已知用户；</li>
<li>req.session.user = newUser ：向会话对象写入了当前用户的信息，通过它判断用户是否已经登录。</li>
</ol>
</blockquote>
<div><p>提示</p>
<p>4.x版本不在原生支持<code>req.flash()</code>，你需要自己安装<code>connect-flash</code>，并在<code>app.js</code>中引用；</p>
<div><pre><code><span>const</span> flash <span>=</span> <span>require</span><span>(</span><span>'connect-flash'</span><span>)</span><span>;</span>
app<span>.</span><span>use</span><span>(</span><span>flash</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></div>
<h2 id="用户模型"> 用户模型</h2>
<blockquote>
<p>与视图和控制器不同，模型是真正与数据打交道的工具，没有模型，网站就只是一个外壳，不能发挥真实的作用，因此它是框架中最根本的部分。  前面的User 是一个描述数据的对象，即 MVC架构中的模型。</p>
</blockquote>
<p>在 models 目录中创建 user.js 的文件，内容如下：</p>
<div><pre><code><span>const</span> crypto <span>=</span> <span>require</span><span>(</span><span>'crypto'</span><span>)</span><span>;</span>
<span>const</span> mongodb <span>=</span> <span>require</span><span>(</span><span>'./db'</span><span>)</span><span>;</span>

<span>class</span> <span>User</span> <span>{</span>
    <span>constructor</span><span>(</span><span>user</span><span>)</span> <span>{</span>
        <span>let</span> pw <span>=</span> crypto<span>.</span><span>createHash</span><span>(</span><span>"md5"</span><span>)</span><span>.</span><span>update</span><span>(</span>user<span>.</span>password<span>)</span><span>.</span><span>digest</span><span>(</span><span>'hex'</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>name <span>=</span> user<span>.</span>name<span>;</span>
        <span>this</span><span>.</span>password <span>=</span> pw<span>;</span>
    <span>}</span>

    <span>// 注册用户</span>
    <span>save</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>)</span> <span>=></span> <span>{</span>
            <span>const</span> _user <span>=</span> <span>{</span>
                name<span>:</span> <span>this</span><span>.</span>name<span>,</span>
                password<span>:</span> <span>this</span><span>.</span>password
            <span>}</span><span>;</span>
            mongodb<span>.</span><span>open</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>db</span> <span>=></span> <span>{</span>
                <span>// 读取 users 集合</span>
                <span>const</span> userCollection <span>=</span> db<span>.</span><span>collection</span><span>(</span><span>'users'</span><span>)</span><span>;</span>
                userCollection<span>.</span><span>insertOne</span><span>(</span>_user<span>,</span> <span>(</span><span>err<span>,</span> result</span><span>)</span> <span>=></span> <span>{</span>
                    <span>if</span> <span>(</span>err<span>)</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span>err<span>)</span><span>;</span>
                    console<span>.</span><span>log</span><span>(</span><span>'保存用户成功：'</span> <span>+</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>_user<span>)</span><span>)</span><span>;</span>
                    mongodb<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
                    <span>resolve</span><span>(</span>result<span>)</span>
                <span>}</span><span>)</span>
            <span>}</span><span>)</span>
        <span>}</span><span>)</span>
    <span>}</span>

    <span>// 查找用户</span>
    <span>static</span> <span>find</span><span>(</span><span>name</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>)</span> <span>=></span> <span>{</span>
            mongodb<span>.</span><span>open</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>db</span> <span>=></span> <span>{</span>
                <span>const</span> userCollection <span>=</span> db<span>.</span><span>collection</span><span>(</span><span>'users'</span><span>)</span><span>;</span>
                userCollection<span>.</span><span>findOne</span><span>(</span>name<span>,</span><span>(</span><span>err<span>,</span> result</span><span>)</span> <span>=></span> <span>{</span>
                    <span>if</span> <span>(</span>err<span>)</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span>err<span>)</span><span>;</span>
                    console<span>.</span><span>log</span><span>(</span><span>'找到用户：'</span> <span>+</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>result<span>)</span><span>)</span><span>;</span>
                    mongodb<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
                    <span>resolve</span><span>(</span>result<span>)</span><span>;</span>
                <span>}</span><span>)</span>
            <span>}</span><span>)</span>
        <span>}</span><span>)</span>
    <span>}</span>
<span>}</span>

module<span>.</span>exports <span>=</span> User<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><blockquote>
<p>以上代码实现了两个接口，save 和 get， 前者是对象实例的方法，用于将用户对象的数据保存到数据库中，后者是对象静态函数的方法，用于从数据库中查找指定的用户。</p>
</blockquote>
<div><p>提示</p>
<p>crypto：Node.js 的一个核心模块，功能是加密并生成各种散列。</p>
</div>
<h2 id="视图交互"> 视图交互</h2>
<blockquote>
<p>为了实现不同登录状态下页面呈现不同内容的功能，我们需要创建动态视图助手，通过它我们才能在视图中访问会话中的用户数据。同时为了显示错误和成功的信息，也要在动态视图助手中增加响应的函数。</p>
</blockquote>
<p>打开 app.js，添加以下代码：</p>
<div><pre><code>app<span>.</span><span>use</span><span>(</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
  res<span>.</span>locals<span>.</span>user <span>=</span> req<span>.</span>session<span>.</span>user<span>;</span>
  console<span>.</span><span>log</span><span>(</span>res<span>.</span>locals<span>.</span>user<span>,</span> <span>'中间件'</span><span>)</span><span>;</span>
  <span>let</span> err <span>=</span> req<span>.</span><span>flash</span><span>(</span><span>'error'</span><span>)</span><span>;</span>
  <span>let</span> succ <span>=</span> req<span>.</span><span>flash</span><span>(</span><span>'success'</span><span>)</span><span>;</span>
  <span>!</span>err<span>.</span>length <span>&amp;&amp;</span> <span>(</span>err <span>=</span> <span>null</span><span>)</span>
  <span>!</span>succ<span>.</span>length <span>&amp;&amp;</span> <span>(</span>succ <span>=</span> <span>null</span><span>)</span>
  res<span>.</span>locals<span>.</span>error <span>=</span> err<span>;</span>
  res<span>.</span>locals<span>.</span>success <span>=</span> succ<span>;</span>
  <span>next</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>修改 layout.ejs中的导航栏部分：</p>
<div><pre><code><span><span><span>&lt;</span>ul</span> <span>class</span><span><span>=</span><span>"</span>navbar-nav<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>nav-item active<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>a</span> <span>class</span><span><span>=</span><span>"</span>nav-link<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>/<span>"</span></span><span>></span></span>首页<span><span><span>&lt;/</span>a</span><span>></span></span>
    <span><span><span>&lt;/</span>li</span><span>></span></span>
    &lt;% if (!user) { %>
    <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>nav-item<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>a</span> <span>class</span><span><span>=</span><span>"</span>nav-link<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>/login<span>"</span></span><span>></span></span>登入<span><span><span>&lt;/</span>a</span><span>></span></span>
    <span><span><span>&lt;/</span>li</span><span>></span></span>
    <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>nav-item<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>a</span> <span>class</span><span><span>=</span><span>"</span>nav-link<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>/reg<span>"</span></span><span>></span></span>注册<span><span><span>&lt;/</span>a</span><span>></span></span>
    <span><span><span>&lt;/</span>li</span><span>></span></span>
    &lt;% } else { %>
    <span><span><span>&lt;</span>li</span> <span>class</span><span><span>=</span><span>"</span>nav-item<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>a</span> <span>class</span><span><span>=</span><span>"</span>nav-link<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>/logout<span>"</span></span><span>></span></span>退出<span><span><span>&lt;/</span>a</span><span>></span></span>
    <span><span><span>&lt;/</span>li</span><span>></span></span>
    &lt;% } %>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>上面功能是为已登入用户和未登入用户显示不同的信息。在 container 中，&lt;%- body %&gt;之前加入：</p>
<div><pre><code>&lt;% if (success) { %>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>alert alert-success mt-3<span>"</span></span><span>></span></span>
        &lt;%= success %>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
&lt;% } %>
&lt;% if (error) { %>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>alert alert-danger mt-3<span>"</span></span><span>></span></span>
        &lt;%= error %>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
&lt;% } %>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>它的主要功能是页面通知。  如下图所示：</p>
</blockquote>
<p><img src="./assets/image-20210719212251977.png" alt="image-20210719212251977" /></p>
<p><img src="./assets/image-20210719212320501.png" alt="image-20210719212320501" /></p>
<h2 id="登入和退出"> 登入和退出</h2>
<blockquote>
<p>完成用户注册的功能以后，这里就需要实现用户登入和登出了。把下面的代码加到 routes/index.js 中：</p>
</blockquote>
<div><pre><code><span>// 登录</span>
router<span>.</span><span>get</span><span>(</span><span>'/login'</span><span>,</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>=></span> <span>{</span>
  res<span>.</span><span>render</span><span>(</span><span>'login'</span><span>,</span> <span>{</span>
    title<span>:</span> <span>'用户登入'</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
router<span>.</span><span>post</span><span>(</span><span>'/login'</span><span>,</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> <span>{</span> username<span>,</span> password <span>}</span> <span>=</span> req<span>.</span>body<span>;</span>
  <span>if</span> <span>(</span><span>!</span>username<span>.</span><span>trim</span><span>(</span><span>)</span><span>)</span> <span>{</span>
    req<span>.</span>session<span>.</span>user <span>=</span> <span>null</span><span>;</span>
    req<span>.</span><span>flash</span><span>(</span><span>'error'</span><span>,</span> <span>'请输入用户名'</span><span>)</span><span>;</span>
    <span>return</span> res<span>.</span><span>redirect</span><span>(</span><span>'/login'</span><span>)</span><span>;</span>
  <span>}</span>
  <span>//生成口令的散列值</span>
  <span>const</span> md5 <span>=</span> crypto<span>.</span><span>createHash</span><span>(</span><span>'md5'</span><span>)</span><span>;</span>
  <span>const</span> passwordMd5 <span>=</span> md5<span>.</span><span>update</span><span>(</span>password<span>)</span><span>.</span><span>digest</span><span>(</span><span>'hex'</span><span>)</span><span>;</span>
  User<span>.</span><span>find</span><span>(</span><span>{</span> name<span>:</span> username <span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>result</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>result<span>)</span> <span>{</span>
      req<span>.</span><span>flash</span><span>(</span><span>'error'</span><span>,</span> <span>'用户不存在'</span><span>)</span><span>;</span>
      <span>return</span> res<span>.</span><span>redirect</span><span>(</span><span>'/login'</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>if</span> <span>(</span>result<span>.</span>password <span>!==</span> passwordMd5<span>)</span> <span>{</span>
        req<span>.</span><span>flash</span><span>(</span><span>'error'</span><span>,</span> <span>'密码错误，请重新输入'</span><span>)</span><span>;</span>
        <span>return</span> res<span>.</span><span>redirect</span><span>(</span><span>'/login'</span><span>)</span><span>;</span>
      <span>}</span>
      req<span>.</span>session<span>.</span>user <span>=</span> result<span>;</span>
      req<span>.</span><span>flash</span><span>(</span><span>'success'</span><span>,</span> <span>'登入成功'</span><span>)</span><span>;</span>
      res<span>.</span><span>redirect</span><span>(</span><span>'/'</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
<span>// 退出</span>
router<span>.</span><span>get</span><span>(</span><span>'/logout'</span><span>,</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>=></span> <span>{</span>
  req<span>.</span>session<span>.</span>user <span>=</span> <span>null</span><span>;</span>
  req<span>.</span><span>flash</span><span>(</span><span>'success'</span><span>,</span> <span>'退出成功'</span><span>)</span><span>;</span>
  res<span>.</span><span>redirect</span><span>(</span><span>'/'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>创建 views/login.ejs，内容如下：</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>d-flex justify-content-center mt-4<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>card<span>"</span></span> <span><span>style</span><span><span>=</span><span>"</span><span><span>width</span><span>:</span> 28rem<span>;</span></span><span>"</span></span></span><span>></span></span>
        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>card-header h5<span>"</span></span><span>></span></span>   
            用户登录
        <span><span><span>&lt;/</span>div</span><span>></span></span>
        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>card-body<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>form</span> <span>method</span><span><span>=</span><span>"</span>post<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>form-group<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>label</span> <span>for</span><span><span>=</span><span>"</span>username<span>"</span></span><span>></span></span>用户名<span><span><span>&lt;/</span>label</span><span>></span></span>
                    <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>form-control<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>username<span>"</span></span><span>></span></span>
                <span><span><span>&lt;/</span>div</span><span>></span></span>
                <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>form-group<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>label</span> <span>for</span><span><span>=</span><span>"</span>password<span>"</span></span><span>></span></span>密码<span><span><span>&lt;/</span>label</span><span>></span></span>
                    <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>password<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>form-control<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>password<span>"</span></span><span>></span></span>
                <span><span><span>&lt;/</span>div</span><span>></span></span>
                <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>d-flex justify-content-center<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>button</span> <span>type</span><span><span>=</span><span>"</span>submit<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>btn btn-primary<span>"</span></span><span>></span></span>登录<span><span><span>&lt;/</span>button</span><span>></span></span>
                <span><span><span>&lt;/</span>div</span><span>></span></span>
            <span><span><span>&lt;/</span>form</span><span>></span></span>
        <span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>在浏览器中访问http://localhost:3000/login，你将会看到以下所示的页面。</p>
<p><img src="./assets/image-20210719212123380.png" alt="image-20210719212123380" /></p>
<h2 id="页面权限控制"> 页面权限控制</h2>
<blockquote>
<p>退出功能应该只对已登入的用户开放，注册和登入页面则应该阻止已登入的用户访问。最简单的方法是在每个页面的路由响应函数内检查用户是否已经登录，但这会带来很多重复的代码，违反了 DRY 原则。因此，我们利用路由中间件来实现这个功能。</p>
</blockquote>
<p>app.js 内容如下：</p>
<div><pre><code>app<span>.</span><span>use</span><span>(</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>req<span>.</span>session<span>.</span>user <span>&amp;&amp;</span> <span>(</span>req<span>.</span>url <span>!==</span> <span>'/login'</span> <span>&amp;&amp;</span> req<span>.</span>url <span>!==</span> <span>'/reg'</span> <span>&amp;&amp;</span> req<span>.</span>url <span>!==</span> <span>'/'</span> <span>)</span> <span>)</span> <span>{</span>
    req<span>.</span><span>flash</span><span>(</span><span>'error'</span><span>,</span> <span>'未登入'</span><span>)</span><span>;</span>
    <span>return</span> res<span>.</span><span>redirect</span><span>(</span><span>'/login'</span><span>)</span><span>;</span>
  <span>}</span>
  <span>if</span> <span>(</span><span>(</span>req<span>.</span>url <span>===</span> <span>'/login'</span> <span>||</span> req<span>.</span>url <span>===</span> <span>'/reg'</span><span>)</span> <span>&amp;&amp;</span> req<span>.</span>session<span>.</span>user<span>)</span> <span>{</span>
    req<span>.</span><span>flash</span><span>(</span><span>'error'</span><span>,</span> <span>'已登入'</span><span>)</span><span>;</span>
    <span>return</span> res<span>.</span><span>redirect</span><span>(</span><span>'/'</span><span>)</span><span>;</span>
  <span>}</span>
  <span>next</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>发表微博</title>
      <link>https://wangyawei.top/views/backEnd/express/express-note-11/</link>
      <guid>https://wangyawei.top/views/backEnd/express/express-note-11/</guid>
      <source url="https://wangyawei.top/rss.xml">发表微博</source>
      <category>EXPRESS</category>
      <pubDate>Mon, 19 Jul 2021 22:12:10 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>网站已经具备了用户注册、登入、页面权限控制的功能，这些功能为网站最核心的部分——发表微博做好了准备。在这个小节里，我们将会实现发表微博的功能，完成整个网站的设计。</p>
</blockquote>
<h2 id="微博模型"> 微博模型</h2>
<blockquote>
<p>仿照用户模型，将微博模型命名为 Post 对象，它拥有与User 相似的接口，分别是get 和 save。get 的功能是从数据库中获取微博，可以按指定用户获取，也可以获取全部的内容。save是 Post 对象实例的方法，用于将对象的变动保存到数据库。</p>
</blockquote>
<p>创建 models/post.js，写入以下内容：</p>
<div><pre><code><span>const</span> mongodb <span>=</span> <span>require</span><span>(</span><span>'./db'</span><span>)</span><span>;</span>
<span>class</span> <span>Post</span> <span>{</span>
    <span>constructor</span><span>(</span><span>username<span>,</span> post<span>,</span> time</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>user <span>=</span> username<span>;</span>
        <span>this</span><span>.</span>post <span>=</span> post<span>;</span>
        <span>if</span> <span>(</span>time<span>)</span> <span>{</span>
            <span>this</span><span>.</span>time <span>=</span> time<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>this</span><span>.</span>time <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>save</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>
            <span>// 存入 Mongodb 的文档</span>
            <span>const</span> post <span>=</span> <span>{</span>
                user<span>:</span> <span>this</span><span>.</span>user<span>,</span>
                post<span>:</span> <span>this</span><span>.</span>post<span>,</span>
                time<span>:</span> <span>this</span><span>.</span>time<span>,</span>
            <span>}</span><span>;</span>
            mongodb<span>.</span><span>open</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>db</span><span>)</span> <span>=></span> <span>{</span>
                <span>// 读取 posts 集合</span>
                <span>const</span> postsCollection <span>=</span> db<span>.</span><span>collection</span><span>(</span><span>'posts'</span><span>)</span><span>;</span>
                console<span>.</span><span>log</span><span>(</span>post<span>)</span><span>;</span>
                postsCollection<span>.</span><span>insertOne</span><span>(</span>post<span>,</span> <span>(</span><span>err<span>,</span> posts</span><span>)</span> <span>=></span> <span>{</span>
                    <span>if</span> <span>(</span>err<span>)</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span>err<span>)</span><span>;</span>
                    console<span>.</span><span>log</span><span>(</span><span>'保存成功：'</span> <span>+</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>post<span>)</span><span>)</span><span>;</span>
                    mongodb<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
                    <span>resolve</span><span>(</span>posts<span>)</span>
                <span>}</span><span>)</span><span>;</span>
            <span>}</span><span>)</span><span>;</span>
        <span>}</span><span>)</span>
    <span>}</span>

    <span>static</span> <span>find</span><span>(</span><span>name</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>
            mongodb<span>.</span><span>open</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>db</span><span>)</span> <span>{</span>
                <span>// 读取 posts 集合</span>
                <span>const</span> query <span>=</span> <span>{</span><span>}</span><span>;</span>
                <span>if</span> <span>(</span>name<span>)</span> <span>{</span>
                    query<span>.</span>user <span>=</span> name
                <span>}</span>
                <span>const</span> postsCollection <span>=</span> db<span>.</span><span>collection</span><span>(</span><span>'posts'</span><span>)</span><span>;</span>
                postsCollection<span>.</span><span>find</span><span>(</span>query<span>,</span> <span>{</span> sort<span>:</span> <span>{</span> _id<span>:</span> <span>-</span><span>1</span> <span>}</span> <span>}</span><span>)</span><span>.</span><span>toArray</span><span>(</span><span>function</span> <span>(</span><span>err<span>,</span> docs</span><span>)</span> <span>{</span>
                    <span>if</span> <span>(</span>err<span>)</span> <span>{</span>
                        mongodb<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
                        <span>return</span> <span>reject</span><span>(</span>err<span>)</span>
                    <span>}</span>
                    <span>// 封装 posts 为 Post 对象</span>
                    <span>const</span> posts <span>=</span> <span>[</span><span>]</span><span>;</span>
                    docs<span>.</span><span>forEach</span><span>(</span><span>function</span> <span>(</span><span>doc<span>,</span> index</span><span>)</span> <span>{</span>
                        posts<span>.</span><span>push</span><span>(</span><span>new</span> <span>Post</span><span>(</span>doc<span>.</span>user<span>,</span> doc<span>.</span>post<span>,</span> doc<span>.</span>time<span>)</span><span>)</span><span>;</span>
                    <span>}</span><span>)</span><span>;</span>
                    mongodb<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
                    <span>resolve</span><span>(</span>posts<span>)</span>
                <span>}</span><span>)</span><span>;</span>
            <span>}</span><span>)</span><span>;</span>
        <span>}</span><span>)</span>
    <span>}</span>
<span>}</span>

module<span>.</span>exports <span>=</span> Post<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div><h2 id="发表微博"> 发表微博</h2>
<p><strong>在 routes/index.js 中添加下面的代码：</strong></p>
<div><pre><code><span>// 发言</span>
router<span>.</span><span>post</span><span>(</span><span>'/post'</span><span>,</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> <span>{</span> name <span>}</span> <span>=</span> req<span>.</span>session<span>.</span>user<span>;</span>
  <span>const</span> post <span>=</span> <span>new</span> <span>Post</span><span>(</span>name<span>,</span> req<span>.</span>body<span>.</span>post<span>)</span><span>;</span>
  post<span>.</span><span>save</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    req<span>.</span><span>flash</span><span>(</span><span>'success'</span><span>,</span> <span>'发表成功'</span><span>)</span><span>;</span>
    res<span>.</span><span>redirect</span><span>(</span><span><span>`</span><span>/u/</span><span><span>${</span>name<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>
    req<span>.</span><span>flash</span><span>(</span><span>'error'</span><span>,</span> err<span>)</span><span>;</span>
    <span>return</span> res<span>.</span><span>redirect</span><span>(</span><span>'/'</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>
<p>通过 req.session.user 获取当前用户信息，从 req.body.post 获取用户发表的内容，建立 Post 对象，调用 save() 方法存储信息，最后将用户重定向到用户页面。</p>
</blockquote>
<h2 id="用户页面"> 用户页面</h2>
<p><strong>用户页面的功能是展示用户发表的所有内容，在routes/index.js中加入以下代码：</strong></p>
<div><pre><code><span>// 获取登录用户的所有发言数据</span>
router<span>.</span><span>get</span><span>(</span><span>'/u/:user'</span><span>,</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> <span>{</span> user <span>}</span> <span>=</span> req<span>.</span>params<span>;</span>
  User<span>.</span><span>find</span><span>(</span><span>{</span> name<span>:</span> user <span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>result</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span>result<span>)</span> <span>{</span>
      Post<span>.</span><span>find</span><span>(</span>result<span>.</span>name<span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>posts</span><span>)</span> <span>=></span> <span>{</span>
        res<span>.</span><span>render</span><span>(</span><span>'user'</span><span>,</span> <span>{</span>
          title<span>:</span> result<span>.</span>name<span>,</span>
          posts<span>:</span> posts<span>,</span>
        <span>}</span><span>)</span><span>;</span>
      <span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>
        req<span>.</span><span>flash</span><span>(</span><span>'error'</span><span>,</span> err<span>)</span><span>;</span>
        <span>return</span> res<span>.</span><span>redirect</span><span>(</span><span>'/'</span><span>)</span><span>;</span>
      <span>}</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      req<span>.</span><span>flash</span><span>(</span><span>'error'</span><span>,</span> <span>'用户不存在'</span><span>)</span><span>;</span>
      <span>return</span> res<span>.</span><span>redirect</span><span>(</span><span>'/'</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    req<span>.</span><span>flash</span><span>(</span><span>'error'</span><span>,</span> <span>'用户不存在'</span><span>)</span><span>;</span>
    <span>return</span> res<span>.</span><span>redirect</span><span>(</span><span>'/'</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>它的功能从数据库中获取该用户的微博，通过 posts 属性传递给 user 视图。 views/user.ejs 的内容如下：</p>
<div><pre><code><span><span>&lt;%</span><span> <span>if</span> <span>(</span>user<span>)</span> <span>{</span> </span><span>%></span></span>
    <span><span>&lt;%-</span><span> <span>include</span><span>(</span><span>'say'</span><span>)</span> </span><span>%></span></span>
<span><span>&lt;%</span><span> <span>}</span> </span><span>%></span></span>
<span><span>&lt;%-</span><span> <span>include</span><span>(</span><span>'posts'</span><span>,</span> <span>{</span> posts<span>:</span> posts <span>}</span><span>)</span> </span><span>%></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>根据 DRY 原则，把重复用到的部分都提取出来，分别放入 say.ejs 和 posts.ejs。 say.ejs的功能是显示一个发表微博的表单，它的内容如下：</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>card bg-light mt-4 mb-4<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>card-body<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>form</span> <span>method</span><span><span>=</span><span>"</span>post<span>"</span></span> <span>action</span><span><span>=</span><span>"</span>/post<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>form-grou row<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>col-sm-10<span>"</span></span><span>></span></span>
                    <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>form-control<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>post<span>"</span></span><span>></span></span>
                <span><span><span>&lt;/</span>div</span><span>></span></span>
                <span><span><span>&lt;</span>button</span> <span>type</span><span><span>=</span><span>"</span>submit<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>btn btn-success<span>"</span></span><span>></span></span>发言<span><span><span>&lt;/</span>button</span><span>></span></span>
            <span><span><span>&lt;/</span>div</span><span>></span></span>
        <span><span><span>&lt;/</span>form</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>posts.ejs 的目的是按照行列显示传入的 posts 的所有内容：</p>
<div><pre><code><span><span>&lt;%</span><span> posts<span>.</span><span>forEach</span><span>(</span><span>function</span><span>(</span><span>post<span>,</span> index</span><span>)</span> <span>{</span> </span><span>%></span></span>
    <span><span>&lt;%</span><span> <span>if</span> <span>(</span>index <span>%</span> <span>3</span> <span>===</span> <span>0</span><span>)</span> <span>{</span> </span><span>%></span></span>
        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>row<span>"</span></span><span>></span></span>
    <span><span>&lt;%</span><span> <span>}</span> </span><span>%></span></span>
        <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>col-4<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>h2</span><span>></span></span><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>/u/<span><span>&lt;%=</span><span> post<span>.</span>user </span><span>%></span></span><span>"</span></span><span>></span></span><span><span>&lt;%=</span><span> post<span>.</span>user </span><span>%></span></span><span><span><span>&lt;/</span>a</span><span>></span></span> 说<span><span><span>&lt;/</span>h2</span><span>></span></span>
            <span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>small</span><span>></span></span><span><span>&lt;%=</span><span> post<span>.</span>time </span><span>%></span></span><span><span><span>&lt;/</span>small</span><span>></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
            <span><span><span>&lt;</span>p</span><span>></span></span><span><span>&lt;%=</span><span> post<span>.</span>post </span><span>%></span></span><span><span><span>&lt;/</span>p</span><span>></span></span>
        <span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span>&lt;%</span><span> <span>if</span> <span>(</span>index <span>%</span> <span>3</span> <span>===</span> <span>2</span><span>)</span> <span>{</span> </span><span>%></span></span>
        <span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span>&lt;%</span><span> <span>}</span> </span><span>%></span></span>
<span><span>&lt;%</span><span> <span>}</span><span>)</span> </span><span>%></span></span>
<span><span>&lt;%</span><span> <span>if</span> <span>(</span>posts<span>.</span>length <span>%</span> <span>3</span> <span>!==</span> <span>0</span><span>)</span> <span>{</span> </span><span>%></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span><span>&lt;!-- end row --></span>
<span><span>&lt;%</span><span><span>}</span> </span><span>%></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>完成上述工作后，重启服务器。在用户的页面上发表几个微博，然后可以看到用户页面的效果如图所示。</p>
<p><img src="./assets/image-20210719214223913.png" alt="image-20210719214223913" /></p>
<h2 id="首页"> 首页</h2>
<blockquote>
<p>最后一步是实现首页的内容。我们计划在首页显示所有用户发表的微博，按时间从新到旧的顺序。</p>
</blockquote>
<p>在 routes/index.js 中添加下面代码：</p>
<div><pre><code><span>// 首页</span>
router<span>.</span><span>get</span><span>(</span><span>'/'</span><span>,</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>=></span> <span>{</span>
  Post<span>.</span><span>find</span><span>(</span><span>null</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>posts</span><span>)</span> <span>=></span> <span>{</span>
    res<span>.</span><span>render</span><span>(</span><span>'index'</span><span>,</span> <span>{</span>
      title<span>:</span> <span>'首页'</span><span>,</span>
      posts<span>,</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span><span>)</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>它的功能是读取所有用户的微博，传递给页面 posts 属性。接下来修改首页的模板index.ejs：</p>
<div><pre><code><span><span>&lt;%</span><span> <span>if</span> <span>(</span><span>!</span>user<span>)</span> <span>{</span> </span><span>%></span></span> 
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>jumbotron bd-example<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>h1</span><span>></span></span>欢迎来到 Microblog<span><span><span>&lt;/</span>h1</span><span>></span></span>
        <span><span><span>&lt;</span>p</span><span>></span></span>Microblog 是一个基于 Node.js 的微博系统。 <span><span><span>&lt;/</span>p</span><span>></span></span>
        <span><span><span>&lt;</span>p</span><span>></span></span>
            <span><span><span>&lt;</span>a</span> <span>class</span><span><span>=</span><span>"</span>btn btn-primary<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>/login<span>"</span></span> <span>role</span><span><span>=</span><span>"</span>button<span>"</span></span><span>></span></span>登录<span><span><span>&lt;/</span>a</span><span>></span></span>
            <span><span><span>&lt;</span>a</span> <span>class</span><span><span>=</span><span>"</span>btn btn-light<span>"</span></span> <span>href</span><span><span>=</span><span>"</span>/reg<span>"</span></span> <span>role</span><span><span>=</span><span>"</span>button<span>"</span></span><span>></span></span>立即注册<span><span><span>&lt;/</span>a</span><span>></span></span>
        <span><span><span>&lt;/</span>p</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span>&lt;%</span><span> <span>}</span> <span>else</span> <span>{</span> </span><span>%></span></span>
    <span><span>&lt;%-</span><span> <span>include</span><span>(</span><span>'say'</span><span>)</span> </span><span>%></span></span>
<span><span>&lt;%</span><span> <span>}</span> </span><span>%></span></span>
<span><span>&lt;%-</span><span> <span>include</span><span>(</span><span>'posts'</span><span>,</span> <span>{</span> posts<span>:</span> posts <span>}</span><span>)</span> </span><span>%></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>下面看看首页的效果吧，分别是用户登入之前和登入以后看到的首页效果。</p>
<p><img src="./assets/image-20210719214505393.png" alt="image-20210719214505393" /></p>
<p><img src="./assets/image-20210719214520604.png" alt="image-20210719214520604" /></p>
<h2 id="下一步"> 下一步</h2>
<blockquote>
<p>到此为止，微博网站的基本功能就完成了。这个网站仅仅是微博的一个雏形，距离真正的微博还有很大的距离。例如，我们没有对注册信息进行完整的验证，如用户名的规则，密码的长短等。作为社交工具，最重要的用户关注、转帖、评论、圈点用户这些功能都没有实现。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>应用部署</title>
      <link>https://wangyawei.top/views/backEnd/express/express-note-12/</link>
      <guid>https://wangyawei.top/views/backEnd/express/express-note-12/</guid>
      <source url="https://wangyawei.top/rss.xml">应用部署</source>
      <category>EXPRESS</category>
      <pubDate>Mon, 19 Jul 2021 10:54:10 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>在开发的过程中，通过node app.js命令运行服务器即可。但它不适合在产品环境下使用，因为到目前为止这个服务器还有几个重大缺陷。</p>
</blockquote>
<ol>
<li>
<p>不支持故障恢复</p>
<p>当程序有错误发生时，整个进程就会结束，需要重新在终端中启动服务器。这一点在开发中无可厚非，但在产品环境下就是严重的问题了，因为一旦用户访问时触发了程序中某个隐含的bug， 整个服务器就崩溃了，将无法继续为所有用户提供服务。所以部署应用时一定要考虑到故障恢复，提高系统的可靠性。</p>
</li>
<li>
<p>没有日志</p>
<p>对于开发者来说，日志，尤其是错误日志是及其重要的，经常查看它可以发现测试时没有注意到的程序错误。然而这个服务器运行时没有产生错误日志，只有访问日志，所以有必要实现它的日志功能。</p>
</li>
<li>
<p>无法利用多核提高性能</p>
<p>由于Node.js是单线程的，一个进程只能利用一个CPU 核心。当请求大量到来时，单线程就成为了提高吞吐量的瓶颈。随着多核乃至众核时代的到来，只能利用一个核心所带来的浪费是十分严重的，我们需要使用多进程来提高系统的性能。</p>
</li>
<li>
<p>独占端口</p>
<p>我们一般会在同一个服务器上建立多个网站，而且这些网站不能每个进程都独占80端口，所以我们有必要通过反向代理来实现基于域名的端口共享。</p>
</li>
<li>
<p>需要手动启动</p>
<p>目前每次启动服务器都是通过在命令行中直接键入命令来实现的，但在产品环境中，特别是在服务器重启以后，全部靠手动启动是不现实的。因此，我们应该制作一个自动启动服务器的脚本，并且通过该脚本可以实现停止服务器等功能</p>
</li>
</ol>
<h2 id="日志功能"> 日志功能</h2>
<blockquote>
<p>主要是实现访问日志和错误日志功能。访问日志就是记录用户对服务器的每个请求，包括客户端IP 地址，访问时间，访问路径，服务器响应以及客户端代理字符串。而错误日志则记录程序发生错误时的信息，由于调试中需要即时查看错误信息，将所有错误直接显示到终端即可，而在产品模式中，需要写入错误日志文件。</p>
</blockquote>
<p>morgan给我们提供了自定义功能，所以我们把修改下，app.js 修改如下：需要下载<code>moment</code></p>
<div><pre><code>app<span>.</span><span>use</span><span>(</span><span>logger</span><span>(</span><span>function</span> <span>(</span><span>tokens<span>,</span> req<span>,</span> res</span><span>)</span> <span>{</span>
  <span>return</span> <span>[</span>
    <span><span>`</span><span>[</span><span><span>${</span><span>moment</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>.</span><span>format</span><span>(</span><span>'YYYY-MM-DD hh:mm:ss'</span><span>)</span><span>}</span></span><span>]</span><span>`</span></span><span>,</span>
    tokens<span>[</span><span>'remote-addr'</span><span>]</span><span>(</span>req<span>)</span><span>,</span>
    tokens<span>.</span><span>method</span><span>(</span>req<span>,</span> res<span>)</span><span>,</span>
    tokens<span>.</span><span>url</span><span>(</span>req<span>,</span> res<span>)</span><span>,</span>
    tokens<span>.</span><span>status</span><span>(</span>req<span>,</span> res<span>)</span><span>,</span>
    tokens<span>.</span><span>res</span><span>(</span>req<span>,</span> res<span>,</span> <span>'content-length'</span><span>)</span><span>,</span> <span>'-'</span><span>,</span>
    tokens<span>[</span><span>'response-time'</span><span>]</span><span>(</span>req<span>,</span> res<span>)</span><span>,</span> <span>'ms'</span>
  <span>]</span><span>.</span><span>join</span><span>(</span><span>' '</span><span>)</span>
<span>}</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>重启服务器访问浏览器，输出如下：</p>
<div><pre><code><span>[</span><span>2021</span>-07-19 <span>11</span>:12:13<span>]</span> ::1 GET /reg <span>304</span>  - <span>28.614</span> ms
<span>[</span><span>2021</span>-07-19 <span>11</span>:12:14<span>]</span> ::1 GET /stylesheets/bootstrap.min.css <span>304</span>  - <span>10.743</span> ms
<span>[</span><span>2021</span>-07-19 <span>11</span>:12:14<span>]</span> ::1 GET /stylesheets/style.css <span>304</span>  - <span>10.250</span> ms
<span>[</span><span>2021</span>-07-19 <span>11</span>:12:14<span>]</span> ::1 GET /javascripts/jquery-3.6.0.min.js <span>304</span>  - <span>7.419</span> ms
<span>[</span><span>2021</span>-07-19 <span>11</span>:12:14<span>]</span> ::1 GET /javascripts/bootstrap.min.js <span>304</span>  - <span>4.551</span> ms
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>但是这是在我们的控制台输出的，我们需要把日志输出到文件中，修改上面代码为：</p>
<div><pre><code><span>const</span> accessLogStream <span>=</span> fs<span>.</span><span>createWriteStream</span><span>(</span>path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>'access.log'</span><span>)</span><span>,</span> <span>{</span> flags<span>:</span> <span>'a'</span> <span>}</span><span>)</span><span>;</span>
app<span>.</span><span>use</span><span>(</span><span>logger</span><span>(</span><span>(</span><span>tokens<span>,</span> req<span>,</span> res</span><span>)</span> <span>=></span> <span>{</span>
  <span>return</span> <span>[</span>
    <span><span>`</span><span>[</span><span><span>${</span><span>moment</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>.</span><span>format</span><span>(</span><span>'YYYY-MM-DD hh:mm:ss'</span><span>)</span><span>}</span></span><span>]</span><span>`</span></span><span>,</span>
    tokens<span>[</span><span>'remote-addr'</span><span>]</span><span>(</span>req<span>)</span><span>,</span>
    tokens<span>.</span><span>method</span><span>(</span>req<span>,</span> res<span>)</span><span>,</span>
    tokens<span>.</span><span>url</span><span>(</span>req<span>,</span> res<span>)</span><span>,</span>
    tokens<span>.</span><span>status</span><span>(</span>req<span>,</span> res<span>)</span><span>,</span>
    tokens<span>.</span><span>res</span><span>(</span>req<span>,</span> res<span>,</span> <span>'content-length'</span><span>)</span><span>,</span> <span>'-'</span><span>,</span>
    tokens<span>[</span><span>'response-time'</span><span>]</span><span>(</span>req<span>,</span> res<span>)</span><span>,</span> <span>'ms'</span>
  <span>]</span><span>.</span><span>join</span><span>(</span><span>' '</span><span>)</span>
<span>}</span><span>,</span> <span>{</span> stream<span>:</span> accessLogStream <span>}</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>
<p>重启服务器访问浏览器可以看到，根目录已经有一个<code>access.log</code>文件，并写入了内容；</p>
</blockquote>
<p>实现错误响应，并写入文件，<code>app.js</code>修改如下：</p>
<div><pre><code><span>// error handler</span>
app<span>.</span><span>use</span><span>(</span><span>function</span> <span>(</span><span>err<span>,</span> req<span>,</span> res<span>,</span> next</span><span>)</span> <span>{</span>
  <span>// set locals, only providing error in development</span>
  res<span>.</span>locals<span>.</span>message <span>=</span> err<span>.</span>message<span>;</span>
  res<span>.</span>locals<span>.</span>error <span>=</span> req<span>.</span>app<span>.</span><span>get</span><span>(</span><span>'env'</span><span>)</span> <span>===</span> <span>'development'</span> <span>?</span> err <span>:</span> <span>{</span><span>}</span><span>;</span>

  <span>// 将错误写入文件</span>
<span>+</span>  <span>const</span> meta <span>=</span> <span><span>`</span><span>[</span><span><span>${</span><span>moment</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>.</span><span>format</span><span>(</span><span>'YYYY-MM-DD hh:mm:ss'</span><span>)</span><span>}</span></span><span>] </span><span><span>${</span>req<span>.</span>url<span>}</span></span><span>\n</span><span><span>${</span>err<span>.</span>stack<span>}</span></span><span>\n</span><span>`</span></span>
<span>+</span>  errorLogfile<span>.</span><span>write</span><span>(</span>meta<span>)</span><span>;</span>

  <span>// render the error page</span>
  res<span>.</span><span>status</span><span>(</span>err<span>.</span>status <span>||</span> <span>500</span><span>)</span><span>;</span>
  res<span>.</span><span>render</span><span>(</span><span>'error'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><blockquote>
<p>到此为止，我们的日志系统就简单完成了；</p>
</blockquote>
<h2 id="使用cluster模块"> 使用cluster模块</h2>
<blockquote>
<p>Node.js 提供了一个核心模块： cluster。 cluster的功能是生成与当前进程相同的子进程，并且允许父进程和子进程之间共享端口。 Node.js 的另一个核心模块child_process 也提供了相似的进程生成功能，但最大的区别在于cluster 允许跨进程端口复用，给我们的网络服务器开发带来了很大的方便。</p>
</blockquote>
<p>为了在外部模块调用bin/www， 首先需要禁止服务器自动启动。修改www，在server.listen(port); 前后加上判断语句：</p>
<div><pre><code><span>// 可以通过测试 require.main === module 来确定文件是被直接运行。</span>
<span>if</span> <span>(</span>require<span>.</span>main <span>===</span> module<span>)</span> <span>{</span>
  server<span>.</span><span>listen</span><span>(</span>port<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p>这个语句的功能是判断当前模块是不是由其他模块调用的，如果不是，说明它是直接启动的，此时启动调试服务器；如果是，则不自动启动服务器。</p>
</blockquote>
<div><p>提示</p>
<p>module.parent  新增于: v0.1.16 弃用于: v14.6.0, v12.19.0 。改为使用 <a href="http://nodejs.cn/api/modules.html#modules_require_main" target="_blank" rel="noopener noreferrer"><code>require.main</code></a> 和 <a href="http://nodejs.cn/api/modules.html#modules_module_children" target="_blank" rel="noopener noreferrer"><code>module.children</code></a> 。</p>
</div>
<p>创建cluster.js，通过cluster 调用bin/www。内容如下所示：</p>
<div><pre><code><span>const</span> cluster <span>=</span> <span>require</span><span>(</span><span>'cluster'</span><span>)</span><span>;</span>
<span>const</span> os <span>=</span> <span>require</span><span>(</span><span>'os'</span><span>)</span><span>;</span>

<span>// 获取CPU 的数量</span>
<span>const</span> numCPUs <span>=</span> os<span>.</span><span>cpus</span><span>(</span><span>)</span><span>.</span>length<span>;</span>
<span>const</span> workers <span>=</span> <span>{</span><span>}</span><span>;</span>

<span>if</span> <span>(</span>cluster<span>.</span>isMaster<span>)</span> <span>{</span>
    <span>// 主进程分支</span>
    cluster<span>.</span><span>on</span><span>(</span><span>'death'</span><span>,</span> <span>function</span> <span>(</span><span>worker</span><span>)</span> <span>{</span>
        <span>// 当一个工作进程结束时，重启工作进程</span>
        <span>delete</span> workers<span>[</span>worker<span>.</span>pid<span>]</span><span>;</span>
        worker <span>=</span> cluster<span>.</span><span>fork</span><span>(</span><span>)</span><span>;</span>
        workers<span>[</span>worker<span>.</span>pid<span>]</span> <span>=</span> worker<span>;</span>
    <span>}</span><span>)</span><span>;</span>
    <span>// 初始开启与CPU 数量相同的工作进程</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> numCPUs<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>const</span> worker <span>=</span> cluster<span>.</span><span>fork</span><span>(</span><span>)</span><span>;</span>
        workers<span>[</span>worker<span>.</span>pid<span>]</span> <span>=</span> worker<span>;</span>
    <span>}</span>
<span>}</span> <span>else</span> <span>{</span>
    <span>// 工作进程分支，启动服务器</span>
    <span>const</span> <span>{</span> server<span>,</span> port <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./bin/www'</span><span>)</span><span>;</span>
    server<span>.</span><span>listen</span><span>(</span>port<span>)</span><span>;</span>
<span>}</span>
<span>// 当主进程被终止时，关闭所有工作进程</span>
process<span>.</span><span>on</span><span>(</span><span>'SIGTERM'</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>var</span> pid <span>in</span> workers<span>)</span> <span>{</span>
        process<span>.</span><span>kill</span><span>(</span>pid<span>)</span><span>;</span>
    <span>}</span>
    process<span>.</span><span>exit</span><span>(</span><span>0</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><blockquote>
<p>cluster.js的功能是创建与CPU 核心个数相同的服务器进程，以确保充分利用多核CPU的资源。主进程生成若干个工作进程，并监听工作进程结束事件，当工作进程结束时，重新启动一个工作进程。分支进程产生时会自顶向下重新执行当前程序，并通过分支判断进入工作进程分支，在其中读取模块并启动服务器。通过cluster启动的工作进程可以直接实现端口复用，因此所有工作进程只需监听同一端口。当主进程终止时，还要主动关闭所有工作进程。</p>
</blockquote>
<p>修改bin/www，导出 server和port,修改如下：</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  server<span>,</span>
  port
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>在终端中执行node cluster.js 命令， 可以看到进程列表中启动了多个 node进程（4核CPU）：</p>
<div><pre><code><span>></span> express-example@1.0.0 start C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span>express--example<span>\</span>qwer
<span>></span> SET <span>DEBUG</span><span>=</span>express-example:* <span>&amp;&amp;</span> node ./cluster.js

express-session deprecated undefined resave option<span>;</span> provide resave option app.js:37:9
express-session deprecated undefined resave option<span>;</span> provide resave option app.js:37:9
express-session deprecated undefined saveUninitialized option<span>;</span> provide saveUninitialized option app.js:37:9
express-session deprecated undefined saveUninitialized option<span>;</span> provide saveUninitialized option app.js:37:9
express-session deprecated undefined resave option<span>;</span> provide resave option app.js:37:9
express-session deprecated undefined saveUninitialized option<span>;</span> provide saveUninitialized option app.js:37:9
  express-example:server Listening on port <span>3000</span> +0ms
  express-example:server Listening on port <span>3000</span> +0ms
  express-example:server Listening on port <span>3000</span> +0ms
express-session deprecated undefined resave option<span>;</span> provide resave option app.js:37:9
express-session deprecated undefined saveUninitialized option<span>;</span> provide saveUninitialized option app.js:37:9
  express-example:server Listening on port <span>3000</span> +0ms
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><blockquote>
<p>我配置了npm 脚本：  &quot;start&quot;: &quot;SET DEBUG=express-example:* &amp;&amp; node ./cluster.js&quot;。</p>
<p>终止工作进程，新的工作进程会立即启动，终止主进程，所有工作进程也会同时结束。</p>
</blockquote>
<h2 id="启动脚本"> 启动脚本</h2>
<blockquote>
<p>如果你维护过Linux 服务器，会对/etc/init.d/ 下面的脚本有印象。例如使用/etc/init.d/nginx start 和/etc/init.d/nginx stop 可以启动和关闭Nginx 服务器。我们通过bash 脚本也来实现一个类似的功能，创建microblog 并使用chmod +x microblog 赋予其执行权限，脚本内容为：</p>
</blockquote>
<div><pre><code><span>#! /bin/sh</span>
<span>NODE_ENV</span><span>=</span>production
<span>DAEMON</span><span>=</span><span>"node cluster.js"</span>
<span>NAME</span><span>=</span>Microblog
<span>DESC</span><span>=</span>Microblog
<span>PIDFILE</span><span>=</span><span>"microblog.pid"</span>

<span>case</span> <span>"<span>$1</span>"</span> <span>in</span>
start<span>)</span>
    <span>echo</span> <span>"Starting <span>$DESC</span>: "</span>
        <span>nohup</span> <span>$DAEMON</span> <span>></span> /dev/null <span>&amp;</span>
    <span>echo</span> <span>$!</span> <span>></span> <span>$PIDFILE</span>
    <span>echo</span> <span>"<span>$NAME</span>."</span>
        <span>;</span><span>;</span>
stop<span>)</span>
    <span>echo</span> <span>"Stopping <span>$DESC</span>: "</span>
        <span>pid</span><span>=</span><span>'cat $PIDFILE'</span>
    <span>kill</span> <span>$pid</span>
        <span>rm</span> <span>$PIDFILE</span>
    <span>echo</span> <span>"<span>$NAME</span>."</span>
        <span>;</span><span>;</span>
<span>esac</span>
<span>exit</span> <span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><blockquote>
<p>它的功能是通过nohup 启动服务器，使进程不会因为退出终端而关闭，同时将主进程的pid 写入microblog.pid 文件。当调用结束命令时，从microblog.pid 读取pid 的值，终止主进程以关闭服务器。</p>
</blockquote>
<div><p>注意</p>
<p>这段脚本只支持 POSIX操作系统，如 Linux、 Mac OS等，在 Windows下不可用。</p>
</div>
<h2 id="共享-80-端口"> 共享 80 端口</h2>
<blockquote>
<p>到目前为止，网站都是运行在3000端口下的，也就是说用户必须在网址中加入:3000才能访问网站。默认的HTTP 端口是80，因此必须监听80端口才能使网址更加简洁。如果整个服务器只有一个网站，那么只需让app.js 监听80 端口即可。但很多时候一个服务器上运行着不止一个网站，此时虚拟主机可以粉墨登场了。</p>
</blockquote>
<p>在Nginx 中设置反向代理和虚拟主机非常简单，下面是配置文件的一个示例：</p>
<div><pre><code>server <span>{</span>
    listen <span>80</span><span>;</span>
    server_name mysite<span>.</span>com<span>;</span>
    location <span>/</span> <span>{</span>
        proxy_pass http<span>:</span><span>/</span><span>/</span>localhost<span>:</span><span>3000</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>
<p>这个配置文件的功能是监听访问mysite.com 80 端口的请求，并将所有的请求转发给http://localhost:3000，即我们的Node.js 服务器。现在访问http://mysite.com/，就相当于服务器访问http://localhost:3000了。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>前言、常量与变量</title>
      <link>https://wangyawei.top/views/backEnd/java/basic/node-note-01/</link>
      <guid>https://wangyawei.top/views/backEnd/java/basic/node-note-01/</guid>
      <source url="https://wangyawei.top/rss.xml">前言、常量与变量</source>
      <category>JAVA</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1、前言"> 1、前言；</h2>
<blockquote>
<p>Java语言是美国Sun公司（Stanford University Network），在1995年推出的高级的编程语言。所谓编程语言，是计算机的语言，人们可以使用编程语言对计算机下达命令，让计算机完成人们需要的功能。</p>
</blockquote>
<h6 id="java语言发展历史"> Java语言发展历史;</h6>
<ul>
<li>1995年Sun公司发布Java1.0版本</li>
<li>1997年发布Java 1.1版本</li>
<li>1998年发布Java 1.2版本</li>
<li>2000年发布Java 1.3版本</li>
<li>2002年发布Java 1.4版本</li>
<li>2004年发布Java 1.5版本</li>
<li>2006年发布Java 1.6版本</li>
<li>2009年Oracle甲骨文公司收购Sun公司，并于2011发布Java 1.7版本</li>
<li>2014年发布Java 1.8版本</li>
<li>2017年发布Java 9.0版本</li>
</ul>
<h6 id="java语言能做什么"> Java语言能做什么;</h6>
<p>Java语言主要应用在互联网程序的开发领域。常见的互联网程序比如天猫、京东、物流系统、网银系统等，以及服务器后台处理大数据的存储、查询、数据挖掘等也有很多应用。</p>
<h6 id="计算机基础知识"> 计算机基础知识;</h6>
<ol>
<li>
<p>二进制;</p>
<p>计算机中的数据不同于人们生活中的数据，人们生活采用十进制数，而计算机中全部采用二进制数表示，它只包含
0、1两个数，逢二进一。每一个0或者每一个1，叫做一个bit（比特）。</p>
</li>
<li>
<p>十进制和二进制数据之间的转换计算;</p>
<ul>
<li>
<p>十进制数据转成二进制数据：使用除以2获取余数的方式;
<img src="./assets/1610891155434.png" alt="1610891155434" /></p>
</li>
<li>
<p>二进制数据转成十进制数据：使用8421编码的方式;
<img src="./assets/1610891199227.png" alt="1610891199227" /></p>
</li>
</ul>
</li>
<li>
<p>字节:  是我们常见的计算机中最小存储单元。计算机存储任何的数据，都是以字节的形式存储，右键点击文件属性，
我们可以查看文件的字节大小。</p>
<ul>
<li>8个bit（二进制位） 0000-0000表示为1个字节，写成1 byte或者1 B。</li>
<li>8 bit = 1 B</li>
<li>1024 B =1 KB</li>
<li>1024 KB =1 MB</li>
<li>1024 MB =1 GB</li>
<li>1024 GB = 1 TB</li>
</ul>
</li>
<li>
<p>常用DOS命令:  DOS是一个早期的操作系统，现在已经被Windows系统取代，对于我们开发人员，目前需要在DOS中完成一些事情，因此就需要掌握一些必要的命令。</p>
<ol>
<li>
<p>进入DOS操作窗口：按下Windows+R键盘，打开运行窗口，输入cmd回车，进入到DOS的操作窗口(常说的黑窗口)。</p>
</li>
<li>
<p>常用命令；</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>操作符号</th>
</tr>
</thead>
<tbody>
<tr>
<td>盘符切换命令</td>
<td>c:</td>
</tr>
<tr>
<td>查看当前文件夹</td>
<td>dir</td>
</tr>
<tr>
<td>进入文件夹命令</td>
<td>cd filename</td>
</tr>
<tr>
<td>退出文件夹命令</td>
<td>cd ..</td>
</tr>
<tr>
<td>退出到磁盘根目录</td>
<td>cd\</td>
</tr>
<tr>
<td>清屏</td>
<td>cls</td>
</tr>
</tbody>
</table>
</li>
</ol>
</li>
</ol>
<h2 id="_2、java语言开发环境搭建"> 2、Java语言开发环境搭建</h2>
<h3 id="_2、1-java虚拟机-jvm"> 2、1 Java虚拟机——JVM；</h3>
<blockquote>
<p>JVM（Java Virtual Machine ）：Java虚拟机，简称JVM，是运行所有Java程序的假想计算机，是Java程序的运行环境，是Java 最具吸引力的特性之一。我们编写的Java代码，都运行在 JVM 之上。
跨平台：任何软件的运行，都必须要运行在操作系统之上，而我们用Java编写的软件可以运行在任何的操作系统上，这个特性称为Java语言的跨平台特性。该特性是由JVM实现的，我们编写的程序运行在JVM上，而JVM运行在操作系统上。</p>
</blockquote>
<p><img src="./assets/1610891870708.png" alt="1610891870708" /></p>
<blockquote>
<p>如图所示，Java的虚拟机本身不具备跨平台功能的，每个操作系统下都有不同版本的虚拟机.</p>
</blockquote>
<h3 id="_2-2-jre-和-jdk"> 2.2 JRE 和 JDK;</h3>
<ul>
<li>
<p>JRE (Java Runtime Environment) ：是Java程序的运行时环境，包含 JVM 和运行时所需要的 核心类库 。</p>
</li>
<li>
<p>JDK (Java Development Kit)：是Java程序开发工具包，包含 JRE 和开发人员使用的工具。</p>
<blockquote>
<p>如果运行一个已有的Java程序，那么只需安装 JRE 即可。
如果开发一个全新的Java程序，那么必须安装 JDK 。</p>
<p>JDK &gt; JRE &gt; JVM</p>
</blockquote>
</li>
<li>
<p><a href="https://www.oracle.com/java/technologies/java-readme.html" target="_blank" rel="noopener noreferrer">下载：</a></p>
</li>
</ul>
<h3 id="_2-4-java-home环境变量的配置"> 2.4 JAVA_HOME环境变量的配置；</h3>
<blockquote>
<p>配置环境变量作用：开发Java程序需要使用JDK中提供的工具，工具在JDK9安装目录的 bin 目录下；在命令行下使用这些工具，就要先进入到JDK的bin目录下，这个过程就会非常的麻烦。不进入JDK的 bin 目录，这些工具就不能使用，会报错。为了开发方便，我们想在任意的目录下都可以使用JDK的开发工具，则必须要配置环境变量，配置环境变量的意义在于告诉操作系统，我们使用的JDK开发工具在哪个目录下。</p>
</blockquote>
<p><strong>配置环境变量步骤</strong>；</p>
<ol>
<li>计算机鼠标右键,选择 <strong>属性</strong>；</li>
<li>选择 <strong>高级系统设置</strong>；</li>
<li>高级选项卡，点击 <strong>环境变量</strong>；</li>
<li>在系统环境变量中，点击<strong>新建</strong> ，创建新的环境变量；</li>
<li>变量名输入 JAVA_HOME ，变量值输入JDK9的安装目录：D:\java9.04；</li>
<li>选中 <code>Path</code> 环境变量， 双击 或者 点击<strong>编辑</strong>;</li>
<li>在变量值的最前面，键入 %JAVA_HOME%\bin; 分号必须要写，必须是英文格式。</li>
<li>环境变量配置完成，重新开启DOS命令行，在任意目录下输入 javac 命令，运行成功。</li>
</ol>
<h2 id="_3、helloworld入门程序"> 3、HelloWorld入门程序；</h2>
<h3 id="_3、1-程序开发步骤说明"> 3、1 程序开发步骤说明；</h3>
<blockquote>
<p>开发环境已经搭建完毕，可以开发我们第一个Java程序了。Java程序开发三步骤：编写、编译、运行。</p>
</blockquote>
<p><img src="./assets/1610893656914.png" alt="1610893656914" /></p>
<h3 id="_3、2-编写java源程序"> 3、2 编写Java源程序；</h3>
<ol>
<li>
<p>新建文本文件，文件名修改为 HelloWorld.java ，其中文件名为 <code>HelloWorld</code> ，后缀名必须为 <code>.java</code> 。</p>
</li>
<li>
<p>用记事本打开,并键入以下代码；</p>
</li>
</ol>
<div><pre><code><span>public</span> <span>class</span> <span>HelloWorld</span> <span>{</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Hello World!"</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>
<p>第一个 HelloWord 源程序就编写完成了，但是这个文件是程序员编写的，JVM是看不懂的，也就不能运行，因此我们必须将编写好的 Java源文件编译成JVM可以看懂的 字节码文件 。</p>
</blockquote>
<h3 id="_3、3-编译java源文件"> 3、3  编译Java源文件；</h3>
<blockquote>
<p>在cmd命令行中，进入Java源文件的目录，使用 javac 命令进行编译。</p>
</blockquote>
<div><pre><code>javac HelloWorld.java
</code></pre>
<div><span>1</span><br></div></div><p>编译成功后，命令行没有任何提示。打开目录，发现产生了一个新的文件 HelloWorld.class ，该文件就是编译后的文件，是Java的可运行文件，称为字节码文件，有了字节码文件，就可以运行程序了。</p>
<blockquote>
<p>Java源文件的编译工具是 javac.exe ，在JDK安装目录的bin目录下。但是由于配置了环境变量，可以再任意目录下使用。</p>
</blockquote>
<h3 id="_3、4-运行java程序"> 3、4 运行Java程序；</h3>
<blockquote>
<p>在cmd命令行中，进入Java源文件的目录，使用 java 命令进行运行。</p>
</blockquote>
<div><pre><code>java HelloWorld <span># 注意不能写.class文件后缀</span>
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>Java程序 .class文件 的运行工具 java.exe ，在JDK安装目录的bin目录下。但是由于配置了环境变量，可以再任意目录下使用。</p>
</blockquote>
<h3 id="_3、5-入门程序说明"> 3、5 入门程序说明；</h3>
<ul>
<li>编译：是指将我们编写的Java源文件翻译成JVM认识的class文件，在这个过程中， javac 编译器会检查我们所写的程序是否有错误，有错误就会提示出来，如果没有错误就会编译成功。</li>
<li>运行：是指将 class文件，交给JVM去运行，此时JVM就会去执行我们编写的程序了。</li>
<li><strong>main</strong>方法：称为主方法。写法是<strong>固定格式</strong>不可以更改。main方法是程序的入口点或起始点，无论我们编写多
少程序，JVM在运行的时候，都会从main方法这里开始执行。</li>
</ul>
<h3 id="_3、6-添加注释comment"> 3、6 添加注释comment；</h3>
<ul>
<li>注释：就是对代码的解释和说明。其目的是让人们能够更加轻松地了解代码。为代码添加注释，是十分必须
要的，它不影响程序的编译和运行。</li>
<li>Java中有单行注释和多行注释。
<ul>
<li>单行注释以 <code>//</code> 开头，换行结束。</li>
<li>多行注释以 /*开头 以*/结束。</li>
</ul>
</li>
</ul>
<h3 id="_3、7-关键字keywords"> 3、7 关键字keywords；</h3>
<ul>
<li>关键字：是指在程序中，Java已经定义好的单词，具有特殊含义。
HelloWorld案例中，出现的关键字有 public 、 class 、 static 、 void 等，这些单词已经被Java定义好，全部都是小写字母。</li>
</ul>
<h3 id="_3、8-标识符"> 3、8 标识符；</h3>
<ul>
<li>标识符：是指在程序中，我们自己定义内容。比如类的名字、方法的名字和变量的名字等等，都是标识符。
HelloWorld案例中，出现的标识符有类名字 HelloWorld 。</li>
<li>命名规则： 硬性要求
<ul>
<li>标识符可以包含 英文字母26个(区分大小写) 、 0-9数字 、 $（美元符号） 和 _（下划线） 。</li>
<li>标识符不能以<strong>数字</strong>开头。</li>
<li>标识符不能是<strong>关键字</strong>。</li>
</ul>
</li>
<li>命名规范： 软性建议
<ul>
<li>类名规范：首字母大写，后面每个单词首字母大写（大驼峰式）。</li>
<li>方法名规范： 首字母小写，后面每个单词首字母大写（小驼峰式）。</li>
<li>变量名规范：全部小写。</li>
</ul>
</li>
</ul>
<h2 id="_4、常量"> 4、常量；</h2>
<blockquote>
<p>常量：是指在Java程序中固定不变的数据。</p>
</blockquote>
<table>
<thead>
<tr>
<th>类型</th>
<th>含义</th>
<th>数据举例</th>
</tr>
</thead>
<tbody>
<tr>
<td>整数常量</td>
<td>所有的整数</td>
<td>0 ，1 ，567， -9</td>
</tr>
<tr>
<td>小数常量</td>
<td>所有的小数</td>
<td>0.0， -0.1， 2.55</td>
</tr>
<tr>
<td>字符常量</td>
<td>单引号引起来,只能写一个字符,必须有内容</td>
<td>'a' ， ' '， '好'</td>
</tr>
<tr>
<td>字符串常量</td>
<td>双引号引起来,可以写多个字符,也可以不写</td>
<td>&quot;A&quot; ，&quot;Hello&quot; ，&quot;你好&quot; ，&quot;&quot;</td>
</tr>
<tr>
<td>布尔常量</td>
<td>只有两个值</td>
<td>true，false</td>
</tr>
<tr>
<td>空常量</td>
<td>只有一个值</td>
<td>null</td>
</tr>
</tbody>
</table>
<h2 id="_5、变量和数据类型"> 5、变量和数据类型；</h2>
<blockquote>
<p>变量：常量是固定不变的数据，那么在程序中可以变化的量称为变量。</p>
<p>Java中要求一个变量每次只能保存一个数据，必须要明确保存的<strong>数据类型</strong>。</p>
</blockquote>
<h3 id="_5、1-数据类型"> 5、1 数据类型；</h3>
<ul>
<li>
<p>Java的数据类型分为两大类：</p>
<ul>
<li>基本数据类型：包括 整数 、 浮点数 、 字符 、 布尔 。</li>
<li>引用数据类型：包括 类 、 数组 、 接口 。</li>
</ul>
</li>
<li>
<p><strong>基本数据类型</strong>；</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>关键字</th>
<th>内存占用</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>字节型</td>
<td>byte</td>
<td>1个字节</td>
<td>-128~127</td>
</tr>
<tr>
<td>短整型</td>
<td>short</td>
<td>2个字节</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>整型</td>
<td>int（默认）</td>
<td>4个字节</td>
<td>-231次方~2的31次方-1</td>
</tr>
<tr>
<td>长整型</td>
<td>long</td>
<td>8个字节</td>
<td>-2的63次方~2的63次方-1</td>
</tr>
<tr>
<td>单精度浮点数</td>
<td>ﬂoat</td>
<td>4个字节</td>
<td>1.4013E-45~3.4028E+38</td>
</tr>
<tr>
<td>双精度浮点数</td>
<td>double（默认）</td>
<td>8个字节</td>
<td>1.4013E-45~3.4028E+38</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
<td>2个字节</td>
<td>0-65535</td>
</tr>
<tr>
<td>布尔类型</td>
<td>boolean</td>
<td>1个字节</td>
<td>true false</td>
</tr>
</tbody>
</table>
<blockquote>
<p>Java中的默认类型：整数类型是 int 、浮点类型是 double 。</p>
</blockquote>
</li>
</ul>
<h3 id="_5、2-变量的定义"> 5、2  变量的定义；</h3>
<blockquote>
<p>变量定义的格式包括三个要素： 数据类型 、 变量名 、 数据值 。</p>
</blockquote>
<p>示例：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Variable</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
        <span>//定义字节型变量</span>
        <span>byte</span> b <span>=</span> <span>100</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>b<span>)</span><span>;</span>
        <span>//定义短整型变量</span>
        <span>short</span> s <span>=</span> <span>1000</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>s<span>)</span><span>;</span>
        <span>//定义整型变量</span>
        <span>int</span> i <span>=</span> <span>123456</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i<span>)</span><span>;</span>
        <span>//定义长整型变量</span>
        <span>long</span> l <span>=</span> <span>12345678900L</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>l<span>)</span><span>;</span>
        <span>//定义单精度浮点型变量</span>
        <span>float</span> f <span>=</span> <span>5.5F</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>f<span>)</span><span>;</span>
        <span>//定义双精度浮点型变量</span>
        <span>double</span> d <span>=</span> <span>8.5</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>d<span>)</span><span>;</span>
        <span>//定义布尔型变量</span>
        <span>boolean</span> bool <span>=</span> <span>false</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>bool<span>)</span><span>;</span>
        <span>//定义字符型变量</span>
        <span>char</span> c <span>=</span> <span>'A'</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><blockquote>
<p>long类型：建议数据后加L表示。</p>
<p>ﬂoat类型：建议数据后加F表示。</p>
<p>变量名称：在同一个大括号范围内，变量的名字不可以相同。</p>
<p>变量赋值：定义的变量，不赋值不能使用。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/backEnd/java/basic/</link>
      <guid>https://wangyawei.top/views/backEnd/java/basic/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>JAVA</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>由于本人java知识基本为零，所以这里主要记录一些java基础，供自己学习；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>数据类型转换、运算符、方法入门</title>
      <link>https://wangyawei.top/views/backEnd/java/basic/node-note-02/</link>
      <guid>https://wangyawei.top/views/backEnd/java/basic/node-note-02/</guid>
      <source url="https://wangyawei.top/rss.xml">数据类型转换、运算符、方法入门</source>
      <category>JAVA</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1、数据类型转换"> 1、数据类型转换；</h2>
<blockquote>
<p>Java程序中要求参与的计算的数据，必须要保证数据类型的一致性，如果数据类型不一致将发生类型的转换。</p>
</blockquote>
<h3 id="_1、1-自动转换"> 1、1 自动转换；</h3>
<ol>
<li>
<p>一个 int 类型变量和一个 byte 类型变量进行加法运算；</p>
<ul>
<li>自动转换：将 取值范围小的类型 自动提升为 取值范围大的类型 。</li>
</ul>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>int</span> i <span>=</span> <span>1</span><span>;</span>
    <span>byte</span> b <span>=</span> <span>2</span><span>;</span>
    <span>// byte x = b + i; // 报错</span>
    <span>//int类型和byte类型运算，结果是int类型</span>
    <span>int</span> j <span>=</span> b <span>+</span> i<span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>j<span>)</span><span>;</span>
<span>}</span>
<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>int</span> i <span>=</span> <span>1</span><span>;</span>
    <span>double</span> d <span>=</span> <span>2.5</span><span>;</span>
    <span>//int类型和double类型运算，结果是double类型</span>
    <span>//int类型会提升为double类型</span>
    <span>double</span> e <span>=</span> d<span>+</span>i<span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>e<span>)</span><span>;</span>
<span>}</span>
<span>// 同理，当一个 int 类型变量和一个 double 变量运算时， int 类型将会自动提升为 double 类型进行运算。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><blockquote>
<p>byte 类型内存占有1个字节，在和 int 类型运算时会提升为 int 类型 ，自动补充3个字节，因此计算后的结果还是 int 类型。</p>
<p><strong>转换规则</strong>：范围小的类型向范围大的类型提升，byte、short、char 运算时直接提升为 int；</p>
<p>byte、short、char‐‐&gt;int‐‐&gt;long‐‐&gt;float‐‐&gt;double</p>
</blockquote>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/backEnd/jenkins/</link>
      <guid>https://wangyawei.top/views/backEnd/jenkins/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>JENKINS</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些自己平时积累的jenkin相关的知识；</p>
</blockquote>
<h2 id="参考资料"> 参考资料：</h2>
<h4 id="jenkins-2权威指南"> jenkins 2权威指南；</h4>
<h4 id="jenkins-2-x-实践指南"> jenkins 2.x 实践指南；</h4>
<h4 id="https-blog-csdn-net-weixin-40046357-article-details-104788271"> https://blog.csdn.net/weixin_40046357/article/details/104788271</h4>
<h4 id="https-www-cnblogs-com-forever521lee-p-9593739-html"> https://www.cnblogs.com/forever521Lee/p/9593739.html</h4>
]]></content:encoded>
    </item>
    <item>
      <title>jenkins基础命令；</title>
      <link>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-00/</link>
      <guid>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-00/</guid>
      <source url="https://wangyawei.top/rss.xml">jenkins基础命令；</source>
      <category>JENKINS</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>简单记录一下==Linux== 中Jenkins启动/重启/停止命令</p>
</blockquote>
<h2 id="启动"> 启动</h2>
<div><pre><code><span>service</span> jenkins start
<span>#  or</span>
systemctl start jenkins.service
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="停止"> 停止</h2>
<div><pre><code><span>service</span> jenkins stop
<span># or</span>
systemctl stop jenkins.service
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="重启"> 重启</h2>
<div><pre><code><span>service</span> jenkins restart
<span># or</span>
systemctl restart jenkins.service
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="状态"> 状态</h2>
<div><pre><code><span>service</span> jenkins status
<span># or</span>
systemctl status jenkins.service
<span># or 展开被省略的行</span>
systemctl -l status jenkins.service 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="重新加载"> 重新加载</h2>
<div><pre><code><span>service</span> jenkins reload
<span># or</span>
systemctl reload jenkins.service
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="扩展"> 扩展</h2>
<blockquote>
<p>我们还可以通过用url的方式，进行 关闭、重启、重新加载配置文件，假设jenkins的服务为：http://localhost:8080</p>
</blockquote>
<ol>
<li>
<p>关闭；</p>
<div><pre><code>http://localhost:8080/exit
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>重启；</p>
<div><pre><code>http://localhost:8080/restart
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>重新加载配置文件；</p>
<div><pre><code>http://localhost:8080/reload
</code></pre>
<div><span>1</span><br></div></div></li>
</ol>
<p><a href="https://www.cnblogs.com/faberbeta/p/jenkins004.html" target="_blank" rel="noopener noreferrer">阅读原文</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>jenkins结合git实现自动化部署</title>
      <link>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-01/</link>
      <guid>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-01/</guid>
      <source url="https://wangyawei.top/rss.xml">jenkins结合git实现自动化部署</source>
      <category>JENKINS</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="jenkins结合git实现自动化部署"> jenkins结合git实现自动化部署；</h2>
<blockquote>
<p>概述：Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于Hudson（Hudson是商用的），主要用于持续自动的构建/测试软件项目、监控外部任务的运行。通常与版本管理工具构建工具结合使用。常用的版本控制工具有SVN、GIT，构建工具有Maven、Ant、Gradle。</p>
</blockquote>
<p>本人使用的是阿里云服务器，jenkins的安装我就不在阐述，这个网上有很多教程(其实是不想在重新安装一遍，嘻嘻🤭)；下面主要记录以下，创建一个项目结合git用于自动化构建。</p>
<h2 id="_1、创建一个项目"> 1、创建一个项目；</h2>
<ul>
<li>
<p>登录你的jenkins服务；</p>
</li>
<li>
<p>点击新建任务创建一个项目；</p>
<p><img src="./assets/1610888635772.png" alt="1610888635772" /></p>
<p><img src="./assets/1610888755505.png" alt="1610888755505" /></p>
</li>
<li>
<p>jenkins的基本配置；</p>
</li>
<li>
<p>**general项；**填写描述信息；</p>
<p><img src="./assets/1610890119553.png" alt="1610890119553" /></p>
</li>
<li>
<p>源码管理项；</p>
<p><img src="./assets/1610982302021.png" alt="1610982302021" /></p>
<p><img src="./assets/1610982361544.png" alt="1610982361544" /></p>
</li>
<li>
<p>构建触发器；</p>
<p><img src="./assets/1610982449453.png" alt="1610982449453" /></p>
</li>
<li>
<p>构建环境；</p>
<p><img src="./assets/1610982566178.png" alt="1610982566178" /></p>
</li>
<li>
<p>绑定;</p>
<p><img src="./assets/1610982679537.png" alt="1610982679537" /></p>
<p><img src="./assets/1610982857819.png" alt="1610982857819" /></p>
</li>
<li>
<p>构建;</p>
<p><img src="./assets/1610982915869.png" alt="1610982915869" /></p>
<p><img src="./assets/1610983067604.png" alt="1610983067604" /></p>
</li>
</ul>
<h3 id="githup设置个人访问令牌"> githup设置个人访问令牌；</h3>
<p><img src="./assets/1610983896410.png" alt="1610983896410" /></p>
<p><img src="./assets/1610983925852.png" alt="1610983925852" /></p>
<p><img src="./assets/1610983974066.png" alt="1610983974066" /></p>
<p><img src="./assets/1610984118411.png" alt="1610984118411" /></p>
<p><img src="./assets/1610984152001.png" alt="1610984152001" /></p>
<p>​</p>
<p><strong>在构建选项卡那一步添加凭据ID为你在githup上创建的个人用户凭证；</strong></p>
<p><img src="./assets/1610986810110.png" alt="1610986810110" /></p>
<p>以上就是这些配置了，主要是构建时的命令需要根据的项目书写一下；</p>
<p>最后点击立即构建；</p>
]]></content:encoded>
    </item>
    <item>
      <title>基础知识</title>
      <link>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-02/</link>
      <guid>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-02/</guid>
      <source url="https://wangyawei.top/rss.xml">基础知识</source>
      <category>JENKINS</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>脚本式流水线更像是一种脚本或编程语言，像其他命令式语言一样可以运行程序和处理逻辑，而声明式流水线则更像Jenkins的传统实现方式，在Web表单的预定义字段中输入关键信息，代表了特定目标和预期行为。与传统的Web表单类似，当执行声明式流水线时，每一个段落定义了基于用户输入数据的执行内容和方式。</p>
</blockquote>
<h2 id="脚本式语法"> 脚本式语法</h2>
<blockquote>
<p>脚本式语法是Jenkins最开始实现的流水线即代码方式。这是一种命令式风格，也就是在流水线脚本中定义逻辑和程序流程。它也更依赖于Groovy语言和结构，特别是对于错误检查和异常处理来说。</p>
</blockquote>
<div><pre><code>node<span>(</span><span>'worker_node1'</span><span>)</span> <span>{</span>
	stage<span>(</span><span>'Source'</span><span>)</span> <span>{</span>
		// 从Git仓库中获取代码
		<span>git</span> <span>'git@diyvb2:/home/git/repositories/workshop.git'</span>
	<span>}</span>
	stage<span>(</span><span>'Compile'</span><span>)</span> <span>{</span>
		// 运行Grable 进行编译和单元测试
		<span>sh</span> <span>'grade clean compileJava test'</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>优点：</p>
<ul>
<li>更少的代码段落和弱规范要求。</li>
<li>更强大的程序代码能力。</li>
<li>更像编写代码程序。</li>
<li>传统的流水线即代码模型，用户熟悉并向后兼容性。</li>
<li>更灵活的自定义代码操作。</li>
<li>能够构建更复杂的工作流和流水线。</li>
</ul>
<p>缺点。</p>
<ul>
<li>普遍要求更高的编程水平。</li>
<li>语法检查受限于Groovy语言及环境。</li>
<li>和传统Jenkins模型有很大差异。</li>
<li>与声明式流水线的实现相比，同一工作流会更复杂。</li>
</ul>
<h2 id="声明式语法"> 声明式语法</h2>
<blockquote>
<p>声明式语法（declarative syntax）是Jenkins提供的一种新的选择。声明式风格的流水线代码被编排在清晰的段落中，相对于只关注实现逻辑，这些流水线的主要区域描述（或“声明”）了我们所期望的流水线的状态和输出。</p>
</blockquote>
<div><pre><code>pipeline <span>{</span>
	agent <span>{</span> label <span>"worker_node1"</span> <span>}</span>
	stages <span>{</span>
	<span># 获取代码</span>
		stage<span>(</span><span>'Source'</span><span>)</span> <span>{</span>
			steps <span>{</span>
				<span># 从git仓库中获取代码</span>
				<span>git</span> <span>"git@diyvb2:/home/git/repositories/workshop.git"</span>
			<span>}</span>
			steps<span>(</span><span>'Compile'</span><span>)</span> <span>{</span>
				steps <span>{</span>
					<span># 运行Gradle进行编译和单元测试</span>
					<span>sh</span> <span>"gradle clean compilejava test"</span>
				<span>}</span>
			<span>}</span>
		<span>}</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>优点：</p>
<ul>
<li>更结构化，贴近传统的Jenkins Web表单形式。</li>
<li>更强大的声明内容能力，高可读性。</li>
<li>可以通过Blue Ocean图形化界面自动生成。</li>
<li>段落可映射到常见的Jenkins概念，比如通知。</li>
<li>更友好的语法检查和错误识别。</li>
<li>提升流水线间的一致性。</li>
</ul>
<p>缺点：</p>
<ul>
<li>对迭代逻辑支持较弱（相比程序而言）。</li>
<li>仍在开发完善中（对于传统Jenkins中的部分功能缺乏支持）。</li>
<li>更严格的结构（更难实现自定义流水线代码）。</li>
<li>目前对于复杂的流水线和工作流难以胜任。</li>
</ul>
<blockquote>
<p>简而言之，对于新用户和希望流水线具备传统Jenkins一样可读性的用户来说，声明式流水线更容易学习和维护。这是以灵活性为代价换取结构不支持的功能。
脚本式流水线更加灵活，提供了“超级用户”的选项，即允许用户不受结构约束实现更多功能。不过，总的来说，任何一种流水线类型对大多数场景而言都同样适用。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>节点</title>
      <link>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-03/</link>
      <guid>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-03/</guid>
      <source url="https://wangyawei.top/rss.xml">节点</source>
      <category>JENKINS</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>在jenkins 2x中，节点是一个基础概念，代表了任何可以执行jenkins任务的系统。节点中包含主节点和代理节点。此外，节点也可以是一个容器，比如docker;</p>
</blockquote>
<h2 id="主节点"> 主节点；</h2>
<blockquote>
<p>主节点是一个jenkins实例的主要控制系统。它能够完全访问所有的jenkins配置选项和任务列表。如果没有指定其他系统，它也是默认的任务执行节点</p>
</blockquote>
<p>缺点：凡是在主节点上执行的任务，都有权限访问所有的数据，配置和操作，这会构成潜在的安全风险。同样值得注意的是，在主系统上不应该执行包含潜在阻塞的操作，因为主系统需要持续响应和管理各类操作过程。所以不推荐在主节点上执行任务。</p>
<h2 id="代理节点"> 代理节点</h2>
<blockquote>
<ol>
<li>在早先版本的Jenkins中，代理节点被称为从节点（slave），其代表了所有非主节点的系统。这类系统由主系统管理，按需分配或指定执行特定的任务。例如，我们可以分配不同的代理节点针对不同的操作系统构建任务，或者可以分配多个代理节点并发地运行测试任务。</li>
<li>为了减少系统负载，降低安全风险，通常在子系统上只会安装一个轻量级的Jenkins客户端应用来处理任务，这个客户端应用对资源访问是受限的。</li>
<li>随着代理节点和节点之间关系的演进，代理节点在节点上运行。在脚本式流水线中，“节点”特指一个运行代理节点的系统，而在声明式流水线中，其指代一个特定的代理节点来分配节点。</li>
<li>根据节点和代理节点在声明式语法和脚本式语法中的使用方式，我们可以得出这两个概念之间的差异。
node用于脚本式流水线，从技术层面上看它是一个步骤，代表可以用于流水线中执行活动的资源。它在一个运行代理节点的节点上面分配一个执行器，并进一步在定义的代码块上运行代码。</li>
</ol>
</blockquote>
<p>根据节点和代理节点在声明式语法和脚本式语法中的使用方式，我们可以得出这两个概念之间的差异:</p>
<ol>
<li>
<p>node用于脚本式流水线;</p>
<blockquote>
<p>从技术层面上看它是一个步骤，代表可以用于流水线中执行活动的资源。它在一个运行代理节点的节点上面分配一个执行器，并进一步在定义的代码块上运行代码。</p>
</blockquote>
<div><pre><code><span>// 脚本式流水线</span>
<span>node</span><span>(</span><span>'worker'</span><span>)</span> <span>{</span>
  <span>// 获取源码</span>
  <span>stage</span><span>(</span><span>'Source'</span><span>)</span> <span>{</span>
    <span>// 从git仓库获取代码</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>agent用于声明式流水线；</p>
<blockquote>
<p>而相对于声明式流水线中的agent，它作为一个指令用来分配节点，除非使用了特殊用法agent none。下面是一个简单的agent声明的示例</p>
</blockquote>
<div><pre><code><span>// 声明式流水线；</span>
pipeline <span>{</span>
	agent <span>{</span>label<span>:</span> <span>'worker'</span><span>}</span>
	stages <span>{</span>
		<span>stage</span><span>(</span><span>'Source'</span><span>)</span> <span>{</span>
			<span>// 获取代码</span>
		<span>}</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
</ol>
<blockquote>
<p>只需要记住一点：</p>
<ol>
<li>node用于脚本式流水线；</li>
<li>agent用于声明式流水线；</li>
</ol>
</blockquote>
<h2 id="创建节点"> 创建节点；</h2>
<blockquote>
<p>任务可以在主节点示例或者从节点示例上执行。在jenkins 2.x的术语中，这些实例被统一成通用术语“节点”。</p>
</blockquote>
<ol>
<li>
<p>登录jenkins，访问系统管理界面；</p>
</li>
<li>
<p>单击【节点管理】；下图为节点管理页面；</p>
<p><img src="./assets/image-20210529135426312.png" alt="image-20210529135426312" /></p>
</li>
<li>
<p>点击新建节点；并填写表单；</p>
<ul>
<li>节点名称：自定义；</li>
<li>选择固定节点；</li>
<li>点击确定；</li>
</ul>
</li>
<li>
<p>进入新建节点表单页面；</p>
<ul>
<li>主机为：你的服务器ip</li>
<li>凭证：为你的服务器登录用户名和密码；</li>
</ul>
<p><img src="./assets/image-20210529140020658.png" alt="image-20210529140020658" /></p>
<p><img src="./assets/image-20210529140148277.png" alt="image-20210529140148277" /></p>
</li>
<li>
<p>点击确定便会在你的节点管理页面出现新建的节点；</p>
</li>
<li>
<p>手动配置Java路径</p>
<blockquote>
<p>因为有一个节点代表一个jenkins示例，需要执行一个任务，而jenkins运行需要依赖jvm；所以如果你的节点不含有java则你需要安装java或手动配置java路径；在启动方式右下角点击【高级按钮】</p>
</blockquote>
<p><img src="./assets/image-20210529140844542.png" alt="image-20210529140844542" /></p>
</li>
</ol>
<blockquote>
<p>注意，在界面底部有环境变量和工具路径两个复选框。勾选这些复选框可以为该节点定义特殊变量和工具。只有当你希望使用与主节点不同的配置时，才会用到这些复选框。</p>
</blockquote>
<h2 id="节点标签"> 节点标签；</h2>
<blockquote>
<p>在标签配置中可以指定多个标签。标签名中如果包含空格，可以通过双引号来标注。</p>
</blockquote>
<p>标签可以满足系统和用户的不同需求，比如可以用于以下场景。</p>
<ul>
<li>识别一个特定的节点（通过一个专有标签）。</li>
<li>对一类节点进行分组（通过分配相同的标签）。</li>
<li>识别节点的特征，方便使用（通过一个有意义的标签，比如“Windows”或者“West Coast”）。</li>
</ul>
<p>标签可以被流水线直接引用，以定义代码执行的位置。一旦节点准备就绪，我们就可以专注于创建流水线了</p>
]]></content:encoded>
    </item>
    <item>
      <title>脚本式语法</title>
      <link>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-04/</link>
      <guid>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-04/</guid>
      <source url="https://wangyawei.top/rss.xml">脚本式语法</source>
      <category>JENKINS</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>脚本式语法一般以 node开头</p>
</blockquote>
<h2 id="指定节点运行任务"> 指定节点运行任务</h2>
<blockquote>
<p>执行以下任务，请保证你已经新建了一个节点并 打上了 worker1 的标签；</p>
</blockquote>
<ol>
<li>新建一个流水线项目；</li>
<li>在流水线选项卡中添加以下代码并运行；</li>
</ol>
<div><pre><code><span>node</span><span>(</span><span>'worker1'</span><span>)</span> <span>{</span>
	<span>stage</span><span>(</span><span>'Source'</span><span>)</span> <span>{</span>
		<span>// 从Git仓库中获取代码</span>
		<span>// git 'https://github.com/wyw-s/documents.git';</span>
		sh <span>'echo source'</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>运行结果：</p>
<div><pre><code>Started by user wangyawei
Running <span>in</span> Durability level: MAX_SURVIVABILITY
<span>[</span>Pipeline<span>]</span> Start of Pipeline
<span>[</span>Pipeline<span>]</span> node
Running on worker_node1 <span>in</span> /home/local/jenkinsNodes/worker_node1/workspace/blog
<span>[</span>Pipeline<span>]</span> <span>{</span>
<span>[</span>Pipeline<span>]</span> stage
<span>[</span>Pipeline<span>]</span> <span>{</span> <span>(</span>Source<span>)</span>
<span>[</span>Pipeline<span>]</span> <span>sh</span>
+ <span>echo</span> <span>source</span>
<span>source</span>
Cannot contact worker_node1: java.lang.InterruptedException
<span>[</span>Pipeline<span>]</span> <span>}</span>
<span>[</span>Pipeline<span>]</span> // stage
<span>[</span>Pipeline<span>]</span> <span>}</span>
<span>[</span>Pipeline<span>]</span> // node
<span>[</span>Pipeline<span>]</span> End of Pipeline
Finished: SUCCESS
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><blockquote>
<p>如果你不指定worker1标签，或者使用以下方式，那么则默认使用主节点(master)执行任务；</p>
</blockquote>
<div><pre><code><span>// 不指定标签</span>
node <span>{</span>
	<span>stage</span><span>(</span><span>'Source'</span><span>)</span> <span>{</span>
		<span>// 从Git仓库中获取代码</span>
		<span>// git 'https://github.com/wyw-s/documents.git';</span>
		sh <span>'echo source'</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>运行结果：</p>
<div><pre><code>Started by user wangyawei
Running <span>in</span> Durability level: MAX_SURVIVABILITY
<span>[</span>Pipeline<span>]</span> Start of Pipeline
<span>[</span>Pipeline<span>]</span> node
Running on Jenkins <span>in</span> /var/lib/jenkins/workspace/blog
<span>[</span>Pipeline<span>]</span> <span>{</span>
<span>[</span>Pipeline<span>]</span> stage
<span>[</span>Pipeline<span>]</span> <span>{</span> <span>(</span>Source<span>)</span>
<span>[</span>Pipeline<span>]</span> <span>sh</span>
+ <span>echo</span> <span>source</span>
<span>source</span>
<span>[</span>Pipeline<span>]</span> <span>}</span>
<span>[</span>Pipeline<span>]</span> // stage
<span>[</span>Pipeline<span>]</span> <span>}</span>
<span>[</span>Pipeline<span>]</span> // node
<span>[</span>Pipeline<span>]</span> End of Pipeline
Finished: SUCCESS
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>脚本式流水线拉取代码</title>
      <link>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-05/</link>
      <guid>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-05/</guid>
      <source url="https://wangyawei.top/rss.xml">脚本式流水线拉取代码</source>
      <category>JENKINS</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>以下操作默认你已新建节点并打上了 worker1的标签；</p>
</blockquote>
<ol>
<li>
<p>语法方式1：原始写法</p>
<div><pre><code><span>node</span><span>(</span><span>'worker1'</span><span>)</span> <span>{</span>
	<span>stage</span><span>(</span><span>'Source'</span><span>)</span> <span>{</span>
		<span>// 从Git仓库中获取代码</span>
		<span>git</span><span>(</span><span>[</span>credentialsId<span>:</span> <span>'16fc630b-8061-40f8-9dda-0723a2d794c2'</span><span>,</span> url<span>:</span> <span>'https://github.com/wyw-s/documents.git'</span><span>]</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>语法方式2: 映射语法：</p>
<div><pre><code><span>node</span><span>(</span><span>'worker1'</span><span>)</span> <span>{</span>
	<span>stage</span><span>(</span><span>'Source'</span><span>)</span> <span>{</span>
		<span>// 从Git仓库中获取代码 并指定凭据</span>
		git credentialsId<span>:</span> <span>'16fc630b-8061-40f8-9dda-0723a2d794c2'</span><span>,</span> url<span>:</span> <span>'https://github.com/wyw-s/documents.git'</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>语法方式3 简写方式:</p>
<div><pre><code><span>node</span><span>(</span><span>'worker1'</span><span>)</span> <span>{</span>
	<span>stage</span><span>(</span><span>'Source'</span><span>)</span> <span>{</span>
		<span>// 从Git仓库中获取代码</span>
      <span>// 如果只有一个必选参数，同时只传递一个值，那么参数名称可以被省略，从而实现简写；</span>
		git <span>'https://github.com/wyw-s/documents.git'</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>添加凭据的表单；</p>
<ul>
<li>类型选择 <code>Username with password</code>;</li>
<li>用户名：githup 登录账户；</li>
<li>密码： githup 登录密码；</li>
<li>ID：不填写的话，jenkins会自动生成；</li>
</ul>
</li>
</ol>
<p><img src="./assets/image-20210529200332893.png" alt="image-20210529200332893" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>脚本式语法使用nodejs</title>
      <link>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-06/</link>
      <guid>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-06/</guid>
      <source url="https://wangyawei.top/rss.xml">脚本式语法使用nodejs</source>
      <category>JENKINS</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>部署web应用的话，nodejs则会经常使用，但是在jenkins脚本式流水线中node则需要另外配置；</p>
</blockquote>
<ol>
<li>
<p>jenkins版本：2.291</p>
</li>
<li>
<p>配置安装指定版本的Nodejs；</p>
<ul>
<li>
<p>点击【系统设置】找到【全局工具配置】；</p>
</li>
<li>
<p>找到nodejs配置选项；配置完成单击确认；</p>
<p><img src="./assets/image-20210529231116596.png" alt="image-20210529231116596" /></p>
</li>
</ul>
</li>
<li>
<p>配置；</p>
<div><pre><code>node <span>{</span>
	<span>stage</span><span>(</span><span>'git clone'</span><span>)</span> <span>{</span>
		sh <span>'echo git clone'</span><span>;</span>
	<span>}</span>
	<span>stage</span><span>(</span><span>'nodejs'</span><span>)</span> <span>{</span>
	   sh <span>'echo nodejs'</span>
    <span>// 这里括号里面的内容为上面你配置的Nodejs的别名；</span>
	   <span>nodejs</span><span>(</span><span>'node-v12.18.2'</span><span>)</span> <span>{</span>
       	  <span>// 这种方式都可以执行</span>
	        <span>sh</span><span>(</span><span>"node -v &amp;&amp; npm -v"</span><span>)</span>
	        sh <span>'node -v'</span>
	    <span>}</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>脚本式语法部署web项目</title>
      <link>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-07/</link>
      <guid>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-07/</guid>
      <source url="https://wangyawei.top/rss.xml">脚本式语法部署web项目</source>
      <category>JENKINS</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>以下内容可以作为通用模板使用，但是你需要根据自己的项目灵活修改配置；</p>
</blockquote>
<div><pre><code>node <span>{</span>
	<span>stage</span><span>(</span><span>'git clone'</span><span>)</span> <span>{</span>
		git credentialsId<span>:</span> <span>'16fc630b-8061-40f8-9dda-0723a2d794c2'</span><span>,</span> url<span>:</span> <span>'https://github.com/wyw-s/documents.git'</span><span>;</span>
		sh <span>'pwd'</span><span>;</span>
		sh <span>'ls'</span>
	<span>}</span>
	<span>stage</span><span>(</span><span>'npm install'</span><span>)</span> <span>{</span>
	   <span>nodejs</span><span>(</span><span>'node-v12.18.2'</span><span>)</span> <span>{</span>
	       sh <span>'node -v &amp;&amp; npm -v'</span><span>;</span>
	       sh <span>'npm install'</span><span>;</span>
	    <span>}</span>
	<span>}</span>
	<span>stage</span><span>(</span><span>'npm build'</span><span>)</span> <span>{</span>
	   <span>nodejs</span><span>(</span><span>'node-v12.18.2'</span><span>)</span> <span>{</span>
	       sh <span>'npm run docs:build'</span><span>;</span>
	    <span>}</span>
	<span>}</span>
	<span>stage</span><span>(</span><span>'deploy'</span><span>)</span> <span>{</span>
	   <span>nodejs</span><span>(</span><span>'node-v12.18.2'</span><span>)</span> <span>{</span>
	       sh <span>'cd ./docs/.vuepress/dist'</span><span>;</span>
	       sh <span>'tar -zcvf docs.tar.gz *'</span><span>;</span>
	       sh <span>'ls -a &amp;&amp; pwd'</span>
	       sh <span>'mv docs.tar.gz /home/local/webview/documents'</span><span>;</span>
	       sh <span>'cd /home/local/webview/documents'</span><span>;</span>
	       sh <span>'tar -zxvf docs.tar.gz'</span><span>;</span>
	       sh <span>'rm -rf docs.tar.gz'</span><span>;</span>
	       sh <span>'ls'</span>
	    <span>}</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p><strong>正确的配置；</strong></p>
<div><pre><code>node <span>{</span>
	<span>stage</span><span>(</span><span>'git clone'</span><span>)</span> <span>{</span>
		git credentialsId<span>:</span> <span>'16fc630b-8061-40f8-9dda-0723a2d794c2'</span><span>,</span> url<span>:</span> <span>'https://github.com/wyw-s/documents.git'</span><span>;</span>
		sh <span>'pwd'</span><span>;</span>
		sh <span>'ls'</span>
	<span>}</span>
	<span>stage</span><span>(</span><span>'npm install'</span><span>)</span> <span>{</span>
	   <span>nodejs</span><span>(</span><span>'node-v12.18.2'</span><span>)</span> <span>{</span>
	       sh <span>'node -v &amp;&amp; npm -v'</span><span>;</span>
	       sh <span>'npm install'</span><span>;</span>
	    <span>}</span>
	<span>}</span>
	<span>stage</span><span>(</span><span>'npm build'</span><span>)</span> <span>{</span>
	   <span>nodejs</span><span>(</span><span>'node-v12.18.2'</span><span>)</span> <span>{</span>
	       sh <span>'npm run docs:build'</span><span>;</span>
	    <span>}</span>
	<span>}</span>
	<span>stage</span><span>(</span><span>'deploy'</span><span>)</span> <span>{</span>
	   <span>nodejs</span><span>(</span><span>'node-v12.18.2'</span><span>)</span> <span>{</span>
	       <span>sh</span><span>(</span><span>''</span>'
	       cd <span>.</span><span>/</span>docs<span>/</span><span>.</span>vuepress<span>/</span>dist<span>;</span>
	       tar <span>-</span>zcvf docs<span>.</span>tar<span>.</span>gz <span>*</span><span>;</span>
	       mv docs<span>.</span>tar<span>.</span>gz <span>/</span>home<span>/</span>local<span>/</span>webview<span>/</span>documents<span>;</span>
	       cd <span>/</span>home<span>/</span>local<span>/</span>webview<span>/</span>documents<span>;</span>
	       tar <span>-</span>zxvf docs<span>.</span>tar<span>.</span>gz<span>;</span>
	       rm <span>-</span>rf docs<span>.</span>tar<span>.</span>gz
	       pwd<span>;</span>
	       ls<span>;</span>
	       <span>''</span>'<span>)</span>
	    <span>}</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><div><p>注意</p>
<p>在最后的一个阶段 deploy 中，我采用了 <code>sh('''ls''')</code>三个引号的方式来写多行shell命令，之所以采用这种方式，是因为在上述第一种方法里面执行到最后一个阶段的时候你会发现，cd 这个命令虽然执行了，但是没有效果，简单的说就是你没有进入 cd 到的那个目录中去；现在不知道是 BUG 还是设计就是如此；</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>githup钩子触发jenkins构建</title>
      <link>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-08/</link>
      <guid>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-08/</guid>
      <source url="https://wangyawei.top/rss.xml">githup钩子触发jenkins构建</source>
      <category>JENKINS</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>对于程序员来说，子githup提交项目是一件非常平常的事情，有些时候我们也会把我们的项目部署到服务器上，在结合jenkins，我们就可以在Push到githup时触发jenkins构建我们的项目，这样就可以实现自动化部署；</p>
</blockquote>
<h2 id="自由风格的软件项目"> 自由风格的软件项目</h2>
<ol>
<li>
<p>项目类型：<strong>自由风格的软件项目</strong>；</p>
</li>
<li>
<p>在你的项目配置中勾选：<code>GitHub hook trigger for GITScm polling</code></p>
<p><img src="./assets/image-20210530100443008.png" alt="image-20210530100443008" /></p>
</li>
<li>
<p>登录你的githup；</p>
</li>
<li>
<p>找到你部署的项目，点击：<code>Settings</code>按钮；</p>
<p><img src="./assets/image-20210530100721896.png" alt="image-20210530100721896" /></p>
</li>
<li>
<p>找到<code>WebHooks</code>,点击<code>Add webhook</code>;</p>
<p><img src="./assets/image-20210530101535723.png" alt="image-20210530101535723" /></p>
</li>
<li>
<p>填写表单；填写完成点击 <code>Add webhookk</code>按钮；</p>
<p><img src="./assets/image-20210530101700850.png" alt="image-20210530101700850" /></p>
</li>
<li>
<p>在本地<code>git push</code>你的项目，jenkins则会自动构建；</p>
</li>
</ol>
<div><p>注意</p>
<p>以上示例默认你已经有一个<code>jenkins</code>项目并且已经可以执行手动构建;</p>
</div>
<h2 id="流水线类型项目"> 流水线类型项目</h2>
<blockquote>
<p>语法：脚本式流水线</p>
</blockquote>
<ol>
<li>
<p>在你的项目配置中勾选：<code>GitHub hook trigger for GITScm polling</code></p>
</li>
<li>
<p><strong>勾选：轮询SCM；</strong></p>
<p><img src="./assets/image-20210530105911262.png" alt="image-20210530105911262" /></p>
</li>
<li>
<p>后面步骤与<strong>自由风格的软件项目</strong>介绍相同；</p>
</li>
</ol>
<h2 id="使用脚本式语法"> 使用脚本式语法</h2>
<blockquote>
<p>使用：properties 配置属性；并添加 githubPush()。pollSCM 用于设置轮询的可有可无；</p>
</blockquote>
<div><pre><code>node <span>{</span>
  <span>// 重点：</span>
  <span>properties</span><span>(</span><span>[</span>
    <span>pipelineTriggers</span><span>(</span><span>[</span><span>githubPush</span><span>(</span><span>)</span><span>,</span> <span>pollSCM</span><span>(</span><span>''</span><span>)</span><span>]</span><span>)</span>
  <span>]</span><span>)</span>
  
	<span>stage</span><span>(</span><span>'git clone'</span><span>)</span> <span>{</span>
		git credentialsId<span>:</span> <span>'16fc630b-8061-40f8-9dda-0723a2d7xxxx2'</span><span>,</span> url<span>:</span> <span>'https://github.com/xxxw-s/documents.git'</span><span>;</span>
		sh <span>'pwd'</span><span>;</span>
		sh <span>'ls'</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>构建后操作</title>
      <link>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-09/</link>
      <guid>https://wangyawei.top/views/backEnd/jenkins/jenkins-note-09/</guid>
      <source url="https://wangyawei.top/rss.xml">构建后操作</source>
      <category>JENKINS</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>传统的（基于Web的）Jenkins自由风格类型任务包含一个构建后操作部分，在那里用户可以添加一些在构建结束后一定发生的行为，不管构建的状态是成功、失败或者被中止。我们可以在脚本式和声明式流水线中复制这种功能。脚本式流水线依靠编程结构来仿效这个功能，而声明式流水线使用内置的功能实现。</p>
<p>我的jenkins版本：2.291</p>
</blockquote>
<h2 id="构建后发送通知"> 构建后发送通知</h2>
<blockquote>
<p>在项目部署结束后，我们总希望可以得到一些通知例如：构建状态、构建日志等，所以项目构建完成后发送一些通知，是常见的需求</p>
</blockquote>
<h3 id="安装插件"> 安装插件;</h3>
<ol>
<li>
<p>进入：系统管理-&gt;插件管理；</p>
</li>
<li>
<p>搜索插件：<code>Email Extension</code>；</p>
</li>
<li>
<p>选中然后安装【建议安装完成重启一下jenkins服务】；</p>
<p><img src="./assets/image-20210530215224937.png" alt="image-20210530215224937" /></p>
</li>
</ol>
<h3 id="系统配置"> 系统配置；</h3>
<ol>
<li>
<p>进入：系统管理-&gt; 系统配置</p>
</li>
<li>
<p>找到：<code>Extended E-mail Notification</code>这一项；</p>
<p><img src="./assets/image-20210530215636282.png" alt="image-20210530215636282" /></p>
</li>
<li>
<p>填写表单；</p>
<p><img src="./assets/image-20210530215849870.png" alt="image-20210530215849870" /></p>
<p><img src="./assets/image-20210530220124153.png" alt="image-20210530220124153" /></p>
<p><img src="./assets/image-20210530220538419.png" alt="image-20210530220538419" /></p>
<p><img src="./assets/image-20210530220653993.png" alt="image-20210530220653993" /></p>
<p><img src="./assets/image-20210530220817434.png" alt="image-20210530220817434" /></p>
</li>
<li>
<p>邮件主体模板: 上图中的默认内容部分，可以直接使用以下模板；</p>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
    <span><span><span>&lt;</span>html</span><span>></span></span>
    <span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>${PROJECT_NAME}-第${BUILD_NUMBER}次构建日志<span><span><span>&lt;/</span>title</span><span>></span></span>
    <span><span><span>&lt;/</span>head</span><span>></span></span>

    <span><span><span>&lt;</span>body</span> <span>leftmargin</span><span><span>=</span><span>"</span>8<span>"</span></span> <span>marginwidth</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>topmargin</span><span><span>=</span><span>"</span>8<span>"</span></span> <span>marginheight</span><span><span>=</span><span>"</span>4<span>"</span></span>
        <span>offset</span><span><span>=</span><span>"</span>0<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>table</span> <span>width</span><span><span>=</span><span>"</span>95%<span>"</span></span> <span>cellpadding</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>cellspacing</span><span><span>=</span><span>"</span>0<span>"</span></span>
            <span><span>style</span><span><span>=</span><span>"</span><span><span>font-size</span><span>:</span> 11pt<span>;</span> <span>font-family</span><span>:</span> Tahoma<span>,</span> Arial<span>,</span> Helvetica<span>,</span> sans-serif</span><span>"</span></span></span><span>></span></span>
            <span><span><span>&lt;</span>tr</span><span>></span></span>
                <span><span><span>&lt;</span>td</span><span>></span></span>(本邮件是程序自动下发的，请勿回复！)<span><span><span>&lt;/</span>td</span><span>></span></span>
            <span><span><span>&lt;/</span>tr</span><span>></span></span>
            <span><span><span>&lt;</span>tr</span><span>></span></span>
                <span><span><span>&lt;</span>td</span><span>></span></span><span><span><span>&lt;</span>br</span> <span>/></span></span>
                <span><span><span>&lt;</span>b</span><span>></span></span><span><span><span>&lt;</span>font</span> <span>color</span><span><span>=</span><span>"</span>#0B610B<span>"</span></span><span>></span></span>构建信息($BUILD_STATUS)<span><span><span>&lt;/</span>font</span><span>></span></span><span><span><span>&lt;/</span>b</span><span>></span></span>
                <span><span><span>&lt;</span>hr</span> <span>size</span><span><span>=</span><span>"</span>2<span>"</span></span> <span>width</span><span><span>=</span><span>"</span>100%<span>"</span></span> <span>align</span><span><span>=</span><span>"</span>center<span>"</span></span> <span>/></span></span><span><span><span>&lt;/</span>td</span><span>></span></span>
            <span><span><span>&lt;/</span>tr</span><span>></span></span>
            <span><span><span>&lt;</span>tr</span><span>></span></span>
                <span><span><span>&lt;</span>td</span><span>></span></span>
                    <span><span><span>&lt;</span>ul</span><span>></span></span>
                        <span><span><span>&lt;</span>li</span><span>></span></span>项目名称 ： ${PROJECT_NAME}<span><span><span>&lt;/</span>li</span><span>></span></span>
                        <span><span><span>&lt;</span>li</span><span>></span></span>构建编号 ： 第${BUILD_NUMBER}次构建<span><span><span>&lt;/</span>li</span><span>></span></span>
                        <span><span><span>&lt;</span>li</span><span>></span></span>触发原因 ： ${CAUSE}<span><span><span>&lt;/</span>li</span><span>></span></span>
                        <span><span><span>&lt;</span>li</span><span>></span></span>项目地址 ： <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>${PROJECT_URL}<span>"</span></span><span>></span></span>${PROJECT_URL}<span><span><span>&lt;/</span>a</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
                        <span><span><span>&lt;</span>li</span><span>></span></span>构建日志 ： <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>${BUILD_URL}console<span>"</span></span><span>></span></span>${BUILD_URL}console<span><span><span>&lt;/</span>a</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
                        <span><span><span>&lt;</span>li</span><span>></span></span>工作目录 ： <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>${BUILD_URL}ws<span>"</span></span><span>></span></span>${BUILD_URL}ws<span><span><span>&lt;/</span>a</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
                        <span><span><span>&lt;</span>li</span><span>></span></span>Allure Report ： <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>${BUILD_URL}allure<span>"</span></span><span>></span></span>${BUILD_URL}allure<span><span><span>&lt;/</span>a</span><span>></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
                    <span><span><span>&lt;/</span>ul</span><span>></span></span>
                <span><span><span>&lt;/</span>td</span><span>></span></span>
            <span><span><span>&lt;/</span>tr</span><span>></span></span>
            <span><span><span>&lt;</span>tr</span><span>></span></span>
                <span><span><span>&lt;</span>td</span><span>></span></span><span><span><span>&lt;</span>b</span><span>></span></span><span><span><span>&lt;</span>font</span> <span>color</span><span><span>=</span><span>"</span>#0B610B<span>"</span></span><span>></span></span>构建日志(最后100行):<span><span><span>&lt;/</span>font</span><span>></span></span><span><span><span>&lt;/</span>b</span><span>></span></span>
                <span><span><span>&lt;</span>hr</span> <span>size</span><span><span>=</span><span>"</span>2<span>"</span></span> <span>width</span><span><span>=</span><span>"</span>100%<span>"</span></span> <span>align</span><span><span>=</span><span>"</span>center<span>"</span></span> <span>/></span></span><span><span><span>&lt;/</span>td</span><span>></span></span>
            <span><span><span>&lt;/</span>tr</span><span>></span></span>
            <span><span><span>&lt;</span>tr</span><span>></span></span>
                <span><span><span>&lt;</span>td</span><span>></span></span><span><span><span>&lt;</span>textarea</span> <span>cols</span><span><span>=</span><span>"</span>80<span>"</span></span> <span>rows</span><span><span>=</span><span>"</span>30<span>"</span></span> <span>readonly</span><span><span>=</span><span>"</span>readonly<span>"</span></span>
                        <span><span>style</span><span><span>=</span><span>"</span><span><span>font-family</span><span>:</span> Courier New</span><span>"</span></span></span><span>></span></span>${BUILD_LOG, maxLines=100}<span><span><span>&lt;/</span>textarea</span><span>></span></span>
                <span><span><span>&lt;/</span>td</span><span>></span></span>
            <span><span><span>&lt;/</span>tr</span><span>></span></span>
        <span><span><span>&lt;/</span>table</span><span>></span></span>
    <span><span><span>&lt;/</span>body</span><span>></span></span>
    <span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><blockquote>
<p>可以直接粘贴复制使用；</p>
</blockquote>
</li>
</ol>
<h3 id="邮箱开启smtp"> 邮箱开启SMTP;</h3>
<ol>
<li>
<p>电脑端登录你的qq邮箱网页版；</p>
</li>
<li>
<p>顶部找到：设置-&gt;账户；</p>
</li>
<li>
<p>开启SMTP;点击开启，会自动生成授权码，</p>
<p><img src="./assets/image-20210530221357942.png" alt="image-20210530221357942" /></p>
</li>
</ol>
<p><strong>配置结束</strong></p>
<h2 id="自由风格的项目"> 自由风格的项目</h2>
<blockquote>
<p>这种风格的项目有一个构建后操作的选项卡，我们可以在里面配置我们的电子邮件；</p>
</blockquote>
<h3 id="构建后操作-填写表单"> 构建后操作，填写表单；</h3>
<p><img src="./assets/image-20210530222726559.png" alt="image-20210530222726559" /></p>
<p><img src="./assets/image-20210530223221415.png" alt="image-20210530223221415" /></p>
<p><img src="./assets/image-20210530223324881.png" alt="image-20210530223324881" /></p>
<h3 id="触发器"> 触发器；</h3>
<p><img src="./assets/image-20210530223657855.png" alt="image-20210530223657855" /></p>
<p><img src="./assets/image-20210530223854919.png" alt="image-20210530223854919" /></p>
<blockquote>
<p>其他表单直接默认值，不修改即可，如有需要也可以自定义配置；</p>
</blockquote>
<h3 id="构建项目"> 构建项目；</h3>
<p>构建日志;</p>
<div><pre><code>Checking <span>if</span> email needs to be generated
Email was triggered for: Success
Sending email <span>for</span> trigger: Success
messageContentType <span>=</span> text/html<span>;</span> <span>charset</span><span>=</span>UTF-8
Request made to attach build log
  Collecting change authors<span>..</span>.
    build: <span>47</span>
Adding recipients from trigger recipient list
Analyzing: 2576xxx459@qq.com,116xxx2779@qq.com
Looking for: 257xxxx3459@qq.com
	starting at: <span>0</span>
	firstFoundIdx: <span>0</span>
	firstFoundIdx-substring: 25763xxx59@qq.com,116xxxx79@qq.com
	<span>=</span><span>></span> found type: <span>0</span>
<span>..</span><span>..</span><span>..</span>
Looking for: 11xxx2779@qq.com
	starting at: <span>18</span>
	firstFoundIdx: <span>18</span>
	firstFoundIdx-substring: 116xxx2779@qq.com
	<span>=</span><span>></span> found type: <span>0</span>
Successfully created MimeMessage
Sending email to: 257xxx93459@qq.com 116xx2779@qq.com
Finished: SUCCESS
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>邮件内容；</p>
<p><img src="./assets/image-20210530224704320.png" alt="image-20210530224704320" /></p>
<h2 id="流水线项目"> 流水线项目</h2>
<blockquote>
<p>这里我使用的是脚本式流水线；以下的配置前提是你已经有一个流水线项目，并且完成了前面最基础的配置；</p>
</blockquote>
<ol>
<li>
<p>新建一个阶段：'email'</p>
<div><pre><code>node <span>{</span>
	<span>stage</span><span>(</span><span>'email'</span><span>)</span> <span>{</span>
	    emailext attachLog<span>:</span> <span>true</span><span>,</span> body<span>:</span> <span>'jenkins构建成功'</span><span>,</span> to<span>:</span> <span>'123@qq.com'</span><span>,</span> subject<span>:</span> <span>'jenkins构建信息'</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h5 id="参数解释"> 参数解释：</h5>
<ol>
<li>attachLog：表示发送邮件的时候会把日志作为附件，一起发送；</li>
<li>body：发送的邮件的主体内容；例：jenkins构建成功；</li>
<li>to：要发送的联系人邮件地址；例：12345@qq.com;</li>
<li>subject: 邮件的主题；例：jenkins构建信息；</li>
</ol>
</li>
<li>
<p>简单流程；</p>
<div><pre><code>node <span>{</span>
	<span>stage</span><span>(</span><span>'git clone'</span><span>)</span> <span>{</span>
		git credentialsId<span>:</span> <span>'16fc630b-8061-40f8-9dda-0723a2d79xxx'</span><span>,</span> url<span>:</span> <span>'https://github.com/xxw-s/documents.git'</span><span>;</span>
		sh <span>'pwd'</span><span>;</span>
		sh <span>'ls'</span>
	<span>}</span>
	<span>stage</span><span>(</span><span>'email'</span><span>)</span> <span>{</span>
	    emailext attachLog<span>:</span> <span>true</span><span>,</span> body<span>:</span> <span>'jenkins构建成功'</span><span>,</span> to<span>:</span> <span>'123@qq.com'</span><span>,</span> subject<span>:</span> <span>'jenkins构建信息'</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
<li>
<p>日志；</p>
<div><pre><code><span>..</span><span>..</span><span>..</span>
Looking for: <span>2576393459</span>@qq.com
	starting at: <span>0</span>
	firstFoundIdx: <span>0</span>
	firstFoundIdx-substring: 257xxx459@qq.com
	<span>=</span><span>></span> found type: <span>0</span>
Adding recipients from trigger recipient list
Successfully created MimeMessage
Sending email to: 2576xxx9@qq.com
<span>[</span>Pipeline<span>]</span> <span>}</span>
<span>[</span>Pipeline<span>]</span> // stage
<span>[</span>Pipeline<span>]</span> <span>}</span>
<span>[</span>Pipeline<span>]</span> // node
<span>[</span>Pipeline<span>]</span> End of Pipeline
Finished: SUCCESS
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></li>
<li>
<p>邮件内容；</p>
<p><img src="./assets/image-20210531003622753.png" alt="image-20210531003622753" /></p>
</li>
<li>
<p>使用全局配置的默认值；</p>
<div><pre><code>node <span>{</span>
	<span>stage</span><span>(</span><span>'git clone'</span><span>)</span> <span>{</span>
		git credentialsId<span>:</span> <span>'16fc630b-8061-40f8-9dda-0723a2d7xxx'</span><span>,</span> url<span>:</span> <span>'https://github.com/xxx-s/documents.git'</span><span>;</span>
		sh <span>'pwd'</span><span>;</span>
		sh <span>'ls'</span>
	<span>}</span>
	<span>stage</span><span>(</span><span>'email'</span><span>)</span> <span>{</span>
	    emailext attachLog<span>:</span> <span>true</span><span>,</span> body<span>:</span> <span>''</span><span>'$DEFAULT_CONTENT'</span><span>''</span><span>,</span> to<span>:</span> <span>''</span><span>'$DEFAULT_RECIPIENTS'</span><span>''</span><span>,</span> subject<span>:</span> <span>''</span><span>'$DEFAULT_SUBJECT'</span><span>''</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>这里我使用了三重双引号，这是Groovy的特征，其中三重双引号用于封装多行消息，可以直接插入带有变量的字符串；</p>
<p>body、to、subject，这三处我使用的是默认值(全局配置里预先配置好的)；当然你也可以使用这是插件提供的；</p>
</blockquote>
</li>
</ol>
<h2 id="错误处理"> 错误处理；</h2>
<blockquote>
<p>脚本式流水线没有内置支持构建后处理。在脚本式流水线中，当我们还没有内置功能时，通常依靠Groovy程序结构来提供此功能。这也意味着在这种情况下，我们会使用try-catch-finally机制。然而，Jenkins DSL包含了另一个步骤，可以作为try-catch-finally功能的快捷方式：catchError。这个catchError步骤对多种场景都有用，此处对于构建后用例非常适用。</p>
</blockquote>
<ol>
<li>
<p>使用<code>try catch finally</code>；</p>
<div><pre><code>node <span>{</span>
	<span>try</span> <span>{</span>
	    <span>stage</span><span>(</span><span>'git clone'</span><span>)</span> <span>{</span>
    		git credentialsId<span>:</span> <span>'16fc630b-8061-40f8-9dda-0723a2d7xxx2'</span><span>,</span> url<span>:</span> <span>'https://github.com/wxx-s/documents.git'</span><span>;</span>
    		sh <span>'pwd'</span><span>;</span>
    		sh <span>'ls'</span>
    	<span>}</span>
	<span>}</span>
	<span>catch</span> <span>(</span>err<span>)</span> <span>{</span>
		<span>// 捕获错误</span>
		echo <span>'错误${err}'</span>
	<span>}</span> 
	<span>finally</span> <span>{</span>
    <span>// 无论结果如何都执行；</span>
		<span>stage</span><span>(</span><span>'email'</span><span>)</span> <span>{</span>
	    	emailext attachLog<span>:</span> <span>true</span><span>,</span> body<span>:</span> <span>''</span><span>'$DEFAULT_CONTENT'</span><span>''</span><span>,</span> to<span>:</span> <span>''</span><span>'$DEFAULT_RECIPIENTS'</span><span>''</span><span>,</span> subject<span>:</span> <span>''</span><span>'$DEFAULT_SUBJECT'</span><span>''</span><span>;</span>
		<span>}</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div></li>
<li>
<p>简写方式：<code>catchError</code>;</p>
<div><pre><code>node <span>{</span>
	catchError <span>{</span>
	    <span>stage</span><span>(</span><span>'git clone'</span><span>)</span> <span>{</span>
    		git credentialsId<span>:</span> <span>'16fc630b-8061-40f8-9dda-0723a2d79xxx'</span><span>,</span> url<span>:</span> <span>'https://github.com/xxw-s/documents.git'</span><span>;</span>
    		sh <span>'pwd'</span><span>;</span>
    		sh <span>'ls'</span>
    	<span>}</span>
	<span>}</span>
	<span>// 无论结果如何都执行；</span>
   <span>stage</span><span>(</span><span>'email'</span><span>)</span> <span>{</span>
     emailext attachLog<span>:</span> <span>true</span><span>,</span> body<span>:</span> <span>''</span><span>'$DEFAULT_CONTENT'</span><span>''</span><span>,</span> to<span>:</span> <span>''</span><span>'$DEFAULT_RECIPIENTS'</span><span>''</span><span>,</span> subject<span>:</span> <span>''</span><span>'$DEFAULT_SUBJECT'</span><span>''</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></li>
</ol>
<h2 id="整体配置"> 整体配置</h2>
<blockquote>
<p>这是个人的博客项目的流水线的整体配置；如要使用，请预先完成前面的插件配置；</p>
</blockquote>
<div><pre><code>node <span>{</span>
    <span>properties</span><span>(</span><span>[</span>
        <span>pipelineTriggers</span><span>(</span><span>[</span><span>githubPush</span><span>(</span><span>)</span><span>,</span> <span>pollSCM</span><span>(</span><span>''</span><span>)</span><span>]</span><span>)</span>
    <span>]</span><span>)</span>
	catchError <span>{</span>
	    <span>stage</span><span>(</span><span>'git clone'</span><span>)</span> <span>{</span>
    		git credentialsId<span>:</span> <span>'16fc630b-8061-40f8-9dda-0723a2d7xxx'</span><span>,</span> url<span>:</span> <span>'https://github.com/xxxw-s/documents.git'</span><span>;</span>
    		sh <span>'pwd'</span><span>;</span>
    		sh <span>'ls'</span>
    	<span>}</span>
    	<span>stage</span><span>(</span><span>'npm install'</span><span>)</span> <span>{</span>
    	   <span>nodejs</span><span>(</span><span>'node-v12.18.2'</span><span>)</span> <span>{</span>
    	       sh <span>'node -v &amp;&amp; npm -v'</span><span>;</span>
    	       sh <span>'npm install'</span><span>;</span>
    	    <span>}</span>
    	<span>}</span>
    	<span>stage</span><span>(</span><span>'npm build'</span><span>)</span> <span>{</span>
    	   <span>nodejs</span><span>(</span><span>'node-v12.18.2'</span><span>)</span> <span>{</span>
    	       sh <span>'npm run docs:build'</span><span>;</span>
    	    <span>}</span>
    	<span>}</span>
    	<span>stage</span><span>(</span><span>'deploy'</span><span>)</span> <span>{</span>
    	   <span>nodejs</span><span>(</span><span>'node-v12.18.2'</span><span>)</span> <span>{</span>
    	       <span>sh</span><span>(</span><span>''</span>'
    	       cd <span>.</span><span>/</span>docs<span>/</span><span>.</span>vuepress<span>/</span>dist<span>;</span>
    	       tar <span>-</span>zcvf docs<span>.</span>tar<span>.</span>gz <span>*</span><span>;</span>
    	       mv docs<span>.</span>tar<span>.</span>gz <span>/</span>home<span>/</span>local<span>/</span>webview<span>/</span>documents<span>;</span>
    	       cd <span>/</span>home<span>/</span>local<span>/</span>webview<span>/</span>documents<span>;</span>
    	       tar <span>-</span>zxvf docs<span>.</span>tar<span>.</span>gz<span>;</span>
    	       rm <span>-</span>rf docs<span>.</span>tar<span>.</span>gz
    	       pwd<span>;</span>
    	       ls<span>;</span>
    	       <span>''</span>'<span>)</span>
    	    <span>}</span>
    	<span>}</span>
	<span>}</span>
	<span>stage</span><span>(</span><span>'email'</span><span>)</span> <span>{</span>
	    emailext attachLog<span>:</span> <span>true</span><span>,</span> body<span>:</span> <span>''</span><span>'$DEFAULT_CONTENT'</span><span>''</span><span>,</span> to<span>:</span> <span>''</span><span>'$DEFAULT_RECIPIENTS'</span><span>''</span><span>,</span> subject<span>:</span> <span>''</span><span>'$DEFAULT_SUBJECT'</span><span>''</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/backEnd/koa/</link>
      <guid>https://wangyawei.top/views/backEnd/koa/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>KOA</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些自己平时积累的<strong>koa</strong>相关的知识；</p>
</blockquote>
<h2 id="目录"> 目录</h2>
<ul>
<li><a href="./koa-note-01.html">框架简介</a></li>
<li><a href="./koa-note-02.html">Bluebird</a></li>
<li><a href="./koa-note-03.html">创建应用程序</a></li>
<li><a href="./koa-note-04.html">Middleware</a></li>
<li><a href="./koa-note-02.html">context</a></li>
<li><a href="./koa-note-06.html">cookie操作</a></li>
<li><a href="./koa-note-07.html">错误处理</a></li>
<li><a href="./koa-note-08.html">路由系统</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>框架简介</title>
      <link>https://wangyawei.top/views/backEnd/koa/koa-note-01/</link>
      <guid>https://wangyawei.top/views/backEnd/koa/koa-note-01/</guid>
      <source url="https://wangyawei.top/rss.xml">框架简介</source>
      <category>KOA</category>
      <pubDate>Mon, 26 Jul 2021 15:24:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Koa是Express背后的团队设计的一个新的web框架，其目标是为web应用程序和api提供一个更小、更富表现力、更健壮的基础。 通过利用异步函数，Koa允许您放弃回调并极大地增加错误处理。 Koa在其核心中没有捆绑任何中间件，它提供了一套优雅的方法，使编写服务器变得快速和愉快。</p>
</blockquote>
<p><img src="./assets/image-20210726174022729.png" alt="image-20210726174022729" /></p>
<p>由于Koa核心不捆绑任何中间件，因此koa核心是“纯净的”，这极大的方便了用户的扩展。此外，koa使用了Peomise、async/await语法来进行移步编程，而express是基于事件和回调的。</p>
<p><strong>koa框架和express框架的主要差别在于异步编程和中间件方面，其他特性是相似的。</strong></p>
<ul>
<li>Express框架使用回调来进行异步处理，这也是Node.js标准的做法。但是基于回调的异步编程模型在多个异步操作之间有顺序依赖时，会产生回调地狱（Callback Hell），也就是多层callback嵌套问题，代码不利于维护。</li>
<li>Koa框架使用了ES2017最新的async/await语法来进行异步编程，从根本上解决了传统Node.js异步编程风格存在的问题，但是需要将异步调用包装为Promise。</li>
</ul>
<div><p>提示</p>
<p>由于Koa进行异步调用时强制使用async/await，因此需要将异步回调方法转换为Promise，如果每个回调方法都需要自己包装的话，工作量还是有点大，这一问题目前最好的解决方案—Bluebird。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Bluebird</title>
      <link>https://wangyawei.top/views/backEnd/koa/koa-note-02/</link>
      <guid>https://wangyawei.top/views/backEnd/koa/koa-note-02/</guid>
      <source url="https://wangyawei.top/rss.xml">Bluebird</source>
      <category>KOA</category>
      <pubDate>Mon, 26 Jul 2021 18:05:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p><code>Promise</code>对象已在ECMAScript 2015中被写入标准，且已被最新版本的浏览器和Node.js/IO.js所支持。<code>bluebird</code>是Node.js最出名的一个第三方<code>Promise</code>规范实现库，除了实现标准的Promise规范之外，Bluebird还提供了包装方法，可以快速地将Node.js回调风格的函数包装为Promise。它不仅完全兼容原生<code>Promise</code>对象，且比原生对象功能更强大。</p>
</blockquote>
<h2 id="安装"> 安装</h2>
<p>npm安装，cmd输入以下命令 <a href="http://bluebirdjs.com/docs/getting-started.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
<div><pre><code><span>npm</span> i bluebird
</code></pre>
<div><span>1</span><br></div></div><h2 id="使用"> 使用</h2>
<blockquote>
<p>这里只简单介绍下，把不是异步的回调函数，包装成promise来使用；<a href="http://bluebirdjs.com/docs/working-with-callbacks.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
</blockquote>
<h3 id="promise-promisify"> <a href="http://bluebirdjs.com/docs/api/promise.promisify.html" target="_blank" rel="noopener noreferrer"><code>Promise.promisify</code></a></h3>
<p>将单个回调函数转换为promise函数。它不会改变原始函数并返回修改后的函数。</p>
<div><pre><code><span># 1.text</span>

hello word
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>// test.js</span>

<span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>
<span>const</span> bluebird <span>=</span> <span>require</span><span>(</span><span>'bluebird'</span><span>)</span><span>;</span>

<span>// 回调函数的书写形式</span>
<span>// fs.readFile('./1.text', 'utf-8', (err, result) => {</span>
<span>//     console.log(result);</span>
<span>// })</span>

<span>// 把fs.readFile包装为promise</span>
<span>const</span> readFile <span>=</span> bluebird<span>.</span><span>promisify</span><span>(</span>fs<span>.</span>readFile<span>)</span>

<span>readFile</span><span>(</span><span>'./1.text'</span><span>,</span> <span>'utf-8'</span><span>)</span><span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>res<span>)</span><span>;</span>
<span>}</span><span>)</span>

<span>readFile</span><span>(</span><span>'../1.text'</span><span>,</span> <span>'utf-8'</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>err<span>)</span><span>;</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><div><pre><code><span># 输入结果</span>
C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span>test<span>></span> node .<span>\</span>test.js
<span>[</span>OperationalError: ENOENT: no such <span>file</span> or directory, <span>open</span> <span>'C:\Users\wangy\Desktop\1.text'</span><span>]</span> <span>{</span>
  cause: <span>[</span>Error: ENOENT: no such <span>file</span> or directory, <span>open</span> <span>'C:\Users\wangy\Desktop\1.text'</span><span>]</span> <span>{</span>
    errno: -4058,
    code: <span>'ENOENT'</span>,
    syscall: <span>'open'</span>,
    path: <span>'C:\\Users\\wangy\\Desktop\\1.text'</span>
  <span>}</span>,
  isOperational: true,
  errno: -4058,
  code: <span>'ENOENT'</span>,
  syscall: <span>'open'</span>,
  path: <span>'C:\\Users\\wangy\\Desktop\\1.text'</span>
<span>}</span>
hello word
PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span>test<span>></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="promise-promisifyall"> <a href="http://bluebirdjs.com/docs/api/promise.promisifyall.html" target="_blank" rel="noopener noreferrer"><code>Promise.promisifyAll</code></a></h3>
<p>获取一个充满函数的对象，并将每个函数转换为带有<code>Async</code>后缀的新函数（默认情况下）。它不会改变原有的功能，而是增加了新的功能。</p>
<div><pre><code><span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>

<span>// 把 fs模块 包装为promise</span>
<span>const</span> bluebird <span>=</span> <span>require</span><span>(</span><span>'bluebird'</span><span>)</span><span>.</span><span>promisifyAll</span><span>(</span>fs<span>)</span><span>;</span>

fs<span>.</span><span>readFileAsync</span><span>(</span><span>'./1.text'</span><span>,</span> <span>'utf-8'</span><span>)</span><span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>res<span>)</span><span>;</span>
<span>}</span><span>)</span>

fs<span>.</span><span>readFileAsync</span><span>(</span><span>'../1.text'</span><span>,</span> <span>'utf-8'</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>err<span>)</span><span>;</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span># 输入结果</span>
PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span>test<span>></span> node .<span>\</span>test.js
<span>[</span>OperationalError: ENOENT: no such <span>file</span> or directory, <span>open</span> <span>'C:\Users\wangy\Desktop\1.text'</span><span>]</span> <span>{</span>
  cause: <span>[</span>Error: ENOENT: no such <span>file</span> or directory, <span>open</span> <span>'C:\Users\wangy\Desktop\1.text'</span><span>]</span> <span>{</span>  
    errno: -4058,
    code: <span>'ENOENT'</span>,
    syscall: <span>'open'</span>,
    path: <span>'C:\\Users\\wangy\\Desktop\\1.text'</span>
  <span>}</span>,
  isOperational: true,
  errno: -4058,
  code: <span>'ENOENT'</span>,
  syscall: <span>'open'</span>,
  path: <span>'C:\\Users\\wangy\\Desktop\\1.text'</span>
<span>}</span>
hello word
PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span>test<span>></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><p>提示</p>
<p>新方法后缀为<code>Async</code>，如<code>fs.readFileAsync</code>。它没有取代<code>fs.readFile</code>功能。</p>
</div>
<div><p>注意</p>
<p><code>Promise.promisify</code>并<code>Promise.promisifyAll</code>为真正快速的包装器使用动态重新编译，因此调用它们应该只进行一次。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>创建应用程序</title>
      <link>https://wangyawei.top/views/backEnd/koa/koa-note-03/</link>
      <guid>https://wangyawei.top/views/backEnd/koa/koa-note-03/</guid>
      <source url="https://wangyawei.top/rss.xml">创建应用程序</source>
      <category>KOA</category>
      <pubDate>Mon, 26 Jul 2021 17:36:23 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="新建目录"> 新建目录</h2>
<blockquote>
<p>新建应用目录，然后进入该目录并将其作为工作目录</p>
</blockquote>
<div><pre><code><span>mkdir</span> koa-example
<span>cd</span> koa-example
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>通过<code>npm</code>创建<code>package.json</code></p>
<div><pre><code><span>npm</span> init -y
</code></pre>
<div><span>1</span><br></div></div><p>安装<code>koa</code>依赖包<code>&quot;koa&quot;: &quot;^2.13.1&quot;,</code></p>
<div><pre><code><span>npm</span> <span>install</span> koa -save
</code></pre>
<div><span>1</span><br></div></div><h2 id="创建应用程序"> 创建应用程序</h2>
<div><pre><code><span>const</span> koa <span>=</span> <span>require</span><span>(</span><span>'koa'</span><span>)</span><span>;</span>
<span>const</span> app <span>=</span> <span>new</span> <span>koa</span><span>(</span><span>)</span>

app<span>.</span><span>use</span><span>(</span><span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span>body <span>=</span> <span>'晚上好'</span><span>;</span>
<span>}</span><span>)</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>,</span> <span>'localhost'</span><span>,</span> <span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'lister on 300'</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>
<p>到此一个简单的http服务就启动了，浏览器访问：http://localhost:3000，会显示 <code>晚上好</code>；</p>
</blockquote>
<div><p>提示</p>
<p>上面的<code>app.listen()</code>只是一个语法糖；它的实质是下面：</p>
<div><pre><code><span>const</span> http <span>=</span> <span>require</span><span>(</span><span>'http'</span><span>)</span><span>;</span>
<span>const</span> Koa <span>=</span> <span>require</span><span>(</span><span>'koa'</span><span>)</span><span>;</span>
<span>const</span> app <span>=</span> <span>new</span> <span>Koa</span><span>(</span><span>)</span><span>;</span>
http<span>.</span><span>createServer</span><span>(</span>app<span>.</span><span>callback</span><span>(</span><span>)</span><span>)</span><span>.</span><span>listen</span><span>(</span><span>3000</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>app.callback()</code>返回适用于 <code>http.createServer()</code> 方法的回调函数来处理请求。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Middleware</title>
      <link>https://wangyawei.top/views/backEnd/koa/koa-note-04/</link>
      <guid>https://wangyawei.top/views/backEnd/koa/koa-note-04/</guid>
      <source url="https://wangyawei.top/rss.xml">Middleware</source>
      <category>KOA</category>
      <pubDate>Sun, 01 Aug 2021 16:38:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Koa是一个中间件框架，中间件可以采用两种不同的功能:</p>
</blockquote>
<ul>
<li>async function</li>
<li>common function</li>
</ul>
<h2 id="async-function"> <code>async function</code></h2>
<blockquote>
<p>koa中间件可以使用<code>async</code>函数，<code>next</code>的调用会返回一个<code>promise</code>函数;</p>
</blockquote>
<div><pre><code><span>const</span> koa <span>=</span> <span>require</span><span>(</span><span>'koa'</span><span>)</span><span>;</span>
<span>const</span> app <span>=</span> <span>new</span> <span>koa</span><span>(</span><span>)</span>

app<span>.</span><span>use</span><span>(</span><span>async</span> <span>(</span><span>ctx<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'111'</span><span>)</span><span>;</span>
    <span>const</span> start <span>=</span> Date<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>

    <span>await</span> <span>next</span><span>(</span><span>)</span><span>;</span>
    <span>const</span> ms <span>=</span> Date<span>.</span><span>now</span><span>(</span><span>)</span> <span>-</span> start<span>;</span>
    console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span>ctx<span>.</span>method<span>}</span></span><span> </span><span><span>${</span>ctx<span>.</span>url<span>}</span></span><span> - </span><span><span>${</span>ms<span>}</span></span><span>ms</span><span>`</span></span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

app<span>.</span><span>use</span><span>(</span><span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'222'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>,</span> <span>'localhost'</span><span>,</span> <span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'lister on 300'</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>浏览器访问：http://localhost:3000/，控制台会输出以下信息：</p>
<div><pre><code>111
222
GET / - 0ms
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>
<p>通过上面打印的结果我们可以得出，第三行的打印是在<code>await next()</code>之后，也就是下一个中间件调用后打印的。</p>
</blockquote>
<h2 id="common-function"> common function</h2>
<blockquote>
<p>中间件通常有两个参数(ctx，next)，ctx是一个请求的上下文，next调用来执行下游中间件的函数。 它返回一个带有then函数的Promise，用于在完成后运行代码。</p>
</blockquote>
<div><pre><code><span>const</span> koa <span>=</span> <span>require</span><span>(</span><span>'koa'</span><span>)</span><span>;</span>
<span>const</span> app <span>=</span> <span>new</span> <span>koa</span><span>(</span><span>)</span>

app<span>.</span><span>use</span><span>(</span><span>(</span><span>ctx<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> start <span>=</span> Date<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>next</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        <span>const</span> ms <span>=</span> Date<span>.</span><span>now</span><span>(</span><span>)</span> <span>-</span> start<span>;</span>
        console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span>ctx<span>.</span>method<span>}</span></span><span> </span><span><span>${</span>ctx<span>.</span>url<span>}</span></span><span> - </span><span><span>${</span>ms<span>}</span></span><span>ms</span><span>`</span></span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

app<span>.</span><span>use</span><span>(</span><span>(</span><span>ctx<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'222'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>,</span> <span>'localhost'</span><span>,</span> <span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'lister on 300'</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>浏览器访问：http://localhost:3000/，控制台会输出以下信息：</p>
<div><pre><code><span>222</span>
GET / - 2ms
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="example"> example</h2>
<blockquote>
<p>使用 async 功能，我们可以实现 “真实” 的中间件。通过一系列功能直接传递控制，Koa 调用“下游”，然后控制流回“上游”。下面以 “Hello World” 的响应作为示例：</p>
</blockquote>
<div><pre><code><span>const</span> Koa <span>=</span> <span>require</span><span>(</span><span>'koa'</span><span>)</span><span>;</span>
<span>const</span> app <span>=</span> <span>new</span> <span>Koa</span><span>(</span><span>)</span><span>;</span>

<span>// logger</span>

app<span>.</span><span>use</span><span>(</span><span>async</span> <span>(</span><span>ctx<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>await</span> <span>next</span><span>(</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span><span>2</span><span>)</span><span>;</span>
    <span>const</span> rt <span>=</span> ctx<span>.</span>response<span>.</span><span>get</span><span>(</span><span>'X-Response-Time'</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span>ctx<span>.</span>method<span>}</span></span><span> </span><span><span>${</span>ctx<span>.</span>url<span>}</span></span><span> - </span><span><span>${</span>rt<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>// x-response-time</span>

app<span>.</span><span>use</span><span>(</span><span>async</span> <span>(</span><span>ctx<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>3</span><span>)</span><span>;</span>
    <span>const</span> start <span>=</span> Date<span>.</span><span>now</span><span>(</span><span>)</span><span>;</span>
    <span>await</span> <span>next</span><span>(</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span><span>4</span><span>)</span><span>;</span>
    <span>const</span> ms <span>=</span> Date<span>.</span><span>now</span><span>(</span><span>)</span> <span>-</span> start<span>;</span>
    ctx<span>.</span><span>set</span><span>(</span><span>'X-Response-Time'</span><span>,</span> <span><span>`</span><span><span>${</span>ms<span>}</span></span><span>ms</span><span>`</span></span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>// response</span>

app<span>.</span><span>use</span><span>(</span><span>async</span> <span>ctx</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>5</span><span>)</span><span>;</span>
    ctx<span>.</span>body <span>=</span> <span>'Hello World'</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>浏览器访问：http://localhost:3000/，控制台会输出以下信息：</p>
<div><pre><code><span>1</span>
<span>3</span>
<span>5</span>
<span>4</span>
<span>2</span>
GET / - 7ms
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>
<p>当请求开始时首先请求流通过 <code>x-response-time</code> 和 <code>logging</code> 中间件，然后继续移交控制给 <code>response</code> 中间件。当一个中间件调用 <code>next()</code>时，则该函数暂停并将控制传递给定义的下一个中间件。当在下游没有更多的中间件执行后，堆栈将展开并且每个中间件恢复执行其上游行为。</p>
</blockquote>
<div><p>提示</p>
<p><code>app.use(function)</code>将给定的中间件方法添加到此应用程序。<code>app.use()</code> 返回 <code>this</code>, 因此可以链式表达:</p>
<div><pre><code>app<span>.</span><span>use</span><span>(</span>someMiddleware<span>)</span>
app<span>.</span><span>use</span><span>(</span>someOtherMiddleware<span>)</span>
app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>)</span>

<span>// 等同于</span>

app<span>.</span><span>use</span><span>(</span>someMiddleware<span>)</span>
  <span>.</span><span>use</span><span>(</span>someOtherMiddleware<span>)</span>
  <span>.</span><span>listen</span><span>(</span><span>3000</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></div>
]]></content:encoded>
    </item>
    <item>
      <title>context</title>
      <link>https://wangyawei.top/views/backEnd/koa/koa-note-05/</link>
      <guid>https://wangyawei.top/views/backEnd/koa/koa-note-05/</guid>
      <source url="https://wangyawei.top/rss.xml">context</source>
      <category>KOA</category>
      <pubDate>Wed, 28 Jul 2021 17:36:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>context在koa应用中又称为”上下文“，该对象包含了koa请求对象、koa响应对象和应用实例，context可以理解一个容器，该容器挂载了本次请求的请求对象和响应对象等信息，中间件通过context对象来获取请求信息，处理之后返回响应。</p>
</blockquote>
<p>*<em>context实例有以下常用的几个属性或方法(<em>号所标记是常用属性或方法)：</em></em></p>
<ul>
<li>
<p>ctx.request：koa的请求对象，一般不直接使用，通过别名引用来访问。</p>
</li>
<li>
<p>ctx.response：koa的响应对象，一般不直接使用，通过别名引用来访问。</p>
</li>
<li>
<p>*ctx.state：自定义数据储存，比如中间需要往请求中挂载变量就可以存放在ctx.state中，后续中间件可以读取。</p>
</li>
<li>
<p>*ctx.throw()：抛出HTTP异常。</p>
</li>
<li>
<p>ctx.headers：请求报头，ctx.request.headers的别名。</p>
</li>
<li>
<p>ctx.method：请求方法，ctx.request.method的别名。</p>
</li>
<li>
<p>ctx.url：请求链接，ctx.request.url的别名。</p>
</li>
<li>
<p>ctx.path：请求路径，ctx.request.path的别名。</p>
</li>
<li>
<p>*ctx.query：解析后的GET参数对象，ctx.request.query的别名。</p>
</li>
<li>
<p>ctx.host：当前域名，ctx.request.host的别名。</p>
</li>
<li>
<p>*ctx.ip：客户端IP，ctx.request.ip的别名。</p>
</li>
<li>
<p>ctx.ips：反向代理环境下的客户端IP列表，ctx.request.ips的别名。</p>
</li>
<li>
<p>ctx.get()：读取请求报头，ctx.request.get的别名。</p>
</li>
<li>
<p>*ctx.body：响应内容，支持字符串、对象、Buffer，ctx.response.body的别名。</p>
</li>
<li>
<p>*ctx.status：响应状态码，ctx.response.status的别名。</p>
</li>
<li>
<p>ctx.type：响应体类型，ctx.response.type的别名。</p>
</li>
<li>
<p>*ctx.redirect()：重定向，ctx.response.redirect的别名。</p>
</li>
<li>
<p>*ctx.set()：设置响应报头，ctx.response.set的别名。</p>
</li>
</ul>
<p>以下是一个显示当前请求信息并添加自定义响应报头的示例：</p>
<div><pre><code><span>const</span> Koa <span>=</span> <span>require</span><span>(</span><span>'koa'</span><span>)</span><span>;</span>
<span>const</span> app <span>=</span> <span>new</span> <span>Koa</span><span>(</span><span>)</span><span>;</span>

app<span>.</span><span>use</span><span>(</span><span>async</span> <span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span><span>set</span><span>(</span><span>'x-version'</span><span>,</span> <span>'1.0.0'</span><span>)</span><span>;</span>
    ctx<span>.</span>body <span>=</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>{</span>
        method<span>:</span> ctx<span>.</span>method<span>,</span>
        path<span>:</span> ctx<span>.</span>path<span>,</span>
        url<span>:</span> ctx<span>.</span>url<span>,</span>
        query<span>:</span> ctx<span>.</span>query<span>,</span>
        Headers<span>:</span> ctx<span>.</span>headers<span>,</span>
        ip<span>:</span> ctx<span>.</span>ip
    <span>}</span><span>,</span> <span>null</span><span>,</span> <span>4</span><span>)</span>
<span>}</span><span>)</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>浏览器访问：http://localhost:3000?a=2&amp;b=3，响应如下：</p>
<div><pre><code><span>{</span>
    <span>"method"</span><span>:</span> <span>"GET"</span><span>,</span>
    <span>"path"</span><span>:</span> <span>"/"</span><span>,</span>
    <span>"url"</span><span>:</span> <span>"/?a=1&amp;b=3"</span><span>,</span>
    <span>"query"</span><span>:</span> <span>{</span>
        <span>"a"</span><span>:</span> <span>"1"</span><span>,</span>
        <span>"b"</span><span>:</span> <span>"3"</span>
    <span>}</span><span>,</span>
    <span>"Headers"</span><span>:</span> <span>{</span>
        <span>"host"</span><span>:</span> <span>"localhost:3000"</span><span>,</span>
        <span>"connection"</span><span>:</span> <span>"keep-alive"</span><span>,</span>
        <span>"cache-control"</span><span>:</span> <span>"max-age=0"</span><span>,</span>
        <span>"sec-ch-ua"</span><span>:</span> <span>"\" Not;A Brand\";v=\"99\", \"Google Chrome\";v=\"91\", \"Chromium\";v=\"91\""</span><span>,</span>
        <span>"sec-ch-ua-mobile"</span><span>:</span> <span>"?0"</span><span>,</span>
        <span>"upgrade-insecure-requests"</span><span>:</span> <span>"1"</span><span>,</span>
        <span>"user-agent"</span><span>:</span> <span>"Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.164 Safari/537.36"</span><span>,</span>
        <span>"accept"</span><span>:</span> <span>"text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9"</span><span>,</span>
        <span>"sec-fetch-site"</span><span>:</span> <span>"none"</span><span>,</span>
        <span>"sec-fetch-mode"</span><span>:</span> <span>"navigate"</span><span>,</span>
        <span>"sec-fetch-user"</span><span>:</span> <span>"?1"</span><span>,</span>
        <span>"sec-fetch-dest"</span><span>:</span> <span>"document"</span><span>,</span>
        <span>"accept-encoding"</span><span>:</span> <span>"gzip, deflate, br"</span><span>,</span>
        <span>"accept-language"</span><span>:</span> <span>"zh-CN,zh;q=0.9"</span>
    <span>}</span><span>,</span>
    <span>"ip"</span><span>:</span> <span>"::1"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>cookie操作</title>
      <link>https://wangyawei.top/views/backEnd/koa/koa-note-06/</link>
      <guid>https://wangyawei.top/views/backEnd/koa/koa-note-06/</guid>
      <source url="https://wangyawei.top/rss.xml">cookie操作</source>
      <category>KOA</category>
      <pubDate>Sun, 01 Aug 2021 17:36:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>cookie是web应用维持少量数据的一种手段，通过cookie，服务端可以标识用户以及用户身份。由于cookie存放在浏览器端，存在篡改风险，因此web应用一般会在存放数据的时候同时存放一个签名cookie，以保证cookie内容不被篡改。</p>
</blockquote>
<p><strong>koa中需要配置cookie签名密钥才能使用cookie功能，否则会报错；</strong></p>
<div><pre><code><span>const</span> Koa <span>=</span> <span>require</span><span>(</span><span>'koa'</span><span>)</span><span>;</span>
<span>const</span> app <span>=</span> <span>new</span> <span>Koa</span><span>(</span><span>)</span><span>;</span>
app<span>.</span>keys <span>=</span> <span>[</span><span>'qwer'</span><span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="写入cookie"> 写入cookie：</h2>
<div><pre><code><span>const</span> Koa <span>=</span> <span>require</span><span>(</span><span>'koa'</span><span>)</span><span>;</span>
<span>const</span> app <span>=</span> <span>new</span> <span>Koa</span><span>(</span><span>)</span><span>;</span>

app<span>.</span>keys <span>=</span> <span>[</span><span>'qwer'</span><span>]</span>

app<span>.</span><span>use</span><span>(</span><span>async</span> <span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span>cookies<span>.</span><span>set</span><span>(</span><span>'logged'</span><span>,</span> <span>2221</span><span>,</span> <span>{</span>
        signed<span>:</span> <span>true</span><span>,</span>
        httpOnly<span>:</span> <span>true</span><span>,</span>
        maxAge<span>:</span> <span>3600</span> <span>*</span> <span>24</span> <span>*</span> <span>1000</span>
    <span>}</span><span>)</span><span>;</span>
    ctx<span>.</span>body <span>=</span> <span>JSON</span><span>.</span><span>stringify</span><span>(</span>ctx<span>,</span> <span>null</span><span>,</span> <span>4</span><span>)</span>
<span>}</span><span>)</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>访问：http://localhost:3000，浏览器查看cookie，结果如下：</p>
<p><img src="./assets/image-20210801172617428.png" alt="image-20210801172617428" /></p>
<blockquote>
<p>可以看到除了我们设置的“logged”之外，多了个“logged.sig”，这就是用来签名的Cookie。服务端读取“logged”时，还会同时读取“logged.sig”，一旦发现签名不匹配，则读取到的cookie值为“undefined”。</p>
</blockquote>
<h2 id="读取cookie"> 读取cookie</h2>
<div><pre><code><span>const</span> Koa <span>=</span> <span>require</span><span>(</span><span>'koa'</span><span>)</span><span>;</span>
<span>const</span> app <span>=</span> <span>new</span> <span>Koa</span><span>(</span><span>)</span><span>;</span>

app<span>.</span>keys <span>=</span> <span>[</span><span>'qwer'</span><span>]</span>

app<span>.</span><span>use</span><span>(</span><span>async</span> <span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> loggged <span>=</span> ctx<span>.</span>cookies<span>.</span><span>get</span><span>(</span><span>'logged'</span><span>,</span> <span>{</span> signed<span>:</span> <span>true</span> <span>}</span><span>)</span>
    ctx<span>.</span>body <span>=</span> loggged
<span>}</span><span>)</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>访问：http://localhost:3000，浏览器显示 2221</p>
<div><p>提示</p>
<p>ctx.cookie.get()建议传递signed选项来验证签名，否则cookie将有篡改风险；</p>
</div>
<h2 id="cookie解析中间件"> cookie解析中间件</h2>
<blockquote>
<p>与上面的中间件不同，本节编写的中间件解析完请求cookie之后，需要将其挂载到ctx.state中，然后在路由中间件使用。</p>
</blockquote>
<div><pre><code><span>const</span> Koa <span>=</span> <span>require</span><span>(</span><span>'koa'</span><span>)</span><span>;</span>
<span>const</span> app <span>=</span> <span>new</span> <span>Koa</span><span>(</span><span>)</span><span>;</span>

app<span>.</span><span>use</span><span>(</span><span>(</span><span>ctx<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> headerCookie <span>=</span> ctx<span>.</span>headers<span>.</span>cookie<span>;</span>
    ctx<span>.</span>state<span>.</span>cookie <span>=</span> <span>{</span><span>}</span><span>;</span>
    <span>if</span> <span>(</span>headerCookie<span>)</span> <span>{</span>
        <span>const</span> cookies <span>=</span> headerCookie<span>.</span><span>split</span><span>(</span><span>';'</span><span>)</span><span>;</span>
        cookies<span>.</span><span>forEach</span><span>(</span><span>(</span><span>cookie</span><span>)</span> <span>=></span> <span>{</span>
            <span>const</span> parts <span>=</span> cookie<span>.</span><span>split</span><span>(</span><span>'='</span><span>)</span><span>;</span>
            ctx<span>.</span>state<span>.</span>cookie<span>[</span>parts<span>[</span><span>0</span><span>]</span><span>]</span> <span>=</span> parts<span>[</span><span>1</span><span>]</span><span>;</span>
        <span>}</span><span>)</span>
    <span>}</span>
    <span>next</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>)</span>

app<span>.</span><span>use</span><span>(</span><span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span>body <span>=</span> ctx<span>.</span>state<span>.</span>cookie<span>;</span>
<span>}</span><span>)</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>访问：http://localhost:3000，浏览器显示:</p>
<div><pre><code><span>{</span><span>"logged"</span><span>:</span><span>"2221"</span>,<span>" logged.sig"</span><span>:</span><span>"wrwaefesrg"</span><span>}</span>
</code></pre>
<div><span>1</span><br></div></div><div><p>提示</p>
<p>建议将中间件中处理完的自定义数据挂载到ctx.state下。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>错误处理</title>
      <link>https://wangyawei.top/views/backEnd/koa/koa-note-07/</link>
      <guid>https://wangyawei.top/views/backEnd/koa/koa-note-07/</guid>
      <source url="https://wangyawei.top/rss.xml">错误处理</source>
      <category>KOA</category>
      <pubDate>Sun, 01 Aug 2021 17:36:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Koa有着简单且优雅的中间件机制，因此编写错误处理中间件变得很简单。和Express错误处理中间件需要放置在应用末尾不同，Koa采用了洋葱圈模型，所以Koa的错误处理中间件需要在应用的开始处挂载，这样才能将整个请求-响应周期涵盖，捕获其发生的错误。</p>
</blockquote>
<h2 id="错误处理"> 错误处理</h2>
<div><pre><code><span>const</span> Koa <span>=</span> <span>require</span><span>(</span><span>'koa'</span><span>)</span><span>;</span>
<span>const</span> app <span>=</span> <span>new</span> <span>Koa</span><span>(</span><span>)</span><span>;</span>

app<span>.</span><span>use</span><span>(</span><span>async</span> <span>(</span><span>ctx<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
    <span>try</span> <span>{</span>
        <span>await</span> <span>next</span><span>(</span><span>)</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span>err<span>)</span> <span>{</span>
        ctx<span>.</span>status <span>=</span> err<span>.</span>status <span>||</span> <span>500</span><span>;</span>
        ctx<span>.</span>body <span>=</span> <span><span>`</span><span>System Error：</span><span><span>${</span>err<span>.</span>message<span>}</span></span><span>`</span></span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span>

app<span>.</span><span>use</span><span>(</span><span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span><span>throw</span><span>(</span><span>403</span><span>,</span> <span>'Forbidden'</span><span>)</span>
<span>}</span><span>)</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>访问：http://localhost:3000 ，浏览器显示：'System Error：Forbidden'。</p>
<p><strong>调换一下位置呢：</strong></p>
<div><pre><code><span>const</span> Koa <span>=</span> <span>require</span><span>(</span><span>'koa'</span><span>)</span><span>;</span>
<span>const</span> app <span>=</span> <span>new</span> <span>Koa</span><span>(</span><span>)</span><span>;</span>

app<span>.</span><span>use</span><span>(</span><span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span><span>throw</span><span>(</span><span>403</span><span>,</span> <span>'Forbidden'</span><span>)</span>
<span>}</span><span>)</span>

app<span>.</span><span>use</span><span>(</span><span>async</span> <span>(</span><span>ctx<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
    <span>try</span> <span>{</span>
        <span>await</span> <span>next</span><span>(</span><span>)</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span>err<span>)</span> <span>{</span>
        ctx<span>.</span>status <span>=</span> err<span>.</span>status <span>||</span> <span>500</span><span>;</span>
        ctx<span>.</span>body <span>=</span> <span><span>`</span><span>System Error：</span><span><span>${</span>err<span>.</span>message<span>}</span></span><span>`</span></span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span>

app<span>.</span><span>use</span><span>(</span><span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span><span>throw</span><span>(</span><span>403</span><span>,</span> <span>'Forbidden'</span><span>)</span>
<span>}</span><span>)</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>访问：http://localhost:3000 ，浏览器显示：'Forbidden'。</p>
<blockquote>
<p>也就是说，错误处理函数放在后面不生效，最终会采用koa自带的错误处理机制；</p>
</blockquote>
<h2 id="多个错误处理"> 多个错误处理</h2>
<blockquote>
<p>在生产环境的应用中，发生错误除了要显示错误信息给客户端之外，还需要上报错误、记录日志等操作，因此为了项目的可维护性，一般需要将错误处理中间件进行拆分，拆分为错误响应中间件、日志记录中间件等，每个中间件只负责一项工作。</p>
</blockquote>
<div><pre><code><span>const</span> Koa <span>=</span> <span>require</span><span>(</span><span>'koa'</span><span>)</span><span>;</span>
<span>const</span> app <span>=</span> <span>new</span> <span>Koa</span><span>(</span><span>)</span><span>;</span>

<span>// 错误处理中间件</span>
app<span>.</span><span>use</span><span>(</span><span>async</span> <span>(</span><span>ctx<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
    <span>try</span> <span>{</span>
        <span>await</span> <span>next</span><span>(</span><span>)</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span>err<span>)</span> <span>{</span>
        ctx<span>.</span>status <span>=</span> err<span>.</span>status <span>||</span> <span>500</span><span>;</span>
        ctx<span>.</span>body <span>=</span> <span><span>`</span><span>System Error：</span><span><span>${</span>err<span>.</span>message<span>}</span></span><span>`</span></span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span>

<span>// 错误日志记录中间件</span>
app<span>.</span><span>use</span><span>(</span><span>async</span> <span>(</span><span>ctx<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
    <span>try</span> <span>{</span>
        <span>await</span> <span>next</span><span>(</span><span>)</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span>err<span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span>ctx<span>.</span>method<span>}</span></span><span> </span><span><span>${</span>ctx<span>.</span>path<span>}</span></span><span> Error: </span><span><span>${</span>err<span>.</span>message<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
        <span>throw</span> err<span>;</span> <span>// 继续抛出错误，这样最外层的中间件才能捕获到该错误；</span>
    <span>}</span>
<span>}</span><span>)</span>

app<span>.</span><span>use</span><span>(</span><span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span><span>throw</span><span>(</span><span>403</span><span>,</span> <span>'Forbidden'</span><span>)</span>
<span>}</span><span>)</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>路由系统</title>
      <link>https://wangyawei.top/views/backEnd/koa/koa-note-08/</link>
      <guid>https://wangyawei.top/views/backEnd/koa/koa-note-08/</guid>
      <source url="https://wangyawei.top/rss.xml">路由系统</source>
      <category>KOA</category>
      <pubDate>Sun, 01 Aug 2021 17:36:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>路由是一个web应用的核心功能，然而，koa为了精简核心未包含路由功能，因此我们需要使用koa-router模块来实现路由功能。</p>
</blockquote>
<h2 id="安装"> 安装</h2>
<div><pre><code><span># "koa-router": "^10.0.0",</span>
<span>npm</span> <span>install</span> koa-router -save
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="使用"> 使用</h2>
<div><pre><code><span>const</span> Koa <span>=</span> <span>require</span><span>(</span><span>'koa'</span><span>)</span><span>;</span>
<span>const</span> Router <span>=</span> <span>require</span><span>(</span><span>'koa-router'</span><span>)</span><span>;</span>
<span>const</span> app <span>=</span> <span>new</span> <span>Koa</span><span>(</span><span>)</span><span>;</span>
<span>const</span> router <span>=</span> <span>new</span> <span>Router</span><span>(</span><span>)</span><span>;</span>

router<span>.</span><span>get</span><span>(</span><span>'/'</span><span>,</span> <span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span>body <span>=</span> <span>'Hello world'</span>
<span>}</span><span>)</span>

router<span>.</span><span>get</span><span>(</span><span>'/user'</span><span>,</span> <span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span>body <span>=</span> <span>'User'</span>
<span>}</span><span>)</span>

app<span>.</span><span>use</span><span>(</span>router<span>.</span><span>routes</span><span>(</span><span>)</span><span>)</span><span>;</span>
app<span>.</span><span>use</span><span>(</span>router<span>.</span><span>allowedMethods</span><span>(</span><span>)</span><span>)</span><span>;</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>访问：http://localhost:3000 ，浏览器显示 Hello world</p>
<h2 id="路由对象"> 路由对象</h2>
<blockquote>
<p>路由需要实例化之后才能进行配置和挂载，路由的构造器函数签名如下：</p>
</blockquote>
<div><pre><code><span>function</span> <span>Router</span><span>(</span><span><span>[</span>options<span>]</span></span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>options选项，一般使用的是prefix。
<ul>
<li>profix：路由前缀。</li>
</ul>
</li>
</ul>
<p>实例化后的路由和express类似，路由定义的方法如下：</p>
<div><pre><code>router<span>[</span>method<span>]</span><span>(</span>path<span>,</span> handler<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>method：Http请求方法，支持get/post/put/delete/head/options；</li>
<li>path：路由路径。</li>
<li>handler：路由处理函数支持多个。</li>
</ul>
<h2 id="路由路径"> 路由路径</h2>
<blockquote>
<p>koa-router的路由路径支持字符串和字符串模式。</p>
</blockquote>
<ol>
<li>
<p>字符串路径：</p>
<div><pre><code>router<span>.</span><span>get</span><span>(</span><span>'/'</span><span>,</span> <span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span>body <span>=</span> <span>'Home'</span><span>;</span>
<span>}</span><span>)</span>

router<span>.</span><span>get</span><span>(</span><span>'/about'</span><span>,</span> <span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span>body <span>=</span> <span>'关于'</span><span>;</span>
<span>}</span><span>)</span>

<span>// 匹配文件</span>
router<span>.</span><span>get</span><span>(</span><span>'/random.text'</span><span>,</span> <span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span>body <span>=</span> <span>'random.text'</span><span>;</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
<li>
<p>字符串模式:</p>
<div><pre><code><span>// 匹配到 /users/xxx</span>
router<span>.</span><span>get</span><span>(</span><span>'/users/:userId'</span><span>,</span> <span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span>body <span>=</span> <span>{</span>
        userId<span>:</span> ctx<span>.</span>params<span>.</span>userId<span>;</span>
    <span>}</span><span>;</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
</ol>
<h2 id="路由函数"> 路由函数</h2>
<blockquote>
<p>koa-router的路由函数和Koa默认的路由函数是相似的，也支持多个路由函数处理同一个请求。但是ctx.params只有koa-router的路由函数才可以访问。</p>
</blockquote>
<div><pre><code>router<span>.</span><span>get</span><span>(</span><span>'/'</span><span>,</span> <span>async</span> <span>(</span><span>ctx<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span>state<span>.</span>data <span>=</span> <span>{</span> logged<span>:</span> <span>true</span> <span>}</span><span>;</span>
    <span>await</span> <span>next</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>,</span> <span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span>body <span>=</span> ctx<span>.</span>state<span>.</span>data<span>;</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="路由中间件"> 路由中间件</h2>
<blockquote>
<p>koa-router也支持多个路由函数，因此可以在指定路由或者整个路由对象上使用中间件。</p>
</blockquote>
<div><pre><code><span>const</span> Koa <span>=</span> <span>require</span><span>(</span><span>'koa'</span><span>)</span><span>;</span>
<span>const</span> Router <span>=</span> <span>require</span><span>(</span><span>'koa-router'</span><span>)</span><span>;</span>
<span>const</span> app <span>=</span> <span>new</span> <span>Koa</span><span>(</span><span>)</span><span>;</span>
<span>const</span> router <span>=</span> <span>new</span> <span>Router</span><span>(</span><span>)</span><span>;</span>

router<span>.</span><span>use</span><span>(</span><span>async</span> <span>(</span><span>ctx<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span>ctx<span>.</span>method<span>}</span></span><span> </span><span><span>${</span>ctx<span>.</span>path<span>}</span></span><span> </span><span><span>${</span>ctx<span>.</span>headers<span>[</span><span>'user-agent'</span><span>]</span><span>}</span></span><span>`</span></span><span>)</span><span>;</span>
    <span>await</span> <span>next</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>)</span>

router<span>.</span><span>get</span><span>(</span><span>'/'</span><span>,</span> <span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span>body <span>=</span> <span>'Hello world'</span>
<span>}</span><span>)</span>

app<span>.</span><span>use</span><span>(</span>router<span>.</span><span>routes</span><span>(</span><span>)</span><span>)</span><span>;</span>
app<span>.</span><span>use</span><span>(</span>router<span>.</span><span>allowedMethods</span><span>(</span><span>)</span><span>)</span><span>;</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="路由前缀"> 路由前缀</h2>
<blockquote>
<p>路由前缀可以将同一个路由模块的路由聚合在一起，提供一个统一的URL前缀共客户端访问；</p>
</blockquote>
<div><pre><code><span>const</span> Koa <span>=</span> <span>require</span><span>(</span><span>'koa'</span><span>)</span><span>;</span>
<span>const</span> Router <span>=</span> <span>require</span><span>(</span><span>'koa-router'</span><span>)</span><span>;</span>
<span>const</span> app <span>=</span> <span>new</span> <span>Koa</span><span>(</span><span>)</span><span>;</span>
<span>const</span> router <span>=</span> <span>new</span> <span>Router</span><span>(</span><span>{</span> prefix<span>:</span> <span>'/user'</span> <span>}</span><span>)</span><span>;</span>

router<span>.</span><span>get</span><span>(</span><span>'/'</span><span>,</span> <span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span>body <span>=</span> <span>'Hello world'</span>
<span>}</span><span>)</span>

router<span>.</span><span>get</span><span>(</span><span>'/list'</span><span>,</span> <span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span>body <span>=</span> <span>'/user/list'</span>
<span>}</span><span>)</span>

app<span>.</span><span>use</span><span>(</span>router<span>.</span><span>routes</span><span>(</span><span>)</span><span>)</span><span>;</span>
app<span>.</span><span>use</span><span>(</span>router<span>.</span><span>allowedMethods</span><span>(</span><span>)</span><span>)</span><span>;</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><blockquote>
<p>浏览器访问：http://localhost:3000/user和http://localhost:3000/user/list</p>
</blockquote>
<h2 id="路由模块化"> 路由模块化</h2>
<blockquote>
<p>为了保持项目的可维护性，建议将路由逻辑拆分到其他模块中，否则不利于代码维护；</p>
</blockquote>
<ul>
<li>独立文件中实现路由逻辑；</li>
<li>入口文件中挂载路由；</li>
</ul>
<div><pre><code><span>// router/site.js</span>
<span>const</span> Router <span>=</span> <span>require</span><span>(</span><span>'koa-router'</span><span>)</span><span>;</span>
<span>const</span> router <span>=</span> <span>new</span> <span>Router</span><span>(</span><span>)</span><span>;</span>

router<span>.</span><span>get</span><span>(</span><span>'/'</span><span>,</span> <span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span>body <span>=</span> <span>'首页'</span><span>;</span>
<span>}</span><span>)</span>

router<span>.</span><span>get</span><span>(</span><span>'/about'</span><span>,</span> <span>(</span><span>ctx</span><span>)</span> <span>=></span> <span>{</span>
    ctx<span>.</span>body <span>=</span> <span>'关于页'</span><span>;</span>
<span>}</span><span>)</span>

module<span>.</span>exports <span>=</span> router<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>// app.js</span>
<span>const</span> Koa <span>=</span> <span>require</span><span>(</span><span>'koa'</span><span>)</span><span>;</span>
<span>const</span> Router <span>=</span> <span>require</span><span>(</span><span>'koa-router'</span><span>)</span><span>;</span>
<span>const</span> app <span>=</span> <span>new</span> <span>Koa</span><span>(</span><span>)</span><span>;</span>
<span>const</span> router <span>=</span> <span>new</span> <span>Router</span><span>(</span><span>)</span><span>;</span>
<span>const</span> siteRouter <span>=</span> <span>require</span><span>(</span><span>'./router/site.js'</span><span>)</span>

app<span>.</span><span>use</span><span>(</span>siteRouter<span>.</span><span>routes</span><span>(</span><span>)</span><span>)</span><span>.</span><span>use</span><span>(</span>siteRouter<span>.</span><span>allowedMethods</span><span>(</span><span>)</span><span>)</span><span>;</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><a href="https://github.com/koajs/router/blob/master/API.md" target="_blank" rel="noopener noreferrer">官方文档</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/backEnd/linux/</link>
      <guid>https://wangyawei.top/views/backEnd/linux/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>LINUX</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些自己平时积累的<strong>linux</strong>相关的知识；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>基础命令</title>
      <link>https://wangyawei.top/views/backEnd/linux/linux-base-00/</link>
      <guid>https://wangyawei.top/views/backEnd/linux/linux-base-00/</guid>
      <source url="https://wangyawei.top/rss.xml">基础命令</source>
      <category>LINUX</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<div><pre><code><span># 查看磁盘空间</span>

<span># 查看应用进程</span>
<span>ps</span> -ef <span>|</span> <span>grep</span> node

<span># 查看端口占用情况</span>
<span>netstat</span> -tunlp<span>|</span><span>grep</span> <span>8090</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>查看linux防火墙</title>
      <link>https://wangyawei.top/views/backEnd/linux/linux-note-01/</link>
      <guid>https://wangyawei.top/views/backEnd/linux/linux-note-01/</guid>
      <source url="https://wangyawei.top/rss.xml">查看linux防火墙</source>
      <category>LINUX</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="查看防火墙状态"> 查看防火墙状态</h2>
<div><pre><code><span>#查看防火墙状态</span>
systemctl status firewalld
<span>#开启防火墙</span>
systemctl start firewalld
<span>#关闭防火墙</span>
systemctl stop firewalld
<span>#设置开机启动</span>
systemctl <span>enable</span> firewalld
<span>#停止并禁用开机启动</span>
sytemctl disable firewalld
<span>#若遇到无法开启</span>
systemctl unmask firewalld.service 
systemctl start firewalld.service
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="查看对外开放的端口状态"> 查看对外开放的端口状态</h2>
<div><pre><code><span>#用于检测端口与网络连接情况</span>
<span>netstat</span> -anpl <span>|</span> <span>grep</span> 端口号
<span># 查询指定端口是否已开</span>
firewall-cmd --query-port<span>=</span><span>9501</span>/tcp
<span>#查看端口列表</span>
firewall-cmd --permanent --list-port

netstat命令各个参数说明如下：
-t <span>:</span> 指明显示TCP端口
-u <span>:</span> 指明显示UDP端口
-l <span>:</span> 仅显示监听套接字<span>(</span>所谓套接字就是使应用程序能够读bai写与收发通讯协议<span>(</span>protocol<span>)</span>与资料的程序<span>)</span>
-p <span>:</span> 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序。
-n <span>:</span> 不进行DNS轮询，显示IP<span>(</span>可以加速操作<span>)</span>
即可显示当前服务器上所有端口及进程服务，于grep结合可查看某个具体端口及服务情况··
<span>netstat</span> -ntlp //查看当前所有tcp端口·
<span>netstat</span> -ntulp <span>|</span><span>grep</span> <span>80</span> //查看所有80端口使用情况·
<span>netstat</span> -an <span>|</span> <span>grep</span> <span>3306</span> //查看所有3306端口使用情况·
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="对外开发端口"> 对外开发端口</h2>
<div><pre><code><span># 单独开放 8080端口</span>
firewall-cmd --permanent --zone<span>=</span>public --add-port<span>=</span><span>8080</span>/tcp
<span># 重新加载防火墙</span>
firewall-cmd --reload
<span># 查看8080端口</span>
firewall-cmd --zone<span>=</span>public --query-port<span>=</span><span>8080</span>/tcp
<span># 删除端口</span>
firewall-cmd --permanent --zone<span>=</span>public --remove-port<span>=</span><span>8080</span>/tcp 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>linux软连接的作用</title>
      <link>https://wangyawei.top/views/backEnd/linux/linux-note-02/</link>
      <guid>https://wangyawei.top/views/backEnd/linux/linux-note-02/</guid>
      <source url="https://wangyawei.top/rss.xml">linux软连接的作用</source>
      <category>LINUX</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="linux软连接的作用"> linux软连接的作用</h2>
<blockquote>
<p>介绍：</p>
<ul>
<li>Linux软链接，类似于windows系统的快捷键。譬如你将windows系统的D盘中某一个文件夹放在桌面上当做快捷键。</li>
<li>平时在Linux机子上安装好一些工具之后我们就需要跑到那个源码安装的程序包里面执行启动命令，这样做比较麻烦，有没有直接在全局都通用的方法呢？也就是启动那些应用或者程序就像使用Linux自带的命令一样简单轻松而不必每次都跑到指定的源码目录中去执行。</li>
<li>在安装目录中找到你需要的启动指令，并将其通过软连接的方式链接到<code>/usr/local/bin</code>目录下。</li>
</ul>
</blockquote>
<h3 id="_1、软连接的创建"> 1、软连接的创建；</h3>
<ul>
<li>
<p>命令；<code>ln -s [源文件目录] [软连接名称]</code></p>
<div><pre><code><span># 表示把 /home/local/application/node-v12.18.2-linux-x64/bin/目录下的npm创建为软连接，名字为 npm</span>
<span>ln</span> -s /home/local/application/node-v12.18.2-linux-x64/bin/npm <span>npm</span>

<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># npm -v</span>
-bash: npm: <span>command</span> not found  <span># 不能再全局使用</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># cd usr/local/bin/</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ bin<span>]</span><span># ls</span>
node  pm2
<span>[</span>root@iZbp156pkpio44mis76wmxZ bin<span>]</span><span># ln -s /home/local/application/node-v12.18.2-linux-x64/bin/npm npm</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ bin<span>]</span><span># ls</span>
node  <span>npm</span>  pm2
<span>[</span>root@iZbp156pkpio44mis76wmxZ bin<span>]</span><span># npm -v</span>
<span>6.14</span>.5
<span>[</span>root@iZbp156pkpio44mis76wmxZ bin<span>]</span><span># cd /</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># npm -v</span>
<span>6.14</span>.5 <span># 可以再全局使用了</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># ^C</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># </span>
 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div></li>
</ul>
<h3 id="_2、软连接的删除"> 2、软连接的删除；</h3>
<ul>
<li>
<p>命令：</p>
<div><pre><code><span>rm</span> -rf 【软链接地址】
<span># 如果是rm -rf test/ 那么原目录下的文件都会被删除！！！ </span>
<span>rm</span> -rf <span>test</span> <span>#切记不要自动补全</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>
<p>注意： <strong>软链接地址</strong>最后不能含有“/”，当含有“/”时，删除的是软链接目标目录下的资源，而不是软链接本身。</p>
</blockquote>
</li>
</ul>
<h3 id="_3、软连接的修改"> 3、软连接的修改；</h3>
<ul>
<li>
<p>命令：</p>
<div><pre><code><span>ln</span> -snf 【新目标目录】 【软链接地址】
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>这里修改是指修改软链接的目标目录</p>
</blockquote>
</li>
</ul>
<h3 id="_4、扩展说明"> 4、扩展说明；</h3>
<ol>
<li>
<p>linux下/bin和/usr/bin和/usr/local/bin的区别 <a href="https://blog.csdn.net/baidu_31788709/article/details/90679657" target="_blank" rel="noopener noreferrer">阅读原文</a></p>
<div><pre><code>/bin 是所有用户都可以访问并执行的可执行程序。包括超级用户及一般用户。
/usr/bin 是系统安装时自带的一些可执行程序。即系统程序，轻易不要去动里面的东西，容易入坑。
/usr/local/bin 是用户自行编译安装时默认的可执行程序的安装位置，这个不小心误删点什么，不会影响大局。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>service与systemctl命令区别</title>
      <link>https://wangyawei.top/views/backEnd/linux/linux-note-03/</link>
      <guid>https://wangyawei.top/views/backEnd/linux/linux-note-03/</guid>
      <source url="https://wangyawei.top/rss.xml">service与systemctl命令区别</source>
      <category>LINUX</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="service与systemctl命令区别"> service与systemctl命令区别</h2>
<blockquote>
<p>从CentOS 7.x开始，CentOS开始使用systemd服务来代替daemon，原来管理系统启动和管理系统服务的相关命令全部由systemctl命令来代替。</p>
</blockquote>
<h3 id="_1、service命令"> 1、service命令；</h3>
<blockquote>
<p>service命令是Redhat Linux兼容的发行版中用来控制系统服务的实用工具，它以启动、停止、重新启动和关闭系统服务，还可以显示所有系统服务的当前状态。</p>
</blockquote>
<ol>
<li>语法：</li>
</ol>
<div><pre><code><span># command:  [start | stop |restart |reload |stauts]</span>
<span>service</span> <span>&lt;</span> option <span>></span> <span>|</span> --status-all <span>|</span> <span>[</span> service_name <span>[</span> <span>command</span> <span>|</span> --full-restart <span>]</span> <span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="2">
<li>
<p>示例：</p>
<div><pre><code><span># 查看帮助信息；</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># service -h</span>
Usage: <span>service</span> <span>&lt;</span> option <span>></span> <span>|</span> --status-all <span>|</span> <span>[</span> service_name <span>[</span> <span>command</span> <span>|</span> --full-restart <span>]</span> <span>]</span>
<span># 查看nginx服务状态</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># service nginx status</span>
Redirecting to /bin/systemctl status nginx.service
● nginx.service - nginx - high performance web server
   Loaded: loaded <span>(</span>/usr/lib/systemd/system/nginx.service<span>;</span> disabled<span>;</span> vendor preset: disabled<span>)</span>
   Active: active <span>(</span>running<span>)</span> since Tue <span>2021</span>-04-20 <span>21</span>:49:30 CST<span>;</span> <span>1</span> day 1h ago
     Docs: http://nginx.org/en/docs/
  Process: <span>17599</span> <span>ExecStart</span><span>=</span>/usr/sbin/nginx -c /etc/nginx/nginx.conf <span>(</span>code<span>=</span>exited, <span>status</span><span>=</span><span>0</span>/SUCCESS<span>)</span>
 Main PID: <span>17600</span> <span>(</span>nginx<span>)</span>
   CGroup: /system.slice/nginx.service
           ├─17600 nginx: master process /usr/sbin/nginx -c /etc/nginx/nginx.conf
           └─17602 nginx: worker process

Apr <span>20</span> <span>21</span>:49:30 iZbp156pkpio44mis76wmxZ systemd<span>[</span><span>1</span><span>]</span>: Starting nginx - high performance web server<span>..</span>.
Apr <span>20</span> <span>21</span>:49:30 iZbp156pkpio44mis76wmxZ systemd<span>[</span><span>1</span><span>]</span>: Can't <span>open</span> PID <span>file</span> /var/run/nginx.pid <span>(</span>yet?<span>)</span> after start: No such <span>file</span> or directory
Apr <span>20</span> <span>21</span>:49:30 iZbp156pkpio44mis76wmxZ systemd<span>[</span><span>1</span><span>]</span>: Started nginx - high performance web server.
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span>#</span>

<span># 使用 service 启动/重启/停止网络服务</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># service network restart</span>
Restarting network <span>(</span>via systemctl<span>)</span>:                        <span>[</span>  OK  <span>]</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># service network start</span>
Starting network <span>(</span>via systemctl<span>)</span>:                          <span>[</span>  OK  <span>]</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># service network stop</span>
Stopping network <span>(</span>via systemctl<span>)</span>:  Connection reset by <span>47.114</span>.139.71 port <span>22</span>

C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><blockquote>
<p>service network stop 后，网络服务停止，网卡关闭，ssh登录不上。</p>
<p>两种方式解决:</p>
<ul>
<li>重启服务器，</li>
<li>操作台进入系统，执行service network start开启网络服务。</li>
</ul>
</blockquote>
</li>
<li>
<p>原理：service命令其实是去<code>/etc/init.d</code>目录下，去执行相关程；</p>
<blockquote>
<p><strong>注</strong>：在contos7.x中已经用<code>systemctl</code>来代替<code>service</code>,所以不建议使用<code>service</code></p>
</blockquote>
</li>
</ol>
<h3 id="_2、systemctl-命令"> 2、systemctl 命令</h3>
<blockquote>
<p>历史上，Linux 的启动一直采用init进程。systemd是Linux系统最新的初始化系统(init),作用是提高系统的启动速度，尽可能启动较少的进程，尽可能更多进程并发启动。</p>
</blockquote>
<div><pre><code>
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>这种方法有两个缺点：</p>
<ul>
<li>一是启动时间长。init 进程是串行启动，只有前一个进程启动完，才会启动下一个进程。</li>
<li>二是启动脚本复杂。init 进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长</li>
</ul>
<p>Systemd 就是为了解决上面问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。根据 Linux 惯例，字母 d 是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。使用了 Systemd，就不需要再用 init 了。Systemd 取代了 initd，成为系统的第一个进程（PID 等于 1），其他进程都是它的子进程。</p>
</blockquote>
<h4 id="_1、兼容service命令"> 1、兼容service命令</h4>
<blockquote>
<p>systemctl命令兼容了service,即systemctl也会去/etc/init.d目录下，查看，执行相关程序</p>
</blockquote>
<div><pre><code>systemctl redis start
systemctl redis stop
# 开机自启动
systemctl enable redis
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="_2、日常用法"> 2、日常用法：</h4>
<div><pre><code>systemctl  [start | stop |restart |reload |stauts] 服务名
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>nodejs的安装</title>
      <link>https://wangyawei.top/views/backEnd/linux/linux-note-04/</link>
      <guid>https://wangyawei.top/views/backEnd/linux/linux-note-04/</guid>
      <source url="https://wangyawei.top/rss.xml">nodejs的安装</source>
      <category>LINUX</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1、下载安装包"> 1、下载安装包；</h2>
<ul>
<li>
<p>系统环境；</p>
<div><pre><code>命令：uname -a
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594554925522.png" alt="1594554925522" /></p>
</li>
<li>
<p><a href="https://nodejs.org/dist/v12.18.2/node-v12.18.2-linux-x64.tar.xz" target="_blank" rel="noopener noreferrer">安装包</a></p>
<p><img src="./assets/1594553541430.png" alt="1594553541430" /></p>
</li>
<li>
<p>下载；</p>
<div><pre><code>命令：wget https://nodejs.org/dist/v12.18.2/node-v12.18.2-linux-x64.tar.xz
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594553652045.png" alt="1594553652045" /></p>
</li>
</ul>
<h2 id="_2、解压"> 2、解压；</h2>
<div><pre><code>命令：tar xf node-v12.18.2-linux-x64.tar.xz 
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594554214470.png" alt="1594554214470" /></p>
<h2 id="_3、添加环境变量"> 3、添加环境变量；</h2>
<div><pre><code>命令：vim /etc/profile
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594554576590.png" alt="1594554576590" /></p>
<ul>
<li>
<p>立即生效；</p>
<div><pre><code>命令：source /etc/profile
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594554683853.png" alt="1594554683853" /></p>
</li>
<li>
<p>安装成功！</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>linux与环境变量</title>
      <link>https://wangyawei.top/views/backEnd/linux/linux-note-05/</link>
      <guid>https://wangyawei.top/views/backEnd/linux/linux-note-05/</guid>
      <source url="https://wangyawei.top/rss.xml">linux与环境变量</source>
      <category>LINUX</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>环境变量：简要的说，就是指定一个目录，运行软件的时候，相关的程序将会按照该目录寻找相关文件。设置变量对于一般人最实用的功能就是：不用拷贝某些dll文件到系统目录中了，而path这一系统变量就是系统搜索dll文件的一系列路径。</p>
<p>在linux系统下，如果你下载并安装了应用程序，很有可能在键入它的名称时出现“command not found”的提示内容。如果每次都到安装目标文件夹内，找到可执行文件来进行操作就太繁琐了。这涉及到环境变量 PATH 的设置问题，而 PATH的设置也是在linux下定制环境变量的一个组成部分。linux 查看环境变量与设置环境变量在使用过程中很常见，本文整理了一些常用的与环境变量相关的命令。</p>
</blockquote>
<h2 id="变量种类"> 变量种类</h2>
<ol>
<li>按变量的生存周期来划分，Linux变量可分为两类：
<ul>
<li>永久的：需要修改配置文件，变量永久生效。</li>
<li>临时的：使用export命令声明即可，变量在关闭shell时失效。</li>
</ul>
</li>
</ol>
<h2 id="配置方法一-export"> 配置方法一：<code>export</code></h2>
<blockquote>
<p>Linux export 命令用于设置或显示环境变量。在 shell 中执行程序时，shell 会提供一组环境变量。export 可新增，修改或删除环境变量，供后续执行的程序使用。export 的效力仅限于该次登陆操作。</p>
</blockquote>
<ol>
<li>
<p>语法： <code>export [-fnp][变量名称]=[变量设置值]</code>，</p>
</li>
<li>
<p>参数说明：</p>
<ul>
<li>-f 　代表[变量名称]中为函数名称。</li>
<li>-n 　删除指定的变量。变量实际上并未删除，只是不会输出到后续指令的执行环境中。</li>
<li>-p 　列出所有的shell赋予程序的环境变量。</li>
</ul>
</li>
<li>
<p>示例：</p>
<ul>
<li>
<p>设置环境变量；</p>
<div><pre><code><span># 设置环境变量</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># export HELLO="hello"</span>
<span># export or export -p 两种方式</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># export</span>
<span>..</span><span>..</span>
<span>declare</span> -x <span>HELLO</span><span>=</span><span>"hello"</span> <span># 设置成功</span>
<span>declare</span> -x <span><span>HISTCONTROL</span></span><span>=</span><span>"ignoredups"</span>
<span>..</span><span>..</span>

<span># or</span>

<span># 设置环境变量</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># export PATH=$PATH:wangyawei/local</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># export</span>
<span>..</span><span>..</span>
<span>declare</span> -x <span><span>OLDPWD</span></span><span>=</span><span>"/etc/init.d"</span>
<span>declare</span> -x <span><span>PATH</span></span><span>=</span><span>"/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/home/local/JDK/jdk1.8.0_251/bin:/home/local/mynode/node-v12.18.2-linux-x64/bin:/home/local/maven/apache-maven-3.6.3/bin:/root/bin:wangyawei/local"</span> <span># 设置成功</span>
<span>..</span><span>..</span><span>..</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div></li>
<li>
<p>修改环境变量；</p>
<div><pre><code><span># 查看 JAVA_HOME 环境变量及修改</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># export -p | grep JAVA_HOME</span>
<span>declare</span> -x <span>JAVA_HOME</span><span>=</span><span>"/home/local/JDK/jdk1.8.0_251"</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># export JAVA_HOME="/home/local/application/jdk1.8.0_251"</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># export -p | grep JAVA_HOME</span>
<span>declare</span> -x <span>JAVA_HOME</span><span>=</span><span>"/home/local/application/jdk1.8.0_251"</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>删除环境变量；</p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># export -n HELLO</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># export -p</span>
<span>..</span><span>..</span><span>..</span>
<span>declare</span> -x <span>CLASSPATH</span><span>=</span><span>".:/home/local/JDK/jdk1.8.0_251/lib"</span>
- <span>declare</span> -x <span>HELLO</span><span>=</span><span>"hello"</span>  <span># 已删除</span>
<span>declare</span> -x <span><span>HISTCONTROL</span></span><span>=</span><span>"ignoredups"</span>
<span>..</span><span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><p>注意</p>
<p>变量实际上并未删除，只是不会输出到后续指令的执行环境中。</p>
</div>
</li>
<li>
<p>导出一个函数；</p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># test () { echo "Test Function"; }</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># export -f test</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># test</span>
Test Function
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>查看某一个环境变量；</p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># export -p | grep TERM</span>
<span>declare</span> -x <span><span>TERM</span></span><span>=</span><span>"cygwin"</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ul>
<div><p>注意</p>
<p>该变量只在当前的shell(BASH)或其子shell(BASH)下是有效的，shell关闭了，变量也就失效了，再打开新shell时就没有这个变	量，需要使用的话还需要重新定义。</p>
</div>
</li>
</ol>
<h2 id="配置方法一-profile"> 配置方法一：<code>profile</code></h2>
<blockquote>
<p>在 <code>/etc/profile</code>文件中添加变量【对所有用户生效(永久的)】</p>
</blockquote>
<ol>
<li>
<p>打开profile文件；</p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ customer<span>]</span><span># vim /etc/profile</span>

<span># /etc/profile</span>

<span># System wide environment and startup programs, for login setup</span>
<span># Functions and aliases go in /etc/bashrc</span>

<span># It's NOT a good idea to change this file unless you know what you</span>
<span># are doing. It's much better to create a custom.sh shell script in</span>
<span># /etc/profile.d/ to make custom changes to your environment, as this</span>
<span># will prevent the need for merging in future updates.</span>
<span>..</span><span>..</span><span>..</span>
<span>export</span> <span>JAVA_HOME</span><span>=</span>/home/local/JDK/jdk1.8.0_251
<span>export</span> <span><span>PATH</span></span><span>=</span><span>$PATH</span><span>:</span><span>$JAVA_HOME</span>/bin
<span>export</span> <span>CLASSPATH</span><span>=</span>.:<span>$JAVA_HOME</span>/lib
<span>export</span> <span>CATALINA_HOME</span><span>=</span>/home/local/tomcat
<span>export</span> JAVA_HOME <span>PATH</span> CLASSPATH CATALINA_HOME
<span>..</span><span>..</span><span>..</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div></li>
<li>
<p>添加或修改</p>
<div><pre><code><span># 修改 JAVA_HOME （根据自己的jdk安装位置设置）</span>
<span>export</span> <span>JAVA_HOME</span><span>=</span>/home/local/application/jdk1.8.0_251
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><p>注意</p>
<p>生效时间：新开终端或者手动执行<code>source /etc/profile</code>生效;</p>
</div>
</li>
</ol>
<h2 id="配置方法三-bash-profile"> 配置方法三：<code>.bash_profile</code></h2>
<blockquote>
<p>在用户目录下的.bash_profile文件中增加变量【对单一用户生效(永久的)】,用<code>vim</code>在用户目录下的.bash_profile文件中增加变量，改变量仅会对当前用户有效，并且是“永久的”。 这种方法更为安全，它可以把使用这些环境变量的权限控制到用户级别,这里是针对某一个特定的用户，如果你需要给某个用户权限使用这些环境变量，你只需要修改其个人用户主目录下的.bash_profile文件就可以了。通常.bash_profile和.bashrc认为效果一样，也就是此处在 .bashrc中增加环境变量也行。</p>
</blockquote>
<ol>
<li>
<p>添加环境变量；</p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ customer<span>]</span><span># vim ~/.bash_profile</span>
<span>JAVA_HOME</span><span>=</span>/home/local/application/jdk1.8.0_251
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><p>注意</p>
<p>使用相同的用户打开新的终端时生效，或者手动source ~/.bash_profile生效</p>
</div>
</li>
</ol>
<h2 id="环境变量加载顺序"> 环境变量加载顺序</h2>
<blockquote>
<p>Linux加载环境变量的顺序如下：</p>
<ol>
<li>/etc/environment</li>
<li>/etc/profile</li>
<li>/etc/bashrc 或者 /etc/bash.bashrc</li>
<li>/etc/profile.d/test.sh</li>
<li>~/.profile 或者 ~/.bash_profile</li>
<li>~/.bashrc</li>
</ol>
<p>/etc/profile，/etc/bashrc 是系统全局环境变量设定
~/.profile，~/.bashrc 用户家目录下的私有环境变量设定</p>
<p>当登入系统时候获得一个shell进程时，其读取环境设定档有三步 ：
1、首先读入的是全局环境变量设定档/etc/profile，然后根据其内容读取额外的设定的文档，如 /etc/profile.d和/etc/inputrc 。
2、然后根据不同使用者帐号，去其根目录读取~/.bash_profile，如果这读取不了就读取~/.bash_login，这个也读取不了才会读取 ~/.profile，这三个文档设定基本上是一样的，读取有优先关系 。其中，Unbutu默认没有~/.bash_profile文件，可新建。
3、最后在根据用户帐号读取~/.bashrc 。</p>
</blockquote>
<h2 id="查看环境变量"> 查看环境变量</h2>
<ol>
<li>显示已知的环境变量</li>
</ol>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># echo $JAVA_HOME</span>
/home/local/application/jdk1.8.0_251
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="2">
<li>
<p>显示所有的环境变量</p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># env</span>
<span>..</span><span>..</span><span>..</span>
<span>JAVA_HOME</span><span>=</span>/home/local/application/jdk1.8.0_251
<span><span>LANG</span></span><span>=</span>en_US.UTF-8
<span>..</span><span>..</span><span>..</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># </span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>显示所有本地定义的Shell变量</p>
</li>
</ol>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># set</span>
</code></pre>
<div><span>1</span><br></div></div><ol start="4">
<li>
<p>列出所有的shell赋予程序的环境变量。</p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># export -p</span>
<span>..</span><span>..</span><span>..</span>
<span>declare</span> -x <span>CLASSPATH</span><span>=</span><span>".:/home/local/JDK/jdk1.8.0_251/lib"</span>
<span>declare</span> -x <span><span>HISTCONTROL</span></span><span>=</span><span>"ignoredups"</span>
<span>..</span><span>..</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>查看当前用户是什么;</p>
</li>
</ol>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># whoami</span>
root
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="参考博文"> 参考博文：</h2>
<p>原文链接：https://blog.csdn.net/ljheee/article/details/53350116</p>
<p>原文链接：https://www.cnblogs.com/qiuhong10/p/7815943.html</p>
<p>原文链接：https://www.linuxprobe.com/environment-variable-configuration.html</p>
]]></content:encoded>
    </item>
    <item>
      <title>Linux 查看磁盘空间</title>
      <link>https://wangyawei.top/views/backEnd/linux/linux-note-07/</link>
      <guid>https://wangyawei.top/views/backEnd/linux/linux-note-07/</guid>
      <source url="https://wangyawei.top/rss.xml">Linux 查看磁盘空间</source>
      <category>LINUX</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Linux 查看磁盘空间可以使用 <strong>df</strong> 和 <strong>du</strong> 命令。</p>
</blockquote>
<h2 id="df"> <code>df</code></h2>
<blockquote>
<p>df 以磁盘分区为单位查看文件系统，可以获取硬盘被占用了多少空间，目前还剩下多少空间等信息。例如，我们使用<strong>df -h</strong>命令来查看磁盘信息， <strong>-h</strong> 选项为根据大小适当显示：</p>
</blockquote>
<div><pre><code>wangyawei@yaweidediannao:/$ <span>df</span> -h
Filesystem      Size  Used Avail Use% Mounted on
/dev/sdd        251G  <span>1</span>.2G  238G   <span>1</span>% /
tmpfs           <span>4</span>.7G  401M  <span>4</span>.3G   <span>9</span>% /mnt/wsl
/dev/sdc        251G  868M  238G   <span>1</span>% /mnt/wsl/docker-desktop-data/isocache
none            <span>4</span>.7G   12K  <span>4</span>.7G   <span>1</span>% /mnt/wsl/docker-desktop/shared-sockets/host-services
/dev/sdb        251G  130M  239G   <span>1</span>% /mnt/wsl/docker-desktop/docker-desktop-proxy
/dev/loop0      430M  430M     <span>0</span> <span>100</span>% /mnt/wsl/docker-desktop/cli-tools
tools           238G  153G   86G  <span>65</span>% /init
none            <span>4</span>.7G     <span>0</span>  <span>4</span>.7G   <span>0</span>% /dev
none            <span>4</span>.7G   16K  <span>4</span>.7G   <span>1</span>% /run
none            <span>4</span>.7G     <span>0</span>  <span>4</span>.7G   <span>0</span>% /run/lock
none            <span>4</span>.7G     <span>0</span>  <span>4</span>.7G   <span>0</span>% /run/shm
none            <span>4</span>.7G     <span>0</span>  <span>4</span>.7G   <span>0</span>% /run/user
tmpfs           <span>4</span>.7G     <span>0</span>  <span>4</span>.7G   <span>0</span>% /sys/fs/cgroup
C:<span>\</span>             238G  153G   86G  <span>65</span>% /mnt/c
D:<span>\</span>             100G   24G   77G  <span>24</span>% /mnt/d
E:<span>\</span>             754G  540G  215G  <span>72</span>% /mnt/e
F:<span>\</span>              78G   38G   41G  <span>49</span>% /mnt/f
wangyawei@yaweidediannao:/$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><ol>
<li>
<p><strong>显示内容参数说明：</strong></p>
<ul>
<li><strong>Filesystem</strong>：文件系统</li>
<li><strong>Size</strong>： 分区大小</li>
<li><strong>Used</strong>： 已使用容量</li>
<li><strong>Avail</strong>： 还可以使用的容量</li>
<li><strong>Use%</strong>： 已用百分比</li>
<li><strong>Mounted on</strong>： 挂载点</li>
</ul>
</li>
<li>
<p><strong>相关命令：</strong></p>
<div><pre><code><span># df -hl：查看磁盘剩余空间</span>
wangyawei@yaweidediannao:/$ <span>df</span> -hl
Filesystem      Size  Used Avail Use% Mounted on
/dev/sdd        251G  <span>1</span>.2G  238G   <span>1</span>% /
tmpfs           <span>4</span>.7G  401M  <span>4</span>.3G   <span>9</span>% /mnt/wsl
/dev/sdc        251G  868M  238G   <span>1</span>% /mnt/wsl/docker-desktop-data/isocache
none            <span>4</span>.7G   12K  <span>4</span>.7G   <span>1</span>% /mnt/wsl/docker-desktop/shared-sockets/host-services
/dev/sdb        251G  130M  239G   <span>1</span>% /mnt/wsl/docker-desktop/docker-desktop-proxy
/dev/loop0      430M  430M     <span>0</span> <span>100</span>% /mnt/wsl/docker-desktop/cli-tools
tools           238G  153G   86G  <span>65</span>% /init
none            <span>4</span>.7G     <span>0</span>  <span>4</span>.7G   <span>0</span>% /dev
none            <span>4</span>.7G   16K  <span>4</span>.7G   <span>1</span>% /run
none            <span>4</span>.7G     <span>0</span>  <span>4</span>.7G   <span>0</span>% /run/lock
none            <span>4</span>.7G     <span>0</span>  <span>4</span>.7G   <span>0</span>% /run/shm
none            <span>4</span>.7G     <span>0</span>  <span>4</span>.7G   <span>0</span>% /run/user
tmpfs           <span>4</span>.7G     <span>0</span>  <span>4</span>.7G   <span>0</span>% /sys/fs/cgroup

<span># du -sh [目录名]：返回该目录的大小</span>
wangyawei@yaweidediannao:/$ <span>du</span> -sh /dev/sdb
<span>0</span>       /dev/sdb
wangyawei@yaweidediannao:/$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></li>
</ol>
<h2 id="du"> <code>du</code></h2>
<blockquote>
<p><strong>du</strong> 的英文原义为 <strong>disk usage</strong>，含义为显示磁盘空间的使用情况，用于查看当前目录的总大小。</p>
</blockquote>
<div><pre><code><span># 看当前目录的大小：</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ patient<span>]</span><span># du -sh</span>
<span>3</span>.1M    
<span>[</span>root@iZbp156pkpio44mis76wmxZ patient<span>]</span><span># du -h test</span>
608K    test/test6
308K    test/test4
<span>4</span>.0K    test/scf/lib
<span>4</span>.0K    test/scf/service/deploy/product
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="参考资料"> 参考资料</h2>
<p>https://www.runoob.com/w3cnote/linux-view-disk-space.html</p>
]]></content:encoded>
    </item>
    <item>
      <title>普通用户切换到root用户</title>
      <link>https://wangyawei.top/views/backEnd/linux/ubantu-note-06/</link>
      <guid>https://wangyawei.top/views/backEnd/linux/ubantu-note-06/</guid>
      <source url="https://wangyawei.top/rss.xml">普通用户切换到root用户</source>
      <category>LINUX</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>在使用ubantu的Linux系统时，终端顶部一直提示：<code>To run a command as administrator (user &quot;root&quot;), use &quot;sudo &lt;command&gt;&quot;.See &quot;man sudo_root&quot; for details.</code>,而且你会发你进入不了<code>root</code>目录，有权限限制的；由于 <code>Ubuntu</code> 是基于 <code>Debian</code> 的 <code>linux</code> 操作系统，在默认的情况下，是没有超级用户(superuser, root)的，但有些系统操作必须有超级用户的权限才能进行，如手动释放内存等。 在其他 linux 操作系统 (如 fedora) 下，可以使用 su 切换到超级用户。 当输入 su 命令后， 系统会要求输入 root 的密码。 可是，在 <code>Ubuntu</code> 下我们根本不知道 root 的密码是什么。 这样，在 Ubuntu 下切换到超级用户需要使用其他方法，</p>
</blockquote>
<div><pre><code><span># 没有权限</span>
wangyawei@yaweidediannao:/$ <span>cd</span> root/
bash: cd: root/: Permission denied
wangyawei@yaweidediannao:/$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="sudo命令"> <code>sudo</code>命令；</h2>
<blockquote>
<p>Linux sudo命令以系统管理者的身份执行指令，也就是说，经由 sudo 所执行的指令就好像是 root 亲自执行。</p>
</blockquote>
<h3 id="语法"> 语法</h3>
<div><pre><code><span># sudo -V 显示版本编号</span>
wangyawei@yaweidediannao:/$ <span>sudo</span> -V
Sudo version <span>1.8</span>.31
Sudoers policy plugin version <span>1.8</span>.31
Sudoers <span>file</span> grammar version <span>46</span>
Sudoers I/O plugin version <span>1.8</span>.31

<span># sudo -h 显示版本编号及指令的使用方式说明</span>
wangyawei@yaweidediannao:/$ <span>sudo</span> -h
<span>sudo</span> - execute a <span>command</span> as another user

usage: <span>sudo</span> -h <span>|</span> -K <span>|</span> -k <span>|</span> -V
usage: <span>sudo</span> -v <span>[</span>-AknS<span>]</span> <span>[</span>-g group<span>]</span> <span>[</span>-h host<span>]</span> <span>[</span>-p prompt<span>]</span> <span>[</span>-u user<span>]</span>
usage: <span>sudo</span> -l <span>[</span>-AknS<span>]</span> <span>[</span>-g group<span>]</span> <span>[</span>-h host<span>]</span> <span>[</span>-p prompt<span>]</span> <span>[</span>-U user<span>]</span> <span>[</span>-u user<span>]</span> <span>[</span>command<span>]</span>
usage: <span>sudo</span> <span>[</span>-AbEHknPS<span>]</span> <span>[</span>-r role<span>]</span> <span>[</span>-t type<span>]</span> <span>[</span>-C num<span>]</span> <span>[</span>-g group<span>]</span> <span>[</span>-h host<span>]</span> <span>[</span>-p prompt<span>]</span> <span>[</span>-T timeout<span>]</span> <span>[</span>-u user<span>]</span> <span>[</span>VAR<span>=</span>value<span>]</span> <span>[</span>-i<span>|</span>-s<span>]</span>
            <span>[</span><span>&lt;</span>command<span>></span><span>]</span>
usage: <span>sudo</span> -e <span>[</span>-AknS<span>]</span> <span>[</span>-r role<span>]</span> <span>[</span>-t type<span>]</span> <span>[</span>-C num<span>]</span> <span>[</span>-g group<span>]</span> <span>[</span>-h host<span>]</span> <span>[</span>-p prompt<span>]</span> <span>[</span>-T timeout<span>]</span> <span>[</span>-u user<span>]</span> <span>file</span> <span>..</span>.

Options:
  -A, --askpass                 use a helper program <span>for</span> password prompting
  -b, --background              run <span>command</span> <span>in</span> the background
<span>..</span><span>..</span>省略

<span># sudo -l 显示出自己（执行 sudo 的使用者）的权限</span>
wangyawei@yaweidediannao:/$ <span>sudo</span> -l
Matching Defaults entries <span>for</span> wangyawei on yaweidediannao:
    env_reset, mail_badpass, <span>secure_path</span><span>=</span>/usr/local/sbin<span>\</span>:/usr/local/bin<span>\</span>:/usr/sbin<span>\</span>:/usr/bin<span>\</span>:/sbin<span>\</span>:/bin<span>\</span>:/snap/bin

User wangyawei may run the following commands on yaweidediannao:
    <span>(</span>ALL <span>:</span> ALL<span>)</span> ALL
wangyawei@yaweidediannao:/$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h3 id="sudo-i"> <code>sudo -i</code></h3>
<blockquote>
<p><code>sudo</code> 是 <code>su</code> 的加强版，意思是 <code>do something as the supervisor</code>。 不需要密码就可以得到 root 的权限。 但是它也有很多限制，比如，在默认的情况下，只能在 5 分钟之内使用 root 权限。</p>
</blockquote>
<div><pre><code>wangyawei@yaweidediannao:/$ <span>sudo</span> -i
Welcome to Ubuntu <span>20.04</span>.2 LTS <span>(</span>GNU/Linux <span>5.4</span>.72-microsoft-standard-WSL2 x86_64<span>)</span>

 * Documentation:  https://help.ubuntu.com
 * Management:     https://landscape.canonical.com
 * Support:        https://ubuntu.com/advantage

  System information as of Sat Jun  <span>5</span> <span>16</span>:57:15 CST <span>2021</span>

  System load:  <span>0.08</span>               Processes:             <span>21</span>
  Usage of /:   <span>0.4</span>% of <span>250</span>.98GB   Users logged in:       <span>0</span>
  Memory usage: <span>6</span>%                 IPv4 address <span>for</span> eth0: <span>172.19</span>.226.190
  Swap usage:   <span>0</span>%

<span>1</span> update can be installed immediately.
<span>0</span> of these updates are security updates.
To see these additional updates run: <span>apt</span> list --upgradable


The list of available updates is <span>more</span> than a week old.
To check <span>for</span> new updates run: <span>sudo</span> <span>apt</span> update


This message is shown once a day. To disable it please create the
/root/.hushlogin file.
root@yaweidediannao:~<span># cd /</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id="su"> <code>su</code></h2>
<blockquote>
<p>如果想一直使用<code>root</code>权限，还是要使用 <code>su</code>， 还是要得到 <code>root</code> 密码的。 用 <code>sudo passwd root</code> 可以设置 root 的密码。 之后就可以自由使用 <code>su</code> 命令啦。</p>
</blockquote>
<div><pre><code>wangyawei@yaweidediannao:/$ <span>sudo</span> <span>passwd</span> root
New password:
Retype new password:
passwd: password updated successfully
wangyawei@yaweidediannao:/$ <span>su</span> root
Password:
root@yaweidediannao:/<span># cd /</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/backEnd/mysql/</link>
      <guid>https://wangyawei.top/views/backEnd/mysql/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>MYSQL</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些自己平时积累的mysql相关的知识；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>MYSQL使用</title>
      <link>https://wangyawei.top/views/backEnd/mysql/mysql-note-00/</link>
      <guid>https://wangyawei.top/views/backEnd/mysql/mysql-note-00/</guid>
      <source url="https://wangyawei.top/rss.xml">MYSQL使用</source>
      <category>MYSQL</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Error: ER_NOT_SUPPORTED_AUTH_MODE: Client does not support authentication pr</p>
</blockquote>
<ul>
<li>
<p>错误原因；</p>
<ul>
<li>原因8.0mysql引入了caching_sha2_password模块作为默认身份验证插件，nodejs还没有跟进</li>
</ul>
</li>
<li>
<p>解决；</p>
<ul>
<li>ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '自己的密码';</li>
</ul>
</li>
<li>
<p>启动mysql;</p>
<div><pre><code><span>service</span> mysqld start<span>;</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>关闭mysql</p>
<div><pre><code><span>service</span> mysqld stop 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>查看Mysql的运行状态；</p>
<div><pre><code></code></pre>
<div></div></div></li>
</ul>
<p>service mysqld status;</p>
<div><pre><code>


## 基础命令

1. 启动mysql

 ```bash
 service mysqld start;
 # or
 systemctl start mysqld;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><img src="./assets/1594485624023.png" alt="1594485624023" /></p>
<ol start="2">
<li>
<p>关闭mysql</p>
<div><pre><code><span>service</span> mysqld stop<span>;</span>
<span># or</span>
systemctl stop mysqld<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./assets/1594485694723.png" alt="1594485694723" /></p>
</li>
<li>
<p>查看Mysql的运行状态；</p>
<div><pre><code><span>service</span> mysqld status<span>;</span>
<span># or</span>
systemctl status mysqld<span>;</span>
<span># or </span>
systemctl -l status mysqld<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src="./assets/1594485553438.png" alt="1594485553438" /></p>
</li>
<li>
<p>查看错误日志位置</p>
</li>
</ol>
<div><pre><code><span>cat</span> /etc/my.cnf <span>|</span> <span>grep</span> log-error
</code></pre>
<div><span>1</span><br></div></div><ol start="5">
<li>查看错误日志</li>
</ol>
<div><pre><code><span>more</span> /var/log/mysqld.log
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>mysql安装</title>
      <link>https://wangyawei.top/views/backEnd/mysql/mysql-note-01/</link>
      <guid>https://wangyawei.top/views/backEnd/mysql/mysql-note-01/</guid>
      <source url="https://wangyawei.top/rss.xml">mysql安装</source>
      <category>MYSQL</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1-下载官网的安装包"> 1；下载官网的安装包;</h2>
<p><a href="https://dev.mysql.com/downloads/mysql/" target="_blank" rel="noopener noreferrer">mysql-8.0.20-winx64.zip</a></p>
<ul>
<li>直接解压不需要安装；</li>
</ul>
<h2 id="_2、添加环境变量"> 2、添加环境变量；</h2>
<p><img src="./assets/1594451166381.png" alt="1594451166381" /></p>
<h2 id="_3、初始化data目录"> 3、初始化<code>data</code>目录；</h2>
<blockquote>
<p>在 管理员身份下打开 cmd</p>
</blockquote>
<div><pre><code>mysqld --initialize-insecure --user=mysql  
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>在D:\mysql\mysql-8.0.12-winx64  目录下生成data目录;</li>
</ul>
<h2 id="_4、安装mysql"> 4、安装<code>mysql</code>;</h2>
<p><img src="./assets/1594451454429.png" alt="1594451454429" /></p>
<ol>
<li>
<p>启动；</p>
<p><img src="./assets/1594451488219.png" alt="1594451488219" /></p>
</li>
</ol>
<h2 id="_5、登录mysql"> 5、登录<code>mysql</code>;</h2>
<blockquote>
<p>首次登录不用输入密码直接回车即可；</p>
</blockquote>
<p><img src="./assets/1594451566149.png" alt="1594451566149" /></p>
<ul>
<li>
<p>查询用户密码；</p>
</li>
<li>
<p><img src="./assets/1594451641888.png" alt="1594451641888" /></p>
</li>
<li>
<p>设置用户密码；</p>
</li>
<li>
<p><img src="./assets/1594451743432.png" alt="1594451743432" /></p>
</li>
</ul>
<h2 id="_6、修改用户密码"> 6、修改用户密码；</h2>
<p><img src="./assets/1594451786455.png" alt="1594451786455" /></p>
<h2 id="_7、退出重新登录"> 7、退出重新登录；</h2>
<p><img src="./assets/1594451874114.png" alt="1594451874114" /></p>
<p><img src="./assets/1594456469376.png" alt="1594456469376" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>mysql创建用户并授权</title>
      <link>https://wangyawei.top/views/backEnd/mysql/mysql-note-02/</link>
      <guid>https://wangyawei.top/views/backEnd/mysql/mysql-note-02/</guid>
      <source url="https://wangyawei.top/rss.xml">mysql创建用户并授权</source>
      <category>MYSQL</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1、创建mysql用户"> 1、创建<code>mysql</code>用户；</h2>
<blockquote>
<p>说明：</p>
<ul>
<li><code>userName</code> : 你将要创建的用户名；</li>
<li><code>host</code>：用于指定用户可以在哪台主机上可以登录，如果是本地用户可以用<code>localhost</code>，如果想让改用户从任意远程主机登录，则可以用通配符 <code>%</code>。</li>
<li><code>passWord</code>：改用户的密码，可以为空，为空则可以不用输入密码登录。</li>
</ul>
</blockquote>
<div><pre><code>命令：CREATE USER &#39;userName&#39;@&#39;host&#39; IDENTIFIED by &#39;passWord&#39;;
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594527855404.png" alt="1594527855404" /></p>
<h2 id="_2、授权"> 2、授权；</h2>
<blockquote>
<p>说明：</p>
<ul>
<li><code>privileges</code>：用户的操作权限，如果要授予所有的权限则可以使用<code>ALL</code>。</li>
<li><code>databasename</code>：数据库的名字。</li>
<li><code>tablename</code>：表名，如果要授予用户所有的数据库和表的权限则可以使用<code>*</code>，如：<code>*.*</code>。</li>
<li><code>username</code>：刚刚创建的用户名，</li>
<li><code>host</code>：上面已有概述。</li>
</ul>
</blockquote>
<div><pre><code>命令：GRANT privileges ON databasename.tablename TO &#39;username&#39;@&#39;host&#39;
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594527974719.png" alt="1594527974719" /></p>
<blockquote>
<p>注意：上面创建的用户不能给其他用户授权，如果想授权则可以执行；</p>
<p><code>GRANT privileges ON databasename.tablename TO 'username'@'host' WITH GRANT OPTION;</code></p>
</blockquote>
<h2 id="_3、刷新权限"> 3、刷新权限；</h2>
<div><pre><code>FLUSH PRIVILEGES;
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594530165573.png" alt="1594530165573" /></p>
<h2 id="_4、错误处理"> 4、错误处理；</h2>
<ul>
<li>创建用户的时候出现错误；</li>
</ul>
<p><img src="./assets/1594529657545.png" alt="1594529657545" /></p>
<ul>
<li>
<p>解决；</p>
<div><pre><code>命令：set global validate_password_policy=0; 和 set global validate_password_length=1;
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>在次执行上面的创建用户命令；即可成功；</p>
</li>
</ul>
<h2 id="_5、配置服务器安全组"> 5、配置服务器安全组；</h2>
<p><img src="./assets/1594529927751.png" alt="1594529927751" /></p>
<p><img src="./assets/1594529944379.png" alt="1594529944379" /></p>
<h2 id="_6、开启linux防火强指定端口号3306"> 6、开启<code>linux</code>防火强指定端口号3306；</h2>
<ul>
<li>
<p>查看防火墙状态；</p>
<div><pre><code>systemctl status firewalld
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594530551649.png" alt="1594530551649" /></p>
</li>
<li>
<p>关闭防火墙；</p>
<div><pre><code>sudo service firewalld stop
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594530676467.png" alt="1594530676467" /></p>
</li>
<li>
<p>开启防火墙；</p>
<div><pre><code>sudo service firewalld start
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594530740077.png" alt="1594530740077" /></p>
</li>
<li>
<p>重启防火Q墙；</p>
<div><pre><code>sudo service firewalld restart
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>查看3306端口是否开启 ；</p>
</li>
</ul>
<div><pre><code>firewall-cmd --zone=public --query-port=8080/tcp --permanent
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594531217301.png" alt="1594531217301" /></p>
<ul>
<li>
<p>查看3306端口的使用情况 ；</p>
<div><pre><code>netstat -an | grep 3306
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594531323023.png" alt="1594531323023" /></p>
</li>
<li>
<p>单独开放3306端口；</p>
<div><pre><code>firewall-cmd --permanent --zone=public --add-port=3306/tcp // 添加3306端口
firewall-cmd --reload // 更新防火墙规则
firewall-cmd --zone=public --query-port=3306/tcp // 查看
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./assets/1594531485719.png" alt="1594531485719" /></p>
</li>
</ul>
<h2 id="_7、远程连接服务器测试"> 7、远程连接服务器测试；</h2>
]]></content:encoded>
    </item>
    <item>
      <title>winMysql使用</title>
      <link>https://wangyawei.top/views/backEnd/mysql/mysql-win-note-04/</link>
      <guid>https://wangyawei.top/views/backEnd/mysql/mysql-win-note-04/</guid>
      <source url="https://wangyawei.top/rss.xml">winMysql使用</source>
      <category>MYSQL</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<ol start="2">
<li>
<p>启动；</p>
<div><pre><code>net start mysql
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>关闭；</p>
<div><pre><code>net stop mysql
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>登录；</p>
<div><pre><code>mysql -uroot -p
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>修改密码；</p>
<div><pre><code>ALTER USER &#39;用户名&#39;@&#39;localhost&#39; IDENTIFIED WITH mysql_native_password BY &#39;新密码&#39;;

flush privileges;   --刷新MySQL的系统权限相关表
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>退出；</p>
<div><pre><code>exit;
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>查看连接数 ；</p>
<div><pre><code>show processlist; 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>查看最大连接数 ；</p>
<div><pre><code>show variables like &quot;max_connections&quot;;
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>修改最大连接数 ；</p>
<div><pre><code>set GLOBAL max_connections=1000; 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>mysql在关闭一个非交互的连接之前要等待的秒数，默认是28800s</p>
</li>
</ol>
<div><pre><code>show global variables like &#39;wait_timeout&#39;;
</code></pre>
<div><span>1</span><br></div></div><ol start="11">
<li>
<p>设置wait_timeout;</p>
<div><pre><code> <span>set</span> global <span>wait_timeout</span><span>=</span><span>28800</span><span>;</span>
 
 <span>set</span> global <span>interactive_timeout</span><span>=</span><span>28800</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/backEnd/nginx/</link>
      <guid>https://wangyawei.top/views/backEnd/nginx/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>NGINX</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些自己平时积累的nginx相关的知识；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>nginx部署vue项目</title>
      <link>https://wangyawei.top/views/backEnd/nginx/nginx-note-01/</link>
      <guid>https://wangyawei.top/views/backEnd/nginx/nginx-note-01/</guid>
      <source url="https://wangyawei.top/rss.xml">nginx部署vue项目</source>
      <category>NGINX</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1、安装配置nginx-aliyun-linux"> 1、安装配置nginx(Aliyun linux)</h2>
<blockquote>
<p>概述： Nginx是一款轻量级的网页服务器、反向代理服务器。相较于Apache、lighttpd具有占有内存少，稳定性高等优势。<strong>它最常的用途是提供反向代理服务。</strong></p>
</blockquote>
<h2 id="_2、安装"> 2、安装；</h2>
<ol>
<li>
<p>Nginx的安装依赖于以下三个包，意思就是在安装Nginx之前首先必须安装一下的三个包，注意安装顺序如下：</p>
<ul>
<li>
<p>SSL功能需要openssl库，直接通过yum安装:</p>
<div><pre><code>yum <span>install</span> openssl
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>gzip模块需要zlib库，直接通过yum安装:</p>
</li>
</ul>
<div><pre><code>yum <span>install</span> zlib
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>
<p>rewrite模块需要pcre库，直接通过yum安装:</p>
<div><pre><code> yum <span>install</span> pcre
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
</li>
<li>
<p>安装Nginx依赖项和Nginx</p>
</li>
</ol>
<ul>
<li>使用yum安装nginx需要包括Nginx的库，安装Nginx的库</li>
</ul>
<div><pre><code> ```bash
 rpm -Uvh http://nginx.org/packages/centos/7/noarch/RPMS/nginx-release-centos-7-0.el7.ngx.noarch.rpm
 ```
</code></pre>
</div><ul>
<li>使用下面命令安装nginx</li>
</ul>
<div><pre><code> ```bash
</code></pre>
</div><p>yum install nginx
```</p>
<ul>
<li>
<p>启动Nginx</p>
<div><pre><code><span>service</span> nginx start

Redirecting to /bin/systemctl start nginx.service
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>测试；出现先面这样就说明成功了。</p>
<div><pre><code>[root@iZbp156pkpio44mis76wmxZ /]# curl localhost
&lt;!DOCTYPE html&gt;
&lt;html&gt;
&lt;head&gt;
&lt;title&gt;Welcome to nginx!&lt;/title&gt;
&lt;style&gt;
    body {
        width: 35em;
        margin: 0 auto;
        font-family: Tahoma, Verdana, Arial, sans-serif;
    }
&lt;/style&gt;
&lt;/head&gt;
&lt;body&gt;
&lt;h1&gt;Welcome to nginx!&lt;/h1&gt;
&lt;p&gt;If you see this page, the nginx web server is successfully installed and
working. Further configuration is required.&lt;/p&gt;

&lt;p&gt;For online documentation and support please refer to
&lt;a href=&quot;http://nginx.org/&quot;&gt;nginx.org&lt;/a&gt;.&lt;br/&gt;
Commercial support is available at
&lt;a href=&quot;http://nginx.com/&quot;&gt;nginx.com&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Thank you for using nginx.&lt;/em&gt;&lt;/p&gt;
&lt;/body&gt;
&lt;/html&gt;
[root@iZbp156pkpio44mis76wmxZ /]#
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div></li>
<li>
<p>安装Nginx后，安装在了 /etc/nginx/目录下，你可以打开/etc/nginx/conf.d/default.conf查看里面的配置，包括监听端口，域名和nginx访问的根目录.</p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ conf.d<span>]</span><span># cat default.conf</span>
server <span>{</span>
    listen       <span>80</span><span>;</span>
    server_name  localhost<span>;</span>

    <span>#charset koi8-r;</span>
    <span>#access_log  /var/log/nginx/host.access.log  main;</span>

    location / <span>{</span>
        root   /usr/share/nginx/html<span>;</span>
        index  index.html index.htm<span>;</span>
    <span>}</span>

    <span>#error_page  404              /404.html;</span>

    <span># redirect server error pages to the static page /50x.html</span>
    <span>#</span>
    error_page   <span>500</span> <span>502</span> <span>503</span> <span>504</span>  /50x.html<span>;</span>
    location <span>=</span> /50x.html <span>{</span>
        root   /usr/share/nginx/html<span>;</span>
    <span>}</span>

    <span># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span>
    <span>#</span>
    <span>#location ~ \.php$ {</span>
    <span>#    proxy_pass   http://127.0.0.1;</span>
    <span>#}</span>

    <span># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span>
    <span>#</span>
    <span>#location ~ \.php$ {</span>
    <span>#    root           html;</span>
    <span>#    fastcgi_pass   127.0.0.1:9000;</span>
    <span>#    fastcgi_index  index.php;</span>
    <span>#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span>
    <span>#    include        fastcgi_params;</span>
    <span>#}</span>

    <span># deny access to .htaccess files, if Apache's document root</span>
    <span># concurs with nginx's one</span>
    <span>#</span>
    <span>#location ~ /\.ht {</span>
    <span>#    deny  all;</span>
    <span>#}</span>
<span>}</span>

<span>[</span>root@iZbp156pkpio44mis76wmxZ conf.d<span>]</span><span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div></li>
</ul>
<h2 id="_3、部署"> 3、部署；</h2>
<ol>
<li>
<p>把自己的vue项目进行打包，</p>
<div><pre><code><span>npm</span> run build
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>打包后会生成一个<code>dist</code>文件夹，里面就是打包生成的文件。</p>
</li>
<li>
<p>把打包的文件上传到自己的远程服务中。</p>
</li>
<li>
<p>找到nginx的配置文件，我的路径：/etc/nginx/conf.d/default.conf。</p>
</li>
<li>
<p>使用<code>vim default.conf</code>,进行如下配置。</p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ conf.d<span>]</span><span># cat default.conf </span>
server <span>{</span>
    listen       <span>8090</span><span>;</span> <span># nginx 服务启动监听的端口 默认为：80</span>
    server_name  localhost<span>;</span>

    <span>#charset koi8-r;</span>
    <span>#access_log  /var/log/nginx/host.access.log  main;</span>

    location / <span>{</span>
        root   /home/local/tomcat/webapps_patient/patient<span>;</span> <span># 我的vue打包后的文件夹目录</span>
        index  index.html index.htm<span>;</span>
    <span>}</span>

    location /api/ <span>{</span>
	 	  rewrite ^/api/<span>(</span>.*<span>)</span> /<span>$1</span> <span>break</span><span>;</span> <span># 过滤掉接口前缀</span>
   		proxy_pass  http://47.114.xxx.71:9091<span>;</span> <span># 后端接口地址，</span>
    <span>}</span>

    <span>#error_page  404              /404.html;</span>

    <span># redirect server error pages to the static page /50x.html</span>
    <span>#</span>
    error_page   <span>500</span> <span>502</span> <span>503</span> <span>504</span>  /50x.html<span>;</span>
    location <span>=</span> /50x.html <span>{</span>
        root   /usr/share/nginx/html<span>;</span>
    <span>}</span>

    <span># proxy the PHP scripts to Apache listening on 127.0.0.1:80</span>
    <span>#</span>
    <span>#location ~ \.php$ {</span>
    <span>#    proxy_pass   http://127.0.0.1;</span>
    <span>#}</span>

    <span># pass the PHP scripts to FastCGI server listening on 127.0.0.1:9000</span>
    <span>#</span>
    <span>#location ~ \.php$ {</span>
    <span>#    root           html;</span>
    <span>#    fastcgi_pass   127.0.0.1:9000;</span>
    <span>#    fastcgi_index  index.php;</span>
    <span>#    fastcgi_param  SCRIPT_FILENAME  /scripts$fastcgi_script_name;</span>
    <span>#    include        fastcgi_params;</span>
    <span>#}</span>

    <span># deny access to .htaccess files, if Apache's document root</span>
    <span># concurs with nginx's one</span>
    <span>#</span>
    <span>#location ~ /\.ht {</span>
    <span>#    deny  all;</span>
    <span>#}</span>
<span>}</span>

<span>[</span>root@iZbp156pkpio44mis76wmxZ conf.d<span>]</span><span># </span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div></li>
</ol>
<h2 id="_4、部署中的问题"> 4、部署中的问题；</h2>
<blockquote>
<p>由于自己第一次使用<code>nginx</code>来进行部署，我之前用的<code>tomcat</code>，过程中确实遇到了不少坑。</p>
</blockquote>
<ol>
<li>
<p>不是把vue静态文件配置好就行了，如果只是访问一下静态文件，而不发网络请求的话，那么就没有什么关系了。</p>
</li>
<li>
<p>配置完静态文件后，只是页面可以出来了，但是发网络请求(后端接口)就会出现跨域。以下解决；</p>
<div><pre><code> <span># 说明：/api/ 这个前缀是我在vue项目中加的，用来进行匹配，但是实际上后端的接口是没有这个前缀的，所以 用 rewrite 来进行过滤掉 /api 这个前缀。</span>
 location /api/ <span>{</span>
	 	  rewrite ^/api/<span>(</span>.*<span>)</span> /<span>$1</span> <span>break</span><span>;</span> <span># 过滤掉接口前缀</span>
   		proxy_pass  http://47.114.xxx.71:9091<span>;</span> <span># 后端接口地址，</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>如果更改 nginx 服务的端口，记得 更新 安全组和开放端口防火墙；不然访问不到页面。<a href="https://www.cnblogs.com/ywnh/p/14225944.html" target="_blank" rel="noopener noreferrer">设置防火墙</a></p>
</li>
</ol>
<h2 id="_5、命令启动"> 5、命令启动；</h2>
<div><pre><code><span># 启动 nginx</span>
<span>service</span> nginx start

<span># 关闭 nginx</span>
<span>service</span> nginx stop

<span># 查看 nginx 状态</span>
<span>service</span> nginx status
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>winMysql忘记密码</title>
      <link>https://wangyawei.top/views/backEnd/mysql/mysql-win-note-05/</link>
      <guid>https://wangyawei.top/views/backEnd/mysql/mysql-win-note-05/</guid>
      <source url="https://wangyawei.top/rss.xml">winMysql忘记密码</source>
      <category>MYSQL</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="winmysql忘记密码"> winMysql忘记密码</h2>
<ol>
<li>
<p>进入mysql的安装路径下的bin文件下；</p>
</li>
<li>
<p>停止你的Mysql服务；</p>
<div><pre><code><span># net stop mysql</span>

D:<span>\</span>mysql-8.0.20-winx64<span>\</span>bin
$ net stop mysql
MySQL 服务正在停止.
MySQL 服务已成功停止。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>输入以下命令；</p>
<div><pre><code><span># mysqld --console --skip-grant-tables --shared-memory</span>

D:<span>\</span>mysql-8.0.20-winx64<span>\</span>bin
$ mysqld --console --skip-grant-tables --shared-memory <span># 1</span>
<span>2021</span>-03-13T13:00:39.507312Z <span>0</span> <span>[</span>System<span>]</span> <span>[</span>MY-010116<span>]</span> <span>[</span>Server<span>]</span> D:<span>\</span>mysql-8.0.20-winx64<span>\</span>bin<span>\</span>mysqld.exe <span>(</span>mysqld <span>8.0</span>.20<span>)</span> starting as process <span>15836</span>
<span>2021</span>-03-13T13:00:39.632181Z <span>1</span> <span>[</span>System<span>]</span> <span>[</span>MY-013576<span>]</span> <span>[</span>InnoDB<span>]</span> InnoDB initialization has started.
<span>2021</span>-03-13T13:00:41.077270Z <span>1</span> <span>[</span>System<span>]</span> <span>[</span>MY-013577<span>]</span> <span>[</span>InnoDB<span>]</span> InnoDB initialization has ended.
<span>2021</span>-03-13T13:00:41.422998Z <span>0</span> <span>[</span>Warning<span>]</span> <span>[</span>MY-011311<span>]</span> <span>[</span>Server<span>]</span> Plugin mysqlx reported: <span>'All I/O interfaces are disabled, X Protocol won'</span>t be accessible<span>'
2021-03-13T13:00:41.745906Z 0 [Warning] [MY-010068] [Server] CA certificate ca.pem is self signed.
2021-03-13T13:00:41.839456Z 0 [System] [MY-010931] [Server] D:\mysql-8.0.20-winx64\bin\mysqld.exe: ready for connections. Version: '</span><span>8.0</span>.20<span>'  socket: '</span>'  port: <span>0</span>  MySQL Community Server - GPL.

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>
<p>注意窗口不要关闭，然后再打开一个新的窗口，</p>
</blockquote>
</li>
<li>
<p>登录；</p>
<div><pre><code><span># 注意不要输入密码，直接回车，然后输入以下命令，</span>
mysql -u root -p

D:<span>\</span>mysql-8.0.20-winx64<span>\</span>bin
$ mysql -u root -p  <span># 1</span>
Enter password:
Welcome to the MySQL monitor.  Commands end with <span>;</span> or <span>\</span>g.
Your MySQL connection <span>id</span> is <span>7</span>
Server version: <span>8.0</span>.20 MySQL Community Server - GPL

Copyright <span>(</span>c<span>)</span> <span>2000</span>, <span>2020</span>, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type <span>'help;'</span> or <span>'\h'</span> <span>for</span> help. Type <span>'\c'</span> to <span>clear</span> the current input statement.

mysql<span>></span> use mysql  <span># 2</span>
Database changed
mysql<span>></span> update user <span>set</span> <span>authentication_string</span><span>=</span><span>''</span> where <span>user</span><span>=</span><span>'root'</span><span>;</span> Query OK, <span>1</span> row affected <span>(</span><span>0.14</span> sec<span>)</span>  <span># 3</span>
Rows matched: <span>1</span>  Changed: <span>1</span>  Warnings: <span>0</span>

mysql<span>></span> quit  <span># 4</span>
Bye
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></li>
<li>
<p>关闭1、2窗口；然后再新开一个窗口；</p>
</li>
<li>
<p>执行以下命令；</p>
<div><pre><code>D:<span>\</span>mysql-8.0.20-winx64<span>\</span>bin
$ net start mysql  <span># 1</span>
MySQL 服务正在启动 <span>..</span>
MySQL 服务已经启动成功。

D:<span>\</span>mysql-8.0.20-winx64<span>\</span>bin
$ mysql -u root -p  <span># 2</span>
Enter password:
Welcome to the MySQL monitor.  Commands end with <span>;</span> or <span>\</span>g.
Your MySQL connection <span>id</span> is <span>8</span>
Server version: <span>8.0</span>.20 MySQL Community Server - GPL

Copyright <span>(</span>c<span>)</span> <span>2000</span>, <span>2020</span>, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type <span>'help;'</span> or <span>'\h'</span> <span>for</span> help. Type <span>'\c'</span> to <span>clear</span> the current input statement.

mysql<span>></span> ALTER <span>USER</span> <span>'root'</span>@<span>'localhost'</span> IDENTIFIED BY <span>'root2020'</span><span>;</span>  <span># 3</span>
Query OK, <span>0</span> rows affected <span>(</span><span>0.08</span> sec<span>)</span>

mysql<span>></span> quit  <span># 4</span>
Bye

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><blockquote>
<p>此时密码修改为  <code>root2020</code></p>
</blockquote>
</li>
<li>
<p>使用密码登录；</p>
<div><pre><code>D:<span>\</span>mysql-8.0.20-winx64<span>\</span>bin
$ mysql -u root -p
Enter password: ********
Welcome to the MySQL monitor.  Commands end with <span>;</span> or <span>\</span>g.
Your MySQL connection <span>id</span> is <span>9</span>
Server version: <span>8.0</span>.20 MySQL Community Server - GPL

Copyright <span>(</span>c<span>)</span> <span>2000</span>, <span>2020</span>, Oracle and/or its affiliates. All rights reserved.

Oracle is a registered trademark of Oracle Corporation and/or its
affiliates. Other names may be trademarks of their respective
owners.

Type <span>'help;'</span> or <span>'\h'</span> <span>for</span> help. Type <span>'\c'</span> to <span>clear</span> the current input statement.

mysql<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div></li>
</ol>
<p><a href="https://blog.csdn.net/qq382495414/article/details/107253577/" target="_blank" rel="noopener noreferrer">原文地址</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>nginx配置资源压缩</title>
      <link>https://wangyawei.top/views/backEnd/nginx/nginx-note-02/</link>
      <guid>https://wangyawei.top/views/backEnd/nginx/nginx-note-02/</guid>
      <source url="https://wangyawei.top/rss.xml">nginx配置资源压缩</source>
      <category>NGINX</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>在稍大型的项目中，前端的静态文件也会随之变大，然而当访问量也逐渐增加的时候，那么对于带宽和用户的体验就是一个问题，既要节省带宽又要做到一个很好的用户体验； 那么利用nginx开启gzip压缩可以大大提高页面的加载速度，从而提升用户体验。</p>
<p>gzip 的压缩页面需要浏览器和服务器双方都支持，实际上就是服务器端压缩，传到浏览器后浏览器解压并解析。浏览器那里不需要我们担心，因为目前的巨大多数浏览器 都支持解析gzip过的页面。</p>
</blockquote>
<h2 id="nginx压缩的两种方式"> <code>nginx</code>压缩的两种方式</h2>
<ol>
<li>动态压缩：静态文件还是普通文件，请求来了再压缩，然后返回给前端。</li>
<li>静态压缩：提前把文件压缩成 <code>.gz</code> 格式，请求来了，直接返回即可。</li>
</ol>
<h2 id="动态压缩"> 动态压缩</h2>
<blockquote>
<p>动态压缩还是使用普通的打包编译后的文件，将前端编译打包后的文件上传到服务器，然后配置nginx<code>root</code>属性指向你的静态资源文件；</p>
</blockquote>
<ol>
<li>
<p>打包静态资源文件并上传到服务器；</p>
<div><pre><code>ASUS@yaweidediannao MINGW64 /e/projectCenter/patient/dist <span>(</span>dev<span>)</span>
$ tree
dist
├── favicon.ico
├── index.html
└── static
    ├── css
    │   ├── app.css
    │   ├── chunk-16054821.css
    │   ├── chunk-6424e903.css
    │   ├── chunk-6619cda0.css
    │   ├── chunk-6c291fec.css
    │   ├── chunk-87cbb83a.css
    │   ├── chunk-d0aba2a0.css
    │   └── chunk-vendors.css
    ├── fonts
    │   ├── element-icons.ttf
    │   └── element-icons.woff
    ├── img
    │   ├── login.jpg
    │   └── logo.png
    └── js
        ├── app.js
        ├── chunk-16054821.js
        ├── chunk-2d0b99b3.js
        ├── chunk-2d0df087.js
        ├── chunk-6424e903.js
        ├── chunk-6619cda0.js
        ├── chunk-6c291fec.js
        ├── chunk-87cbb83a.js
        ├── chunk-d0aba2a0.js
        └── chunk-vendors.js


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><blockquote>
<p>上传服务器使用 <code>Xftp</code>就可以；</p>
</blockquote>
</li>
<li>
<p>配置静态资源文件：</p>
<div><pre><code>server <span>{</span>
    listen       <span>8090</span><span>;</span>
    server_name  localhost<span>;</span>
    location / <span>{</span>
        root   /home/local/webview/patient<span>;</span> <span># 我的静态资源文件路径</span>
        index  index.html<span>;</span>
    <span>}</span>
    error_page   <span>500</span> <span>502</span> <span>503</span> <span>504</span>  /50x.html<span>;</span>
    location <span>=</span> /50x.html <span>{</span>
        root   /usr/share/nginx/html<span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></li>
<li>
<p>配置gzip压缩</p>
<div><pre><code>server <span>{</span>
    listen       <span>8090</span><span>;</span>
    server_name  localhost<span>;</span>
    location / <span>{</span>
        root   /home/local/webview/patient<span>;</span>
        index  index.html<span>;</span>
	     <span>gzip</span>  on<span>;</span>           <span># 开启gzip压缩</span>
	     gzip_min_length 2k<span>;</span> <span># 大小超过2kb才进行压缩</span>
	     gzip_disable msie6<span>;</span> <span># IE6对Gzip不怎么友好，不给它Gzip了</span>
	     gzip_types text/css application/javascript text/javascript image/jpeg image/png image/jpg<span>;</span> <span># 需要压缩的文件类型</span>
    <span>}</span>
    error_page   <span>500</span> <span>502</span> <span>503</span> <span>504</span>  /50x.html<span>;</span>
    location <span>=</span> /50x.html <span>{</span>
        root   /usr/share/nginx/html<span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><p>提示</p>
<p>可以F12打开控制面板，在设置中 勾选 <code>Use large request rows</code>选项，来查看浏览器请求的资源压缩前后的大小；</p>
</div>
</li>
</ol>
<h2 id="静态压缩"> 静态压缩</h2>
<blockquote>
<p>静态压缩是前端直接打包出压缩的gz文件，将前端打包后的文件上传到服务器，然后配置nginx<code>root</code>属性指向你的静态资源文件；</p>
</blockquote>
<ol>
<li>
<p>打包静态资源文件并上传到服务器；</p>
<div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/新建文件夹
$ tree
新建文件夹
├── favicon.ico
├── index.html.gz
└── static
    ├── css
    │   ├── app.css.gz
    │   ├── chunk-16054821.css.gz
    │   ├── chunk-6424e903.css.gz
    │   ├── chunk-6619cda0.css.gz
    │   ├── chunk-6c291fec.css.gz
    │   ├── chunk-87cbb83a.css.gz
    │   ├── chunk-d0aba2a0.css.gz
    │   └── chunk-vendors.css.gz
    ├── fonts
    │   ├── element-icons.ttf.gz
    │   └── element-icons.woff
    ├── img
    │   ├── login.jpg
    │   └── logo.png
    └── js
        ├── app.js.gz
        ├── chunk-16054821.js.gz
        ├── chunk-2d0b99b3.js.gz
        ├── chunk-2d0df087.js.gz
        ├── chunk-6424e903.js.gz
        ├── chunk-6619cda0.js.gz
        ├── chunk-6c291fec.js.gz
        ├── chunk-87cbb83a.js.gz
        ├── chunk-d0aba2a0.js.gz
        └── chunk-vendors.js.gz
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><blockquote>
<p>上传服务器使用 <code>Xftp</code>就可以；</p>
</blockquote>
</li>
<li>
<p>配置静态资源文件：同上；</p>
</li>
<li>
<p>配置gzip压缩；</p>
<div><pre><code>server <span>{</span>
    listen       <span>8090</span><span>;</span>
    server_name  localhost<span>;</span>
    location / <span>{</span>
        root   /home/local/webview/patient<span>;</span>
        index  index.html<span>;</span>
			gzip_static on<span>;</span> <span># 开启压缩</span>
			gzip_proxied expired no-cache no-store private auth<span>;</span>
    <span>}</span>
    error_page   <span>500</span> <span>502</span> <span>503</span> <span>504</span>  /50x.html<span>;</span>
    location <span>=</span> /50x.html <span>{</span>
        root   /usr/share/nginx/html<span>;</span>
    <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></li>
<li>
<p>重新加载nginx;</p>
<div><pre><code>systemctl raload nginx
</code></pre>
<div><span>1</span><br></div></div><div><p>注意</p>
<p><strong>注意</strong>：压缩的静态文件里面 需要把 index.html.gz 文件先进行解压为 index.html ;不然nginx会报  403 错误！！</p>
</div>
</li>
</ol>
<h2 id="测试"> 测试</h2>
<ol>
<li>
<p>访问你自己的web页面，查看请求响应的结果；</p>
<div><pre><code>....
Connection: keep-alive 
Content-Encoding: gzip   # 表示压缩生效了
Content-Length: 275
....
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>对比开启压缩前和开启后的响应大小；</p>
</li>
<li>
<p>可以F12打开控制面板，在设置中 勾选 <code>Use large request rows</code>选项，来查看浏览器请求的资源压缩前后的大小；</p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Node.js 不是一种独立的语言， Node.js 也不是一个 JavaScript 框架，Node.js 更不是浏览器端的库，不能与 jQuery、 ExtJS 相提并论。 Node.js 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为脚本语言世界的一等公民，在服务端堪与 PHP、 Python、Perl、 Ruby 平起平坐。它跳过了 Apache、 Nginx 等 HTTP服务器，直接面向前端开发。</p>
</blockquote>
<h2 id="目录"> 目录</h2>
<ul>
<li>nodejs简介
<ul>
<li><a href="./nodejs-note-00.html">nodejs简介</a></li>
<li><a href="./nodejs-note-14.html">Node.js 是什么</a></li>
<li><a href="./nodejs-note-15.html">Node.js 能做什么</a></li>
<li><a href="./nodejs-note-16.html">异步式 I/O 与事件驱动</a></li>
<li><a href="./nodejs-note-17.html">Node.js 的性能</a></li>
<li><a href="./nodejs-note-18.html">CommonJS规范</a></li>
</ul>
</li>
<li>Node.js快速入门
<ul>
<li><a href="./nodejs-note-26.html">安装nodejs</a></li>
<li><a href="./nodejs-note-19.html">使用Nodejs </a></li>
<li><a href="./nodejs-note-20.html">异步式 I/O 与事件式编程</a></li>
<li><a href="./nodejs-note-21.html"> 模块和包</a></li>
<li><a href="./nodejs-note-22.html">调试</a></li>
</ul>
</li>
<li>nodejs核心模块
<ul>
<li><a href="./nodejs-note-09.html">全局对象</a></li>
<li><a href="./nodejs-note-10.html">常用工具util</a></li>
<li><a href="./nodejs-note-11.html">事件驱动 events</a></li>
<li><a href="./nodejs-note-12.html">文件系统 fs</a></li>
<li><a href="./nodejs-note-13.html">HTTP 服务器与客户端</a></li>
</ul>
</li>
<li>进阶
<ul>
<li><a href="./nodejs-note-23.html">模块加载机制</a></li>
<li><a href="./nodejs-note-24.html">控制流</a></li>
<li><a href="./nodejs-note-25.html">Node.js 不是银弹</a></li>
</ul>
</li>
<li>nodejs扩展
<ul>
<li><a href="./nodejs-note-01.html">命令行输出目录树</a></li>
<li><a href="./nodejs-note-02.html">node版本管理工具-nvm</a></li>
<li><a href="./nodejs-note-03.html">node实现自动化部署</a></li>
<li><a href="./nodejs-note-04.html">pm2的使用</a></li>
<li><a href="./nodejs-note-05.html">后台持续运行node</a></li>
<li><a href="./nodejs-note-06.html">搭建本地服务</a></li>
<li><a href="./nodejs-note-07.html">json-serve</a></li>
<li><a href="./nodejs-note-08.html">ora的使用</a></li>
</ul>
</li>
</ul>
<h2 id="参考资料"> 参考资料</h2>
<p>nodejs 开发指南</p>
]]></content:encoded>
    </item>
    <item>
      <title>ES6</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-00/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-00/</guid>
      <source url="https://wangyawei.top/rss.xml">ES6</source>
      <category>ES6</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="es6"> ES6；</h2>
<blockquote>
<p>ECMAScript 的一个颠覆性版本更新  - 面向对象编程（类、对象-- 封装、继承、多态）</p>
</blockquote>
<h3 id="let"> let；</h3>
<ul>
<li>
<p>let 声明变量；</p>
</li>
<li>
<p>特点：</p>
<ul>
<li>无法变量提升</li>
<li>无法重复声明</li>
<li>有块级作用域  { };</li>
</ul>
</li>
</ul>
<div><pre><code><span>//1、变量无法提升；</span>
console<span>.</span><span>log</span><span>(</span>b<span>)</span><span>;</span><span>//b is not defined</span>
<span>let</span> b<span>=</span><span>'小明'</span><span>;</span>

<span>//2、变量无法重复定义；</span>
 <span>let</span> b <span>=</span> <span>'小红'</span><span>;</span>
 <span>let</span> b <span>=</span> <span>'小霞'</span><span>;</span>
 console<span>.</span><span>log</span><span>(</span>b<span>)</span><span>;</span><span>//Identifier 'b' has already been declared</span>

<span>//3、有块级作用域；；</span>
 <span>{</span>
     <span>let</span> b<span>=</span><span>'郭德纲'</span><span>;</span>
 <span>}</span>
 console<span>.</span><span>log</span><span>(</span>b<span>)</span><span>;</span><span>//b is not defined</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="const-常量"> const 常量；</h3>
<blockquote>
<p>常量主要用来保存一些初始信息，不允许修改；</p>
</blockquote>
<ul>
<li>特点：
<ul>
<li>常量声明必须要赋值；</li>
<li>常量无法重新赋值；</li>
<li>无法重复声明；</li>
<li>无法变量提升；</li>
<li>有块级作用域；</li>
</ul>
</li>
<li>常量应用场景；
<ul>
<li>整个程序的核心配置数据，一般使用常量来保存因为无法修改；</li>
<li>在 nodejs 中加载模块时，一般使用常量来保存模块对象；</li>
</ul>
</li>
</ul>
<div><pre><code>
<span>// 1. 常量无法重新赋值</span>
 <span>const</span> age1 <span>=</span> <span>100</span><span>;</span>
 age1 <span>=</span> <span>101</span><span>;</span> <span>// 常量 一旦赋值，不能改变！</span>
 console<span>.</span><span>log</span><span>(</span>age1<span>)</span><span>;</span>

<span>// 2. 常量只能也必须在 创建时赋值</span>
 <span>const</span> age2<span>;</span> <span>//报错： Missing initializer in const declaration</span>
 console<span>.</span><span>log</span><span>(</span>age2<span>)</span><span>;</span>

<span>// 3. 无法变量提升</span>
 console<span>.</span><span>log</span><span>(</span>age3<span>)</span><span>;</span> <span>// 报错： age is not defined</span>
 <span>const</span> age3 <span>=</span> <span>1</span><span>;</span>

<span>// 4.有 块级作用域</span>
 <span>if</span><span>(</span><span>true</span><span>)</span><span>{</span>
   <span>const</span> num4 <span>=</span> <span>100</span><span>;</span>
 <span>}</span>
 console<span>.</span><span>log</span><span>(</span>num4<span>)</span><span>;</span> <span>// 报错：   num is not defined</span>

<span>// 5.无法重复声明</span>
 <span>const</span> num5 <span>=</span> <span>1</span><span>;</span>
 <span>const</span> num5 <span>=</span> <span>2</span><span>;</span> <span>// Identifier 'num' has already been declared</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="解构"> 解构；</h2>
<blockquote>
<p>概念：一种<strong>方便获取</strong>对象和数组中值的方式；</p>
</blockquote>
<h3 id="对象解构"> 对象解构；</h3>
<blockquote>
<p>概念：使用对象解构自动将对象  同名属性  赋值给  同名变量；</p>
</blockquote>
<div><pre><code><span>let</span> a<span>=</span><span>{</span>
    name<span>:</span> <span>'小明'</span><span>,</span>
    age<span>:</span> <span>19</span><span>,</span>
    <span>eat</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'我叫'</span><span>+</span>a<span>.</span>name<span>+</span><span>'今年'</span><span>+</span>a<span>.</span>age<span>+</span><span>'岁了'</span><span>)</span>
        <span>return</span> <span>'下午好'</span><span>;</span>
    <span>}</span>
<span>}</span>
<span>//把对象中的属性值赋值给了 同名 变量；</span>
<span>let</span> <span>{</span>name<span>,</span>age<span>,</span>eat<span>}</span><span>=</span>a<span>;</span>
<span>let</span> c<span>=</span>name<span>;</span>
console<span>.</span><span>log</span><span>(</span>name<span>,</span>age<span>,</span><span>eat</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//小明 19 下午好；</span>
console<span>.</span><span>log</span><span>(</span>c<span>)</span><span>;</span><span>//小明；</span>
<span>//情况1；变量多于对象属性；则多余的那个变量会打印undefined;</span>
<span>let</span> <span>{</span>name<span>,</span>age<span>,</span>eat<span>,</span>key<span>}</span><span>=</span>a<span>;</span><span>// key -> undefined</span>
<span>//情况2；若变量少于对象属性，则正常打印属性值；</span>
<span>let</span> <span>{</span>name<span>}</span><span>=</span>a<span>;</span><span>//小明；</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="数组的解构"> 数组的解构；</h3>
<blockquote>
<p>相当于创建n个变量，并且从数组中 【按顺序】 取出元素设置给变量；</p>
</blockquote>
<div><pre><code><span>//声明一个变量；</span>
<span>let</span> a<span>=</span><span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>,</span><span>7</span><span>,</span><span>8</span><span>]</span><span>;</span>

<span>//将数组解构取出；</span>
<span>let</span> <span>[</span>p<span>,</span>b<span>,</span>c<span>,</span>d<span>,</span>e<span>,</span>f<span>,</span>g<span>,</span>h<span>]</span><span>=</span>a

console<span>.</span><span>log</span><span>(</span>f<span>)</span><span>;</span><span>// 6；</span>
console<span>.</span><span>log</span><span>(</span>b<span>)</span><span>;</span><span>// 2；</span>
console<span>.</span><span>log</span><span>(</span>c<span>)</span><span>;</span><span>// 3；</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="例"> 例；</h3>
<blockquote>
<p>问题：有些函数有多个形参，但实际使用时，需要指定传入任意位置的参数，传统语法无法实现；</p>
</blockquote>
<div><pre><code><span>//一个函数有三个形参，但是有一个需要是默认值，其他两个是用户传入的值；</span>
<span>function</span> <span>fn</span><span>(</span><span><span>{</span>a<span>=</span><span>1</span><span>,</span>b<span>=</span><span>2</span><span>,</span>c<span>=</span><span>3</span><span>}</span></span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>a<span>,</span>b<span>,</span>c<span>)</span><span>;</span><span>//1 9 8</span>
<span>}</span>

<span>let</span> obj<span>=</span><span>{</span>b<span>:</span><span>9</span><span>,</span>c<span>:</span><span>8</span><span>}</span><span>;</span>

<span>fn</span><span>(</span>obj<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="箭头函数"> 箭头函数；</h2>
<blockquote>
<p>​	箭头函数（Arrow Function），并且简化了函数定义。</p>
<p>注：1、<strong>只针对于 匿名函数</strong>，命名函数不能使用；</p>
<p>​	2、箭头函数的this在创建时就确定了，是上下文中的this；</p>
</blockquote>
<div><pre><code><span>// const a=function (b) {</span>
<span>//     console.log(89+b);</span>
<span>//     console.log(78);</span>
<span>// }</span>

<span>//简化后；</span>
<span>const</span> <span>a</span><span>=</span><span>b</span><span>=></span><span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>89</span><span>+</span>b<span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span><span>78</span><span>)</span><span>;</span>
<span>}</span>

<span>a</span><span>(</span><span>39</span><span>)</span> <span>//128  78</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><ol>
<li>
<p>：function 变为  =&gt;;</p>
</li>
<li>
<p>参数：</p>
</li>
</ol>
<ul>
<li>
<p>参数只有1个 省略小括号;</p>
</li>
<li>
<p>参数0个或多个，无法省略小括号;</p>
</li>
</ul>
<ol start="3">
<li>大括号{ }</li>
</ol>
<ul>
<li>如果 函数体代码只有一行可以省略 {}</li>
<li>函数体多行无法省略 {};</li>
</ul>
<ol start="4">
<li>返回值 return</li>
</ol>
<ul>
<li>
<p>函数体一行 有返回值 省略{} 的 同时 【必须省略 return】</p>
<div><pre><code><span>const</span> <span>a</span><span>=</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>99</span><span>;</span>
<span>}</span>
<span>//简化后；</span>
<span>const</span> <span>a</span><span>=</span><span>(</span><span>)</span><span>=></span><span>99</span><span>;</span>

console<span>.</span><span>log</span><span>(</span><span>a</span><span>(</span><span>)</span><span>)</span><span>;</span><span>//99</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
</ul>
<ol start="5">
<li>
<p>this指向改变；</p>
<div><pre><code>   <span>var</span> a <span>=</span> <span>{</span>
        nam<span>:</span> <span>'小明'</span><span>,</span>
        <span>eat</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>this</span><span>)</span><span>;</span>
            <span>//使用箭头函数会发生this指向改变；</span>
            <span>setTimeout</span><span>(</span> <span>(</span><span>)</span> <span>=></span><span>{</span>
                console<span>.</span><span>log</span><span>(</span><span>this</span><span>)</span><span>;</span><span>//此时的this不在是window;</span>
            <span>}</span><span>,</span><span>1000</span><span>)</span>
        <span>}</span><span>,</span>
    <span>}</span>

console<span>.</span><span>log</span><span>(</span>a<span>.</span><span>eat</span><span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
</ol>
<h2 id="属性赋值简写"> 属性赋值简写</h2>
<div><pre><code><span>let</span> name <span>=</span> <span>'妲己'</span>
<span>let</span> gender <span>=</span> <span>'女'</span>
<span>let</span> skill <span>=</span> <span>'傻笑'</span>

<span>//方式一：手动将同名的变量的值设置给对象中的同名属性；</span>
<span>let</span> hero <span>=</span> <span>{</span>
  name<span>:</span> name<span>,</span>
  gender<span>:</span> gender<span>,</span>
  skill<span>:</span> skill
<span>}</span><span>;</span>
<span>//方式二：对象属性赋值简写；</span>
<span>/</span>注意：属性名和值相同可以简写，否则不要这么做
<span>let</span> hero2 <span>=</span> <span>{</span>
  name<span>,</span>
  gender<span>,</span>
  skill
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ul>
<li><strong>对象中的 方法可以省略掉 : function</strong></li>
</ul>
<div><pre><code><span>const</span> person <span>=</span> <span>{</span>
  <span>//sayHi: function() {</span>
  <span>//  console.log('Hi~~~')</span>
  <span>//}</span>
  <span>// 可以省略  ：function ；</span>
  <span>sayHi</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'Hi~~~'</span><span>)</span>
  <span>}</span>
<span>}</span>

person<span>.</span><span>sayHi</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="展开"> 展开；</h2>
<h3 id="对象的展开"> 对象的展开；</h3>
<blockquote>
<p>概念：将对象中的成员自动添加到 另一个对象中;</p>
</blockquote>
<ul>
<li>同名属性会按照书写顺序后面的会把前面的覆盖；</li>
<li>可以展开多个对象；</li>
</ul>
<div><pre><code><span>//定义对象；</span>
<span>const</span> a<span>=</span><span>{</span>
    name<span>:</span> <span>'小明'</span><span>,</span>
    age<span>:</span> <span>18</span><span>,</span>
    <span>eat</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>"我叫"</span><span>+</span>a<span>.</span>name<span>+</span><span>"今年"</span><span>+</span>a<span>.</span>age<span>)</span>
        <span>return</span> <span>576</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>const</span> b<span>=</span><span>{</span>
    name<span>:</span> <span>'小红'</span><span>,</span>
    <span>//对象展开；会把小红覆盖掉；</span>
    <span>...</span>a<span>,</span>
<span>}</span>

console<span>.</span><span>log</span><span>(</span>b<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="数组的展开"> 数组的展开；</h3>
<blockquote>
<p>概念：将数组中的元素自动添加到另一个数组中;</p>
</blockquote>
<ul>
<li><strong>不会覆盖</strong>；</li>
<li>可以展开多个；</li>
</ul>
<div><pre><code><span>//定义数组；</span>
<span>const</span> a<span>=</span><span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>,</span><span>7</span><span>]</span><span>;</span>
<span>const</span> c<span>=</span><span>[</span><span>'a'</span><span>,</span><span>'b'</span><span>,</span><span>'c'</span><span>]</span>

<span>const</span> b<span>=</span><span>[</span><span>'a'</span><span>,</span><span>'b'</span><span>,</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>...</span>a<span>,</span><span>...</span>c<span>]</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>b<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="模板字符串"> 模板字符串；</h2>
<blockquote>
<p>本质：就是一个字符串;</p>
<p>特点：</p>
<ul>
<li>可以换行；</li>
<li>挖坑(占位符) ，用来填充变量值；</li>
</ul>
</blockquote>
<div><pre><code><span>const</span> b<span>=</span><span>'hahahha'</span><span>;</span>

<span>const</span> a<span>=</span><span><span>`</span><span>
望庐山瀑布
日照香炉生</span><span><span>${</span>b<span>}</span></span><span>；
遥看瀑布挂前川；
飞流直下三千尺；
疑似银行落九天
</span><span>`</span></span><span>;</span>

console<span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="node模块"> <code>node</code>模块；</h2>
<blockquote>
<p>注：node有很多模块，它在我们安装时就内置在了里面；直接可以使用但是需要我们自己导入；</p>
<p>​	1、浏览器不能读取计算机的文件；</p>
<p>​	2、但是node.js可以读取计算机的文件；</p>
</blockquote>
<div><pre><code><span>//文件的读；</span>
<span>//导包：可以理解为调用了node的内置的方法；</span>
<span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>
<span>//查文档找读取文件的使用方式；</span>
fs<span>.</span><span>readFile</span><span>(</span><span>'./nav.text'</span><span>,</span><span>'UTF-8'</span> <span>,</span><span>(</span><span>(</span><span>err<span>,</span> data</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>err<span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>data<span>)</span><span>;</span>
<span>}</span><span>)</span><span>)</span>

<span>//写文件；</span>
<span>const</span> a<span>=</span><span>'晚上好晚上好'</span><span>;</span>
<span>const</span> fs<span>=</span><span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>
fs<span>.</span><span>writeFile</span><span>(</span><span>'./nav.text'</span><span>,</span>a<span>,</span><span>err</span><span>=></span> <span>{</span>
console<span>.</span><span>log</span><span>(</span>err<span>)</span><span>//Null  表示文件写入成功；</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="第三方模块"> 第三方模块</h3>
<ul>
<li>
<p>找包 ： <a href="npmjs.com">npmjs.com</a> 去找 ，如果被墙，就去 淘宝镜像 <a href="">npm.taobao.org</a></p>
</li>
<li>
<p>下载包：</p>
<ul>
<li>下载包之前务必找到要使用第三方模块的项目文件夹 ；</li>
<li>再执行 npm 的安装包的命令；</li>
</ul>
</li>
<li>
<p>导包</p>
<ul>
<li>使用 require('包名') 导入已经下载的模块包；</li>
<li>使用 const 常量保存导入的对象，常量名 一般保持 和 包名一致</li>
</ul>
</li>
<li>
<p>用包</p>
<ul>
<li>使用 导入的包中提供的方法，完成我们需要的功能；</li>
</ul>
</li>
</ul>
<h3 id="node-js模块化"> node.js模块化；</h3>
<ol>
<li>
<p>导入模块使用:<code>require()</code></p>
</li>
<li>
<p>导出模块使用:<code>module.exports</code>;</p>
<ol>
<li>暴露多个，用对象方式;</li>
<li>重复为<code>module.exports</code>赋值后面的会把前面的覆盖;</li>
</ol>
<div><pre><code><span>/</span>自己写的模块；
<span>//写自己的变量；</span>
<span>const</span> name <span>=</span> <span>'中午好'</span><span>;</span>
<span>const</span> age <span>=</span> <span>18</span><span>;</span>

<span>//暴露出去；module 是关键字，全局变量</span>
module<span>.</span>exports <span>=</span> <span>{</span>
    name<span>,</span>
    age<span>,</span>
    <span>sayhi</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'你好啊'</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>//导包；注意：要写路径；</span>
<span>const</span> qw <span>=</span> <span>require</span><span>(</span><span>'./text/zi'</span><span>)</span><span>;</span>

<span>//调用；</span>
console<span>.</span><span>log</span><span>(</span>
    qw<span>.</span>age<span>,</span>
    qw<span>.</span>name<span>,</span>
    qw<span>.</span><span>sayhi</span><span>(</span><span>)</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div></li>
</ol>
<h2 id="同步-异步"> 同步&amp;异步</h2>
<h3 id="同步"> 同步</h3>
<ul>
<li>代码中 ：代码从上往下执行</li>
<li>现实中 ：排队</li>
</ul>
<h3 id="异步"> 异步</h3>
<ul>
<li>代码中：多段代码一起执行（调用的顺序和预料的不同）
<ul>
<li>定时器，回调函数</li>
<li>Ajax 异步</li>
</ul>
</li>
<li>现实中：多件事同时干，互不影响</li>
</ul>
<h3 id="_12-3-注意点"> 12.3 注意点</h3>
<ol>
<li>
<p>绝大多数的代码都是同步的</p>
</li>
<li>
<p>NodeJS中有大量的异步方法，判断依据：如果有回调函数 大部分情况都是异步</p>
</li>
<li>
<p>判断依据二：跟 网络 、硬盘、内存 打交道的操作 一般 都是 异步的！</p>
<ul>
<li>
<p>定时器</p>
</li>
<li>
<p>fs读写文件</p>
</li>
<li>
<p>ajax （浏览器）</p>
</li>
<li>
<p>jQuery动画回调函数（浏览器）</p>
<p><code>$('div').animte({height:100},function(){})</code></p>
</li>
</ul>
</li>
</ol>
<h2 id="相对路径"> 相对路径；</h2>
<blockquote>
<p>注：node.js文件中的相对路径，是相对与终端中的路径；</p>
</blockquote>
<p><img src="./assets/1571999468418.png" alt="1571999468418" /></p>
<h2 id="两个全局变量"> 两个全局变量；</h2>
<blockquote>
<p>注：直接可以使用；</p>
<p>​	1.nodeJS 不要使用相对路径，而要使用绝对路径；</p>
</blockquote>
<ul>
<li>__dirname：获取执行文件所处的文件夹的 <strong>绝对路径</strong>；</li>
<li>__filename：获取执行文件自己的 <strong>相对路径</strong>；</li>
</ul>
<div><pre><code><span>//引入模块；</span>
<span>const</span> fs<span>=</span><span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>

<span>//拼接路径；注：拼接的路径最前面不要加 . ;</span>
<span>const</span> fsfile<span>=</span>__dirname<span>+</span><span>'/text/test.text'</span><span>;</span>

<span>//读取文件；</span>
 fs<span>.</span><span>readFile</span><span>(</span>fsfile<span>,</span><span>'utf-8'</span><span>,</span><span>function</span> <span>(</span><span>err<span>,</span>data</span><span>)</span> <span>{</span>
     <span>if</span> <span>(</span>err<span>==</span><span>null</span><span>)</span> <span>{</span>
         console<span>.</span><span>log</span><span>(</span><span>'我读取成功了'</span><span>)</span><span>;</span>
     <span>}</span> <span>else</span><span>{</span>
         console<span>.</span><span>log</span><span>(</span><span>'我读取失败了'</span><span>)</span>
         console<span>.</span><span>log</span><span>(</span>err<span>)</span><span>;</span>
     <span>}</span>
 <span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="path模块"> Path模块；</h2>
<blockquote>
<p>模块提供用于处理文件路径和目录路径的实用工具；</p>
</blockquote>
<div><pre><code><span>//使用方法；导入模块；</span>
<span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li><code>join</code>方法；
<ul>
<li>主要用来拼接路径；</li>
</ul>
</li>
</ul>
<div><pre><code><span>//导包；</span>
<span>const</span> fs<span>=</span><span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>
<span>const</span> path<span>=</span><span>require</span><span>(</span><span>'path'</span><span>)</span><span>;</span>

<span>//生成绝对路径；</span>
c<span>=</span>path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span><span>'text'</span><span>,</span><span>'test.text'</span><span>)</span><span>;</span><span>//可以不加`/`不加`.`,可以智能改错；</span>
c<span>=</span>path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span><span>'./text/test.text'</span><span>)</span><span>;</span>

<span>//读取文件；</span>
fs<span>.</span><span>readFile</span><span>(</span>c<span>,</span><span>'utf-8'</span><span>,</span><span>(</span><span>err<span>,</span>data</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span>err<span>==</span><span>null</span><span>)</span> <span>{</span>
        <span>//返回读取到的文件内容；</span>
        console<span>.</span><span>log</span><span>(</span>data<span>)</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="http模块"> http模块；</h2>
<blockquote>
<p>node内置的服务器模块，可以让程序员方便的开发web服务器程序;</p>
<p>http模块。开启的服务是http服务，访问时要带上；<code>http://</code></p>
</blockquote>
<ol>
<li>
<p><strong>创建服务器；</strong></p>
<div><pre><code><span>//导入内置模块；</span>
<span>const</span> http<span>=</span><span>require</span><span>(</span><span>'http'</span><span>)</span><span>;</span>
<span>//创建服务器；</span>
<span>const</span> server<span>=</span>http<span>.</span><span>createServer</span><span>(</span><span>function</span> <span>(</span><span>request<span>,</span>response</span><span>)</span> <span>{</span>
    <span>//返回响应；</span>
    response<span>.</span><span>end</span><span>(</span><span>'wo fan hui le'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
<span>//开启服务器开始监听；参数：匿名函数是开启后的回调函数；</span>
<span>// 参数1 端口号</span>
<span>// 参数2 监听的地址 省略的话就是本机,</span>
<span>// 参数3 开启之后的回调函数</span>
server<span>.</span><span>listen</span><span>(</span><span>8889</span><span>,</span><span>function</span> <span>(</span><span>err</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>err<span>==</span><span>null</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'开启成功了'</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'开启失败'</span><span>)</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></li>
<li>
<p><strong>响应中英文：</strong></p>
<div><pre><code><span>//响应英文；</span>
<span>//导入内置模块；</span>
<span>const</span> http<span>=</span><span>require</span><span>(</span><span>'http'</span><span>)</span><span>;</span>
<span>//创建服务器；</span>
<span>const</span> server<span>=</span>http<span>.</span><span>createServer</span><span>(</span><span>function</span> <span>(</span><span>request<span>,</span>response</span><span>)</span> <span>{</span>
    <span>//设置请求头，可以访问 中文 文件；</span>
    response<span>.</span><span>setHeader</span><span>(</span><span>'content-type'</span><span>,</span><span>'text/plain;charset=utf-8'</span><span>)</span><span>;</span>
    <span>//返回响应；</span>
    <span>// response.end('wo fan hui le');//若是英文则可以直接访问；</span>
    response<span>.</span><span>end</span><span>(</span><span>'我返回了'</span><span>)</span><span>;</span><span>//若是中文则需设置请求头；</span>
<span>}</span><span>)</span><span>;</span>
<span>//开启服务器开始监听；参数：匿名函数是开启后的回调函数；</span>
server<span>.</span><span>listen</span><span>(</span><span>8889</span><span>,</span><span>function</span> <span>(</span><span>err</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>err<span>==</span><span>null</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'开启成功了'</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'开启失败'</span><span>)</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div></li>
<li>
<p><strong>响应网页；</strong></p>
<ul>
<li>**request：**会把请求的信息都保存在这个对象中；</li>
</ul>
<div><pre><code><span>//导入内置模块；</span>
<span>const</span> http<span>=</span><span>require</span><span>(</span><span>'http'</span><span>)</span><span>;</span><span>//用于创建服务器；</span>
<span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span><span>//用于读写文件；</span>
<span>const</span> path<span>=</span><span>require</span><span>(</span><span>'path'</span><span>)</span><span>;</span><span>//用于生成路径；</span>

<span>//创建服务器；</span>
<span>const</span> server<span>=</span>http<span>.</span><span>createServer</span><span>(</span><span>function</span> <span>(</span><span>request<span>,</span>response</span><span>)</span> <span>{</span>
    <span>//接收请求地址并转码；不然会乱码；</span>
    <span>const</span> requestUrl <span>=</span> <span>decodeURI</span><span>(</span>request<span>.</span>url<span>)</span><span>;</span>
    
    <span>//拼接路径；</span>
    <span>const</span> p_flie<span>=</span>path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span><span>'./web'</span><span>,</span>requestUrl<span>)</span><span>;</span>
    
    <span>//拼接后的路径被写死了，导致可以请求成功但是响应结果依然是hrml结构；</span>
    <span>// const p_flie=path.join(__dirname,'./web/index.html');</span>

    <span>//由于请求头的设置，导致虽然读取到了html文件，但是无法解析；plain：表示普通文本；</span>
    <span>// response.setHeader('content-type','text/plain;charset=utf-8');</span>

    <span>/*
    * 读取文件；此时的参数中不需要再设置编码格式，因为在html中，已有utf-8了；
    * 如果设置了会由于编码格式的限制导致无法解析图片；*/</span>
    fs<span>.</span><span>readFile</span><span>(</span>p_flie<span>,</span><span>function</span> <span>(</span><span>err<span>,</span> data</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>err<span>==</span><span>null</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>'我读取到文件了'</span><span>)</span><span>;</span>
            
            <span>//读取成功则返回响应；</span>
            response<span>.</span><span>end</span><span>(</span>data<span>)</span><span>;</span>
        <span>}</span> <span>else</span><span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>'我没读到文件'</span><span>)</span><span>;</span>
            
            <span>//此处设置请求头，时因为下面的`h1`标签；</span>
            response<span>.</span><span>setHeader</span><span>(</span><span>'content-type'</span><span>,</span><span>'text/html;charset=utf-8'</span><span>)</span><span>;</span>
            
      		<span>// 找不到就 提示404</span>
      		response<span>.</span><span>end</span><span>(</span><span><span>`</span><span>&lt;h1> 404 你要的页面去火星了&lt;/h1></span><span>`</span></span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span><span>)</span>
<span>}</span><span>)</span><span>;</span>

<span>//开启服务器开始监听；参数：匿名函数是开启后的回调函数；</span>
server<span>.</span><span>listen</span><span>(</span><span>8889</span><span>,</span><span>function</span> <span>(</span><span>err</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>err<span>==</span><span>null</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'开启成功了'</span><span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'开启失败'</span><span>)</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div></li>
<li>
<p><strong>获取请求的方式；</strong></p>
<ul>
<li>request.method获取请求的方式；<code>GET</code>或<code>POST</code>;</li>
</ul>
</li>
</ol>
<h2 id="express模块"> <code>express</code>模块；</h2>
<h3 id="注册get路由"> 注册<code>get</code>路由；</h3>
<ul>
<li>Express 框架核心特性;
<ul>
<li>用来创建服务器对象；</li>
<li>可以设置中间件来响应 HTTP 请求。</li>
<li>定义了路由表用于执行不同的 HTTP 请求动作。</li>
<li>可以通过向模板传递参数来动态渲染 HTML 页面。</li>
<li>可以实现服务器的功能；</li>
</ul>
</li>
</ul>
<h4 id="静态资源托管"> 静态资源托管；</h4>
<div><pre><code><span>//导包；</span>
<span>const</span> express<span>=</span><span>require</span><span>(</span><span>'express'</span><span>)</span><span>;</span>

<span>//创建服务器对象；</span>
<span>const</span> app<span>=</span><span>express</span><span>(</span><span>)</span><span>;</span>

<span>/*
* 托管静态资源，实现服务器的功能；
* 参数为中间件的处理函数；此处的
* 地址可以用相对路径./或../；*/</span>
app<span>.</span><span>use</span><span>(</span>express<span>.</span><span>static</span><span>(</span><span>'web'</span><span>)</span><span>)</span><span>;</span>

<span>//开启服务器；</span>
app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>,</span><span>err</span><span>=></span><span>{</span>
    <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'开启成功'</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h4 id="例-2"> 例；</h4>
<ul>
<li><code>get</code>请求时；客户端提交的数据，在url后面；可以直接获取；</li>
</ul>
<div><pre><code>
<span>//导包；导出模块；</span>
<span>const</span> express <span>=</span> <span>require</span><span>(</span><span>'express'</span><span>)</span><span>;</span>
<span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>
<span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span><span>;</span>

<span>/*
* 创建服务器对象；创建一个Express应用程序。
* 该express()函数是express模块导出的顶级函数。*/</span>
<span>const</span> app <span>=</span> <span>express</span><span>(</span><span>)</span><span>;</span>

<span>//注册路由；注意：不要加 .</span>
app<span>.</span><span>get</span><span>(</span><span>'/jokes'</span><span>,</span> <span>function</span> <span>(</span><span>request<span>,</span> response</span><span>)</span> <span>{</span>
    <span>//创建路径；</span>
    <span>const</span> fsfile <span>=</span> path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>'./jokes.json'</span><span>)</span><span>;</span>

    <span>//读取文件；</span>
    fs<span>.</span><span>readFile</span><span>(</span>fsfile<span>,</span> <span>function</span> <span>(</span><span>err<span>,</span> data</span><span>)</span> <span>{</span>
        <span>//判断；</span>
        <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>'我读取到文件了'</span><span>)</span><span>;</span>
            <span>//把读取到的文件进行转换；</span>
            <span>const</span> arr <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span>data<span>)</span><span>;</span>
            <span>//获取地址的输入信息；</span>
            <span>const</span> num <span>=</span> request<span>.</span>query<span>.</span>num<span>;</span>
            <span>//定义空数组；</span>
            <span>const</span> jokes <span>=</span> <span>[</span><span>]</span><span>;</span>
            <span>//循环获取一定数量的笑话，并存放到数组中；</span>
            <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> num<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                <span>//获取随机数；</span>
                <span>const</span> ram <span>=</span> <span>parseInt</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> arr<span>.</span>length<span>)</span><span>;</span>
                jokes<span>.</span><span>push</span><span>(</span>arr<span>[</span>ram<span>]</span><span>)</span>
            <span>}</span>
            <span>//判断笑话数是否在此范围；</span>
            <span>if</span> <span>(</span>num<span>&lt;</span>arr<span>.</span>length<span>)</span> <span>{</span>
                <span>//返回响应；定义一个对象用于返回；</span>
                response<span>.</span><span>send</span><span>(</span><span>{</span>
                    num<span>,</span>
                    msg<span>:</span> <span>'获取成功'</span><span>,</span>
                    jokes<span>,</span>
                <span>}</span><span>)</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                response<span>.</span><span>send</span><span>(</span><span>{</span>
                    num<span>,</span>
                    msg<span>:</span> <span>'获取失败，请重新输入'</span><span>,</span>
                <span>}</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span> <span>else</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>'我没有读取到文件'</span><span>)</span>
        <span>}</span>
    <span>}</span><span>)</span>
<span>}</span><span>)</span><span>;</span>

<span>//开启服务器开始监听；</span>
app<span>.</span><span>listen</span><span>(</span><span>8889</span><span>,</span> <span>function</span> <span>(</span><span>err</span><span>)</span> <span>{</span>
    <span>//判断；</span>
    <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'开启服务器成功'</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'开启服务器失败了'</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div><h3 id="注册post路由"> 注册<code>post</code>路由；</h3>
<h4 id="例-3"> 例：</h4>
<div><pre><code><span>/</span>单文件上传；

<span>//导包；</span>
<span>const</span> express <span>=</span> <span>require</span><span>(</span><span>'express'</span><span>)</span><span>;</span>
<span>//用于生成路径；</span>
<span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span><span>;</span>
<span>//中间件；用于处理上传的文件；</span>
<span>const</span> FileUpload <span>=</span> <span>require</span><span>(</span><span>'express-fileupload'</span><span>)</span><span>;</span>

<span>//创建服务器对象；</span>
<span>const</span> app <span>=</span> <span>express</span><span>(</span><span>)</span><span>;</span>

<span>//处理中间件；</span>
app<span>.</span><span>use</span><span>(</span><span>FileUpload</span><span>(</span><span>)</span><span>)</span><span>;</span>

<span>//注册路由；</span>
app<span>.</span><span>post</span><span>(</span><span>'/fileupload'</span><span>,</span> <span>function</span> <span>(</span><span>resquest<span>,</span> response</span><span>)</span> <span>{</span>
    <span>//获取文件的名字；resquest.files==>获取的是个对象；</span>
    <span>//多文件上传时；icon==>是个数组；</span>
    <span>const</span> filename <span>=</span> resquest<span>.</span>files<span>.</span>icon<span>;</span>
    <span>//生成文件路径；</span>
    <span>const</span> filepath <span>=</span> path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>'./files'</span><span>,</span> filename<span>.</span>name<span>)</span><span>;</span>
    <span>//移动到文件夹中；每一个文件对象都有 mv 方法；</span>
    filename<span>.</span><span>mv</span><span>(</span>filepath<span>,</span> <span>function</span> <span>(</span><span>err</span><span>)</span> <span>{</span>
        <span>//判断；</span>
        <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>'文件移入成功了'</span><span>)</span>
        <span>}</span> <span>else</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>'文件移入失败了哦'</span><span>)</span>
        <span>}</span>
    <span>}</span><span>)</span>
<span>}</span><span>)</span>

<span>//开启路由开始监听；</span>
app<span>.</span><span>listen</span><span>(</span><span>8889</span><span>,</span> <span>function</span> <span>(</span><span>err</span><span>)</span> <span>{</span>
    <span>//判断；</span>
    <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'开启成功了'</span><span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'开启失败了'</span><span>)</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><h4 id="例-4"> 例：</h4>
<div><pre><code><span>/</span>验证用户名；

<span>//导包；</span>
<span>const</span> express<span>=</span><span>require</span><span>(</span><span>'express'</span><span>)</span><span>;</span>
<span>//导包，中间件；</span>
<span>const</span> bodyParser<span>=</span><span>require</span><span>(</span><span>'body-parser'</span><span>)</span><span>;</span>

<span>//创建服务器；</span>
<span>const</span> app<span>=</span><span>express</span><span>(</span><span>)</span><span>;</span>

<span>//解析中间件；</span>
app<span>.</span><span>use</span><span>(</span>bodyParser<span>.</span><span>urlencoded</span><span>(</span><span>{</span>extended<span>:</span> <span>false</span><span>}</span><span>)</span><span>)</span>

<span>//注册路由；默认的post请求无法获取到提交的数据；</span>
app<span>.</span><span>post</span><span>(</span><span>'/username'</span><span>,</span><span>function</span> <span>(</span><span>request<span>,</span>response</span><span>)</span> <span>{</span>
    <span>//定义一个用户名的数组来模拟；</span>
    <span>const</span> arruser<span>=</span><span>[</span><span>'孙悟空'</span><span>,</span><span>'猪八戒'</span><span>,</span><span>'唐僧'</span><span>,</span><span>'沙和尚'</span><span>,</span><span>'如来'</span><span>]</span>
    <span>//获取用户提交的数据；</span>
    <span>const</span> username<span>=</span>request<span>.</span>body<span>.</span>username<span>;</span>
    console<span>.</span><span>log</span><span>(</span>request<span>.</span>body<span>)</span>
    <span>//判断数组中是否有此用户名；</span>
    <span>const</span> num<span>=</span>arruser<span>.</span><span>indexOf</span><span>(</span>username<span>)</span>
     <span>if</span> <span>(</span>num<span>==</span><span>-</span><span>1</span><span>)</span> <span>{</span>
         <span>//返回响应；</span>
         response<span>.</span><span>send</span><span>(</span><span>{</span>
             msg<span>:</span> <span>'恭喜你，可以注册'</span><span>,</span>
             code<span>:</span> <span>200</span><span>,</span>
         <span>}</span><span>)</span><span>;</span>
     <span>}</span><span>else</span><span>{</span>
         response<span>.</span><span>send</span><span>(</span><span>{</span>
             msg<span>:</span> <span>'很遗憾，已被注册'</span><span>,</span>
             code<span>:</span> <span>400</span><span>,</span>
         <span>}</span><span>)</span>
     <span>}</span>
<span>}</span><span>)</span>

<span>//开启服务器开始监听；</span>
app<span>.</span><span>listen</span><span>(</span><span>8889</span><span>,</span><span>function</span> <span>(</span><span>err</span><span>)</span> <span>{</span>
    <span>//判断；</span>
    <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'开启成功了'</span><span>)</span>
    <span>}</span> <span>else</span><span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'开启失败了哦'</span><span>)</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br></div></div><h2 id="nodemon"> nodemon；</h2>
<blockquote>
<p>node 的一个 <code>全局模块</code></p>
<p>安装了之后可以自动检测文件修改，自动重新运行</p>
<ol>
<li>任意位置执行<code>npm i nodemon -g</code></li>
<li>安装完毕之后
<ol>
<li><code>node xxx</code></li>
<li>换成;</li>
<li><code>nodemon xxx</code></li>
</ol>
</li>
</ol>
</blockquote>
<h2 id="跨域"> 跨域；</h2>
<blockquote>
<p>概念：<strong>浏览器使用 <code>ajax</code>时</strong>，如果请求了的<strong>接口地址</strong> 和当前**<code>打开的页面</code><strong>地址</strong><code>不同源</code>**称之为跨域；</p>
</blockquote>
<ol>
<li>同源： 两个url<code>协议</code>地址<code>与</code>端口均一致；</li>
<li>不同源；三个有一个不一同，则为不同源，称之为跨域；</li>
</ol>
<h3 id="跨域的解决方式"> 跨域的解决方式；</h3>
<h4 id="cors-跨域资源共享"> <strong>CORS（跨域资源共享）；</strong></h4>
<ul>
<li>
<p>目前最主流也是最简单的解决方案；</p>
</li>
<li>
<p>工作原理：</p>
<ul>
<li>
<p>服务器在返回响应报文的时候，在响应头中设置一个允许的header ；</p>
</li>
<li>
<p><code>res.setHeader('Access-Control-Allow-Origin', '*');</code></p>
</li>
<li>
<p>让浏览器准许访问来自不同服务器上的指定资源；</p>
<div><pre><code><span>// 注册路由；</span>
app<span>.</span><span>post</span><span>(</span><span>'/corsPOST'</span><span>,</span> <span>(</span><span>request<span>,</span> response</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'请求过来了-post'</span><span>)</span><span>;</span>
    <span>// 设置允许跨域</span>
    response<span>.</span><span>header</span><span>(</span><span>'Access-Control-Allow-Origin'</span><span>,</span> <span>'*'</span><span>)</span><span>;</span>
    response<span>.</span><span>send</span><span>(</span><span>'/post'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
</ul>
</li>
</ul>
<blockquote>
<p><strong>注：</strong></p>
<ol>
<li>get请求时：如果第一次请求成功，则由于缓存的存在，那么如果去掉允许跨域的代码片段；依然可以请求成功;</li>
<li>虽热有跨域问题的出现，但是依然可以发送请求，但是无法接收响应的结果；</li>
</ol>
</blockquote>
<h4 id="cors中间件"> <strong>cors中间件；</strong></h4>
<ul>
<li>
<p>基层原理；</p>
<div><pre><code>app<span>.</span><span>use</span><span>(</span><span>(</span><span>req<span>,</span> res<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
  <span>//任何请求都会进入这个use中间件</span>
  res<span>.</span><span>setHeader</span><span>(</span><span>'Access-Control-Allow-Origin'</span><span>,</span> <span>'*'</span><span>)</span><span>//设置响应头</span>
  <span>next</span><span>(</span><span>)</span><span>//执行下一个中间件</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p><code>express</code>的中间件<code>cors</code>，它的作用是自动给每一个res设置默认请求头;<strong>需要下包</strong>  npm i cors</p>
<div><pre><code> <span>//ajax请求；</span>
<span>$</span><span>(</span><span>".get"</span><span>)</span><span>.</span><span>click</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
            $<span>.</span><span>ajax</span><span>(</span><span>{</span>
                url<span>:</span> <span>"http://192.168.156.26:8889/list"</span><span>,</span>
                <span>success</span><span>(</span><span>backData</span><span>)</span> <span>{</span>
                    console<span>.</span><span>log</span><span>(</span>backData<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span><span>)</span>
        <span>}</span><span>)</span>

<span>//导包；</span>
<span>const</span> express<span>=</span><span>require</span><span>(</span><span>'express'</span><span>)</span><span>;</span>
<span>//中间件;</span>
<span>const</span> cors<span>=</span><span>require</span><span>(</span><span>'cors'</span><span>)</span><span>;</span>

<span>//创建服务器对象；</span>
<span>const</span> app<span>=</span><span>express</span><span>(</span><span>)</span><span>;</span>
<span>//使用中间件来设置默认请求头；</span>
app<span>.</span><span>use</span><span>(</span><span>cors</span><span>(</span><span>)</span><span>)</span><span>;</span>

<span>//注册路由；</span>
app<span>.</span><span>get</span><span>(</span><span>'/list'</span><span>,</span><span>function</span> <span>(</span><span>request<span>,</span>response</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'我被请求了==get'</span><span>)</span><span>;</span>
    response<span>.</span><span>send</span><span>(</span><span>'我返回了'</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

app<span>.</span><span>post</span><span>(</span><span>'/add'</span><span>,</span><span>function</span> <span>(</span><span>request<span>,</span>response</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'我被请求了==post'</span><span>)</span><span>;</span>
    response<span>.</span><span>send</span><span>(</span><span>'我返回了'</span><span>)</span>
<span>}</span><span>)</span>

<span>//开启服务器，开始监听；</span>
app<span>.</span><span>listen</span><span>(</span><span>8889</span><span>,</span><span>function</span> <span>(</span><span>err</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'开启成功'</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div></li>
</ul>
<h4 id="jsonp"> <strong>JSONP;</strong></h4>
<blockquote>
<p>核心原理：如果script标签的src属性的请求，服务器返回的是一个函数调用。则浏览器会执行这个函数;</p>
<p>本质：会动态的在页面的顶部创建一个script标签，并进行解析为js一个函数的调用，并传入有个形参，之后会自动移出；</p>
</blockquote>
<div><pre><code><span>//用JSONP来解决跨域；必须是GET请求；</span>
<span>&lt;</span>input type<span>=</span><span>"button"</span> value<span>=</span><span>"jsonp跨域方案"</span> <span>class</span><span>=</span><span>"jsonp"</span><span>></span>

<span>$</span><span>(</span><span>'.jsonp'</span><span>)</span><span>.</span><span>click</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
            $<span>.</span><span>ajax</span><span>(</span><span>{</span>
                url<span>:</span> <span>'http://192.168.156.26:3000/jsonpApi'</span><span>,</span>
                data<span>:</span><span>{</span>
                    name<span>:</span><span>'rose'</span><span>,</span>
                    friend<span>:</span><span>'jack'</span><span>,</span>
                    skill<span>:</span><span>'抗冻'</span>
                <span>}</span><span>,</span>
                dataType<span>:</span><span>'jsonp'</span><span>,</span><span>//响应内容为jsonp格式的；</span>
                <span>success</span><span>(</span><span>backData</span><span>)</span> <span>{</span>
                    console<span>.</span><span>log</span><span>(</span>backData<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span><span>)</span>
        <span>}</span><span>)</span>


<span>// 导包</span>
<span>const</span> express <span>=</span> <span>require</span><span>(</span><span>'express'</span><span>)</span>
<span>// 创建服务器</span>
<span>const</span> app <span>=</span> <span>express</span><span>(</span><span>)</span>

<span>// 注册路由</span>
app<span>.</span><span>get</span><span>(</span><span>'/jsonpApi'</span><span>,</span><span>(</span><span>request<span>,</span>response</span><span>)</span><span>=></span><span>{</span>
    
    <span>// 响应内容 jsonp的接口 返回数据用`jsonp`</span>
    response<span>.</span><span>jsonp</span><span>(</span><span>{</span>
        msg<span>:</span><span>"请求成功"</span><span>,</span>
        code<span>:</span><span>200</span><span>,</span>
        info<span>:</span><span>"欢迎再来"</span>
    <span>}</span><span>)</span>
<span>}</span><span>)</span>

<span>// 开启服务器</span>
app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>,</span><span>(</span><span>err</span><span>)</span><span>=></span><span>{</span>
    <span>if</span><span>(</span><span>!</span>err<span>)</span><span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'success'</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><ol>
<li>
<p>原理：</p>
<ul>
<li>设置script标签的src属性，向一个不同源的接口发送一个get请求；
<ul>
<li><strong>JSONP只支持get请求，不支持post</strong></li>
</ul>
</li>
<li>src属性发送请求时，在参数中额外携带一个callback的参数，参数值是一个在页面中预先定于好的函数名
<ul>
<li>callback : 这是发明jsonp技术的人提出的一个<code>君子之约</code>，只要是jsonp前端程序员都统一将参数名定义为callback</li>
<li>callback属性值：预先定义的函数名，这个函数必须要在script标签之前定义</li>
</ul>
</li>
<li>服务器接收到请求之后，获取callback的参数值</li>
<li>服务器将要响应的数据拼接成  <code>函数调用格式</code>，通过传参的方式将响应数据返回给浏览器</li>
</ul>
<div><pre><code><span>&lt;</span>script<span>></span>
    <span>function</span> <span>doSomething</span><span>(</span><span>backData</span><span>)</span><span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>"调用了"</span><span>)</span><span>;</span>
        console<span>.</span><span>log</span><span>(</span>backData<span>)</span><span>;</span>
    <span>}</span>
<span>&lt;</span><span>/</span>script<span>></span>
<span>//去请求3000端口，jsonpApi接口时，函数会被调用；</span>
<span>&lt;</span>script src<span>=</span><span>"http://192.168.156.26:3000/jsonpApi?callback=doSomething"</span><span>></span>
<span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
</ol>
<h4 id="jsonp与cors区别"> <strong>JSONP与CORS区别</strong></h4>
<ul>
<li>CORS：
<ul>
<li>服务器返回响应头，前端无需任何处理</li>
<li>简单快捷，支持所有请求方式</li>
</ul>
</li>
<li>JSONP
<ul>
<li>浏览器：自定义响应回调函数，使用script标签的src请求
<ul>
<li>利用浏览器的src属性没有跨域这一限制特点</li>
</ul>
</li>
<li>服务器：接收callback参数，返回函数调用</li>
<li>处理复杂，并且只支持get请求
<ul>
<li><strong>原因：get请求参数直接在url后面拼接，而post请求参数是放在请求体中；</strong></li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>命令行输出目录树</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-01/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-01/</guid>
      <source url="https://wangyawei.top/rss.xml">命令行输出目录树</source>
      <category>nodejs</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="如何使用命令行输出目录树"> 如何使用命令行输出目录树</h2>
<blockquote>
<p>概述：在自己写博客的时候，总会少不了要显示目录结构以更好的表达一些内容；虽然<code>window</code>自己提供了<code>tree</code>命令但是并不好用；比如我要显示项目的目录结构但是要排除<code>node_modules</code>文件夹，这个时候就有点力不从心了，在这里推荐以下<code>tree-node-cli</code>工具；</p>
</blockquote>
<ol>
<li>
<p>下载：<code>tree-node-cli</code><a href="https://www.npmjs.com/package/tree-node-cli" target="_blank" rel="noopener noreferrer">传送门</a>。</p>
</li>
<li>
<p>安装：</p>
<div><pre><code><span>npm</span> <span>install</span> -g tree-node-cli
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>参数：</p>
<div><pre><code>$ tree -h
Usage: tree <span>[</span>options<span>]</span>

Options:
  -V, --version             output the version number
  -a, --all-files           All files, include hidden files, are printed.
  --dirs-first              List directories before files.
  -d, --dirs-only           List directories only.
  -I, --exclude <span>[</span>patterns<span>]</span>  Exclude files that match the pattern. <span>|</span> separates alternate patterns. Wrap your entire pattern <span>in</span> double
                            quotes. E.g. `<span>"node_modules|coverage"</span><span>.</span>
  -L, --max-depth <span>&lt;</span>n<span>></span>       Max display depth of the directory tree.
  -r, --reverse             Sort the output <span>in</span> reverse alphabetic order.
  -F, --trailing-slash      Append a <span>'/'</span> <span>for</span> directories.
  -h, --help                display <span>help</span> <span>for</span> <span>command</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></li>
<li>
<p>使用：直接打印输出；</p>
<div><pre><code>$ tree -L <span>2</span> -I <span>"node_modules"</span>
webNode
├── app
│   ├── app.js
│   ├── db
│   └── router
├── babel.config.js
├── bin
│   ├── build.js
│   └── dev.js
├── dist
│   ├── css
│   ├── favicon.ico
│   ├── img
│   ├── index.html
│   └── js
├── package-lock.json
├── package.json
├── plugins
│   └── md-loader
├── public
│   ├── favicon.ico
│   └── index.html
├── src
│   ├── App.vue
│   ├── assets
│   ├── index.js
│   ├── router
│   ├── <span>service</span>
│   └── views
└── webpack.config.js

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><blockquote>
<p>注意：这里我命令使用的是：<code>tree -L 2 -I &quot;node_modules&quot;</code>并没有使用<code>tree</code>命令那样它会把整个node_modules目录也给遍历出来，对我们来说是无用的。当然在不包含<code>node_modules</code>的目录下直接使用<code>tree</code>命令就行了。</p>
</blockquote>
</li>
<li>
<p>输出到单独的文件中；</p>
<div><pre><code><span><span>`</span>tree -L <span>2</span> -I <span>"node_modules"</span><span>`</span></span> <span>></span> text.md
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>如果文件不存在便会自己创建一个文件，如果存在的话便会覆盖里面的内容；</p>
</blockquote>
</li>
<li>
<p><a href="https://github.com/yangshun/tree-node-cli#readme" target="_blank" rel="noopener noreferrer">官方文档</a></p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>node版本管理工具-nvm</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-02/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-02/</guid>
      <source url="https://wangyawei.top/rss.xml">node版本管理工具-nvm</source>
      <category>nodejs</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>概述： nvm是一个nodejs的版本管理工具。我们可以通过它安装和切换不同版本的node.js。</p>
</blockquote>
<h3 id="_1、安装nvm"> 1、安装<code>nvm</code>；</h3>
<ul>
<li><a href="https://github.com/coreybutler/nvm-windows/releases" target="_blank" rel="noopener noreferrer">传送门</a></li>
<li>双击直接安装即可。</li>
</ul>
<h3 id="_2、测试"> 2、测试；</h3>
<ul>
<li>
<p>桌面打开cmd输入<code>nvm</code>,出现以下界面就说明安装成功；</p>
<div><pre><code>PS C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>></span> nvm

Running version <span>1.1</span>.7.

Usage:

  nvm arch                     <span>:</span> Show <span>if</span> node is running <span>in</span> <span>32</span> or <span>64</span> bit mode.
  nvm <span>install</span> <span>&lt;</span>version<span>></span> <span>[</span>arch<span>]</span> <span>:</span> The version can be a node.js version or <span>"latest"</span> <span>for</span> the latest stable version.
                                 Optionally specify whether to <span>install</span> the <span>32</span> or <span>64</span> bit version <span>(</span>defaults to system arch<span>)</span>.
                                 Set <span>[</span>arch<span>]</span> to <span>"all"</span> to <span>install</span> <span>32</span> AND <span>64</span> bit versions.
                                 Add --insecure to the end of this <span>command</span> to bypass SSL validation of the remote download server.
  nvm list <span>[</span>available<span>]</span>         <span>:</span> List the node.js installations. Type <span>"available"</span> at the end to see what can be installed. Aliased as ls.
  nvm on                       <span>:</span> Enable node.js version management.
  nvm off                      <span>:</span> Disable node.js version management.
  nvm proxy <span>[</span>url<span>]</span>              <span>:</span> Set a proxy to use <span>for</span> downloads. Leave <span>[</span>url<span>]</span> blank to see the current proxy.
                                 Set <span>[</span>url<span>]</span> to <span>"none"</span> to remove the proxy.
  nvm node_mirror <span>[</span>url<span>]</span>        <span>:</span> Set the node mirror. Defaults to https://nodejs.org/dist/. Leave <span>[</span>url<span>]</span> blank to use default url.
  nvm npm_mirror <span>[</span>url<span>]</span>         <span>:</span> Set the <span>npm</span> mirror. Defaults to https://github.com/npm/cli/archive/. Leave <span>[</span>url<span>]</span> blank to default url.
  nvm uninstall <span>&lt;</span>version<span>></span>      <span>:</span> The version must be a specific version.
  nvm use <span>[</span>version<span>]</span> <span>[</span>arch<span>]</span>     <span>:</span> Switch to use the specified version. Optionally specify <span>32</span>/64bit architecture.
                                 nvm use <span>&lt;</span>arch<span>></span> will <span>continue</span> using the selected version, but switch to <span>32</span>/64 bit mode.
  nvm root <span>[</span>path<span>]</span>              <span>:</span> Set the directory where nvm should store different versions of node.js.
                                 If <span>&lt;</span>path<span>></span> is not set, the current root will be displayed.
  nvm version                  <span>:</span> Displays the current running version of nvm <span>for</span> Windows. Aliased as v.

PS C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>></span> nvm list

No installations recognized.
PS C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div></li>
</ul>
<h3 id="_3、下载指定版本的node-js"> 3、下载指定版本的node.js</h3>
<ul>
<li>
<p>使用<code>nvm list</code>查看当前已安装的nodejs版本;（理论上应该是没有可用的版本的）；</p>
</li>
<li>
<p>使用<code>nvm install 8.9</code>来安装Nodejs8.9版本；使用<code>nvm list</code>查看；</p>
<div><pre><code>PS C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>></span> nvm list

  * <span>8.9</span>.0 <span>(</span>Currently using <span>64</span>-bit executable<span>)</span>
PS C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ul>
<h3 id="_4、使用指定的nodejs版本"> 4、使用指定的Nodejs版本；</h3>
<ul>
<li>
<p>命令；* 表示当前正在使用的版本。</p>
<div><pre><code><span># 使用nodsjs8.9版本；</span>
nvm use <span>15.8</span>

PS C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>></span> nvm use <span>8.9</span>
<span>8.9</span>.0
Now using node v8.9.0 <span>(</span><span>64</span>-bit<span>)</span>
PS C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>></span> nvm list

    <span>15.8</span>.0
    <span>10.0</span>.0
  * <span>8.9</span>.0 <span>(</span>Currently using <span>64</span>-bit executable<span>)</span>
PS C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>></span> node -v
v8.9.0
PS C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>></span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></li>
</ul>
<h3 id="_5、卸载nvm"> 5、卸载nvm</h3>
<p>直接在<code>程序和功能</code>中找到<code>NVM for Windows</code>点击卸载即可；</p>
<h3 id="_6、注意"> 6、注意</h3>
<p>首次安装Nodejs请安装全局的即<code>nvm install 12.22.3 -g</code> ，不然的话不可以<strong>全局使用</strong>，全局安装的会在<code>C:\Program Files</code>文件夹下生成<strong>nodejs软链接</strong>，指向你nvm安装并当前使用的Nodejs版本。</p>
]]></content:encoded>
    </item>
    <item>
      <title>node实现自动化部署</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-03/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-03/</guid>
      <source url="https://wangyawei.top/rss.xml">node实现自动化部署</source>
      <category>nodejs</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="node实现自动化部署"> node实现自动化部署；</h2>
<blockquote>
<p>说明：由于本人做的前端，Java就不太会，但是node确实一个对于前端同学写后端代码的一个非常好的技术。个人的项目前端是<code>vue</code>写的后端是<code>Nodejs</code>,同时利用<code>jenkjins</code>实现前后端自动化部署。</p>
</blockquote>
<h2 id="_1、项目上传"> 1、项目上传；</h2>
<blockquote>
<p>前端项目这里就不在概括，以下内容都是node部署内容；注：Node项目写完之后，不需要打包，直接把源码上传到你的远程服务器就可以了，我的服务器用的是阿里云Liunx服务器，下文提到的服务器皆为阿里云服务器。</p>
</blockquote>
<ol>
<li>把你的Node项目进行打包。(node_modules文件不要打包)。</li>
<li>登录你的服务器，然后新建一个文件夹。</li>
<li>把你的node代码上传到你的新建文件夹中。</li>
<li>把你的上传的Node项目解压缩到你的新建文件夹中。</li>
</ol>
<h2 id="_2、jenkins实现半自动化"> 2、<code>jenkins</code>实现半自动化；</h2>
<blockquote>
<p>为什么这里说是半自动化，因为实现了push拉取代码；但是Node并不会<strong>自动启动</strong>；</p>
</blockquote>
<ol>
<li>
<p>登录你的jenkins并新建立一个项目。</p>
</li>
<li>
<p>配置你的jenkins的shell命令。</p>
</li>
<li>
<p>具体的jenkins的git配置请查看我的另外一骗文章，传送门。</p>
</li>
<li>
<p>我的jenkins配置文件；</p>
<div><pre><code><span>#!/bin/bash</span>
<span>cd</span> /var/lib/jenkins/workspace/herolist <span>#进入Jenkins工作空间下herolist项目目录</span>
<span>tar</span> -zcvf heroList.tar.gz * <span>#把生成的项目打包成压缩包，方便移动到项目部署目录</span>
<span>cd</span> /www/herolist <span># 进入node项目根目录</span>
<span>mv</span> /var/lib/jenkins/workspace/heroList/heroList.tar.gz ./  <span># 移动刚刚打包好的项目到web项目根目录</span>
<span>tar</span> -zxvf heroList.tar.gz  <span># 解压项目到本目录</span>
<span>rm</span> -rf heroList.tar.gz <span># 删除压缩包</span>
<span>npm</span> <span>install</span> <span># 安装项目中的依赖</span>
<span># npm run dev # 项目启动。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>
<p>注意：当我们做到这里时，基本就算搞定了，但是还缺少重要的一步，就是node服务启动。</p>
<p>当一切都感觉完好时，却发现最后一行node服务启动报错，不过我没解决掉，具体的报错原因是：<code>Error: Cannot find module 'express'</code>。<strong>我的操作</strong>是在Liunx手动<code>npm run dev</code>运行是完好的，但是带来了另一个问题，远程服务不能关闭，不然Node就挂了，在网上找了不少方法可以使用，<code>nohup npm run dev &gt;myout.file 2&gt;&amp;1 &amp;</code> 持续运行node并把信息输出到指定的文件中,这样启动的Node服务就不会因为你退出终端而停止了。</p>
<p><strong>但是另一个问题便是，你用jjenkins进行新的构建时，node并不会重启，来加载你的新代码</strong>。<strong>看下文pm2解决</strong>；</p>
</blockquote>
</li>
</ol>
<h2 id="_3、jenkins-node-pm2实现自动化"> 3、<code>jenkins + node + pm2</code>实现自动化；</h2>
<p>条件：</p>
<ul>
<li>已完成jenkins和git的配置，</li>
<li>已经可以成功部署实现自动化；</li>
</ul>
<p><strong>1、安装<code>pm2</code>；</strong></p>
<div><pre><code><span>npm</span> <span>install</span> pm2 -g
</code></pre>
<div><span>1</span><br></div></div><p>测试；出现以下类似列表说明安装成功；</p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ herolist<span>]</span><span># pm2 list</span>
┌─────┬────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐
│ <span>id</span>  │ name   │ namespace   │ version │ mode    │ pid      │ <span>uptime</span> │ ↺    │ status    │ cpu      │ mem      │ user     │ watching │
├─────┼────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┼──────────┼──────────┼──────────┤
│ <span>0</span>   │ <span>npm</span>    │ default     │ N/A     │ fork    │ <span>0</span>        │ <span>0</span>      │ <span>30</span>   │ stopped   │ <span>0</span>%       │ 0b       │ root     │ disabled │
└─────┴────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘
<span>[</span>root@iZbp156pkpio44mis76wmxZ herolist<span>]</span><span># cd /</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><strong>2、使用；</strong></p>
<div><pre><code><span># 在你的Jenkins的项目配置文件的shell命令中在最后一行加上：</span>
pm2 restart <span>npm</span> -- run dev <span># 重启nodejs</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>3、测试</strong>；</p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ herolist<span>]</span><span># ps -ef | grep node </span>
root      <span>8981</span>  <span>6550</span>  <span>0</span> <span>22</span>:29 pts/0    00:00:00 <span>grep</span> --color<span>=</span>auto node <span># node启动前</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ herolist<span>]</span><span># ps -ef | grep node </span>
root      <span>9101</span>  <span>9088</span>  <span>0</span> <span>22</span>:29 ?        00:00:00 <span>sh</span> -c <span>export</span> <span>NODE_ENV</span><span>=</span>production <span>&amp;&amp;</span> node app.js
root      <span>9102</span>  <span>9101</span>  <span>3</span> <span>22</span>:29 ?        00:00:00 node app.js <span># node启动后</span>
root      <span>9126</span>  <span>6550</span>  <span>0</span> <span>22</span>:30 pts/0    00:00:00 <span>grep</span> --color<span>=</span>auto node
<span>[</span>root@iZbp156pkpio44mis76wmxZ herolist<span>]</span><span># </span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>4、常见pm2命令介绍</strong>；<a href="https://www.cnblogs.com/ywnh/p/14287631.html" target="_blank" rel="noopener noreferrer">传送门</a>；</p>
<p>到此自动化部署结束；</p>
<h2 id="_4、问题"> 4、问题；</h2>
<ol>
<li>
<p>jenkins执行pm2命令报错；<code>pm2: command not found</code>；</p>
<blockquote>
<p>一般情况下，如果我们全局安装了的话，在window上不会出现，但是liunx上好像不行，需要我们自己手动建立软连接，类似与window创建的环境变量。部分用户可能安装上 连基础的命令也不能使用，也是需要建立软连接的；</p>
</blockquote>
<div><pre><code><span>..</span><span>..</span><span>..</span>以上省略！
<span>[</span>heroList<span>]</span> $ /bin/sh -xe /tmp/jenkins4753469389532234169.sh
<span>[</span>heroList<span>]</span> $ /bin/sh -xe /tmp/jenkins259913818346979744.sh
+ pm2 start <span>npm</span> -- run dev
/tmp/jenkins259913818346979744.sh: line <span>6</span>: pm2: <span>command</span> not found
Build step <span>'Execute shell'</span> marked build as failure
Finished: FAILURE
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>解决：</p>
<div><pre><code><span># 找到pm2的安装根目录；我的：/home/local/mynode/node-v12.18.2-linux-x64/bin/pm2</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ herolist<span>]</span><span># npm install -g pm2 </span>
<span>npm</span> WARN deprecated debug@4.1.1: Debug versions <span>>=</span><span>3.2</span>.0 <span>&lt;</span><span>3.2</span>.7 <span>||</span> <span>>=</span><span>4</span> <span>&lt;</span><span>4.3</span>.1 have a low-severity ReDos regression when used <span>in</span> a Node.js environment. It is recommended you upgrade to <span>3.2</span>.7 or <span>4.3</span>.1. <span>(</span>https://github.com/visionmedia/debug/issues/797<span>)</span>
/home/local/mynode/node-v12.18.2-linux-x64/bin/pm2 -<span>></span> /home/local/mynode/node-v12.18.2-linux-x64/lib/node_modules/pm2/bin/pm2
/home/local/mynode/node-v12.18.2-linux-x64/bin/pm2-dev -<span>></span> /home/local/mynode/node-v12.18.2-linux-x64/lib/node_modules/pm2/bin/pm2-dev
/home/local/mynode/node-v12.18.2-linux-x64/bin/pm2-docker -<span>></span> /home/local/mynode/node-v12.18.2-linux-x64/lib/node_modules/pm2/bin/pm2-docker
/home/local/mynode/node-v12.18.2-linux-x64/bin/pm2-runtime -<span>></span> /home/local/mynode/node-v12.18.2-linux-x64/lib/node_modules/pm2/bin/pm2-runtime
<span>npm</span> WARN ws@7.2.5 requires a peer of bufferutil@^4.0.1 but none is installed. You must <span>install</span> peer dependencies yourself.
<span>npm</span> WARN ws@7.2.5 requires a peer of utf-8-validate@^5.0.2 but none is installed. You must <span>install</span> peer dependencies yourself.
<span>npm</span> WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@2.3.1 <span>(</span>node_modules/pm2/node_modules/fsevents<span>)</span>:
<span>npm</span> WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform <span>for</span> fsevents@2.3.1: wanted <span>{</span><span>"os"</span><span>:</span><span>"darwin"</span>,<span>"arch"</span><span>:</span><span>"any"</span><span>}</span> <span>(</span>current: <span>{</span><span>"os"</span><span>:</span><span>"linux"</span>,<span>"arch"</span><span>:</span><span>"x64"</span><span>}</span><span>)</span>

+ pm2@4.5.1
added <span>195</span> packages from <span>195</span> contributors <span>in</span> <span>9</span>.346s
<span>[</span>root@iZbp156pkpio44mis76wmxZ herolist<span>]</span><span># </span>
<span># 找到环境变量路径 %PATH; </span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># echo $PATH</span>
/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/home/local/JDK/jdk1.8.0_251/bin:/home/local/mynode/node-v12.18.2-linux-x64/bin:/home/local/maven/apache-maven-3.6.3/bin:/root/bin
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span>#</span>
<span># 建立软连接；</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># ln -s /home/local/mynode/node-v12.18.2-linux-x64/bin/pm2 /usr/local/bin/</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><blockquote>
<p>注意：第一次建立软连接后，我并没有解决 <code>pm2: command not found</code>。需要 /usr/local/bin/ 改为 /usr/bin/</p>
<p>完整命令：<code>ln -s /home/local/mynode/node-v12.18.2-linux-x64/bin/pm2 /usr/bin/</code></p>
</blockquote>
</li>
<li>
<p>测试；jenkins控制台输出日志；</p>
<div><pre><code><span>..</span><span>..</span><span>..</span>以上省略！
<span>[</span>heroList<span>]</span> $ /bin/sh -xe /tmp/jenkins4043641238157935034.sh
<span>[</span>heroList<span>]</span> $ /bin/sh -xe /tmp/jenkins4997403699140616984.sh
+ pm2 start <span>npm</span> -- run dev
<span>[</span>PM2<span>]</span> Applying action restartProcessId on app <span>[</span>npm<span>]</span><span>(</span>ids: <span>[</span> <span>0</span> <span>]</span><span>)</span>
<span>[</span>PM2<span>]</span> <span>[</span>npm<span>]</span><span>(</span><span>0</span><span>)</span> ✓
<span>[</span>PM2<span>]</span> Process successfully started
┌─────┬────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐
│ <span>id</span>  │ name   │ namespace   │ version │ mode    │ pid      │ <span>uptime</span> │ ↺    │ status    │ cpu      │ mem      │ user     │ watching │
├─────┼────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┼──────────┼──────────┼──────────┤
│ <span>0</span>   │ <span>npm</span>    │ default     │ N/A     │ fork    │ <span>10506</span>    │ 0s     │ <span>30</span>   │ online    │ <span>0</span>%       │ <span>3</span>.5mb    │ root     │ disabled │
└─────┴────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘
Finished: SUCCESS
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>pm2的使用</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-04/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-04/</guid>
      <source url="https://wangyawei.top/rss.xml">pm2的使用</source>
      <category>nodejs</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="pm2的简单使用"> pm2的简单使用</h1>
<blockquote>
<p>概述： PM2是具有内置负载平衡器的Node.js应用程序的生产过程管理器。它使您可以使应用程序永远保持活动状态，无需停机即可重新加载它们，并简化常见的系统管理任务。</p>
</blockquote>
<h2 id="_1、安装"> 1、安装；</h2>
<ul>
<li>
<p><a href="https://www.npmjs.com/package/pm2" target="_blank" rel="noopener noreferrer">下载PM2</a></p>
</li>
<li>
<p>安装；<code>npm install pm2 -g</code></p>
</li>
<li>
<p>测试；出现以下类似列表说明安装成功；</p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ herolist<span>]</span><span># pm2 list</span>
┌─────┬────────┬─────────────┬─────────┬─────────┬──────────┬────────┬──────┬───────────┬──────────┬──────────┬──────────┬──────────┐
│ <span>id</span>  │ name   │ namespace   │ version │ mode    │ pid      │ <span>uptime</span> │ ↺    │ status    │ cpu      │ mem      │ user     │ watching │
├─────┼────────┼─────────────┼─────────┼─────────┼──────────┼────────┼──────┼───────────┼──────────┼──────────┼──────────┼──────────┤
│ <span>0</span>   │ <span>npm</span>    │ default     │ N/A     │ fork    │ <span>0</span>        │ <span>0</span>      │ <span>30</span>   │ stopped   │ <span>0</span>%       │ 0b       │ root     │ disabled │
└─────┴────────┴─────────────┴─────────┴─────────┴──────────┴────────┴──────┴───────────┴──────────┴──────────┴──────────┴──────────┘
<span>[</span>root@iZbp156pkpio44mis76wmxZ herolist<span>]</span><span># cd /</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
</ul>
<h2 id="_2、命令"> 2、命令；</h2>
<p><a href="https://github.com/Unitech/pm2" target="_blank" rel="noopener noreferrer">githup传送门</a></p>
<div><pre><code><span># 安装pm2</span>
cnpm <span>install</span> pm2 -g

<span># 启动服务</span>
pm2 start app.js 

<span># 启动应用并设置name</span>
pm2 start app.js --name demo 

<span># 停止服务</span>
pm2 stop all <span># 停止所有应用</span>
pm2 stop <span>[</span>AppName<span>]</span> <span># 根据应用名停止指定应用</span>

<span># 删除应用</span>
<span># 关闭并删除应用</span>
pm2 delete all 

<span># 根据应用名关闭并删除应用</span>
pm2 delete <span>[</span>AppName<span>]</span> 

<span># 根据应用ID关闭并删除应用</span>
pm2 delete <span>[</span>ID<span>]</span> 

<span># 创建开机自启动</span>
pm2 startup

<span># 监听模式当文件发生变化，自动重启</span>
pm2 start app.js --watch 

<span># 重新启动</span>
pm2 restart app.js

<span># 更新PM2</span>
pm2 updatePM2
pm2 update

<span># 静态服务器 将目录dist作为静态服务器根目录，端口为9090</span>
pm2 serve ./dist <span>9090</span>

<span># 启用群集模式（自动负载均衡）</span>
pm2 start app.js -i max

<span># 0秒停机重新加载</span>
<span># 重新启动所有进程，始终保持至少一个进程在运行</span>
pm2 reload app.js 
<span># 优雅地以群集模式重新加载所有应用程序</span>
pm2 gracefulReload all 

<span># 查看启动列表</span>
pm2 list

<span># 日志查看</span>
m2 logs  <span># 查看所有应用日志</span>
pm2 logs <span>[</span>Name<span>]</span> <span># 根据指定应用名查看应用日志</span>
pm2 logs <span>[</span>ID<span>]</span> <span># 根据指定应用ID查看应用日志</span>

<span># 保存当前应用列表</span>
pm2 save

<span># 重启保存的应用列表</span>
pm2 resurrect

<span># 清除保存的应用列表</span>
pm2 cleardump

<span># 监控；</span>
pm2 monit
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br></div></div><h2 id="_3、使用"> 3、使用；</h2>
<ol>
<li>
<p>**方式一；**pm2 启动 <code>npm</code> 脚本</p>
<div><pre><code><span>"scripts"</span><span>:</span> <span>{</span>
  <span>"test"</span><span>:</span> <span>"echo <span title="\&quot;">\"</span>Error: no test specified<span title="\&quot;">\"</span> &amp;&amp; exit 1"</span>,
  <span>"start"</span><span>:</span> <span>"nodemon app.js"</span>,
  <span>"dev"</span><span>:</span> <span>"export NODE_ENV=production &amp;&amp; node app.js"</span>
<span>}</span>,
  
简单用法
<span>1</span>. <span>npm</span> run dev
<span>2</span>. pm2 start <span>npm</span> -- run dev 注意: -- run之间有一个空格<span>!</span><span>!</span>
以上使用是等效的

pm2 start <span>npm</span> --watch --name nickname -- run dev
其中 --watch监听代码变化，--name 重命令任务名称，-- run后面跟脚本名字
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></li>
<li>
<p>方式二；pm2 启动 app.js; 命令：<code>pm2 start app.js</code></p>
</li>
<li>
<p>方式三；pm2 根据配置文件启动npm脚本；</p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>后台持续运行node</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-05/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-05/</guid>
      <source url="https://wangyawei.top/rss.xml">后台持续运行node</source>
      <category>nodejs</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<h4 id="_1、后台持续运行nodejs"> 1、后台持续运行<code>nodejs</code></h4>
<div><pre><code><span># 持续运行node并把信息输出到指定的文件中</span>
<span>nohup</span> <span>npm</span> run dev <span>></span>myout.file <span><span>2</span>></span><span>&amp;1</span> <span>&amp;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>搭建本地服务</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-06/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-06/</guid>
      <source url="https://wangyawei.top/rss.xml">搭建本地服务</source>
      <category>nodejs</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="快速搭建本地服务"> 快速搭建本地服务</h2>
<blockquote>
<p>方式一、二、三单个js文件即可操作。</p>
</blockquote>
<h3 id="方式一"> 方式一：</h3>
<p>安装下载<code>serve</code>npm包。<a href="https://www.npmjs.com/package/serve" target="_blank" rel="noopener noreferrer">https://www.npmjs.com/package/serve</a></p>
<div><pre><code><span>npm</span> i serve

<span># 建议全局安装，</span>
<span>npm</span> i -g serve
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>安装完成你可以<code>serve -v</code>来查看版本号，至此安装成功了，</p>
<div><pre><code>serve -v
WARNING: Checking <span>for</span> updates failed <span>(</span>use <span><span>`</span>--debug<span>`</span></span> to see full error<span>)</span>
<span>11.3</span>.2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>直接在打开你的文件目录，执行<code>serve</code>就会直接启动一个服务，默认监听 <code>5000</code> 端口</p>
<blockquote>
<p>服务的启动的方式，还可以在 <code>serve fileName</code> 后面跟文件夹的名称，以此来作为服务启动的文件目录。</p>
</blockquote>
<div><pre><code>serve
WARNING: Checking <span>for</span> updates failed <span>(</span>use <span><span>`</span>--debug<span>`</span></span> to see full error<span>)</span>

   ┌───────────────────────────────────────────────────┐
   │                                                   │
   │   Serving<span>!</span>                                        │
   │                                                   │
   │   - Local:            http://localhost:5000       │
   │   - On Your Network:  http://192.168.137.1:5000   │
   │                                                   │
   │   Copied <span>local</span> address to clipboard<span>!</span>              │
   │                                                   │
   └───────────────────────────────────────────────────┘


</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>恭喜你服务搭建完成！</p>
<h2 id="方式二"> 方式二；</h2>
<p>使用node的<code>http</code>内置模块来快速的新建一个服务，</p>
<blockquote>
<p>此操作代表你已经安装了<code>nodejs</code>不然将不可用。</p>
</blockquote>
<div><pre><code><span>// 引入http包</span>
<span>const</span> http <span>=</span> <span>require</span><span>(</span><span>'http'</span><span>)</span>
<span>const</span> app <span>=</span> <span>new</span> <span>http<span>.</span>Server</span><span>(</span><span>)</span>
<span>// 侦听请求</span>
app<span>.</span><span>on</span><span>(</span><span>'request'</span><span>,</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>=></span> <span>{</span>
  res<span>.</span><span>writeHead</span><span>(</span><span>200</span><span>,</span> <span>{</span>
    <span>"Content-Type"</span><span>:</span> <span>'text/html;charset=UTF-8'</span><span>,</span>
  <span>}</span><span>)</span>
  <span>// 返回响应内容</span>
  res<span>.</span><span>write</span><span>(</span><span>'&lt;h1>Node.js-监听3000端口~&lt;/h1>'</span><span>)</span>
  <span>// 结束响应，此方法必须调用，不然客户端会一直处于等待状态。</span>
  res<span>.</span><span>end</span><span>(</span><span>)</span>
<span>}</span><span>)</span>
<span>// 监听 3000端口</span>
app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>,</span> <span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'开始监听3000端口'</span><span>)</span>
  <span>}</span>
<span>}</span><span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>shell中启动这个文件，<code>node fileName</code></p>
<div><pre><code>node <span>service</span>
开始监听3000端口
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="方式三"> 方式三；</h2>
<p>下载安装依赖<code>express</code>,<a href="https://www.npmjs.com/package/express" target="_blank" rel="noopener noreferrer">点击下载</a></p>
<div><pre><code><span>npm</span> i express
</code></pre>
<div><span>1</span><br></div></div><p>引入并创建服务</p>
<div><pre><code><span>// 引入包 express</span>
<span>const</span> express <span>=</span> <span>require</span><span>(</span><span>'express'</span><span>)</span>
<span>// 创建服务器；</span>
<span>const</span> app <span>=</span> <span>express</span><span>(</span><span>)</span>
<span>// 创建get请求</span>
app<span>.</span><span>get</span><span>(</span><span>'/'</span><span>,</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>=></span> <span>{</span>
  res<span>.</span><span>send</span><span>(</span><span>'请求成功'</span><span>)</span>
<span>}</span><span>)</span>
<span>// 启动服务；</span>
app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>,</span> <span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'server started on port 3000'</span><span>)</span>
  <span>}</span>
<span>}</span><span>)</span>

<span>// ============</span>
node service<span>.</span>js
server started on port <span>3000</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="方式四"> 方式四；</h2>
<blockquote>
<p>此种方式需要初始化一个项目，</p>
<ol>
<li>
<p>创建一个文件夹，</p>
</li>
<li>
<p>执行 npm init 会生成package.json文件，</p>
</li>
<li>
<p>同级目录新建webpack.config.js文件，写入一下代码，</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  entry<span>:</span> <span>'./main.js'</span><span>,</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>新建main.js文件，随便写点东西</p>
</li>
</ol>
</blockquote>
<ol>
<li>
<p>首先你需要安装<code>webpack</code>包，<a href="https://www.npmjs.com/package/webpack" target="_blank" rel="noopener noreferrer">下载</a></p>
<div><pre><code><span>npm</span> <span>install</span> --save-dev webpack
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>安装<code>webpack-dev-server</code>包，<a href="https://www.npmjs.com/package/webpack-dev-server" target="_blank" rel="noopener noreferrer">下载</a></p>
<div><pre><code><span>npm</span> <span>install</span> webpack-dev-server --save-dev
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>然后在<code>package.json</code>文件里面的script字段里面添加，</p>
<div><pre><code><span>"scripts"</span><span>:</span> <span>{</span>
    <span>"test"</span><span>:</span> <span>"echo <span title="\&quot;">\"</span>Error: no test specified<span title="\&quot;">\"</span> &amp;&amp; exit 1"</span>,
    <span>"serve"</span><span>:</span> <span>"webpack-dev-server"</span>, <span># 添加此行</span>
  <span>}</span>,
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>执行cmd命令；</p>
<div><pre><code><span>npm</span> run serve

<span># webpack: Compiled successfully.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>默认会监听8080端口，浏览器打开访问<code>localhost</code>即可，</p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>json-serve</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-07/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-07/</guid>
      <source url="https://wangyawei.top/rss.xml">json-serve</source>
      <category>nodejs</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="json-server"> <code>JSON Server</code>;</h2>
<blockquote>
<ul>
<li>概述：<code>JSON Server</code> 是一个提供测试环境接口的工具，它可以帮我们快速生成一套接口服务;</li>
<li>它是免费开源的命令行工具;</li>
</ul>
</blockquote>
<ol>
<li>
<p><strong>安装：</strong></p>
<div><pre><code><span>npm</span> <span>install</span> -g json-server  <span># -g 安装的东西只需安装一次即可；后续无需再安装；</span>

<span># 该命令用于测试是否安装成功，如果看到一个版本输出，就证明OK了</span>
json-server --version
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p><strong>创建文件目录；</strong></p>
<ul>
<li>创建文件名为 <code>json-server-demo</code>的文件夹，然后在该文件夹中创建一个文件 <code>db.json</code> 并写入以下内容：</li>
</ul>
<div><pre><code><span>{</span>
  <span>"posts"</span><span>:</span> <span>[</span>
    <span>{</span> <span>"id"</span><span>:</span> <span>1</span><span>,</span> <span>"title"</span><span>:</span> <span>"json-server"</span><span>,</span> <span>"author"</span><span>:</span> <span>"typicode"</span> <span>}</span>
  <span>]</span><span>,</span>
  <span>"comments"</span><span>:</span> <span>[</span>
    <span>{</span> <span>"id"</span><span>:</span> <span>1</span><span>,</span> <span>"body"</span><span>:</span> <span>"some comment"</span><span>,</span> <span>"postId"</span><span>:</span> <span>1</span> <span>}</span>
  <span>]</span><span>,</span>
  <span>"profile"</span><span>:</span> <span>{</span> <span>"name"</span><span>:</span> <span>"typicode"</span> <span>}</span><span>,</span>
  <span>"users"</span><span>:</span> <span>[</span>
    <span>{</span>
      <span>"id"</span><span>:</span> <span>1</span><span>,</span>
      <span>"name"</span><span>:</span> <span>"张三"</span><span>,</span>
      <span>"age"</span><span>:</span> <span>18</span><span>,</span>
      <span>"gender"</span><span>:</span> <span>"男"</span>
    <span>}</span>
  <span>]</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></li>
<li>
<p><strong>执行 <code>db.json</code>文件；</strong></p>
<div><pre><code>json-server --watch db.json
</code></pre>
<div><span>1</span><br></div></div></li>
</ol>
<blockquote>
<p>注：接口服务默认占用 3000 端口;</p>
</blockquote>
<h2 id="发送请求"> 发送请求；</h2>
<ol>
<li>
<p><strong><code>GET</code>请求；</strong></p>
<ol>
<li>获取所有数据信息；
<ul>
<li>请求过程和之前一样；</li>
</ul>
</li>
<li>根据条件查询数据信息；
<ul>
<li>请求过程和之前一样；</li>
</ul>
</li>
</ol>
</li>
<li>
<p><strong><code>POST</code>请求；</strong></p>
<ol>
<li>添加数据；
<ul>
<li>响应结果为修改后的数据；</li>
<li>注：请求参数必须是<code>JSON</code>格式的；</li>
</ul>
</li>
</ol>
<p><img src="./assets/20191107190408596.png" alt="20191107190408596" /></p>
</li>
<li>
<p><strong><code>DELETE</code>请求方式；</strong></p>
<ul>
<li>删除<code>id</code>为 1 的数据；</li>
</ul>
<p><img src="./assets/20191107191542387.png" alt="20191107191542387" /></p>
</li>
<li>
<p><strong><code>PATCH</code>请求方式；</strong></p>
<ul>
<li>修改<code>id</code>为2的数据；</li>
<li>注：请求体为<code>JSON</code>格式；</li>
<li>响应结果为：修改后的数据；</li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>ora的使用</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-08/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-08/</guid>
      <source url="https://wangyawei.top/rss.xml">ora的使用</source>
      <category>nodejs</category>
      <pubDate>Mon, 14 Jun 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>使用Node做开发已经是必备的一项技能，然后有时终端中的一些耗时操作的输出对我们不太友好，希望可以提供一个进度loading使用；</p>
</blockquote>
<h3 id="安装"> 安装；</h3>
<p><a href="https://www.npmjs.com/package/ora" target="_blank" rel="noopener noreferrer">传送门</a></p>
<div><pre><code><span>npm</span> i ora -D
</code></pre>
<div><span>1</span><br></div></div><h3 id="使用"> 使用：</h3>
<div><pre><code><span>const</span> ora <span>=</span> <span>require</span><span>(</span><span>'ora'</span><span>)</span><span>;</span>

<span>// 开启loading</span>
<span>const</span> spinner <span>=</span> <span>ora</span><span>(</span><span>'Loading unicorns'</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
 
<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>// 更改loading的文字与颜色；</span>
	spinner<span>.</span>color <span>=</span> <span>'yellow'</span><span>;</span>
	spinner<span>.</span>text <span>=</span> <span>'Loading rainbows'</span><span>;</span>
<span>}</span><span>,</span> <span>2000</span><span>)</span><span>;</span>

<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
	spinner<span>.</span><span>succeed</span><span>(</span>‘已完成’<span>)</span><span>;</span>
<span>}</span><span>,</span> <span>6000</span><span>)</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><img src="./assets/image-20210614101405802.png" alt="image-20210614101405802" /></p>
<h3 id="参数说明"> 参数说明：</h3>
<div><pre><code><span>// 快捷方式；ora(string)</span>
<span>const</span> spinner <span>=</span> <span>ora</span><span>(</span><span>'Loading unicorns'</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>

<span>// 选项对象</span>
<span>const</span> spinner <span>=</span> <span>ora</span><span>(</span><span>{</span>
  text<span>:</span> <span>'压缩中...'</span><span>,</span>
  color<span>:</span> <span>'red'</span><span>,</span>
  prefixText<span>:</span> <span>'开始压缩'</span><span>,</span>
  spinner<span>:</span> <span>'bouncingBar'</span>
  <span>// spinner: {</span>
  <span>//   interval: 80,</span>
  <span>//   frames: ['-', '+', '-']</span>
  <span>// }</span>
<span>}</span><span>)</span><span>;</span>
spinner<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
	spinner<span>.</span><span>succeed</span><span>(</span><span>'压缩文件已保存 路径：xxx'</span><span>)</span><span>;</span>
<span>}</span><span>,</span> <span>8000</span><span>)</span><span>;</span>

<span>// $ node zip.js </span>
<span>// 开始压缩 [==  ] 压缩中...</span>
<span>// ✔ 压缩文件已保存 路径：xxx</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id="官方文档"> 官方文档；</h3>
<p>https://github.com/sindresorhus/ora#readme</p>
]]></content:encoded>
    </item>
    <item>
      <title>全局对象</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-09/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-09/</guid>
      <source url="https://wangyawei.top/rss.xml">全局对象</source>
      <category>nodejs</category>
      <pubDate>Tue, 15 Jun 2021 07:25:35 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>JavaScript 中有一个特殊的对象，称为全局对象（Global Object），它及其所有属性都可以在程序的任何地方访问，即全局变量。在浏览器 JavaScript 中，通常 window 是全局对象，而 Node.js 中的全局对象是 global，所有全局变量（除了 global 本身以外）都是 global对象的属性。我们在 Node.js 中能够直接访问到对象通常都是 global 的属性，如 console、process等;</p>
</blockquote>
<h2 id="全局对象与全局变量"> 全局对象与全局变量</h2>
<blockquote>
<p>global 最根本的作用是作为全局变量的宿主。按照 ECMAScript 的定义，满足以下条件的变量是全局变量：
1：在最外层定义的变量；
2：全局对象的属性；
3：隐式定义的变量（未定义直接赋值的变量）。
当你定义一个全局变量时，这个变量同时也会成为全局对象的属性，反之亦然。</p>
</blockquote>
<div><p>提示</p>
<p>需要注意的是：</p>
<p>1、在 Node.js 中你不可能在最外层定义变量，因为所有用户代码都是属于当前模块的，而模块本身不是最外层上下文。</p>
<p>2、永远使用 var 定义变量以避免引入全局变量，因为全局变量会污染命名空间，提高代码的耦合风险。</p>
</div>
<h2 id="process"> process</h2>
<blockquote>
<p>process 是一个全局变量，即 global 对象的属性。它用于描述当前 Node.js <strong>进程状态</strong>的对象，提供了一个与操作系统的简单接口。</p>
</blockquote>
<h3 id="process-argv"> process.argv</h3>
<p>process.argv是命令行参数数组，第一个元素是 node， 第二个元素是脚本文件名，从第三个元素开始每个元素是一个运行参数。</p>
<div><pre><code><span>// argv.js</span>
console<span>.</span><span>log</span><span>(</span>process<span>.</span>argv<span>)</span><span>;</span>

<span>ASUS</span>@yaweidediannao <span>MINGW64</span> <span>~</span><span>/</span>Desktop<span>/</span>test
$ node <span>.</span><span>/</span>argv<span>.</span>js <span>1991</span> name<span>=</span>bycoid <span>--</span>v <span>"Carbo Kuo"</span>
<span>[</span>
  <span>'C:\\Program Files\\nodejs\\node.exe'</span><span>,</span>
  <span>'C:\\Users\\ASUS\\Desktop\\test\\argv.js'</span><span>,</span>
  <span>'1991'</span><span>,</span>
  <span>'name=bycoid'</span><span>,</span>
  <span>'--v'</span><span>,</span>
  <span>'Carbo Kuo'</span>
<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="process-stdout"> process.stdout</h3>
<p>process.stdout是标准输出流，通常我们使用的 console.log() 向标准输出打印字符，而 process.stdout.write() 函数提供了更底层的接口</p>
<div><pre><code>process<span>.</span>stdout<span>.</span><span>write</span><span>(</span><span>'我执行了'</span><span>)</span> <span>// 我执行了</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="process-stdin"> process.stdin</h3>
<p>process.stdin是标准输入流，初始时它是被暂停的，要想从标准输入读取数据，你必须恢复流，并手动编写流的事件响应函数。</p>
<div><pre><code><span>// module.js</span>
process<span>.</span>stdin<span>.</span><span>resume</span><span>(</span><span>)</span><span>;</span>
process<span>.</span>stdin<span>.</span><span>on</span><span>(</span><span>'data'</span><span>,</span> <span>function</span><span>(</span><span>data</span><span>)</span> <span>{</span>
  process<span>.</span>stdout<span>.</span><span>write</span><span>(</span><span>'read from console: '</span> <span>+</span> data<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module.js 
我执行了
<span>read</span> from console: 我执行了
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>例：process.stdout和process.stdin实现控制台登录</strong></p>
<div><pre><code><span>let</span> users<span>=</span><span>{</span>
	<span>"admin"</span><span>:</span><span>"123"</span><span>,</span>
	<span>"user1"</span><span>:</span><span>"321"</span><span>,</span>
	<span>"user2"</span><span>:</span><span>"213"</span>
<span>}</span><span>;</span>
<span>let</span> username<span>=</span><span>""</span><span>;</span>
process<span>.</span>stdout<span>.</span><span>write</span><span>(</span><span>"请输入用户名:"</span><span>)</span><span>;</span>
process<span>.</span>stdin<span>.</span><span>on</span><span>(</span><span>'data'</span><span>,</span><span>(</span><span>input</span><span>)</span><span>=></span><span>{</span>
	input<span>=</span>input<span>.</span><span>toString</span><span>(</span><span>)</span><span>.</span><span>trim</span><span>(</span><span>)</span><span>;</span>
	<span>if</span><span>(</span><span>!</span>username<span>)</span><span>{</span>
		<span>if</span><span>(</span>Object<span>.</span><span>keys</span><span>(</span>users<span>)</span><span>.</span><span>indexOf</span><span>(</span>input<span>)</span><span>===</span><span>-</span><span>1</span><span>)</span><span>{</span>
			process<span>.</span>stdout<span>.</span><span>write</span><span>(</span><span>'用户名不存在'</span><span>+</span><span>'\n'</span><span>)</span><span>;</span>
			process<span>.</span>stdout<span>.</span><span>write</span><span>(</span><span>"请输入用户名:"</span><span>)</span><span>;</span>
			username<span>=</span><span>""</span><span>;</span>
		<span>}</span> <span>else</span> <span>{</span>
			process<span>.</span>stdout<span>.</span><span>write</span><span>(</span><span>"请输入密码:"</span><span>)</span><span>;</span>
			username<span>=</span>input<span>;</span>
		<span>}</span>
	<span>}</span> <span>else</span><span>{</span>
    <span>// 输入密码</span>
		<span>if</span><span>(</span>input<span>===</span>users<span>[</span>username<span>]</span><span>)</span><span>{</span>
			console<span>.</span><span>log</span><span>(</span><span>"登陆成功"</span><span>)</span><span>;</span>
		<span>}</span> <span>else</span><span>{</span>
			process<span>.</span>stdout<span>.</span><span>write</span><span>(</span><span>"请输入密码"</span><span>+</span><span>"\n"</span><span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module.js
请输入用户名:er
用户名不存在
请输入用户名:admin
请输入密码:er
请输入密码
<span>123</span>
登陆成功
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>原文链接：<a href="https://blog.csdn.net/weixin_36339245/article/details/81126960" target="_blank" rel="noopener noreferrer">传送门</a></p>
<h3 id="process-nexttick"> process.nextTick()</h3>
<p>process.nextTick(callback)的功能是为事件循环设置一项任务， Node.js 会在下次事件循环调响应时调用 callback。</p>
<p>我们知道，Node.js 适合 I/O 密集型的应用，而不是计算密集型的应用，因为一个 Node.js 进程只有一个线程，因此在任何时刻都只有一个事件在执行。如果这个事件占用大量的 CPU 时间，执行事件循环中的下一个事件就需要等待很久，因此 Node.js 的一个编程原则就是尽量缩短每个事件的执行时间。 process.nextTick() 提供了一个这样的工具，可以把复杂的工作拆散，变成一个个较小的事件。</p>
<div><pre><code><span>function</span> <span>doSomething</span><span>(</span><span>args<span>,</span> callback</span><span>)</span> <span>{</span>
	<span>somethingComplicated</span><span>(</span>args<span>)</span><span>;</span>
	<span>callback</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>doSomething</span><span>(</span><span>function</span> <span>onEnd</span><span>(</span><span>)</span> <span>{</span>
	<span>compute</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p>我们假设 compute() 和 somethingComplicated() 是两个较为耗时的函数，以上的程序在调用 doSomething() 时会先执行 somethingComplicated()，然后立即调用回调函数，在 onEnd() 中又会执行 compute()。下面用 process.nextTick() 改写上面的程序：</p>
</blockquote>
<div><pre><code><span>function</span> <span>doSomething</span><span>(</span><span>args<span>,</span> callback</span><span>)</span> <span>{</span>
	<span>somethingComplicated</span><span>(</span>args<span>)</span><span>;</span>
	process<span>.</span><span>nextTick</span><span>(</span>callback<span>)</span><span>;</span>
<span>}</span>
<span>doSomething</span><span>(</span><span>function</span> <span>onEnd</span><span>(</span><span>)</span> <span>{</span>
	<span>compute</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>
<p>改写后的程序会把上面耗时的操作拆分为两个事件，减少每个事件的执行时间，提高事件响应速度。</p>
</blockquote>
<div><p>注意</p>
<p>不要使用 setTimeout(fn,0)代替 process.nextTick(callback)，前者比后者效率要低得多</p>
</div>
<h2 id="console"> console</h2>
<blockquote>
<p>console 用于提供控制台标准输出，它是由 Internet Explorer 的 JScript 引擎提供的调试工具，后来逐渐成为浏览器的事实标准。 Node.js 沿用了这个标准，提供与习惯行为一致的console 对象，用于向标准输出流（stdout）或标准错误流（stderr）输出字符</p>
</blockquote>
<h3 id="console-log"> console.log()</h3>
<blockquote>
<p>向标准输出流打印字符并以换行符结束。</p>
</blockquote>
<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>'Hello world'</span><span>)</span><span>;</span>
<span>// Hello world</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="console-error"> console.error()</h3>
<blockquote>
<p>与 console.log() 用法相同，只是向标准错误流输出。</p>
</blockquote>
<h3 id="console-trace"> console.trace()</h3>
<blockquote>
<p>向标准错误流输出当前的调用栈</p>
</blockquote>
<div><pre><code><span>// console.trace('Hello world');</span>
Trace<span>:</span> Hello world
    at Object<span>.</span><span>&lt;</span>anonymous<span>></span> <span>(</span><span>C</span><span>:</span>\Users\<span>ASUS</span>\Desktop\test\module<span>.</span>js<span>:</span><span>1</span><span>:</span><span>9</span><span>)</span>
    at Module<span>.</span><span>_compile</span> <span>(</span>internal<span>/</span>modules<span>/</span>cjs<span>/</span>loader<span>.</span>js<span>:</span><span>999</span><span>:</span><span>30</span><span>)</span>
    at Object<span>.</span>Module<span>.</span>_extensions<span>.</span><span>.</span><span>js</span> <span>(</span>internal<span>/</span>modules<span>/</span>cjs<span>/</span>loader<span>.</span>js<span>:</span><span>1027</span><span>:</span><span>10</span><span>)</span>
    at Module<span>.</span><span>load</span> <span>(</span>internal<span>/</span>modules<span>/</span>cjs<span>/</span>loader<span>.</span>js<span>:</span><span>863</span><span>:</span><span>32</span><span>)</span>
    at Function<span>.</span>Module<span>.</span><span>_load</span> <span>(</span>internal<span>/</span>modules<span>/</span>cjs<span>/</span>loader<span>.</span>js<span>:</span><span>708</span><span>:</span><span>14</span><span>)</span>
    at Function<span>.</span>executeUserEntryPoint <span>[</span><span>as</span> runMain<span>]</span> <span>(</span>internal<span>/</span>modules<span>/</span>run_main<span>.</span>js<span>:</span><span>60</span><span>:</span><span>12</span><span>)</span>
    at internal<span>/</span>main<span>/</span>run_main_module<span>.</span>js<span>:</span><span>17</span><span>:</span><span>47</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>常用工具util</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-10/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-10/</guid>
      <source url="https://wangyawei.top/rss.xml">常用工具util</source>
      <category>nodejs</category>
      <pubDate>Fri, 18 Jun 2021 23:19:35 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>util 是一个 Node.js 核心模块，提供常用函数的集合，用于弥补核心 JavaScript 的功能过于精简的不足。</p>
</blockquote>
<h2 id="util-inherits"> util.inherits</h2>
<blockquote>
<p>是一个实现对象间原型继承的函数。 JavaScript 的面向对象特性是基于原型的，与常见的基于类的不同。 JavaScript 没有提供对象继承的语言级别特性，而是通过原型复制来实现的。</p>
</blockquote>
<p>语法：</p>
<div><pre><code><span>// constructor：子类的构造函数</span>
<span>// superConstructor：父类的构造函数</span>
util<span>.</span><span>inherits</span><span>(</span>constructor<span>,</span> superConstructor<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>
<p>该方法对继承的实现，其本质上还是JavaScript原型链式继承。该方法会将父类superConstructor原型链上的方法复制到子类constructor原型链上，在其内部是调用Object.create()实现新对象的创建及原型链方法的复制。</p>
</blockquote>
<p>示例：</p>
<div><pre><code><span>var</span> util <span>=</span> <span>require</span><span>(</span><span>'util'</span><span>)</span>
<span>function</span> <span>Base</span><span>(</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>name <span>=</span> <span>'base'</span>
  <span>this</span><span>.</span>base <span>=</span> <span>1991</span>
  <span>this</span><span>.</span><span>sayHello</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'Hello '</span> <span>+</span> <span>this</span><span>.</span>name<span>)</span>
  <span>}</span>
<span>}</span>
<span>Base</span><span>.</span>prototype<span>.</span><span>showName</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span>
<span>}</span>
<span>function</span> <span>Sub</span><span>(</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>name <span>=</span> <span>'sub'</span>
<span>}</span>
util<span>.</span><span>inherits</span><span>(</span>Sub<span>,</span> Base<span>)</span>
<span>var</span> objBase <span>=</span> <span>new</span> <span>Base</span><span>(</span><span>)</span>
objBase<span>.</span><span>showName</span><span>(</span><span>)</span>
objBase<span>.</span><span>sayHello</span><span>(</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>objBase<span>)</span>

<span>var</span> objSub <span>=</span> <span>new</span> <span>Sub</span><span>(</span><span>)</span>
objSub<span>.</span><span>showName</span><span>(</span><span>)</span>
<span>//objSub.sayHello();</span>
console<span>.</span><span>log</span><span>(</span>objSub<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><div><p>注意</p>
<p>Sub 仅仅继承了 Base 在原型中定义的函数，而构造函数内部创造的 base 属性和 sayHello 函数都没有被 Sub 继承。同时，在原型中定义的属性不会被 console.log 作为对象的属性输出。如果我们去掉 objSub.sayHello();  则会报错；</p>
</div>
<h2 id="util-inspect"> util.inspect</h2>
<blockquote>
<p>是一个将任意对象转换为字符串的方法，通常用于调试和错误输出。</p>
</blockquote>
<p>语法：</p>
<div><pre><code>util<span>.</span><span>inspect</span><span>(</span>object<span>,</span><span>[</span>showHidden<span>]</span><span>,</span><span>[</span>depth<span>]</span><span>,</span><span>[</span>colors<span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>参数：</p>
<ol>
<li>object：转换的对象</li>
<li>showHidden：可选参数，如果值为 true，将会输出更多隐藏信息</li>
<li>depth： 表示最大递归的层数，如果对象很复杂，你可以指定层数以控制输出信息的多少。如果不指定depth，默认会递归2层，指定为 null 表示将不限递归层数完整遍历对象。</li>
<li>color ：如果color 值为 true，输出格式将会以 ANSI 颜色编码，通常用于在终端显示更漂亮的效果。</li>
</ol>
<div><p>提示</p>
<p>特别要指出的是， util.inspect 并不会简单地直接把对象转换为字符串，即使该对象定义了 toString 方法也不会调用。</p>
</div>
<div><pre><code><span>var</span> util <span>=</span> <span>require</span><span>(</span><span>'util'</span><span>)</span>
<span>function</span> <span>Person</span><span>(</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>name <span>=</span> <span>'byvoid'</span>
  <span>this</span><span>.</span><span>toString</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>name
  <span>}</span>
<span>}</span>
<span>var</span> obj <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>util<span>.</span><span>inspect</span><span>(</span>obj<span>)</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>util<span>.</span><span>inspect</span><span>(</span>obj<span>,</span> <span>true</span><span>,</span> <span>null</span><span>,</span> <span>true</span><span>)</span><span>)</span>

<span>// 打印结果</span>
Person <span>{</span> name<span>:</span> <span>'byvoid'</span><span>,</span> toString<span>:</span> <span>[</span>Function<span>]</span> <span>}</span>
Person <span>{</span>
  name<span>:</span> <span>'byvoid'</span><span>,</span>
  toString<span>:</span> <span>[</span>Function<span>]</span> <span>{</span>
    <span>[</span>length<span>]</span><span>:</span> <span>0</span><span>,</span>
    <span>[</span>name<span>]</span><span>:</span> <span>''</span><span>,</span>
    <span>[</span>arguments<span>]</span><span>:</span> <span>null</span><span>,</span>
    <span>[</span>caller<span>]</span><span>:</span> <span>null</span><span>,</span>
    <span>[</span>prototype<span>]</span><span>:</span> <span>{</span> <span>[</span>constructor<span>]</span><span>:</span> <span>[</span>Circular<span>]</span> <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><p>提示</p>
<p>util还提供了util.isArray()、util.isRegExp()、util.isDate()、 util.isError() 四个类型测试工具，以及 util.format()、 util.debug() 等工具。</p>
<p>可以访问 http://nodejs.org/api/util.html 了解详细内容</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>事件驱动 events</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-11/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-11/</guid>
      <source url="https://wangyawei.top/rss.xml">事件驱动 events</source>
      <category>nodejs</category>
      <pubDate>Sat, 19 Jun 2021 00:19:35 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>events 是 Node.js 最重要的模块，没有“之一”，原因是 Node.js 本身架构就是事件式的，而它提供了唯一的接口，所以堪称 Node.js 事件编程的基石。 events 模块不仅用于用户代码与 Node.js 下层事件循环的交互，还几乎被所有的模块依赖。</p>
</blockquote>
<h2 id="事件发射器"> 事件发射器</h2>
<blockquote>
<p>events 模块只提供了一个对象： events.EventEmitter。 EventEmitter 的核心就是事件发射与事件监听器功能的封装。EventEmitter 的每个事件由一个事件名和若干个参数组成，事件名是一个字符串，通常表达一定的语义。对于每个事件， EventEmitter 支持若干个事件监听器。当事件发射时，注册到这个事件的事件监听器被依次调用，事件参数作为回调函数参数传递。</p>
</blockquote>
<div><pre><code><span>const</span> events <span>=</span> <span>require</span><span>(</span><span>'events'</span><span>)</span><span>;</span>
<span>const</span> emitter <span>=</span> <span>new</span> <span>events<span>.</span>EventEmitter</span><span>(</span><span>)</span><span>;</span>

<span>// 监听事件</span>
<span>// emitter.on('someEvent', function(arg1, arg2) {</span>
<span>//   console.log('listener1', arg1, arg2)</span>
<span>// })</span>
<span>// emitter.on('someEvent', function(arg1, arg2) {</span>
<span>//   console.log('listener2', arg1, arg2)</span>
<span>// })</span>

<span>// 触发事件</span>
<span>// emitter.emit('someEvent', 'byvoid', 1991)</span>
<span>// listener1 byvoid 1991</span>
<span>// listener2 byvoid 1991</span>

emitter<span>.</span><span>once</span><span>(</span><span>'someEvent'</span><span>,</span> <span>function</span><span>(</span><span>arg1<span>,</span> arg2</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'listener1'</span><span>,</span> arg1<span>,</span> arg2<span>)</span>
<span>}</span><span>)</span>

emitter<span>.</span><span>emit</span><span>(</span><span>'someEvent'</span><span>,</span> <span>'byvoid'</span><span>,</span> <span>1991</span><span>)</span>
emitter<span>.</span><span>emit</span><span>(</span><span>'someEvent'</span><span>,</span> <span>'byvoid'</span><span>,</span> <span>1991</span><span>)</span>
<span>// listener1 byvoid 1991</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><blockquote>
<p>以上例子中， emitter 为事件 someEvent 注册了两个事件监听器，然后发射了someEvent 事件。运行结果中可以看到两个事件监听器回调函数被先后调用</p>
</blockquote>
<p><strong>API说明</strong></p>
<ul>
<li>EventEmitter.on(event, listener) 为指定事件注册一个监听器，接受一个字符串 event 和一个回调函数 listener。</li>
<li>EventEmitter.emit(event, [arg1], [arg2], [...]) 发射 event 事件，传递若干可选参数到事件监听器的参数表。</li>
<li>EventEmitter.once(event, listener) 为指定事件注册一个单次监听器，即监听器最多只会触发一次，触发后立刻解除该监听器。</li>
<li>EventEmitter.removeListener(event, listener) 移除指定事件的某个监听器， listener 必须是该事件已经注册过的监听器。</li>
<li>EventEmitter.removeAllListeners([event]) 移除所有事件的所有监听器，如果指定 event，则移除指定事件的所有监听器。</li>
</ul>
<h2 id="error-事件"> error 事件</h2>
<blockquote>
<p>EventEmitter 定义了一个特殊的事件 error，它包含了“错误”的语义，我们在遇到异常的时候通常会发射 error 事件。当 error 被发射时， EventEmitter 规定如果没有响应的监听器， Node.js 会把它当作异常，退出程序并打印调用栈。我们一般要为会发射 error事件的对象设置监听器，避免遇到错误后整个程序崩溃。</p>
</blockquote>
<div><pre><code><span>var</span> events <span>=</span> <span>require</span><span>(</span><span>'events'</span><span>)</span><span>;</span>

<span>var</span> emitter <span>=</span> <span>new</span> <span>events<span>.</span>EventEmitter</span><span>(</span><span>)</span><span>;</span>

emitter<span>.</span><span>on</span><span>(</span><span>'error'</span><span>,</span> <span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>err<span>)</span> <span>// 错误了</span>
<span>}</span><span>)</span>

emitter<span>.</span><span>emit</span><span>(</span><span>'error'</span><span>,</span> <span>'错误了'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>
<p>如果把监听的<code>error</code>事件去掉则会打印错误；</p>
</blockquote>
<div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node ./module.js 
events.js:305
    throw err<span>;</span> // Unhandled <span>'error'</span> event
    ^

Error <span>[</span>ERR_UNHANDLED_ERROR<span>]</span>: Unhandled error. <span>(</span><span>'错误了'</span><span>)</span>
    at EventEmitter.emit <span>(</span>events.js:303:17<span>)</span>
    at Object.<span>&lt;</span>anonymous<span>></span> <span>(</span>C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>test<span>\</span>module.js:9:9<span>)</span>
    at Module._compile <span>(</span>internal/modules/cjs/loader.js:999:30<span>)</span>
    at Object.Module._extensions<span>..</span>js <span>(</span>internal/modules/cjs/loader.js:1027:10<span>)</span>
    at Module.load <span>(</span>internal/modules/cjs/loader.js:863:32<span>)</span>
    at Function.Module._load <span>(</span>internal/modules/cjs/loader.js:708:14<span>)</span>
    at Function.executeUserEntryPoint <span>[</span>as runMain<span>]</span> <span>(</span>internal/modules/run_main.js:60:12<span>)</span>
    at internal/main/run_main_module.js:17:47 <span>{</span>
  code: <span>'ERR_UNHANDLED_ERROR'</span>,
  context: <span>'错误了'</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="继承-eventemitter"> 继承 EventEmitter</h2>
<blockquote>
<p>大多数时候我们不会直接使用 EventEmitter，而是在对象中继承它。包括 fs、 net、http 在内的，只要是支持事件响应的核心模块都是 EventEmitter 的子类。</p>
</blockquote>
<p><strong>为什么要这样做呢？原因有两点。</strong></p>
<ul>
<li>具有某个实体功能的对象实现事件符合语义，事件的监听和发射应该是一个对象的方法。</li>
<li>JavaScript 的对象机制是基于原型的，支持部分多重继承，继承 EventEmitter 不会打乱对象原有的继承关系。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>文件系统 fs</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-12/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-12/</guid>
      <source url="https://wangyawei.top/rss.xml">文件系统 fs</source>
      <category>nodejs</category>
      <pubDate>Wed, 23 Jun 2021 08:13:35 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>fs 模块是文件操作的封装，它提供了文件的读取、写入、更名、删除、遍历目录、链接等 POSIX 文件系统操作。与其他模块不同的是， fs 模块中所有的操作都提供了异步的和同步的两个版本，例如读取文件内容的函数有异步的 fs.readFile() 和同步的
fs.readFileSync()。</p>
</blockquote>
<p>导入文件系统模块(fs)语法；</p>
<div><pre><code><span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>"fs"</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="fs-readfile"> <code>fs.readFile</code></h2>
<blockquote>
<p>以异步的方式读取一个文件。</p>
</blockquote>
<p><strong>语法：</strong></p>
<div><pre><code>fs<span>.</span><span>readFile</span><span>(</span>path<span>[</span><span>,</span> options<span>]</span><span>,</span> callback<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>参数：</strong></p>
<ul>
<li>path：文件名或文件描述符；</li>
<li>options：<code>object | string</code>，如果 <code>options</code> 是字符串，则它指定编码。
<ul>
<li><code>encoding</code>：文件的字符编码  ，默认值: <code>null</code></li>
<li><code>flag</code> 默认值:<code>r</code>。
<ul>
<li><code>'r'</code>: 打开文件进行读取。 如果文件不存在，则会发生异常。</li>
<li><code>'r+'</code>: 打开文件进行读写。 如果文件不存在，则会发生异常。</li>
<li><code>'rs+'</code>: 以同步模式打开文件进行读写。 指示操作系统绕过本地文件系统缓存。</li>
<li>了解更多请查看官方文档，<a href="http://nodejs.cn/api/fs.html#fs_file_system_flags" target="_blank" rel="noopener noreferrer">传送门</a></li>
</ul>
</li>
<li><code>signal</code> 允许中止正在进行的读取文件</li>
</ul>
</li>
<li>callback：读取成功或失败时的回调函数，有两个参数；
<ul>
<li>err：错误对象；</li>
<li>data：成功时的文件内容；</li>
</ul>
</li>
</ul>
<div><p>提示</p>
<ul>
<li>
<p>callback 是回调函数，用于接收文件的内容。如果不指定 encoding，则 callback 就是第二个参数 。</p>
</li>
<li>
<p>如果指定了 encoding， data 是一个解析后的字符串，否则 data 将会是以 Buffer 形式表示的二进制数据。</p>
</li>
</ul>
</div>
<h3 id="读取文件内容-但不指定编码"> <strong>读取文件内容，但不指定编码</strong></h3>
<div><pre><code><span>// helloWorld.js</span>
<span>const</span> str <span>=</span> <span>'Hello world'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>

fs<span>.</span><span>readFile</span><span>(</span><span>'./helloWorld.js'</span><span>,</span> <span>(</span><span>err<span>,</span> data</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span>err<span>)</span> <span>{</span>
    console<span>.</span><span>error</span><span>(</span>err<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>data<span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module.js 
<span>&lt;</span>Buffer <span>63</span> 6f 6e <span>73</span> <span>74</span> <span>20</span> <span>73</span> <span>74</span> <span>72</span> <span>20</span> 3d <span>20</span> <span>27</span> <span>48</span> <span>65</span> 6c 6c 6f <span>20</span> <span>77</span> 6f <span>72</span> 6c <span>64</span> <span>2</span><span><span>7</span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>
<p>程序以二进制的模式读取了文件的内容， data 的值是 Buffer 对象 ；</p>
</blockquote>
<h3 id="读取文件内容-指定编码"> <strong>读取文件内容，指定编码</strong></h3>
<div><pre><code><span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>

fs<span>.</span><span>readFile</span><span>(</span><span>'./helloWorld.js'</span><span>,</span> <span>'utf-8'</span><span>,</span> <span>(</span><span>err<span>,</span> data</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span>err<span>)</span> <span>{</span>
    console<span>.</span><span>error</span><span>(</span>err<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>data<span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module
const str <span>=</span> <span>'Hello world'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="当读取文件出现错误时"> <strong>当读取文件出现错误时</strong></h3>
<div><pre><code><span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>

fs<span>.</span><span>readFile</span><span>(</span><span>'./helloWorld2.js'</span><span>,</span> <span>'utf-8'</span><span>,</span> <span>(</span><span>err<span>,</span> data</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span>err<span>)</span> <span>{</span>
    console<span>.</span><span>error</span><span>(</span>err<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>data<span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module
<span>[</span>Error: ENOENT: no such <span>file</span> or directory, <span>open</span> <span>'C:\Users\ASUS\Desktop\test\helloWorld2.js'</span><span>]</span> <span>{</span>
  errno: -4058,
  code: <span>'ENOENT'</span>,
  syscall: <span>'open'</span>,
  path: <span>'C:\\Users\\ASUS\\Desktop\\test\\helloWorld2.js'</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><p>提示</p>
<p>Node.js 的异步编程接口习惯是以函数的最后一个参数为回调函数。回调函数的实际参数中第一个是 err，其余的参数是其他返回的内容。如果没有发生错误， err 的值会是 null 或undefined。如果有错误发生， err 通常是 Error 对象的实例。</p>
</div>
<h2 id="fs-readfilesync"> <code>fs.readFileSync</code></h2>
<blockquote>
<p>是 fs.readFile 同步的版本 ，以同步的方式读取一个文件。</p>
</blockquote>
<p><strong>语法：</strong></p>
<div><pre><code>fs<span>.</span><span>readFileSync</span><span>(</span>filename<span>,</span> <span>[</span>encoding<span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>参数：</strong></p>
<ul>
<li>filename：文件名或文件描述符；</li>
<li>encoding：文件的字符编码；</li>
</ul>
<p><strong>读取文件</strong></p>
<div><pre><code><span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>
<span>const</span> content <span>=</span> fs<span>.</span><span>readFileSync</span><span>(</span><span>'./helloWorld.js'</span><span>,</span> <span>'utf-8'</span><span>)</span>

console<span>.</span><span>log</span><span>(</span>content<span>)</span> <span>// const str = 'Hello world'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p>读取到的文件内容会以函数返回值的形式返回。如果有错误发生， fs 将会抛出异常，需要使用 try 和 catch 捕捉并处理异常。</p>
</blockquote>
<h2 id="fs-open"> <code>fs.open</code></h2>
<blockquote>
<p>该方法用于打开文件，以便fs.read()读取。</p>
</blockquote>
<p><strong>语法</strong></p>
<div><pre><code>fs<span>.</span><span>open</span><span>(</span>path<span>,</span> flags<span>,</span> <span>[</span>mode<span>]</span><span>,</span> <span>[</span><span>callback</span><span>(</span>err<span>,</span> fd<span>)</span><span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>参数</strong></p>
<ul>
<li>path：文件的路径</li>
<li>flags：
<ul>
<li>r ：以读取模式打开文件。</li>
<li>r+ ：以读写模式打开文件。</li>
<li>w ：以写入模式打开文件，如果文件不存在则创建。</li>
<li>w+ ：以读写模式打开文件，如果文件不存在则创建。</li>
<li>a ：以追加模式打开文件，如果文件不存在则创建。</li>
<li>a+ ：以读取追加模式打开文件，如果文件不存在则创建。</li>
</ul>
</li>
<li>mode：创建文件时给文件指定权限 默认：0666</li>
<li>callback：
<ul>
<li>err：错误对象；</li>
<li>fd： 文件描述符</li>
</ul>
</li>
</ul>
<div><p>提示</p>
<ol>
<li>文件权限指的是 POSIX 操作系统中对文件读取和访问权限的规范，通常用一个八进制数来表示。例如 0754 表
示文件所有者的权限是 7 （读、写、执行），同组的用户权限是 5 （读、执行），其他用户的权限是 4 （读），
写成字符表示就是 -rwxr-xr--。</li>
<li>文件描述符是一个非负整数，表示操作系统内核为当前进程所维护的打开文件的记录表索引。</li>
</ol>
</div>
<h2 id="fs-read"> <strong>fs.read</strong></h2>
<blockquote>
<p>该功能类似fs.readFile，但提供<strong>更底层的操作</strong>，实际应用中多用fs.readFile。</p>
<p>该功能是从指定的文件描述符 fd 中读取数据并写入 buffer 指向的缓冲区对象 。</p>
</blockquote>
<p><strong>语法</strong></p>
<div><pre><code>fs<span>.</span><span>read</span><span>(</span>fd<span>,</span> buffer<span>,</span> offset<span>,</span> length<span>,</span> position<span>,</span> <span>[</span><span>callback</span><span>(</span>err<span>,</span> bytesRead<span>,</span>buffer<span>)</span><span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>参数</strong></p>
<ul>
<li>fd 文件描述符，必须接收fs.open()方法中的回调函数返回的第二个参数。</li>
<li>buffer 是存放将被写入的数据，buffer尺寸的大小设置最好是8的倍数，效率较高。</li>
<li>offset  <strong>buffer写入的偏移量</strong>。</li>
<li>length (integer)指定 写入文件中数据的<strong>字节数</strong>。</li>
<li>position (integer) 指定 在写入文件内容的<strong>起始位置</strong>。</li>
<li>callback 回调函数，参数如下
<ul>
<li>err 用于抛出异常</li>
<li>bytesWritten从文件中读取内容的<strong>实际字节数</strong>。</li>
<li>buffer 被读取的缓存区对象。</li>
</ul>
</li>
</ul>
<p><strong>使用</strong></p>
<div><pre><code><span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>

fs<span>.</span><span>open</span><span>(</span><span>'./helloWorld.js'</span><span>,</span> <span>'r'</span><span>,</span> <span>(</span><span>err<span>,</span> fd</span><span>)</span> <span>=></span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'open file success.'</span><span>)</span><span>;</span>
    <span>var</span> buffer <span>=</span> Buffer<span>.</span><span>alloc</span><span>(</span><span>255</span><span>)</span><span>;</span>
    <span>// 读取文件</span>
    fs<span>.</span><span>read</span><span>(</span>fd<span>,</span> buffer<span>,</span> <span>0</span><span>,</span> <span>255</span><span>,</span> <span>0</span><span>,</span> <span>function</span><span>(</span><span>err<span>,</span> bytesRead<span>,</span> buffer</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>err<span>)</span> <span>{</span>
            <span>throw</span> err<span>;</span>
        <span>}</span>
        <span>// 打印出buffer中存入的数据</span>
        console<span>.</span><span>log</span><span>(</span>bytesRead<span>,</span> buffer<span>.</span><span>slice</span><span>(</span><span>0</span><span>,</span> bytesRead<span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>// 关闭文件</span>
        fs<span>.</span><span>close</span><span>(</span>fd<span>,</span> <span>(</span><span>data</span><span>)</span> <span>=></span> <span>{</span>
          console<span>.</span><span>log</span><span>(</span>data<span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module
<span>open</span> <span>file</span> success.
<span>25</span> const str <span>=</span> <span>'Hello world'</span>
null
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><p>提示</p>
<p>一般来说，除非必要，否则不要使用这种方式读取文件，因为它要求你手动管理缓冲区和文件指针，尤其是在你不知道文件大小的时候，这将会是一件很麻烦的事情。</p>
</div>
<div><p>注意</p>
<p><code>new Buffer(number)</code>已经被弃用，请使用``Buffer.alloc(255)`代替；</p>
<div><pre><code>DeprecationWarning: Buffer<span>(</span><span>)</span> is deprecated due to security and usability issues. Please use the Buffer.alloc<span>(</span><span>)</span>, Buffer.allocUnsafe<span>(</span><span>)</span>, or Buffer.from<span>(</span><span>)</span> methods instead.
</code></pre>
<div><span>1</span><br></div></div></div>
]]></content:encoded>
    </item>
    <item>
      <title>HTTP 服务器与客户端</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-13/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-13/</guid>
      <source url="https://wangyawei.top/rss.xml">HTTP 服务器与客户端</source>
      <category>nodejs</category>
      <pubDate>Wed, 23 Jun 2021 08:14:35 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Node.js 标准库提供了 http 模块，其中封装了一个高效的 HTTP 服务器和一个简易的HTTP客户端。http.Server 是一个基于事件的 HTTP服务器，它的核心由 Node.js 下层 C++部分实现，而接口由 JavaScript 封装，兼顾了高性能与简易性。 http.request 则是一个HTTP 客户端工具，用于向 HTTP 服务器发起请求，</p>
</blockquote>
<h2 id="http-服务器"> HTTP 服务器</h2>
<blockquote>
<p>http.Server 是 http 模块中的 HTTP 服务器对象，</p>
</blockquote>
<p><strong>实现了一个服务器</strong></p>
<div><pre><code><span>//app.js</span>
<span>const</span> http <span>=</span> <span>require</span><span>(</span><span>'http'</span><span>)</span>

<span>const</span> app <span>=</span> http<span>.</span><span>createServer</span><span>(</span><span>function</span><span>(</span><span>req<span>,</span> res</span><span>)</span> <span>{</span>
    res<span>.</span><span>writeHead</span><span>(</span><span>200</span><span>,</span> <span>{</span> <span>'Content-Type'</span><span>:</span> <span>'text/html'</span> <span>}</span><span>)</span>
    res<span>.</span><span>write</span><span>(</span><span>'&lt;h1>Node.js&lt;/h1>'</span><span>)</span>
    res<span>.</span><span>end</span><span>(</span><span>'&lt;p>Hello World&lt;/p>'</span><span>)</span>
  <span>}</span><span>)</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>,</span> <span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'HTTP server is listening at port 3000.'</span><span>)</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node app.js
HTTP server is listening at port <span>3000</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>
<p>http.createServer 创建了一个 http.Server 的实例，将一个函数作为 HTTP 请求处理函数。这个函数接受两个参数，分别是请求对象（ req ）和响应对象（ res ）。在函数体内， res 显式地写回了响应代码 200 （表示请求成功），指定响应头为'Content-Type': 'text/html'，然后写入响应体 '<h1>Node.js</h1>'，通过 res.end结束并发送。最后该实例还调用了 listen 函数，启动服务器并监听 3000 端口。</p>
</blockquote>
<h3 id="http-server"> http.Server</h3>
<blockquote>
<p>http.Server 是一个基于事件的 HTTP 服务器，所有的请求都被封装为独立的事件，开发者只需要对它的事件编写响应函数即可实现 HTTP 服务器的所有功能。它继承自EventEmitter。</p>
</blockquote>
<ul>
<li>request：当客户端请求到来时，该事件被触发，提供两个参数 req 和res，分别是http.ServerRequest 和 http.ServerResponse 的实例，表示请求和响应信息。</li>
<li>connection：当 TCP 连接建立时，该事件被触发，提供一个参数 socket，为net.Socket 的实例。 connection 事件的粒度要大于 request，因为客户端在Keep-Alive 模式下可能会在同一个连接内发送多次请求。</li>
<li>close：当服务器关闭时，该事件被触发。注意不是在用户连接断开时。</li>
</ul>
<p><strong>在 这 些 事 件 中 ， 最 常 用 的 就 是 request 了 ， 因 此 http 提 供 了 一 个 捷 径 ：http.createServer([requestListener]) ， 功 能 是 创 建 一 个 HTTP 服 务 器 并 将requestListener 作为 request 事件的监听函数，这也是我们前面例子中使用的方法。</strong>  事实上它显式的实现方法是：</p>
<div><pre><code><span>const</span> http <span>=</span> <span>require</span><span>(</span><span>'http'</span><span>)</span>
<span>const</span> server <span>=</span> <span>new</span> <span>http<span>.</span>Server</span><span>(</span><span>)</span>

server<span>.</span><span>on</span><span>(</span><span>'request'</span><span>,</span> <span>function</span><span>(</span><span>req<span>,</span> res</span><span>)</span> <span>{</span>
  res<span>.</span><span>writeHead</span><span>(</span><span>200</span><span>,</span> <span>{</span> <span>'Content-Type'</span><span>:</span> <span>'text/html'</span> <span>}</span><span>)</span>
  res<span>.</span><span>write</span><span>(</span><span>'&lt;h1>Node.js&lt;/h1>'</span><span>)</span>
  res<span>.</span><span>end</span><span>(</span><span>'&lt;p>Hello World&lt;/p>'</span><span>)</span>
<span>}</span><span>)</span>

server<span>.</span><span>listen</span><span>(</span><span>3000</span><span>,</span> <span>err</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'HTTP server is listening at port 3000.'</span><span>)</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module.js 
HTTP server is listening at port <span>3000</span>.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="http-serverrequest"> http.ServerRequest</h3>
<blockquote>
<p>http.ServerRequest 是 HTTP 请求的信息，是后端开发者最关注的内容。<strong>这个对象通常由 <code>http.Server</code> 创建而非用户手动建立，并作为第一个参数传给它触发的 <code>request</code> 事件，通常简称 request 或 req。</strong>  HTTP 请求一般可以分为两部分： 请求头（Request Header）和请求体（Requset Body）。而请求体可能相对较长，需要一定的时间传输，因此 http.ServerRequest 提供了以下3个事件用于控制请求体传输。</p>
</blockquote>
<ul>
<li>data：当请求体数据到来时，该事件被触发。该事件提供一个参数 chunk，表示接收到的数据。如果该事件没有被监听，那么请求体将会被抛弃。该事件可能会被调用多次。</li>
<li>end：当请求体数据传输完成时，该事件被触发，此后将不会再有数据到来。</li>
<li>close：用户当前请求结束时，该事件被触发。不同于 end，如果用户强制终止了传输，也还是调用close。</li>
</ul>
<h4 id="获取-get-请求内容"> 获取 GET 请求内容</h4>
<blockquote>
<p>由于 GET 请求直接被嵌入在路径中，URL是完整的请求路径，包括了 ? 后面的部分，因此你可以手动解析后面的内容作为 GET请求的参数。 Node.js 的 url 模块中的 parse 函数提供了这个功能。</p>
</blockquote>
<div><pre><code><span>const</span> http <span>=</span> <span>require</span><span>(</span><span>'http'</span><span>)</span>
<span>const</span> url <span>=</span> <span>require</span><span>(</span><span>'url'</span><span>)</span>
<span>const</span> util <span>=</span> <span>require</span><span>(</span><span>'util'</span><span>)</span>

<span>const</span> app <span>=</span> http<span>.</span><span>createServer</span><span>(</span><span>function</span><span>(</span><span>req<span>,</span> res</span><span>)</span> <span>{</span>
  res<span>.</span><span>writeHead</span><span>(</span><span>200</span><span>,</span> <span>{</span> <span>'Content-Type'</span><span>:</span> <span>'text/plain'</span> <span>}</span><span>)</span>
  res<span>.</span><span>end</span><span>(</span>util<span>.</span><span>inspect</span><span>(</span>url<span>.</span><span>parse</span><span>(</span>req<span>.</span>url<span>,</span> <span>true</span><span>)</span><span>)</span><span>)</span>
<span>}</span><span>)</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>,</span> <span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'服务启动成功'</span><span>)</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module.js 
服务启动成功
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>// 打开浏览器输入地址：http://127.0.0.1:3000/user?name=byvoid&amp;email=byvoid@byvoid.com</span>
Url <span>{</span>
  protocol<span>:</span> <span>null</span><span>,</span>
  slashes<span>:</span> <span>null</span><span>,</span>
  auth<span>:</span> <span>null</span><span>,</span>
  host<span>:</span> <span>null</span><span>,</span>
  port<span>:</span> <span>null</span><span>,</span>
  hostname<span>:</span> <span>null</span><span>,</span>
  hash<span>:</span> <span>null</span><span>,</span>
  search<span>:</span> <span>'?name=byvoid&amp;email=byvoid@byvoid.com'</span><span>,</span>
  query<span>:</span> <span>[</span>Object<span>:</span> <span>null</span> prototype<span>]</span> <span>{</span>
    name<span>:</span> <span>'byvoid'</span><span>,</span>
    email<span>:</span> <span>'byvoid@byvoid.com'</span>
  <span>}</span><span>,</span>
  pathname<span>:</span> <span>'/user'</span><span>,</span>
  path<span>:</span> <span>'/user?name=byvoid&amp;email=byvoid@byvoid.com'</span><span>,</span>
  href<span>:</span> <span>'/user?name=byvoid&amp;email=byvoid@byvoid.com'</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><blockquote>
<p>通过 url.parse，原始的 path 被解析为一个对象，其中 query 就是我们所谓的 GET请求的内容，而路径则是 pathname</p>
</blockquote>
<h4 id="获取-post-请求内容"> 获取 POST 请求内容</h4>
<blockquote>
<p>相比GET 请求把所有的内容编码到访问路径中， POST 请求的内容全部都在请求体中。然而http.ServerRequest 并没有一个属性内容为请求体，原因是等待请求体传输可能是一件耗时的工作，譬如上传文件。而很多时候我们可能并不需要理会请求体的内容，恶意的 POST请求会大大消耗服务器的资源。所以 Node.js 默认是不会解析请求体的，当你需要的时候，需要手动来做。</p>
</blockquote>
<div><pre><code><span>const</span> http <span>=</span> <span>require</span><span>(</span><span>'http'</span><span>)</span>
<span>const</span> querystring <span>=</span> <span>require</span><span>(</span><span>'querystring'</span><span>)</span><span>;</span>
<span>const</span> util <span>=</span> <span>require</span><span>(</span><span>'util'</span><span>)</span>

<span>const</span> app <span>=</span> http<span>.</span><span>createServer</span><span>(</span><span>function</span><span>(</span><span>req<span>,</span> res</span><span>)</span> <span>{</span>
  <span>var</span> post <span>=</span> <span>''</span>
  req<span>.</span><span>on</span><span>(</span><span>'data'</span><span>,</span> <span>function</span><span>(</span><span>chunk</span><span>)</span> <span>{</span>
    post <span>+=</span> chunk
  <span>}</span><span>)</span>
  req<span>.</span><span>on</span><span>(</span><span>'end'</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
    post <span>=</span> querystring<span>.</span><span>parse</span><span>(</span>post<span>)</span>
    res<span>.</span><span>end</span><span>(</span>util<span>.</span><span>inspect</span><span>(</span>post<span>)</span><span>)</span>
  <span>}</span><span>)</span>
<span>}</span><span>)</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>,</span> <span>err</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'服务启动成功'</span><span>)</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><strong>用postman请求的结果如下</strong></p>
<p><img src="./assets/image-20210625080318250.png" alt="image-20210625080318250" /></p>
<blockquote>
<p>上面代码中我们定义了一个 post 变量，用于在闭包中暂存请求体的信息。通过 req 的 data 事件监听函数，每当接受到请求体的数据，就累加到 post 变量中。在 end 事件触发后，通过 querystring.parse 将 post 解析为真正的 POST 请求格式，然后向客户端返回。</p>
</blockquote>
<h3 id="http-serverresponse"> http.ServerResponse</h3>
<blockquote>
<p>http.ServerResponse 是返回给客户端的信息，决定了用户最终能看到的结果。它也是由 http.Server 的 request 事件发送的，作为第二个参数传递，一般简称为response 或 res。</p>
</blockquote>
<ul>
<li>response.writeHead(statusCode, [headers])：向请求的客户端发送响应头。</li>
<li>response.write(data, [encoding])：向请求的客户端发送响应内容。  如果 data 是字符串，那么需要指定encoding 来说明它的编码方式，默认是 utf-8。在 response.end 调用之前，response.write 可以被多次调用。</li>
<li>response.end([data], [encoding])：  结束响应，告知客户端所有发送已经完成。当所有要返回的内容发送完毕的时候，<strong>该函数 必须 被调用一次。它接受两个可选参数，意义和 response.write 相同</strong>。如果不调用该函数，客户端将永远处于等待状态</li>
</ul>
<h2 id="http-客户端"> HTTP 客户端</h2>
<blockquote>
<p>http 模块提供了两个函数 http.request 和 http.get，功能是作为客户端向 HTTP服务器发起请求。</p>
</blockquote>
<p><strong>http.request(options, callback)  发起 HTTP请求。</strong></p>
<ul>
<li>options：表示请求的参数。
<ul>
<li>host ：请求网站的域名或 IP 地址。</li>
<li>port ：请求网站的端口，默认 80。</li>
<li>method ：请求方法，默认是 GET。</li>
<li>path ：请求的相对于根的路径，默认是“/”。</li>
<li>headers ：请求头的内容；</li>
</ul>
</li>
<li>callback：请求的回调函数。
<ul>
<li>传递一个参数，为 http.ClientResponse 的实例。</li>
</ul>
</li>
</ul>
<blockquote>
<p>http.request 返回一个 http.ClientRequest 的实例。</p>
</blockquote>
<div><pre><code><span>var</span> http <span>=</span> <span>require</span><span>(</span><span>'http'</span><span>)</span>
<span>var</span> querystring <span>=</span> <span>require</span><span>(</span><span>'querystring'</span><span>)</span>
<span>var</span> contents <span>=</span> querystring<span>.</span><span>stringify</span><span>(</span><span>{</span>
  name<span>:</span> <span>'byvoid'</span><span>,</span>
  email<span>:</span> <span>'byvoid@byvoid.com'</span><span>,</span>
  address<span>:</span> <span>'Zijing 2#, Tsinghua University'</span>
<span>}</span><span>)</span>
<span>var</span> options <span>=</span> <span>{</span>
  host<span>:</span> <span>'www.byvoid.com'</span><span>,</span>
  path<span>:</span> <span>'/application/node/post.php'</span><span>,</span>
  method<span>:</span> <span>'POST'</span><span>,</span>
  headers<span>:</span> <span>{</span>
    <span>'Content-Type'</span><span>:</span> <span>'application/x-www-form-urlencoded'</span><span>,</span>
    <span>'Content-Length'</span><span>:</span> contents<span>.</span>length
  <span>}</span>
<span>}</span>
<span>var</span> req <span>=</span> http<span>.</span><span>request</span><span>(</span>options<span>,</span> <span>function</span><span>(</span><span>res</span><span>)</span> <span>{</span>
  res<span>.</span><span>setEncoding</span><span>(</span><span>'utf8'</span><span>)</span>
  res<span>.</span><span>on</span><span>(</span><span>'data'</span><span>,</span> <span>function</span><span>(</span><span>data</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>data<span>)</span>
  <span>}</span><span>)</span>
<span>}</span><span>)</span>
req<span>.</span><span>write</span><span>(</span>contents<span>)</span>
req<span>.</span><span>end</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><div><p>提示</p>
<p>不要忘了通过 req.end() 结束请求，否则服务器将不会收到信息。</p>
</div>
<p><strong>http.get(options, callback)  用于发起GET请求</strong></p>
<blockquote>
<p>它是 http.request 的简化版，唯一的区别在于http.get自动将请求方法设为了 GET 请求，同时不需要手动调用 req.end()。</p>
</blockquote>
<div><pre><code><span>var</span> http <span>=</span> <span>require</span><span>(</span><span>'http'</span><span>)</span>
http<span>.</span><span>get</span><span>(</span><span>{</span> host<span>:</span> <span>'www.baidu.com'</span> <span>}</span><span>,</span> <span>function</span><span>(</span><span>res</span><span>)</span> <span>{</span>
  res<span>.</span><span>setEncoding</span><span>(</span><span>'utf8'</span><span>)</span>
  res<span>.</span><span>on</span><span>(</span><span>'data'</span><span>,</span> <span>function</span><span>(</span><span>data</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>data<span>)</span>
  <span>}</span><span>)</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="http-clientrequest"> http.ClientRequest</h3>
<blockquote>
<p>http.ClientRequest 是由 http.request 或 http.get 返回产生的对象，表示一个已经产生而且正在进行中的 HTTP请求。</p>
</blockquote>
<p>它提供一个 response 事件，即 http.request或 http.get 第二个参数指定的回调函数的绑定对象。我们也可以显式地绑定这个事件的监听函数</p>
<div><pre><code><span>var</span> http <span>=</span> <span>require</span><span>(</span><span>'http'</span><span>)</span>
<span>var</span> req <span>=</span> http<span>.</span><span>get</span><span>(</span><span>{</span> host<span>:</span> <span>'www.baidu.com'</span> <span>}</span><span>)</span>
req<span>.</span><span>on</span><span>(</span><span>'response'</span><span>,</span> <span>function</span><span>(</span><span>res</span><span>)</span> <span>{</span>
  res<span>.</span><span>setEncoding</span><span>(</span><span>'utf8'</span><span>)</span>
  res<span>.</span><span>on</span><span>(</span><span>'data'</span><span>,</span> <span>function</span><span>(</span><span>data</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>data<span>)</span>
  <span>}</span><span>)</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>http.ClientRequest 像 http.ServerResponse 一样也提供了 write 和 end 函数，用于向服务器发送请求体，<strong>通常用于 POST、 PUT 等操作</strong>。所有写结束以后<strong>必须调用 end函数</strong>以通知服务器，否则请求无效。</p>
<p><strong>http.ClientRequest 还提供了以下函数 :</strong></p>
<ul>
<li>request.abort()：终止正在发送的请求。</li>
<li>request.setTimeout(timeout, [callback])：设置请求超时时间， timeout 为毫秒数。当请求超时以后， callback 将会被调用。</li>
</ul>
<h3 id="http-clientresponse"> http.ClientResponse</h3>
<blockquote>
<p>http.ClientResponse 与 http.ServerRequest 相似，提供了三个事件 data、 end和 close，分别在数据到达、传输结束和连接结束时触发，其中 data 事件传递一个参数chunk，表示接收到的数据。</p>
</blockquote>
<p>http.ClientResponse 也提供了一些属性，用于表示请求的结果状态 ;</p>
<p><img src="./assets/image-20210627000016407.png" alt="image-20210627000016407" /></p>
<p>http.ClientResponse 还提供了以下几个特殊的函数。</p>
<ul>
<li>response.setEncoding([encoding])：  设置默认的编码，当 data 事件被触发时，数据将会以 encoding 编码。默认值是 null，即不编码，以 Buffer 的形式存储。常用编码为 utf8。</li>
<li>response.pause()：  暂停接收数据和发送事件，方便实现下载功能。</li>
<li>response.resume()：  从暂停的状态中恢复。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Node.js 是什么</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-14/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-14/</guid>
      <source url="https://wangyawei.top/rss.xml">Node.js 是什么</source>
      <category>nodejs</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Node.js 不是一种独立的语言， Node.js 也不是一个 JavaScript 框架，Node.js 更不是浏览器端的库，不能与 jQuery、 ExtJS 相提并论。 Node.js 是一个让 JavaScript 运行在服务端的开发平台，它让 JavaScript 成为脚本语言世界的一等公民，在服务端堪与 PHP、 Python、Perl、 Ruby 平起平坐。它跳过了 Apache、 Nginx 等 HTTP服务器，直接面向前端开发。</p>
</blockquote>
<h2 id="node-js-与-javascript"> Node.js 与 JavaScript</h2>
<blockquote>
<p>Node.js 是一个划时代的技术。它让 JavaScript 可以脱离浏览器而运行，它实现了诸如文件系统、模块、包、操作系统 API、网络通信等 Core JavaScript 没有或者不完善的功能。 它在原有的 Web 前端和后端技术的基础上总结并提炼出了许多新的概念和方法，堪称是多年来 Web 开发经验的集大成者。 Node.js 的许多设计理念与经典架构（如 LAMP）有着很大的不同，可提供强大的伸缩能力，以适应21世纪10年代以后规模越来越庞大的互联网环境。</p>
<p>JavaScript 是由 ECMAScript、文档对象模型（DOM）和浏览器对象模型（BOM）组成的，而 Mozilla 则指出 JavaScript 由
Core JavaScript 和 Client JavaScript 组成。Node.js 中所谓的 JavaScript 只是ECMAScript 的一个实现，不包含 DOM、 BOM 或者 Client JavaScript。这是因为 Node.js 不运行在浏览器中，所以不需要使用浏览器中的许多特性。</p>
</blockquote>
<ol>
<li>javascript包括；
<ul>
<li>ECMAScript  ;</li>
<li>文档对象模型（DOM）;</li>
<li>浏览器对象模型（BOM）;</li>
</ul>
</li>
<li>Node.js  包括；(只支持 JS语法)
<ul>
<li>ECMAScript</li>
<li>不包含 DOM、 BOM ;</li>
<li>node模块：封装好的js代码；</li>
<li>第三方模块：例 npm安装的</li>
</ul>
</li>
<li>优点：
<ul>
<li>采用v8引擎，V8 号称是目前世界上最快JavaScript 引擎</li>
<li>Node.js 不运行在浏览器中，所以也就不存在 JavaScript 的浏览器兼容性问题，JavaScript 语言的所有特性 ；</li>
<li>遵循了CommonJS规范  ；</li>
<li>采用异步式 I/O 与事件驱动的架构设计；</li>
<li>包含libev 和 libeio 库</li>
</ul>
</li>
<li>缺点；异步事件模式，因为它不符合开发者的常规线性思路，往往需要把一个完整的逻辑拆分为一个个事件，增加了开发和调试难度</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>Node.js 能做什么</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-15/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-15/</guid>
      <source url="https://wangyawei.top/rss.xml">Node.js 能做什么</source>
      <category>nodejs</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>正如 JavaScript 为客户端而生， Node.js 为网络而生。 Node.js 能做的远不止开发一个网站那么简单 ，Node.js 内建了 HTTP 服务器支持，也就是说你可以轻而易举地实现一个网站和服务器的组合。</p>
</blockquote>
<p><strong>使用 Node.js，你可以轻松地开发</strong></p>
<ul>
<li>具有复杂逻辑的网站；</li>
<li>基于社交网络的大规模 Web 应用；</li>
<li>Web Socket 服务器；</li>
<li>TCP/UDP 套接字应用程序；</li>
<li>命令行工具；</li>
<li>交互式终端程序；</li>
<li>带有图形用户界面的本地应用程序；</li>
<li>单元测试工具；</li>
<li>客户端 JavaScript 编译器。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>异步式 I/O 与事件驱动</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-16/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-16/</guid>
      <source url="https://wangyawei.top/rss.xml">异步式 I/O 与事件驱动</source>
      <category>nodejs</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Node.js 最大的特点就是采用异步式 I/O 与事件驱动的架构设计.</p>
</blockquote>
<p><strong>特点：</strong></p>
<ul>
<li>对于高并发的解决方案，传统的架构是多线程模型，也就是为每个业务逻辑提供一个系统线程，通过系统线程切换来弥补同步式 I/O 调用时的时间开销。 Node.js 使用的是单线程模型，对于所有 I/O 都采用异步式的请求方式，避免了频繁的上下文切换。 Node.js 在执行的过程中会维护一个事件队列，程序在执行时进入事件循环等待下一个事件到来，每个异步式 I/O 请求完成后会被推送到事件队列，等待程序进程进行处理。</li>
<li>Node.js 的异步机制是基于事件的，所有的磁盘 I/O、网络通信、数据库查询都以非阻塞的方式请求，返回的结果由事件循环来处理 ;</li>
<li>Node.js 进程在同一时刻只会处理一个事件，完成后立即进入事件循环检查并处理后面的事件。
<ul>
<li>这样做的好处是，CPU 和内存在同一时间集中处理一件事，同时尽可能让耗时的 I/O 操作并行执行。对于低速连接攻击， Node.js 只是在事件队列中增加请求，等待操作系统的回应，因而不会有任何多线程开销，很大程度上可以提高 Web 应用的健壮性，防止恶意攻击</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Node.js 的性能</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-17/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-17/</guid>
      <source url="https://wangyawei.top/rss.xml">Node.js 的性能</source>
      <category>nodejs</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Node.js 用异步式 I/O 和事件驱动代替多线程，带来了可观的性能提升。 Node.js 除了使用 V8 作为JavaScript引擎以外，还使用了高效的 libev 和 libeio 库支持事件驱动和异步式 I/O。</p>
</blockquote>
<p>Node.js 的开发者在 libev 和 libeio 的基础上还抽象出了层 libuv。对于 POSIX操作系统，libuv 通过封装 libev 和 libeio 来利用 epoll 或 kqueue。  而在 Windows 下， libuv 使用了 Windows  的 IOCP（Input/Output Completion Port，输入输出完成端口）机制，以在不同平台下实现同样的高性能。</p>
<p><img src="./assets/image-20210627141529169.png" alt="image-20210627141529169" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>CommonJS规范</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-18/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-18/</guid>
      <source url="https://wangyawei.top/rss.xml">CommonJS规范</source>
      <category>nodejs</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>正如当年为了统一 JavaScript 语言标准，人们制定了 ECMAScript 规范一样，如今为了统一 JavaScript 在浏览器之外的实现， CommonJS 诞生了。</p>
</blockquote>
<p>CommonJS 试图定义一套普通应用程序使用的API，譬如文件系统访问、命令行、模块管理、函数库集成等功能，从而填补 JavaScript 标准库过于简单的不足。 CommonJS 的终极目标是制定一个像 C++ 标准库一样的规范，使得基于 CommonJS API 的应用程序可以在不同的环境下运行，就像用 C++ 编写的应用程序可以使用不同的编译器和运行时函数库一样。为了保持中立， CommonJS 不参与标准库实现，其实现交给像 Node.js 之类的项目来完成。</p>
<p>CommonJS 制定者希望众多服务端 JavaScript 实现遵循CommonJS 规范，以便相互兼容和代码复用。 Node.js 的部份实现遵循了CommonJS规范，但由于两者还都处于诞生之初的快速变化期，也会有不一致的地方。</p>
]]></content:encoded>
    </item>
    <item>
      <title>使用nodejs</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-19/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-19/</guid>
      <source url="https://wangyawei.top/rss.xml">使用nodejs</source>
      <category>nodejs</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>用 Node.js 编程是一件令人愉快的事情，你会发现像这样的语言是很容易入门的，可以快速了解到它的细节，然后掌握它。</p>
</blockquote>
<h2 id="hello-world"> Hello World</h2>
<blockquote>
<p>请保证你已经安装了Nodejs；</p>
</blockquote>
<ol>
<li>
<p>打印<code>hello world</code>;</p>
<ul>
<li>
<p>打开你常用的文本编辑器，在其中输入：console.log('Hello World');</p>
<div><pre><code><span>// helloWorld.js</span>
console<span>.</span><span>log</span><span>(</span><span>'hello world'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>保存后修改文件名为 helloworld.js ；</p>
</li>
<li>
<p>打开终端，进入 helloworld.js 所在的目录，</p>
</li>
<li>
<p>执行以下命令：node helloworld.js</p>
<div><pre><code>C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>test  <span>(</span>test@1.0.0<span>)</span>
$ node helloWorld.js
hello world
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ul>
</li>
</ol>
<h2 id="node-js-命令行工具"> Node.js 命令行工具</h2>
<blockquote>
<p>在前面的 Hello World 示例中，我们用到了命令行中的 node 命令，输入 node --help可以看到详细的帮助信息：</p>
</blockquote>
<div><pre><code>C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>test  <span>(</span>test@1.0.0<span>)</span>                                           
$ node -h                                                                          
Usage: node <span>[</span>options<span>]</span> <span>[</span> script.js <span>]</span> <span>[</span>arguments<span>]</span>                                    
       node inspect <span>[</span>options<span>]</span> <span>[</span> script.js <span>|</span> host:port <span>]</span> <span>[</span>arguments<span>]</span>                
                                                                                   
Options:                                                                           
  -                                          script <span>read</span> from stdin <span>(</span>default <span>if</span> no 
                                             interactive mode <span>if</span> a <span>tty</span><span>)</span>            
  --                                         indicate the end of node options      
  --abort-on-uncaught-exception              aborting instead of exiting causes a c
                                             <span>for</span> analysis                          
  -c, --check                                syntax check script without executing 
  --completion-bash                          print source-able <span>bash</span> completion scri
  --cpu-prof                                 Start the V8 CPU profiler on start up,
                                             profile to disk before exit. If --cpu-
                                             specified, <span>write</span> the profile to the cu
  --cpu-prof-dir<span>=</span><span>..</span>.                         Directory where the V8 profiles genera
                                             be placed. Does not affect --prof.    
  --cpu-prof-interval<span>=</span><span>..</span>.                    specified sampling interval <span>in</span> microse
                                             profile generated with --cpu-prof. <span>(</span>de
  --cpu-prof-name<span>=</span><span>..</span>.                        specified <span>file</span> name of the V8 CPU prof
                                             --cpu-prof                            
  --disable-proto<span>=</span><span>..</span>.                        disable Object.prototype.__proto__    
  --disallow-code-generation-from-strings    disallow <span>eval</span> and friends             
  --enable-source-maps                       experimental Source Map V3 support    
  <span>..</span><span>..</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><blockquote>
<p>其中显示了 node 的用法，运行 Node.js 程序的基本方法就是执行 node script.js，其中 script.js是脚本的文件名。</p>
</blockquote>
<h2 id="repl-模式"> REPL 模式</h2>
<blockquote>
<p>REPL （Read-eval-print loop），即输入—求值—输出循环。使用 cmd 打开的 shell，可以进入一个即时求值的运行环境。运行无参数的 node 将会启动一个 JavaScript的交互式 shell：</p>
</blockquote>
<div><pre><code>C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>test  <span>(</span>test@1.0.0<span>)</span>
$ node
Welcome to Node.js v12.18.0.
Type <span>".help"</span> <span>for</span> <span>more</span> information.
<span>></span> console.log<span>(</span><span>'Hello World'</span><span>)</span><span>;</span>
Hello World
undefined
<span>></span> consol.log<span>(</span><span>'Hello World'</span><span>)</span><span>;</span>
Uncaught ReferenceError: consol is not defined
<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>进入 REPL 模式以后，会出现一个“&gt;”提示符提示你输入命令，输入后按回车， Node.js将会解析并执行命令。如果你执行了一个函数，那么 REPL 还会在下面显示这个函数的返回值，上面例子中的 undefined 就是 console.log 的返回值。如果你输入了一个错误的指令， REPL 则会立即显示错误并输出调用栈。在任何时候，连续按两次 Ctrl + C 即可推出Node.js 的 REPL 模式。node 提出的 REPL 在应用开发时会给人带来很大的便利，例如我们可以测试一个包能否正常使用，单独调用应用的某一个模块，执行简单的计算等 ;</p>
</blockquote>
<h2 id="建立-http-服务器"> 建立 HTTP 服务器</h2>
<blockquote>
<p>Node.js 将“HTTP服务器”这一层抽离，直接面向浏览器用户,所以我们只需几行代码就可以创建一个http服务器；</p>
</blockquote>
<div><pre><code><span>// app.js</span>
<span>// 引入内置的 http 模块</span>
<span>const</span> http <span>=</span> <span>require</span><span>(</span><span>'http'</span><span>)</span><span>;</span>
http<span>.</span><span>createServer</span><span>(</span><span>(</span><span>req<span>,</span> res</span><span>)</span> <span>=></span> <span>{</span>
  <span>// charset=utf-8 识别中文字符</span>
  res<span>.</span><span>writeHead</span><span>(</span><span>200</span><span>,</span> <span>{</span>
    <span>'Content-Type'</span><span>:</span> <span>'text/html;charset=utf-8'</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>
  res<span>.</span><span>write</span><span>(</span><span>'你好'</span><span>)</span><span>;</span>
  res<span>.</span><span>write</span><span>(</span><span>'&lt;h1>Node.js&lt;/h1>'</span><span>)</span><span>;</span>
  res<span>.</span><span>end</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>.</span><span>listen</span><span>(</span><span>3000</span><span>,</span> <span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'服务启动成功'</span><span>)</span>
  <span>}</span>
<span>}</span><span>)</span>

<span>// 终端：node app.js 你会看到  服务启动成功 </span>
<span>// 打开浏览器访问 http://127.0.0.1:3000  ，你会看到 你好 Node.js</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><blockquote>
<p>用 Node.js 实现的最简单的 HTTP 服务器就这样诞生了。这个程序调用了 Node.js 提供的http 模块，对所有 HTTP 请求答复同样的内容并监听 3000 端口。</p>
</blockquote>
<p><strong>小技巧--使用 <a href="https://www.npmjs.com/package/nodemon" target="_blank" rel="noopener noreferrer">nodemon</a></strong></p>
<p>在开发 Node.js 实现的 HTTP 应用时会发现，无论你修改了代码的哪一部份，都必须终止Node.js 再重新运行才会奏效。这是因为 Node.js 只有在第一次引用到某部份时才会去解析脚本文件，以后都会直接访问内存，避免重复载入。 Node.js的这种设计虽然有利于提高性能，却不利于开发调试，因为我们在开发过程中总是希望修改后立即看到效果，而不是每次都要终止进程并重启。
nodemon可以帮助你实现这个功能，它会监视你对代码的改动，并自动重启 Node.js。使用方法很简单，首先使用 npm 安装nodemon：</p>
<div><pre><code><span># npm 安装</span>
<span>npm</span> i nodemon

<span># 查看是否安装成功；</span>
nodemon -v

<span># 运行app.js</span>
nodemon app.js

ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ nodemon app.js 
<span>[</span>nodemon<span>]</span> <span>2.0</span>.7
<span>[</span>nodemon<span>]</span> to restart at any time, enter <span><span>`</span>rs<span>`</span></span>
<span>[</span>nodemon<span>]</span> watching path<span>(</span>s<span>)</span>: *.*
<span>[</span>nodemon<span>]</span> watching extensions: js,mjs,json
<span>[</span>nodemon<span>]</span> starting <span><span>`</span>node app.js<span>`</span></span>
服务启动成功
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><blockquote>
<p>当你的代码被改动时，它会自动检测并运行；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>异步式 I/O 与事件式编程</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-20/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-20/</guid>
      <source url="https://wangyawei.top/rss.xml">异步式 I/O 与事件式编程</source>
      <category>nodejs</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Node.js 最大的特点就是异步式 I/O（或者非阻塞 I/O）与事件紧密结合的编程模式。这种模式与传统的同步式 I/O 线性的编程思路有很大的不同，因为控制流很大程度上要靠事件和回调函数来组织，一个逻辑要拆分为若干个单元。</p>
</blockquote>
<h2 id="阻塞与线程"> 阻塞与线程 ;</h2>
<ol>
<li>
<p>阻塞；</p>
<ul>
<li>线程在执行中如果遇到磁盘读写或网络通信（统称为 I/O 操作），通常要耗费较长的时间，这时操作系统会剥夺这个线程的 CPU 控制权，使其暂停执行，同时将资源让给其他的工作线程，这种线程调度方式称为阻塞。</li>
<li>当 I/O 操作完毕时，操作系统将这个线程的阻塞状态解除，恢复其对CPU的控制权，令其继续执行。这种 I/O 模式就是通
常的同步式 I/O（Synchronous I/O）或阻塞式 I/O （Blocking I/O）。</li>
</ul>
</li>
<li>
<p>线程；</p>
<ul>
<li><a href="https://baike.baidu.com/item/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F" target="_blank" rel="noopener noreferrer">操作系统</a>能够进行运算<a href="https://baike.baidu.com/item/%E8%B0%83%E5%BA%A6" target="_blank" rel="noopener noreferrer">调度</a>的最小单位。它被包含在<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener noreferrer">进程</a>之中，是<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener noreferrer">进程</a>中的实际运作单位。一条线程指的是<a href="https://baike.baidu.com/item/%E8%BF%9B%E7%A8%8B" target="_blank" rel="noopener noreferrer">进程</a>中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。</li>
</ul>
</li>
</ol>
<h2 id="异步式-i-o"> 异步式 I/O</h2>
<p>异步式 I/O （Asynchronous I/O）或非阻塞式 I/O （Non-blocking I/O）则针对所有 I/O 操作不采用阻塞的策略。当线程遇到 I/O 操作时，不会以阻塞的方式等待 I/O 操作的完成或数据的返回，而只是将 I/O 请求发送给操作系统，继续执行下一条语句。当操作系统完成 I/O 操作时，以事件的形式通知执行 I/O 操作的线程，线程会在特定时候处理这个事件。为了处理异步 I/O，线程必须有事件循环，不断地检查有没有未处理的事件，依次予以处理。</p>
<blockquote>
<p>阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。而非阻塞模式下，一个线程永远在执行计算操作，这个线程所使用的 CPU 核心利用率永远是 100%，I/O 以事件的方式通知。在阻塞模式下，多线程往往能提高系统吞吐量，因为一个线程阻塞时还有其他线程在工作，多线程可以让 CPU 资源不被阻塞中的线程浪费。而在非阻塞模式下，线程不会被 I/O 阻塞，永远在利用 CPU。多线程带来的好处仅仅是在多核 CPU 的情况下利用更多的核，而Node.js的单线程也能带来同样的好处。这就是为什么 Node.js 使用了单线程、非阻塞的事件编程模式;</p>
</blockquote>
<p><img src="./assets/image-20210601081746784.png" alt="image-20210601081746784" /></p>
<h2 id="回调函数"> 回调函数；</h2>
<ol>
<li>
<p>在 Node.js 中用异步的方式读取一个文件  ；</p>
<div><pre><code><span>// app.js</span>
<span>// 引入内置的 fs 模块</span>
<span>const</span> fs  <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>

<span>// 这里我指定了编码格式 utf-8 ，因为我的文件中包含中文</span>
fs<span>.</span><span>readFile</span><span>(</span><span>'./readFile.js'</span><span>,</span> <span>'utf-8'</span><span>,</span> <span>(</span><span>err<span>,</span> data</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>data<span>)</span><span>;</span>
  <span>}</span>
<span>}</span><span>)</span>

<span>// 打印结果</span>
end
console<span>.</span><span>log</span><span>(</span><span>'中午好'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></li>
<li>
<p>在 Node.js 中用同步的方式读取一个文件  ；</p>
<div><pre><code><span>const</span> fs  <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>

<span>const</span> content <span>=</span> fs<span>.</span><span>readFileSync</span><span>(</span><span>'./readFile.js'</span><span>,</span> <span>'utf-8'</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>content<span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>'end'</span><span>)</span>

<span>// 打印结果</span>
console<span>.</span><span>log</span><span>(</span><span>'中午好'</span><span>)</span><span>;</span>
end
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
</ol>
<blockquote>
<p>1、 fs.readFileSync 函数同步式读取文件的方式比较容易理解，将文件名作为参数传入，阻塞等待读取完成后，将文件的内容作为函数的返回值赋给变量，接下来控制台输出 值，最后输出 end.。</p>
<p>2、fs.readFile 调用时所做的工作只是将异步式 I/O 请求发送给了操作系统，然后立即返回并执行后面的语句，执行完以后进入事件循环监听事件。当 fs 接收到 I/O 请求完成的事件时，事件循环会主动调用回调函数以完成后续工作。因此我们会先看到 end.，再看到readFile.js文件的内容。</p>
</blockquote>
<div><p>注意</p>
<p>Node.js 中，并不是所有的 API 都提供了同步和异步版本。 Node.js 不鼓励使用同步 I/O。</p>
</div>
<h2 id="事件"> 事件</h2>
<blockquote>
<p>Node.js 所有的异步 I/O 操作在完成时都会发送一个事件到事件队列。在开发者看来，事件由 EventEmitter 对象提供。前面提到的 fs.readFile 和 http.createServer 的回调函数都是通过 EventEmitter 来实现的。</p>
</blockquote>
<div><pre><code><span>const</span> eventEmit <span>=</span> <span>require</span><span>(</span><span>'events'</span><span>)</span><span>.</span>EventEmitter<span>;</span>
<span>const</span> event <span>=</span> <span>new</span> <span>eventEmit</span><span>(</span><span>)</span><span>;</span>

event<span>.</span><span>on</span><span>(</span><span>'some_event'</span><span>,</span> <span>(</span><span>res</span><span>)</span> <span>=></span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>res<span>,</span> <span>'----'</span><span>,</span> <span>'some_event'</span><span>)</span><span>;</span> <span>// 每秒输出： 我执行了 ---- some_event</span>
<span>}</span><span>)</span>

<span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  event<span>.</span><span>emit</span><span>(</span><span>'some_event'</span><span>,</span> <span>'我执行了'</span><span>)</span>
<span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>运行这段代码， 每过1秒后控制台输出了 <code>我执行了 ---- some_event</code>。其原理是 event 对象注册了事件 some_event 的一个监听器，然后我们通过 setInterval在1000毫秒以后向event 对象发送事件 some_event，此时会调用 some_event 的监听器。</p>
</blockquote>
<h3 id="node-js-的事件循环机制"> Node.js 的事件循环机制</h3>
<blockquote>
<p>Node.js 程序由事件循环开始，到事件循环结束，所有的逻辑都是事件的回调函数，所以 Node.js 始终在事件循环中，程序入口就是事件循环第一个事件的回调函数。事件的回调函数在执行的过程中，可能会发出 I/O 请求或直接发射（emit）事件，执行完毕后再返回事件循环，事件循环会检查事件队列中有没有未处理的事件，直到程序结束。Node.js 没有显式的事件循环，事件循环对开发者不可见，由 libev 库实现。libev支持多种类型的事件，如 ev_io、 ev_timer、 ev_signal、 ev_idle 等，在 Node.js 中均被EventEmitter 封装。 libev 事件循环的每一次迭代，在 Node.js 中就是一次 Tick， libev 不断检查是否有活动的、可供检测的事件监听器，直到检测不到时才退出事件循环，进程结束。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>模块和包</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-21/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-21/</guid>
      <source url="https://wangyawei.top/rss.xml">模块和包</source>
      <category>nodejs</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>模块（Module）和包（Package）是 Node.js 最重要的支柱。开发一个具有一定规模的程序不可能只用一个文件，通常需要把各个功能拆分、封装，然后组合起来，模块正是为了实现这种方式而诞生的。在浏览器 JavaScript 中，脚本模块的拆分和组合通常使用 HTML 的script 标签来实现。 Node.js 提供了 require 函数来调用其他模块，而且模块都是基于文件的，机制十分简单。Node.js 的模块和包机制的实现参照了 CommonJS 的标准，</p>
</blockquote>
<h3 id="什么是模块"> 什么是模块；</h3>
<blockquote>
<p>模块是 Node.js 应用程序的基本组成部分，文件和模块是一一对应的。换言之，一个Node.js 文件就是一个模块，这个文件可能是 JavaScript 代码、 JSON 或者编译过的 C/C++ 扩展。我们用到的 var http = require('http')， 其中 http是 Node.js 的一个核心模块，其内部是用 C++ 实现的，外部用 JavaScript 封装。我们通过require 函数获取了这个模块，然后才能使用其中的对象；</p>
</blockquote>
<h3 id="创建模块"> 创建模块；</h3>
<blockquote>
<p>创建一个模块非常简单，因为一个文件就是一个模块，我们要关注的问题仅仅在于如何在其他文件中获取这个模块。 Node.js 提供了 exports 和 require 两个对象，其中 exports 是模块公开的接口， require 用于从外部获取一个模块的接口，即所获取模块的 exports 对象。</p>
</blockquote>
<div><pre><code><span>// module.js</span>
<span>let</span> name <span>=</span> <span>''</span>
exports<span>.</span><span>setName</span> <span>=</span> <span>(</span><span>thyName</span><span>)</span> <span>=></span> <span>{</span>
  name <span>=</span> thyName
<span>}</span>

exports<span>.</span><span>sayHello</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'Hello '</span> <span>+</span> name<span>)</span><span>;</span> <span>// Hello 小萌</span>
<span>}</span><span>;</span>
<span>// 或</span>
<span>let</span> name <span>=</span> <span>''</span>
module<span>.</span>exports<span>.</span><span>setName</span> <span>=</span> <span>(</span><span>thyName</span><span>)</span> <span>=></span> <span>{</span>
  name <span>=</span> thyName
<span>}</span>
module<span>.</span>exports<span>.</span><span>sayHello</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'Hello '</span> <span>+</span> name<span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>// getModule.js</span>
<span>const</span> myModule <span>=</span> <span>require</span><span>(</span><span>'./module.js'</span><span>)</span><span>;</span>
myModule<span>.</span><span>setName</span><span>(</span><span>'小萌'</span><span>)</span><span>;</span>
myModule<span>.</span><span>sayHello</span><span>(</span><span>)</span><span>;</span>
<span>// 运行node getmodule.js，结果是：Hello 小萌</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><blockquote>
<p>在以上示例中， module.js 通过 exports 对象把 setName 和 sayHello 作为模块的访问接口，在 getModule.js 中通过require('./module') 加载这个模块，然后就可以直接访问 module.js 中 exports 对象的成员函数了。</p>
</blockquote>
<h4 id="单次加载"> 单次加载；</h4>
<blockquote>
<p>require 不会重复加载模块，也就是说无论调用多少次 require， 获得的模块都是同一个。</p>
</blockquote>
<div><pre><code><span>// module.js</span>
<span>let</span> name <span>=</span> <span>''</span>
module<span>.</span>exports<span>.</span><span>setName</span> <span>=</span> <span>(</span><span>thyName</span><span>)</span> <span>=></span> <span>{</span>
  name <span>=</span> thyName
<span>}</span>
module<span>.</span>exports<span>.</span><span>sayHello</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'Hello '</span> <span>+</span> name<span>)</span><span>;</span>
<span>}</span>

<span>// getModule.js</span>
<span>const</span> myModule1 <span>=</span> <span>require</span><span>(</span><span>'./module.js'</span><span>)</span><span>;</span>
<span>const</span> myModule2<span>=</span> <span>require</span><span>(</span><span>'./module.js'</span><span>)</span><span>;</span>
myModule1<span>.</span><span>setName</span><span>(</span><span>'小萌'</span><span>)</span><span>;</span>
myModule2<span>.</span><span>setName</span><span>(</span><span>'小红'</span><span>)</span><span>;</span>
myModule1<span>.</span><span>sayHello</span><span>(</span><span>)</span><span>;</span>

<span>// 这里我们引入了两次 module.js 模块，但是最后的输出的结果为 hello 小红 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><blockquote>
<p>运行后发现输出结果是 <code>hello 小红</code> ，这是因为变量 <code>myModule2</code> 和 <code>myModule1</code>指向的是同一个实例，因此 myModule2.setName 的结果被 myModule1.setName 覆盖，最终输出结果是由后者决定的。</p>
</blockquote>
<h4 id="覆盖-exports"> 覆盖 exports ;</h4>
<div><pre><code><span>// module.js</span>
<span>function</span> <span>Hello</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> name<span>;</span>
  <span>this</span><span>.</span><span>setName</span> <span>=</span> <span>function</span> <span>(</span><span>thyName</span><span>)</span> <span>{</span>
    name <span>=</span> thyName<span>;</span>
  <span>}</span><span>;</span>
  <span>this</span><span>.</span><span>sayHello</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'Hello '</span> <span>+</span> name<span>)</span><span>;</span>
  <span>}</span><span>;</span>
<span>}</span><span>;</span>
<span>// 导出</span>
exports<span>.</span>Hello <span>=</span> Hello<span>;</span>

<span>// getModule.js</span>
<span>const</span> myModule1 <span>=</span> <span>require</span><span>(</span><span>'./module.js'</span><span>)</span><span>.</span>Hello<span>;</span>
<span>const</span> obj1 <span>=</span> <span>new</span> <span>myModule1</span><span>(</span><span>)</span><span>;</span>
obj1<span>.</span><span>setName</span><span>(</span><span>'小萌'</span><span>)</span><span>;</span>
obj1<span>.</span><span>sayHello</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><blockquote>
<p>上面的例子我们想要使用<code>module.js</code>模块，那么我们需要通过 require('./singleobject').Hello 来获取Hello 对象，这略显冗余，可以用下面方法稍微简化：</p>
</blockquote>
<div><pre><code><span>// module.js</span>
<span>function</span> <span>Hello</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> name<span>;</span>
  <span>this</span><span>.</span><span>setName</span> <span>=</span> <span>function</span> <span>(</span><span>thyName</span><span>)</span> <span>{</span>
    name <span>=</span> thyName<span>;</span>
  <span>}</span><span>;</span>
  <span>this</span><span>.</span><span>sayHello</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'Hello '</span> <span>+</span> name<span>)</span><span>;</span>
  <span>}</span><span>;</span>
<span>}</span><span>;</span>
<span>// 这里添加 modeule</span>
modeule<span>.</span>exports <span>=</span> Hello<span>;</span>

<span>// getModule.js</span>
<span>// 这里可以不用.Hello了</span>
<span>const</span> myModule1 <span>=</span> <span>require</span><span>(</span><span>'./module.js'</span><span>)</span><span>;</span>
<span>const</span> obj1 <span>=</span> <span>new</span> <span>myModule1</span><span>(</span><span>)</span><span>;</span>
obj1<span>.</span><span>setName</span><span>(</span><span>'小萌'</span><span>)</span><span>;</span>
obj1<span>.</span><span>sayHello</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><blockquote>
<p>注意，模块接口的唯一变化是使用 module.exports = Hello 代替了 exports.Hello=Hello。在外部引用该模块时，其接口对象就是要输出的 Hello 对象本身，而不是原先的exports。事实上， exports 本身仅仅是一个普通的空对象，即 {}，它专门用来声明接口，本质上是通过它为模块闭包的内部建立了一个有限的访问接口。因为它没有任何特殊的地方，所以可以用其他东西来代替，譬如我们上面例子中的 Hello 对象。</p>
</blockquote>
<div><p>注意</p>
<p>不可以通过对 exports 直接赋值代替对 module.exports 赋值。exports 实际上只是一个和 module.exports 指向同一个对象的变量，
它本身会在模块执行结束后释放，但 module 不会，因此只能通过指定module.exports 来改变访问接口。</p>
</div>
<div><p>提示</p>
<p>一个js文件就是一个模块，然而一些变量是有本地和全局之分的：</p>
<p>本地：可以理解为每个js文件所拥有的变量，是当前模块暴露出来的变量，其中本地变量包含：<code>exports</code> <code>module</code> <code>require</code> <code>this</code> <code>__dirname</code> <code>__filename</code> ；<strong>所以你会发现打印global是找不到这些变量的</strong></p>
<p>全局：全局变量可以理解为浏览器端的<code>window</code>，在nodejs中是：<code>global</code></p>
<p><strong>想要查看这些变量可以使用远程调试来查看；</strong></p>
<div><pre><code><span>ASUS</span>@yaweidediannao <span>MINGW64</span> <span>~</span><span>/</span>Desktop<span>/</span>test
$ node <span>--</span>inspect<span>-</span>brk module<span>.</span>js
Debugger listening on ws<span>:</span><span>/</span><span>/</span><span>127.0</span><span>.0</span><span>.1</span><span>:</span><span>9229</span><span>/</span>e96bbb47<span>-</span><span>3</span>ece<span>-</span><span>45</span>a2<span>-</span><span>97e2</span><span>-</span><span>2376</span>f23825f4
For help<span>,</span> see<span>:</span> https<span>:</span><span>/</span><span>/</span>nodejs<span>.</span>org<span>/</span>en<span>/</span>docs<span>/</span>inspector
Debugger attached<span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src="./assets/image-20210617080445839.png" alt="image-20210617080445839" /></p>
</div>
<h3 id="创建包"> 创建包；</h3>
<blockquote>
<p>包是在模块基础上更深一步的抽象。它将某个独立的功能封装起来，用于发布、更新、依赖管理和版本控制。 Node.js 根据 CommonJS 规范实现了包机制，开发了 npm来解决包的发布和获取需求。Node.js 的包是一个目录，其中包含一个 JSON 格式的包说明文件 package.json。</p>
</blockquote>
<ol>
<li>严格符合 CommonJS 规范的包应该具备以下特征：
<ul>
<li>package.json 必须在包的顶层目录下；</li>
<li>二进制文件应该在 bin 目录下；</li>
<li>JavaScript 代码应该在 lib 目录下；</li>
<li>文档应该在 doc 目录下；</li>
<li>单元测试应该在 test 目录下。</li>
</ul>
</li>
</ol>
<blockquote>
<p>Node.js 对包的要求并没有这么严格，只要顶层目录下有 package.json，并符合一些规范即可。当然为了提高兼容性，我们还是建议你在制作包的时候，严格遵守 CommonJS 规范。</p>
</blockquote>
<h3 id="nodejs包管理器"> Nodejs包管理器；</h3>
<blockquote>
<p>Node.js包管理器，即npm是 Node.js 官方提供的包管理工具，它已经成了 Node.js 包的标准发布平台，用于 Node.js 包的发布、传播、依赖控制。 npm 提供了命令行工具，使你可以方便地下载、安装、升级、删除包，也可以让你作为开发者发布并维护包。</p>
</blockquote>
<h4 id="获取一个包"> 获取一个包</h4>
<div><pre><code>// 语法
<span>npm</span> <span>[</span>install/i<span>]</span> <span>[</span>package_name<span>]</span>

// 获取express  本地安装
<span>npm</span> <span>install</span> express 
// 或
<span>npm</span> i express
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id="全局模式"> 全局模式</h4>
<blockquote>
<p>npm 默认会把包安装到当前目录下。这反映了 npm 不同的设计哲学。如果把包安装到全局，可以提高程序的重复利用程度，避免同样的内容的多份副本，但坏处是难以处理不同的版本依赖。如果把包安装到当前目录，或者说本地，则不会有不同程序依赖不同版本的包的冲突问题，同时还减轻了包作者的 API 兼容性压力，但缺陷则是同一个包可能会被安装许多次。</p>
</blockquote>
<div><pre><code><span>npm</span> i -g express
</code></pre>
<div><span>1</span><br></div></div><div><p>提示</p>
<p>使用全局模式安装的包并不能直接在 JavaScript 文件中用 require 获得，因为 require 不会搜索 /usr/local/lib/node_modules/。</p>
</div>
<table>
<thead>
<tr>
<th style="text-align:center">模式</th>
<th style="text-align:center">可通过require使用</th>
<th style="text-align:center">注册PATH</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">本地模式</td>
<td style="text-align:center">是</td>
<td style="text-align:center">否</td>
</tr>
<tr>
<td style="text-align:center">全局模式</td>
<td style="text-align:center">否</td>
<td style="text-align:center">是</td>
</tr>
</tbody>
</table>
<blockquote>
<p>总而言之，当我们要把某个包作为工程运行时的一部分时，通过本地模式获取，如果要在命令行下使用，则使用全局模式安装。</p>
</blockquote>
<h4 id="创建全局链接"> 创建全局链接</h4>
<blockquote>
<p>npm 提供了一个有趣的命令 <code>npm link</code>， 它的功能是在本地包和全局包之间创建符号链接。我们说过使用全局模式安装的包不能直接通过 require 使用，但通过 npm link命令可以打破这一限制。</p>
</blockquote>
<div><pre><code><span># 通过  npm root -g 查找全局包的安装位置</span>
$ <span>npm</span> root -g
C:<span>\</span>Program Files<span>\</span>nodejs<span>\</span>node_modules

<span># 链接；我这里使用了nvm控制nodejs版本</span>
<span>npm</span> <span>link</span> express
./node_modules/express -<span>></span> /d/nvm/v12.18.0/node_modules/express/
<span># 在 node_modules 子目录中可以发现一个指向安装到全局的包的符号链接。通过这种方法，我们就可以把全局包当本地包来使用了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>调试</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-22/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-22/</guid>
      <source url="https://wangyawei.top/rss.xml">调试</source>
      <category>nodejs</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>写程序时免不了遇到 bug，而当 bug 发生以后，除了抓耳挠腮之外，一个常用的技术是单步调试。  在浏览器中我们可以通过开发者工具进行调试。然而Node.js 的调试功能正是由 V8 提供的，保持了一贯的高效和方便的特性</p>
</blockquote>
<h3 id="命令行调试"> 命令行调试 ；</h3>
<p>Node.js 支持命令行下的单步调试。</p>
<div><pre><code><span># node inspect module.js</span>

ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node inspect module.js
<span>&lt;</span> Debugger listening on
<span>&lt;</span>  ws://127.0.0.1:9229/b3996866-2006-4c08-8330-1b5432dd33e8
<span>&lt;</span> For help, see: https://nodejs.org/en/docs/inspector
<span>&lt;</span> Debugger attached.
Break on start <span>in</span> module.js:1
<span>></span> <span>1</span> const a <span>=</span> <span>1</span><span>;</span>
  <span>2</span> const b <span>=</span> <span>2</span><span>;</span>
  <span>3</span> <span>function</span> fn<span>(</span>x<span>)</span> <span>{</span>
debug<span>></span> n
<span>break</span> <span>in</span> module.js:2
  <span>1</span> const a <span>=</span> <span>1</span><span>;</span>
<span>></span> <span>2</span> const b <span>=</span> <span>2</span><span>;</span>
  <span>3</span> <span>function</span> fn<span>(</span>x<span>)</span> <span>{</span>
  <span>4</span>   console.log<span>(</span>x, a + b<span>)</span><span>;</span>
debug<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><blockquote>
<p>这样就打开了一个 Node.js 的调试终端，我们可以用一些基本的命令进行单步跟踪调试</p>
</blockquote>
<p><img src="./assets/image-20210604080352410.png" alt="image-20210604080352410" /></p>
<div><p>注意</p>
<p>这里涉及到一个版本的问题，</p>
<p>1、<strong>Node8.9</strong>版本时 执行<code>node inspect module.js</code>会出现报错，</p>
<p>2、<strong>node 12.18.0</strong>版本时，不在报错了，但是出现另一个问题<code>Timeout (2000) waiting for 127.0.0.1:9229 to be free</code>;社区提出的解决方案是使用<code>node --inspect-brk module.js</code>,它会在你的终端开启一个服务，需要用浏览器打开提供的url，然后利用谷歌的<code>DevTools</code>进行可视化调试；</p>
<p>3、<strong>Node15.8</strong>版本时，已经修复了这个问题；直接终端执行<code>node inspect module.js</code>;依然可以用浏览器的调试工具进行可视化调试；</p>
</div>
<p>node8.9</p>
<div><pre><code>PS C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>test<span>></span> node inspect module.js
There was an internal error <span>in</span> node-inspect. Please report this bug.
Timeout <span>(</span><span>2000</span><span>)</span> waiting <span>for</span> <span>127.0</span>.0.1:9229 to be <span>free</span>
Error: Timeout <span>(</span><span>2000</span><span>)</span> waiting <span>for</span> <span>127.0</span>.0.1:9229 to be <span>free</span>
    at Timeout.setTimeout <span>[</span>as _onTimeout<span>]</span> <span>(</span>node-inspect/lib/_inspect.js:63:14<span>)</span>
    at ontimeout <span>(</span>timers.js:475:11<span>)</span>
    at tryOnTimeout <span>(</span>timers.js:310:5<span>)</span>
    at Timer.listOnTimeout <span>(</span>timers.js:270:5<span>)</span>
PS C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>test<span>></span> node debug
<span>(</span>node:9612<span>)</span> <span>[</span>DEP0068<span>]</span> DeprecationWarning: <span><span>`</span>node debug<span>`</span></span> is deprecated. Please use <span><span>`</span>node inspect<span>`</span></span> instead.
Usage: C:<span>\</span>Program Files<span>\</span>nodejs<span>\</span>node.exe debug script.js
       C:<span>\</span>Program Files<span>\</span>nodejs<span>\</span>node.exe debug <span>&lt;</span>host<span>></span>:<span>&lt;</span>port<span>></span>
       C:<span>\</span>Program Files<span>\</span>nodejs<span>\</span>node.exe debug -p <span>&lt;</span>pid<span>></span>
PS C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>test<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>node12.18.0</p>
<div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node -v
v12.18.0
ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node inspect module.js
Timeout <span>(</span><span>2000</span><span>)</span> waiting <span>for</span> <span>127.0</span>.0.1:9229 to be <span>free</span>
ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node --inspect-brk module.js
Debugger listening on ws://127.0.0.1:9229/8261b94b-a71c-4eaa-a4fe-6f93b06fb221
For help, see: https://nodejs.org/en/docs/inspector
<span># 需要在浏览器打开这个地址后用devtool调试: 127.0.0.1:9229/8261b94b-a71c-4eaa-a4fe-6f93b06fb221</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>Node15.8</p>
<div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node -v
v15.8.0
ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node inspect module.js
<span>&lt;</span> Debugger listening on
<span>&lt;</span> ws://127.0.0.1:9229/0417f239-a689-4372-a68c-412bbd299556
<span>&lt;</span> For help, see: https://nodejs.org/en/docs/inspector
<span>&lt;</span> Debugger attached.
Break on start <span>in</span> module.js:1
<span>></span> <span>1</span> const a <span>=</span> <span>1</span><span>;</span>
  <span>2</span> const b <span>=</span> <span>2</span><span>;</span>
  <span>3</span> <span>function</span> fn<span>(</span>x<span>)</span> <span>{</span>
<span>&lt;</span> Debugger attached.
debug<span>></span> n
<span>break</span> <span>in</span> module.js:2
  <span>1</span> const a <span>=</span> <span>1</span><span>;</span>
<span>></span> <span>2</span> const b <span>=</span> <span>2</span><span>;</span>
  <span>3</span> <span>function</span> fn<span>(</span>x<span>)</span> <span>{</span>
  <span>4</span>   console.log<span>(</span>x, a + b<span>)</span><span>;</span>
debug<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id="远程调试"> 远程调试：</h3>
<blockquote>
<p>V8 提供的调试功能是基于 TCP 协议的，因此 Node.js 可以轻松地实现远程调试。在命令行下使用以下两个语句之一可以打开调试服务器：</p>
</blockquote>
<div><pre><code><span>// node --inspect[=port] script.js</span>
<span>// node --inspect-brk[=port] script.js</span>

<span>// module.js</span>
<span>const</span> a <span>=</span> <span>1</span><span>;</span>
<span>const</span> b <span>=</span> <span>2</span><span>;</span>
<span>debugger</span><span>;</span>
<span>function</span> <span>fn</span><span>(</span><span>x</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>x<span>,</span> a <span>+</span> b<span>)</span><span>;</span>
<span>}</span><span>;</span>
<span>fn</span><span>(</span><span>'计算和值'</span><span>)</span>

<span>ASUS</span>@yaweidediannao <span>MINGW64</span> <span>~</span><span>/</span>Desktop<span>/</span>test
$ node <span>--</span>inspect <span>.</span><span>/</span>module<span>.</span>js
Debugger listening on ws<span>:</span><span>/</span><span>/</span><span>127.0</span><span>.0</span><span>.1</span><span>:</span><span>9229</span><span>/</span><span>9</span>d655deb<span>-</span><span>9123</span><span>-</span><span>4054</span><span>-</span><span>8515</span><span>-</span>a7c63abbc09f
For help<span>,</span> see<span>:</span> https<span>:</span><span>/</span><span>/</span>nodejs<span>.</span>org<span>/</span>en<span>/</span>docs<span>/</span>inspector
计算和值 <span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>node --inspect命令选项可以启动调试服务器，默认情况下调试端口是 9229，也可以使用 --inspect=1234 指定调试端口为 1234。使用 --inspect选项运行脚本时，<strong>脚本会正常执行，但不会暂停</strong>，在执行过程中调试客户端可以连接到调试服务器。如果要求脚本暂停执行等待客户端连接，则应该使用 --inspect-brk 选项。这时调试服务器在启动后会立刻暂停执行脚本，等待调试客户端连接。</p>
<div><pre><code><span># 使用 --inspect-brk 浏览器打开 127.0.0.1:9229/dab0653a-b13f-48fa-a178-d3ed2939f04b</span>
ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node --inspect-brk ./module.js
Debugger listening on ws://127.0.0.1:9229/dab0653a-b13f-48fa-a178-d3ed2939f04b
For help, see: https://nodejs.org/en/docs/inspector
Debugger attached.
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>当调试服务器启动以后，可以用命令行调试工具作为调试客户端连接，例如：</p>
<div><pre><code><span># 在一个终端中</span>
ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node --inspect-brk ./module.js
Debugger listening on ws://127.0.0.1:9229/dab0653a-b13f-48fa-a178-d3ed2939f04b
For help, see: https://nodejs.org/en/docs/inspector
Debugger attached.

<span># 在另一个终端中</span>
ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node debug <span>127.0</span>.0.1:9229
<span>(</span>node:12756<span>)</span> <span>[</span>DEP0068<span>]</span> DeprecationWarning: <span><span>`</span>node debug<span>`</span></span> is deprecated. Please use <span><span>`</span>node inspect<span>`</span></span> instead.
<span>break</span> <span>in</span> module.js:7
  <span>5</span>   console.log<span>(</span>x, a + b<span>)</span><span>;</span>
  <span>6</span> <span>}</span><span>;</span>
<span>></span> <span>7</span> fn<span>(</span><span>'计算和值'</span><span>)</span>
debug<span>></span> n
<span>break</span> <span>in</span> module.js:7
  <span>5</span>   console.log<span>(</span>x, a + b<span>)</span><span>;</span>
  <span>6</span> <span>}</span><span>;</span>
<span>></span> <span>7</span> fn<span>(</span><span>'计算和值'</span><span>)</span>
debug<span>></span> n
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>模块加载机制</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-23/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-23/</guid>
      <source url="https://wangyawei.top/rss.xml">模块加载机制</source>
      <category>nodejs</category>
      <pubDate>Mon, 28 Jun 2021 07:23:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Node.js 的模块加载对用户来说十分简单，只需调用 require 即可，但其内部机制较为复杂。</p>
</blockquote>
<h2 id="模块的类型"> 模块的类型</h2>
<blockquote>
<p>Node.js 的模块可以分为两大类，一类是核心模块，另一类是文件模块。</p>
</blockquote>
<ol>
<li>核心模块：
<ul>
<li>Node.js 标准 API 中提供的模块，如 fs、 http、 net、 vm 等，由 Node.js 官方提供的模块，编译成了二进制代码。</li>
<li>可以直接通过 require 获取核心模块，例如require('fs')。</li>
<li><strong>核心模块拥有最高的加载优先级，换言之如果有模块与其命名冲突，Node.js 总是会加载核心模块。</strong></li>
</ul>
</li>
<li>文件模块：
<ul>
<li>存储为单独的文件（或文件夹）的模块，可能是 JavaScript 代码、 JSON 或编译好的 C/C++ 代码。</li>
<li>加载方法相对复杂。</li>
<li>在不显式指定文件模块扩展名的时候， Node.js 会分别试图加上 .js、 .json 和 .node扩展名，进行查找。</li>
</ul>
</li>
</ol>
<div style="text-align: center;font-weight: bold">Nodejs模块的类别和加载顺序</div>
<table>
<thead>
<tr>
<th>模块类别</th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>核心模块</td>
<td></td>
<td>内建</td>
</tr>
<tr>
<td>文件模块</td>
<td>JavaScript</td>
<td>.js</td>
</tr>
<tr>
<td></td>
<td>JSON</td>
<td>.json</td>
</tr>
<tr>
<td></td>
<td>C/C++扩展</td>
<td>.node</td>
</tr>
</tbody>
</table>
<h2 id="按路径加载模块"> 按路径加载模块</h2>
<blockquote>
<p>文件模块的加载有两种方式，一种是按路径加载，一种是查找 node_modules 文件夹。</p>
</blockquote>
<ol>
<li>
<p>按路径加载：</p>
<ul>
<li>如果 require 参数以“/ ”开头，那么就以绝对路径的方式查找模块名称。
<ul>
<li>例如 require('/home/byvoid/module') 将 会 按照 优 先 级 依次 尝 试 加 载 /home/byvoid/module.js、 /home/byvoid/module.json 和 /home/byvoid/module.node。</li>
</ul>
</li>
<li>如果 require 参数以“./ ”或“../ ”开头，那么则以相对路径的方式来查找模块。</li>
</ul>
</li>
<li>
<p>查找 node_modules：</p>
<ul>
<li>如果require参数不以“/ ”、“./ ”或“../ ”开头，而该模块又不是核心模块，那么就要通过查找 node_modules 加载模块了。</li>
<li>我们通常引入的npm包就是以这种方式加载的。</li>
<li>当 require 遇到一个既不是核心模块，又不是以路径形式表示的模块名称时，会试图在当前目录下的 node_modules 目录中来查找是不是有这样一个模块。如果没有找到，则会在当前目录的上一层中的 node_modules 目录中继续查找，反复执行这一过程，直到遇到根目录为止。
<ul>
<li>如果我们要在 /home/byvoid/develop/foo.js 中使用 require('bar.js') 命令， Node.js会依次查找：
<ul>
<li>/home/byvoid/develop/node_modules/bar.js。</li>
<li>/home/byvoid/node_modules/bar.js。</li>
<li>/home/node_modules/bar.js。</li>
<li>/node_modules/bar.js。</li>
</ul>
</li>
</ul>
</li>
</ul>
<blockquote>
<p>为什么要这样做呢？因为通常一个工程内会有一些子目录，当子目录内的文件需要访问到工程共同依赖的模块时，就需要向父目录追溯了，比如同级的app.js需要express包，但是一些嵌套目录也有可能使用这个包。</p>
</blockquote>
</li>
</ol>
<h2 id="加载缓存"> 加载缓存</h2>
<blockquote>
<p>Node.js 模块不会被重复加载，这是因为 Node.js 通过文件名缓存所有加载过的文件模块，所以以后再访问到时就不会重新加载了。</p>
</blockquote>
<div><p>提示</p>
<p>Node.js 是根据实际文件名缓存的，而不是 require() 提供的参数缓存的 ，也就是说即使你分别通过require('express') 和 require('./node_modules/express') 加载两次，也不会重复加载，因为尽管两次参数不同，解析到的文件却是同一个。</p>
</div>
<h2 id="加载顺序"> 加载顺序</h2>
<p><strong>使用 require(some_module) 时的加载顺序：</strong></p>
<ol>
<li>如果some_module 是一个核心模块，直接加载，结束。</li>
<li>如果some_module以“/ ”、“./ ”或“../ ”开头，按路径加载 some_module，如果找不到则向上追溯，直到遇到根目录，抛出异常，结束。</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>控制流</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-24/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-24/</guid>
      <source url="https://wangyawei.top/rss.xml">控制流</source>
      <category>nodejs</category>
      <pubDate>Tue, 29 Jun 2021 07:55:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>基于异步 I/O 的事件式编程容易将程序的逻辑拆得七零八落，给控制流的疏理制造障碍。</p>
</blockquote>
<h2 id="循环的陷阱"> 循环的陷阱</h2>
<blockquote>
<p>Node.js 的异步机制由事件和回调函数实现，一开始接触可能会感觉违反常规，但习惯以后就会发现还是很简单的。然而这之中其实暗藏了不少陷阱。</p>
</blockquote>
<p><strong>循环中的回调函数</strong></p>
<div><pre><code><span>var</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>
<span>var</span> files <span>=</span> <span>[</span><span>'1.text'</span><span>,</span> <span>'2.text'</span><span>,</span> <span>'3.text'</span><span>]</span>
<span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> files<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
  fs<span>.</span><span>readFile</span><span>(</span>files<span>[</span>i<span>]</span><span>,</span> <span>'utf-8'</span><span>,</span> <span>function</span><span>(</span><span>err<span>,</span> contents</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>files<span>[</span>i<span>]</span> <span>+</span> <span>': '</span> <span>+</span> contents<span>)</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code><span># 当你多次执行时，你会发现这个结果的顺序也是不固定的，text3也可能排在最前面，这要看哪一个异步最先完成。</span>
ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module
undefined: text2
undefined: text1
undefined: text3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>
<p>上面的例子我们发现，文件内容正确输出了，而文件名却不对为<code>undefined</code>；</p>
</blockquote>
<p><strong>原因分析</strong></p>
<div><pre><code><span>var</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>
<span>var</span> files <span>=</span> <span>[</span><span>'1.text'</span><span>,</span> <span>'2.text'</span><span>,</span> <span>'3.text'</span><span>]</span>
<span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> files<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
  fs<span>.</span><span>readFile</span><span>(</span>files<span>[</span>i<span>]</span><span>,</span> <span>'utf-8'</span><span>,</span> <span>function</span><span>(</span><span>err<span>,</span> contents</span><span>)</span> <span>{</span>
    <span>// console.log(files[i] + ': ' + contents)</span>
    console<span>.</span><span>log</span><span>(</span>files<span>)</span>
    console<span>.</span><span>log</span><span>(</span>i<span>)</span>
    console<span>.</span><span>log</span><span>(</span>files<span>[</span>i<span>]</span><span>)</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span># 我们依次打印出 files、i、files[i]结果如下：</span>
ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module
<span>[</span> <span>'1.text'</span>, <span>'2.text'</span>, <span>'3.text'</span> <span>]</span>
<span>3</span>
undefined
<span>[</span> <span>'1.text'</span>, <span>'2.text'</span>, <span>'3.text'</span> <span>]</span>
<span>3</span>
undefined
<span>[</span> <span>'1.text'</span>, <span>'2.text'</span>, <span>'3.text'</span> <span>]</span>
<span>3</span>
undefined
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>
<p>通过上面的结果我们发现，三次输出的 i 的值都是 3，超出了 files 数组的下标范围，因此 files[i] 的值就是 undefined 了。</p>
</blockquote>
<p>这种情况通常会在 for 循环结束时发生，退出循环时 i 的值就是files.length 的值。既然 i 的值是 3，那么说明了事实上 fs.readFile 的回调函数中访问到的 i 值都是循环退出以后的，因此<code>files[i]</code>的结果为undefined。而 files[i] 作为 fs.readFile 的第一个参数在循环中就传递了，所以文件可以被定位到，而且可以显示出文件的内容。</p>
<p><strong>问题解决：方法1</strong> 利用JavaScript 函数式编程的特性，手动建立一个闭包：</p>
<div><pre><code><span>var</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span>
<span>var</span> files <span>=</span> <span>[</span><span>'1.text'</span><span>,</span> <span>'2.text'</span><span>,</span> <span>'3.text'</span><span>]</span>
<span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> files<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
  <span>(</span><span>function</span><span>(</span><span>i</span><span>)</span><span>{</span>
    fs<span>.</span><span>readFile</span><span>(</span>files<span>[</span>i<span>]</span><span>,</span> <span>'utf-8'</span><span>,</span> <span>function</span><span>(</span><span>err<span>,</span> contents</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span>files<span>[</span>i<span>]</span> <span>+</span> <span>': '</span> <span>+</span> contents<span>)</span>
    <span>}</span><span>)</span>
  <span>}</span><span>)</span><span>(</span>i<span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module
<span>1</span>.text: text1
<span>2</span>.text: text2
<span>3</span>.text: text3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>
<p>我们在 for 循环体中建立了一个匿名函数，将循环迭代变量 i 作为函数的参数传递并调用。由于运行时闭包的存在，该匿名函数中定义的变量在它内部的函数（fs.readFile 的回调函数）执行完毕之前都不会释放，因此我们在其中访问到的 i 就分别是不同的闭包实例，这个实例是在循环体执行的过程中创建的，保留了不同的值。</p>
</blockquote>
<p><strong>问题解决：方法2</strong> 利用JavaScript forEach 方法  ：</p>
<div><pre><code><span>var</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span>
<span>var</span> files <span>=</span> <span>[</span><span>'1.text'</span><span>,</span> <span>'2.text'</span><span>,</span> <span>'3.text'</span><span>]</span>
files<span>.</span><span>forEach</span><span>(</span><span>item</span> <span>=></span> <span>{</span>
  fs<span>.</span><span>readFile</span><span>(</span>item<span>,</span> <span>'utf-8'</span><span>,</span> <span>function</span><span>(</span><span>err<span>,</span> contents</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>item <span>+</span> <span>': '</span> <span>+</span> contents<span>)</span>
  <span>}</span><span>)</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module
<span>1</span>.text: text1
<span>2</span>.text: text2
<span>3</span>.text: text3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><p>注意</p>
<p>无论你使用上面哪一种方法，当你多次执行时，你会发现结果的顺序可能会发生变化，text3也可能第一个输出，这主要取决于哪一个异步最先完成。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>Node.js 不是银弹</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-25/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-25/</guid>
      <source url="https://wangyawei.top/rss.xml">Node.js 不是银弹</source>
      <category>nodejs</category>
      <pubDate>Tue, 29 Jun 2021 08:14:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要讨论一下Node.js 不适合做什么，以及它的不足之处和一些弊端。</p>
</blockquote>
<p>在西方古老的传说里，有一种叫做“狼人”的可怕生物。这种生物平时和人类没有什么不同之处，但每到月圆之夜，他们就会变成狼身。当他们变成狼以后，兽性会不能控制，开始袭击普通的人类。狼人给人类带来了巨大的恐惧，因为他们是无法被一般的手段杀死的，只有用赐福过的银弹（Silver Bullet）才能杀死狼人。<strong>“银弹”因此成为了“任何能够带来极大效果的直接解决方案”的代名词。</strong></p>
<h2 id="node-js-不适合做什么"> Node.js 不适合做什么</h2>
<blockquote>
<p>Node.js 是一个优秀的平台，它有许多传统架构不具备的优点，以至于我们情不自禁地愿意用它来做开发。 其实Node.js 和任何东西一样，都有它擅长的和不擅长的事情，如果你非要用它来做它不擅长的事情，那么你将会陷入僵局之中。</p>
</blockquote>
<h3 id="计算密集型的程序"> 计算密集型的程序</h3>
<p>​		我们知道Nodejs是单线程的，因为Node.js的开发者和支持者坚信单线程和事件驱动的异步式编程比传统的多线程编程运行效
率更高。但事实上多线程可以达到同样的吞吐量，尽管可能开销不小。相比之下， Node.js 由于其单线程性的特性，必须通过多进程的方法才能充分利用多核资源。</p>
<p>​		理想情况下， Node.js单线程在执行的过程中会将一个CPU核心完全占满，所有的请求必须等待当前请求处理完毕以后进入事件循环才能响应。如果一个应用是计算密集型的，那么除非你手动将它拆散，否则请求响应延迟将会相当大。例如，某个事件的回调函数中要进行复杂的计算，占用CPU 200毫秒，那么事件循环中所有的请求都要等待200毫秒。为了提高响应速度，你唯一的办法就是把这个计算密集的部分拆成若干个逻辑，这给编程带来了额外的复杂性。即使这样，系统的总吞吐量和总响应延迟也不会降低，只是调度稍微公平了一些。不过好在真正的Web 服务器中，很少会有计算密集的部分，如果真的有，那么它不应该被实现为即时的响应。正确的方式是给用户一个提示，说服务器正在处理中，完成后会通知用户，然后交给服务器的其他进程甚至其他专职的服务器来做这件事。</p>
<h3 id="单用户多任务型应用"> 单用户多任务型应用</h3>
<p>​		尽管是单用户，却不一定是单任务。例如给用户提供界面的同时后台在进行某个计算，为了让用户界面不出现阻塞状态，你不得不开启多线程或多进程。而Node.js 线程或进程之间的通信到目前为止还很不便，因为它根本没有锁，因而号称不会死锁。 Node.js 的多进程往往是在执行同一任务，通过多进程利用多处理器的资源，但遇到多进程相互协作时，就显得捉襟见肘了。</p>
<h3 id="逻辑十分复杂的事务"> 逻辑十分复杂的事务</h3>
<p>​		Node.js 的控制流不是线性的，它被一个个事件拆散，但人的思维却是线性的，当你试图转换思维来迎合语言或编译器时，就不得不作出牺牲。举例来说，你要实现一个这样的逻辑：从银行取钱，拿钱去购买某个虚拟商品，买完以后加入库存数据库，这中间的任何一步都可能会涉及数十次的I/O操作，而且任何一次操作失败以后都要进行回滚操作。这个过程是线性的，已经很复杂了，如果要拆分为非线性的逻辑，那么其复杂程度很可能就达到无法维护的地步了。Node.js更善于处理那些逻辑简单但访问频繁的任务，而不适合完成逻辑十分复杂的工作。</p>
<h3 id="unicode-与国际化"> Unicode 与国际化</h3>
<p>​		Node.js 不支持完整的Unicode，很多字符无法用string 表示。公平地说这不是Node.js 的缺陷，而是JavaScript 标准的问题。 这其实是一个历史遗留问题，最早的Unicode设计者认为65536个字符足以囊括全世界所有的文字了，因此那个时候盲目兼容Unicode 的系统或平台（如Windows、 Java 和JavaScript）在后来都遇到了问题。</p>
<p>​		因此你无法使用Node.js 处理罕见的字符。想用Node.js 实现一个多语言的字典工具？除非你放弃使用string 数据类型，把所有的字符当作二进制的Buffer 数据来处理。</p>
]]></content:encoded>
    </item>
    <item>
      <title>安装nodejs</title>
      <link>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-26/</link>
      <guid>https://wangyawei.top/views/backEnd/nodejs/nodejs-note-26/</guid>
      <source url="https://wangyawei.top/rss.xml">安装nodejs</source>
      <category>nodejs</category>
      <pubDate>Sun, 11 Jul 2021 15:54:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>在 Windows 上安装 Node.js 十分方便，你只需要访问http://nodejs.org，点击Download链接，然后选择Windows Installer，下载安装包。下载完成后打开安装包，点击Next即可自动完成安装。</p>
</blockquote>
<p><img src="./assets/image-20210711161248602.png" alt="image-20210711161248602" /></p>
<p>Node.js 会被安装到 C:\Program Files\nodejs 或C:\Program Files (x86)\nodejs（64位系统）目录下，并且会在系统的 PATH 环境变量中增加该目录，因此我们可以在 Windows 的命令提示符中直接运行 node。为了测试是否已经安装成功，我们在运行中输入 cmd，打开命令提示符，然后输入 node，将会进入 Node.js 的交互模式。</p>
<div><pre><code>PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>></span> node -v
v14.17.3
PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>></span> <span>npm</span> -v
<span>6.14</span>.13
PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>></span> node
Welcome to Node.js v14.17.3.
Type <span>".help"</span> <span>for</span> <span>more</span> information.
<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><p>提示</p>
<p>nodejs安装会附带npm，所以你可以直接使用npm，不必在下载安装；</p>
</div>
<p>卸载nodejs直接在程序和功能中点击卸载即可；</p>
]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/backEnd/tomcat/</link>
      <guid>https://wangyawei.top/views/backEnd/tomcat/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>TOMCAT</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些自己平时学习tomcat的学习的一些相关的知识；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>tomcat安装</title>
      <link>https://wangyawei.top/views/backEnd/tomcat/tomcat-note-00/</link>
      <guid>https://wangyawei.top/views/backEnd/tomcat/tomcat-note-00/</guid>
      <source url="https://wangyawei.top/rss.xml">tomcat安装</source>
      <category>TOMCAT</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1、下载安装包"> 1、下载安装包；</h2>
<p><a href="https://tomcat.apache.org/download-80.cgi" target="_blank" rel="noopener noreferrer">安装包</a></p>
<p><img src="./assets/1594550355325.png" alt="1594550355325" /></p>
<ul>
<li>
<p>把下载的安装包，传到服务器；</p>
<ul>
<li><strong>我已安装完成，所以下面的文件上传我只是举例</strong>；</li>
</ul>
<blockquote>
<p><code>scp</code>命令是用于<code>linux</code>机器之间复制文件夹或目录。<code>scp</code>是<code>source copy</code>的缩写，<code>scp</code>是基于<code>ssh</code>登录进行安全的远程文件的拷贝命令，<code>scp</code>是加密的，<code>rcp</code>是不加密的，<code>scp</code>是<code>rcp</code>的加强版。</p>
</blockquote>
<div><pre><code>命令：scp [可选参数] file_source file_target
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594548835142.png" alt="1594548835142" /></p>
<div><pre><code>表示将当前目录下的`./herolist.sql`文件，传送到ip为47.114.139.71的home目录中； 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>如果上传的是一个文件夹，那么需要使用<code>-r</code>参数，标记这次命令需要递归目录拷贝：</p>
</li>
</ul>
<div><pre><code>命令：scp -r .\we root@47.114.139.71:/home/
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594549264448.png" alt="1594549264448" /></p>
<ul>
<li>
<p>解压；</p>
<div><pre><code>tar -xvf fileName
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
<h2 id="_2、配置环境变量"> 2、配置环境变量；</h2>
<ul>
<li>
<p>编辑文件；</p>
<div><pre><code>vim /etc/profile
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594549913774.png" alt="1594549913774" /></p>
<blockquote>
<p>在打开的文件中添加图中所示内容；编辑完成后按  ESC  退出编辑模式； :wq 保存退出；</p>
<p>然后执行命令：source /etc/profile  (目的是使修改的文件生效)</p>
</blockquote>
</li>
</ul>
<h2 id="_3、-启动tomcat"> 3、 启动tomcat</h2>
<ul>
<li>
<p>启动；</p>
<div><pre><code>命令：cd /home/local/tomcat/apache-tomcat-8.5.39/bin
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594460447734.png" alt="1594460447734" /></p>
</li>
<li>
<p>查看版本号；</p>
<div><pre><code>命令：./version.sh
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594550699344.png" alt="1594550699344" /></p>
</li>
<li>
<p>关闭服务；</p>
<div><pre><code>命令：./shutdown.sh
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
<blockquote>
<p>命令：<code>curl 47.114.139.71:8080</code></p>
<p>也可以直接查看是否启动成功；</p>
</blockquote>
<p><img src="./assets/1594550217713.png" alt="1594550217713" /></p>
<blockquote>
<p><code>tomcat</code>的启动需要<code>jdk</code>的支持，所以请确保你已安装 <code>jdk</code></p>
</blockquote>
<h2 id="_4、关闭防火墙"> 4、关闭防火墙；</h2>
<blockquote>
<p>不推荐关闭防火墙，而是开放一个8080端口；</p>
</blockquote>
<div><pre><code><span># 关闭防火墙</span>
<span>service</span> iptables stop
或
systemctl stop firewalld.service
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="_5、开启或重启防火墙"> 5、开启或重启防火墙</h2>
<div><pre><code>systemctl start firewalld.service

systemctl restart firewalld.service
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>
<p>单独开放8080端口 ；</p>
<ul>
<li>
<div><pre><code>firewall-cmd --permanent --zone=public --add-port=8080/tcp
firewall-cmd --reload
firewall-cmd --zone=public --query-port=8080/tcp
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./assets/1594463096207.png" alt="1594463096207" /></p>
</li>
</ul>
</li>
</ul>
<h2 id="_6、添加安全组"> 6、添加安全组；</h2>
<p><img src="./assets/1594475511039.png" alt="1594475511039" /></p>
<h2 id="_7、启动tomcat测试"> 7、启动tomcat测试</h2>
<ul>
<li>打开浏览器访问</li>
</ul>
<h2 id="_8、直接命令访问web页面"> 8、直接命令访问<code>WEB</code>页面；</h2>
<div><pre><code>curl http://localhost:8080
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594461746150.png" alt="1594461746150" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>更改tomact启动的默认文件夹</title>
      <link>https://wangyawei.top/views/backEnd/tomcat/tomcat-note-01/</link>
      <guid>https://wangyawei.top/views/backEnd/tomcat/tomcat-note-01/</guid>
      <source url="https://wangyawei.top/rss.xml">更改tomact启动的默认文件夹</source>
      <category>TOMCAT</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="解决方案"> 解决方案；</h2>
<ul>
<li>
<p>进入你的tomcat的安装文件夹，找到<code>conf</code>文件夹；</p>
<p><img src="./assets/1594795127447.png" alt="1594795127447" /></p>
</li>
<li>
<p>在<code>conf</code>里找到<code>server.xml</code>文件；</p>
<p><img src="./assets/1594795189526.png" alt="1594795189526" /></p>
</li>
<li>
<p>打开找到<code>&lt;Host&gt;&lt;/Host&gt;</code>标签；添加以下代码；</p>
<div><pre><code><span><span><span>&lt;</span>Context</span> <span>path</span><span><span>=</span><span>"</span><span>"</span></span> <span>docBase</span><span><span>=</span><span>"</span>hero<span>"</span></span> <span>debug</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>reloadable</span><span><span>=</span><span>"</span>true<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>说明：hero是我自己的项目文件名，也就是<code>tomcat</code>的默认文件夹，可根据自己的项目情况来命名；</p>
</blockquote>
<p><img src="./assets/1594795637704.png" alt="1594795637704" /></p>
</li>
</ul>
<blockquote>
<p><strong>重启；测试；</strong> 直接<code>ip</code>地址端口号然后回车；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>tomcat部署多个项目</title>
      <link>https://wangyawei.top/views/backEnd/tomcat/tomcat-note-02/</link>
      <guid>https://wangyawei.top/views/backEnd/tomcat/tomcat-note-02/</guid>
      <source url="https://wangyawei.top/rss.xml">tomcat部署多个项目</source>
      <category>TOMCAT</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="tomcat部署多个web项目"> <code>tomcat</code>部署多个<code>web</code>项目</h2>
<blockquote>
<p>说明：自己业余写了两个vue项目，希望可以都部署到阿里云服务器上。</p>
<p>1、vue打包好的静态资源文件。</p>
<p>2、本人使用的是阿里云服务器 liunx系统；</p>
<p>3、请确保你已安装好<code>tomcat</code>,<a href="https://www.cnblogs.com/ywnh/p/14257537.html" target="_blank" rel="noopener noreferrer">传送门</a></p>
</blockquote>
<h2 id="_1、方式一-同一个端口访问不同项目"> 1、方式一：同一个端口访问不同项目；</h2>
<blockquote>
<p>在我的其它文章中有部署单个web项目的操作说明，这里就不再介绍只有一个项目的部署情况；<a href="https://www.cnblogs.com/ywnh/p/14256867.html" target="_blank" rel="noopener noreferrer">传送门</a></p>
</blockquote>
<ol>
<li>
<p><code>cd</code> 到你的<code>tomcat</code>目录下;</p>
</li>
<li>
<p>把你打包好的vue静态文件，上传至服务器并移动到你的 <code>webapps</code>文件夹中；</p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ webapps<span>]</span><span># ll</span>
total <span>12</span>
drwxr-xr-x <span>3</span> root root <span>4096</span> Jan  <span>9</span> <span>22</span>:36 hero
drwxr-xr-x <span>3</span> root root <span>4096</span> Jan <span>10</span> <span>16</span>:17 patient <span># 我的第二个项目</span>
drwxr-xr-x <span>3</span> root root <span>4096</span> Jan  <span>9</span> <span>19</span>:57 ROOT
<span>[</span>root@iZbp156pkpio44mis76wmxZ webapps<span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>修改<code>cong</code>文件夹下的<code>server.xml</code>文件；</p>
<ul>
<li><strong>代码内容较多，多余注释都已删除</strong>；</li>
</ul>
<div><pre><code>[root@iZbp156pkpio44mis76wmxZ conf]# cat server.xml 
<span>&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span><span><span>&lt;</span>Server</span> <span>port</span><span><span>=</span><span>"</span>8005<span>"</span></span> <span>shutdown</span><span><span>=</span><span>"</span>SHUTDOWN<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>Listener</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.startup.VersionLoggerListener<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>Listener</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.core.AprLifecycleListener<span>"</span></span> <span>SSLEngine</span><span><span>=</span><span>"</span>on<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>Listener</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.core.JreMemoryLeakPreventionListener<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>Listener</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.mbeans.GlobalResourcesLifecycleListener<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>Listener</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.core.ThreadLocalLeakPreventionListener<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>GlobalNamingResources</span><span>></span></span>
        <span><span><span>&lt;</span>Resource</span> <span>name</span><span><span>=</span><span>"</span>UserDatabase<span>"</span></span> <span>auth</span><span><span>=</span><span>"</span>Container<span>"</span></span>
                  <span>type</span><span><span>=</span><span>"</span>org.apache.catalina.UserDatabase<span>"</span></span>
                  <span>description</span><span><span>=</span><span>"</span>User database that can be updated and saved<span>"</span></span>
                  <span>factory</span><span><span>=</span><span>"</span>org.apache.catalina.users.MemoryUserDatabaseFactory<span>"</span></span>
                  <span>pathname</span><span><span>=</span><span>"</span>conf/tomcat-users.xml<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;/</span>GlobalNamingResources</span><span>></span></span>
    <span><span><span>&lt;</span>Service</span> <span>name</span><span><span>=</span><span>"</span>Catalina<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>Connector</span> <span>port</span><span><span>=</span><span>"</span>80<span>"</span></span> <span>protocol</span><span><span>=</span><span>"</span>HTTP/1.1<span>"</span></span>
                   <span>connectionTimeout</span><span><span>=</span><span>"</span>20000<span>"</span></span>
                   <span>redirectPort</span><span><span>=</span><span>"</span>8443<span>"</span></span> <span>/></span></span>
        <span><span><span>&lt;</span>Connector</span> <span>port</span><span><span>=</span><span>"</span>8009<span>"</span></span> <span>protocol</span><span><span>=</span><span>"</span>AJP/1.3<span>"</span></span> <span>redirectPort</span><span><span>=</span><span>"</span>8443<span>"</span></span> <span>/></span></span>
        <span><span><span>&lt;</span>Engine</span> <span>name</span><span><span>=</span><span>"</span>Catalina<span>"</span></span> <span>defaultHost</span><span><span>=</span><span>"</span>localhost<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>Realm</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.realm.LockOutRealm<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>Realm</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.realm.UserDatabaseRealm<span>"</span></span>
                       <span>resourceName</span><span><span>=</span><span>"</span>UserDatabase<span>"</span></span><span>/></span></span>
            <span><span><span>&lt;/</span>Realm</span><span>></span></span>

            <span><span><span>&lt;</span>Host</span> <span>name</span><span><span>=</span><span>"</span>localhost<span>"</span></span>  <span>appBase</span><span><span>=</span><span>"</span>webapps<span>"</span></span>
                  <span>unpackWARs</span><span><span>=</span><span>"</span>true<span>"</span></span> <span>autoDeploy</span><span><span>=</span><span>"</span>true<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>Valve</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.valves.AccessLogValve<span>"</span></span> <span>directory</span><span><span>=</span><span>"</span>logs<span>"</span></span>
                       <span>prefix</span><span><span>=</span><span>"</span>localhost_access_log<span>"</span></span> <span>suffix</span><span><span>=</span><span>"</span>.txt<span>"</span></span>
                       <span>pattern</span><span><span>=</span><span>"</span>%h %l %u %t <span title="&quot;">&amp;quot;</span>%r<span title="&quot;">&amp;quot;</span> %s %b<span>"</span></span> <span>/></span></span>
               <span>&lt;!--这个是我的第一个web项目也是我的默认web项目--></span>
                <span><span><span>&lt;</span>Context</span> <span>path</span><span><span>=</span><span>"</span><span>"</span></span> <span>docBase</span><span><span>=</span><span>"</span>hero<span>"</span></span> <span>debug</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>reloadable</span><span><span>=</span><span>"</span>true<span>"</span></span> <span>/></span></span>
              <span>&lt;!--我的第二个项目 访问时要在url后加上test--></span>
					 <span><span><span>&lt;</span>Context</span> <span>path</span><span><span>=</span><span>"</span>test<span>"</span></span> <span>docBase</span><span><span>=</span><span>"</span>patient<span>"</span></span> <span>debug</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>reloadable</span><span><span>=</span><span>"</span>true<span>"</span></span> <span>/></span></span>
            <span><span><span>&lt;/</span>Host</span><span>></span></span>
        <span><span><span>&lt;/</span>Engine</span><span>></span></span>
    <span><span><span>&lt;/</span>Service</span><span>></span></span>
<span><span><span>&lt;/</span>Server</span><span>></span></span>
[root@iZbp156pkpio44mis76wmxZ conf]# 

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div></li>
<li>
<p>关闭并重启tomcat；</p>
</li>
<li>
<p>测试访问；如果返回html页面就说明你部署成功了。浏览器访问：<code>http://ip:port/test/</code></p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ webapps<span>]</span><span># curl localhost/test/</span>
<span>&lt;</span><span>!</span>DOCTYPE html<span>></span>
<span>&lt;</span>html <span>lang</span><span>=</span><span>"en"</span><span>></span>
  <span>&lt;</span>head<span>></span>
    <span>&lt;</span>meta <span>charset</span><span>=</span><span>"utf-8"</span><span>></span>
    <span>&lt;</span>meta http-equiv<span>=</span><span>"X-UA-Compatible"</span> <span>content</span><span>=</span><span>"IE=edge"</span><span>></span>
    <span>&lt;</span>meta <span>name</span><span>=</span><span>"viewport"</span> <span>content</span><span>=</span><span>"width=device-width,initial-scale=1.0"</span><span>></span>
    <span>&lt;</span>link <span>rel</span><span>=</span><span>"icon"</span> <span>href</span><span>=</span><span>"favicon.ico"</span><span>></span>
    <span>&lt;</span>title<span>></span>百草堂<span>&lt;</span>/title<span>></span>
  <span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/0.js"</span> <span>rel</span><span>=</span><span>"prefetch"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/1.js"</span> <span>rel</span><span>=</span><span>"prefetch"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/2.js"</span> <span>rel</span><span>=</span><span>"prefetch"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/3.js"</span> <span>rel</span><span>=</span><span>"prefetch"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/4.js"</span> <span>rel</span><span>=</span><span>"prefetch"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/5.js"</span> <span>rel</span><span>=</span><span>"prefetch"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/6.js"</span> <span>rel</span><span>=</span><span>"prefetch"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/7.js"</span> <span>rel</span><span>=</span><span>"prefetch"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/8.js"</span> <span>rel</span><span>=</span><span>"prefetch"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/app.js"</span> <span>rel</span><span>=</span><span>"preload"</span> <span>as</span><span>=</span><span>"script"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/chunk-vendors.js"</span> <span>rel</span><span>=</span><span>"preload"</span> <span>as</span><span>=</span><span>"script"</span><span>></span><span>&lt;</span>/head<span>></span>
  <span>&lt;</span>body<span>></span>
    <span>&lt;</span>noscript<span>></span>
      <span>&lt;</span>strong<span>></span>We<span>'re sorry but patient doesn'</span>t work properly without JavaScript enabled. Please <span>enable</span> it to continue.<span>&lt;</span>/strong<span>></span>
    <span>&lt;</span>/noscript<span>></span>
    <span>&lt;</span>div <span>id</span><span>=</span><span>"app"</span><span>></span><span>&lt;</span>/div<span>></span>
    <span>&lt;</span><span>!</span>-- built files will be auto injected --<span>></span>
  <span>&lt;</span>script <span>type</span><span>=</span><span>"text/javascript"</span> <span>src</span><span>=</span><span>"static/js/chunk-vendors.js"</span><span>></span><span>&lt;</span>/script<span>></span><span>&lt;</span>script <span>type</span><span>=</span><span>"text/javascript"</span> <span>src</span><span>=</span><span>"static/js/app.js"</span><span>></span><span>&lt;</span>/script<span>></span><span>&lt;</span>/body<span>></span>
<span>&lt;</span>/html<span>></span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ webapps<span>]</span><span># </span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><blockquote>
<p>注意：这种只是让你可以访问到页面而已，你可能会遇到<strong>接口跨域</strong>情况，这个需要和后端同学沟通；</p>
</blockquote>
</li>
</ol>
<h2 id="_2、方法二-不同端口访问不同的项目"> 2、方法二：不同端口访问不同的项目；</h2>
<blockquote>
<p>说明：大多数时候我们的web项目是在不同的域名或端口下的；也就是一个端口对应一个web项目；</p>
</blockquote>
<ol>
<li>
<p><code>cd</code> 到你的<code>tomcat</code>目录下;</p>
</li>
<li>
<p>复制<code>webapps</code>文件夹，粘贴到当前文件夹下，示例：</p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ tomcat<span>]</span><span># ll</span>
total <span>168</span>
drwxr-x--- <span>2</span> root root  <span>4096</span> Jul  <span>6</span>  <span>2020</span> bin
-rw-r----- <span>1</span> root root <span>19539</span> Mar <span>14</span>  <span>2019</span> BUILDING.txt
drwx------ <span>4</span> root root  <span>4096</span> Jan  <span>9</span> <span>21</span>:18 conf
-rw-r----- <span>1</span> root root  <span>6090</span> Mar <span>14</span>  <span>2019</span> CONTRIBUTING.md
drwxr-x--- <span>2</span> root root  <span>4096</span> Jul  <span>6</span>  <span>2020</span> lib
-rw-r----- <span>1</span> root root <span>57092</span> Mar <span>14</span>  <span>2019</span> LICENSE
drwxr-x--- <span>2</span> root root <span>20480</span> Jan <span>10</span> 00:03 logs
-rw-r----- <span>1</span> root root  <span>1726</span> Mar <span>14</span>  <span>2019</span> NOTICE
-rw-r----- <span>1</span> root root  <span>3255</span> Mar <span>14</span>  <span>2019</span> README.md
-rw-r----- <span>1</span> root root  <span>7142</span> Mar <span>14</span>  <span>2019</span> RELEASE-NOTES
-rw-r----- <span>1</span> root root <span>16262</span> Mar <span>14</span>  <span>2019</span> RUNNING.txt
drwxr-x--- <span>2</span> root root  <span>4096</span> Jul  <span>6</span>  <span>2020</span> temp
drwxr-x--- <span>4</span> root root  <span>4096</span> Jan  <span>9</span> <span>19</span>:57 webapps
drwxr-xr-x <span>4</span> root root  <span>4096</span> Dec <span>27</span> <span>15</span>:09 webapps_patient <span># 我复制的webapps文件夹并重命名为webapps_patient</span>
drwxr-x--- <span>4</span> root root  <span>4096</span> Dec <span>20</span> <span>16</span>:39 work
<span>[</span>root@iZbp156pkpio44mis76wmxZ tomcat<span>]</span><span># </span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div></li>
<li>
<p>把你打包好的vue静态文件，上传至服务器并移动到你复制好的 <code>webapps_patient</code>文件夹中；</p>
</li>
<li>
<p>修改<code>cong</code>文件夹下的<code>server.xml</code>文件；</p>
<ul>
<li><strong>代码内容较多，多余注释都已删除</strong>；</li>
</ul>
<div><pre><code>[root@iZbp156pkpio44mis76wmxZ conf]# cat server.xml 
<span>&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span><span><span>&lt;</span>Server</span> <span>port</span><span><span>=</span><span>"</span>8005<span>"</span></span> <span>shutdown</span><span><span>=</span><span>"</span>SHUTDOWN<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>Listener</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.startup.VersionLoggerListener<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>Listener</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.core.AprLifecycleListener<span>"</span></span> <span>SSLEngine</span><span><span>=</span><span>"</span>on<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>Listener</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.core.JreMemoryLeakPreventionListener<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>Listener</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.mbeans.GlobalResourcesLifecycleListener<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>Listener</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.core.ThreadLocalLeakPreventionListener<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>GlobalNamingResources</span><span>></span></span>
        <span><span><span>&lt;</span>Resource</span> <span>name</span><span><span>=</span><span>"</span>UserDatabase<span>"</span></span> <span>auth</span><span><span>=</span><span>"</span>Container<span>"</span></span>
                  <span>type</span><span><span>=</span><span>"</span>org.apache.catalina.UserDatabase<span>"</span></span>
                  <span>description</span><span><span>=</span><span>"</span>User database that can be updated and saved<span>"</span></span>
                  <span>factory</span><span><span>=</span><span>"</span>org.apache.catalina.users.MemoryUserDatabaseFactory<span>"</span></span>
                  <span>pathname</span><span><span>=</span><span>"</span>conf/tomcat-users.xml<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;/</span>GlobalNamingResources</span><span>></span></span>
  <span>&lt;!--我的第一个项目--></span>
    <span><span><span>&lt;</span>Service</span> <span>name</span><span><span>=</span><span>"</span>Catalina<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>Connector</span> <span>port</span><span><span>=</span><span>"</span>80<span>"</span></span> <span>protocol</span><span><span>=</span><span>"</span>HTTP/1.1<span>"</span></span>
                   <span>connectionTimeout</span><span><span>=</span><span>"</span>20000<span>"</span></span>
                   <span>redirectPort</span><span><span>=</span><span>"</span>8443<span>"</span></span> <span>/></span></span>
        <span><span><span>&lt;</span>Connector</span> <span>port</span><span><span>=</span><span>"</span>8009<span>"</span></span> <span>protocol</span><span><span>=</span><span>"</span>AJP/1.3<span>"</span></span> <span>redirectPort</span><span><span>=</span><span>"</span>8443<span>"</span></span> <span>/></span></span>
        <span><span><span>&lt;</span>Engine</span> <span>name</span><span><span>=</span><span>"</span>Catalina<span>"</span></span> <span>defaultHost</span><span><span>=</span><span>"</span>localhost<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>Realm</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.realm.LockOutRealm<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>Realm</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.realm.UserDatabaseRealm<span>"</span></span>
                       <span>resourceName</span><span><span>=</span><span>"</span>UserDatabase<span>"</span></span><span>/></span></span>
            <span><span><span>&lt;/</span>Realm</span><span>></span></span>

            <span><span><span>&lt;</span>Host</span> <span>name</span><span><span>=</span><span>"</span>localhost<span>"</span></span>  <span>appBase</span><span><span>=</span><span>"</span>webapps<span>"</span></span>
                  <span>unpackWARs</span><span><span>=</span><span>"</span>true<span>"</span></span> <span>autoDeploy</span><span><span>=</span><span>"</span>true<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>Valve</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.valves.AccessLogValve<span>"</span></span> <span>directory</span><span><span>=</span><span>"</span>logs<span>"</span></span>
                       <span>prefix</span><span><span>=</span><span>"</span>localhost_access_log<span>"</span></span> <span>suffix</span><span><span>=</span><span>"</span>.txt<span>"</span></span>
                       <span>pattern</span><span><span>=</span><span>"</span>%h %l %u %t <span title="&quot;">&amp;quot;</span>%r<span title="&quot;">&amp;quot;</span> %s %b<span>"</span></span> <span>/></span></span>
                <span><span><span>&lt;</span>Context</span> <span>path</span><span><span>=</span><span>"</span><span>"</span></span> <span>docBase</span><span><span>=</span><span>"</span>hero<span>"</span></span> <span>debug</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>reloadable</span><span><span>=</span><span>"</span>true<span>"</span></span> <span>/></span></span>
            <span><span><span>&lt;/</span>Host</span><span>></span></span>
        <span><span><span>&lt;/</span>Engine</span><span>></span></span>
    <span><span><span>&lt;/</span>Service</span><span>></span></span>

    <span>&lt;!--以下为我的第二个项目patient--></span>
    <span><span><span>&lt;</span>Service</span> <span>name</span><span><span>=</span><span>"</span>Catalina_patient<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>Connector</span> <span>port</span><span><span>=</span><span>"</span>8088<span>"</span></span> <span>protocol</span><span><span>=</span><span>"</span>HTTP/1.1<span>"</span></span>
                   <span>connectionTimeout</span><span><span>=</span><span>"</span>20000<span>"</span></span>
                   <span>redirectPort</span><span><span>=</span><span>"</span>8443<span>"</span></span> <span>/></span></span>
        <span><span><span>&lt;</span>Connector</span> <span>port</span><span><span>=</span><span>"</span>8099<span>"</span></span> <span>protocol</span><span><span>=</span><span>"</span>AJP/1.3<span>"</span></span> <span>redirectPort</span><span><span>=</span><span>"</span>8443<span>"</span></span> <span>/></span></span>
        <span><span><span>&lt;</span>Engine</span> <span>name</span><span><span>=</span><span>"</span>Catalina_patient<span>"</span></span> <span>defaultHost</span><span><span>=</span><span>"</span>localhost<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>Realm</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.realm.LockOutRealm<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>Realm</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.realm.UserDatabaseRealm<span>"</span></span>
                       <span>resourceName</span><span><span>=</span><span>"</span>UserDatabase<span>"</span></span><span>/></span></span>
            <span><span><span>&lt;/</span>Realm</span><span>></span></span>
            <span><span><span>&lt;</span>Host</span> <span>name</span><span><span>=</span><span>"</span>localhost<span>"</span></span>  <span>appBase</span><span><span>=</span><span>"</span>webapps_patient<span>"</span></span>
                  <span>unpackWARs</span><span><span>=</span><span>"</span>true<span>"</span></span> <span>autoDeploy</span><span><span>=</span><span>"</span>true<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>Valve</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.valves.AccessLogValve<span>"</span></span> <span>directory</span><span><span>=</span><span>"</span>logs<span>"</span></span>
                       <span>prefix</span><span><span>=</span><span>"</span>localhost_access_log<span>"</span></span> <span>suffix</span><span><span>=</span><span>"</span>.txt<span>"</span></span>
                       <span>pattern</span><span><span>=</span><span>"</span>%h %l %u %t <span title="&quot;">&amp;quot;</span>%r<span title="&quot;">&amp;quot;</span> %s %b<span>"</span></span> <span>/></span></span>
              			<span>&lt;!--我的第二个项目--></span>
                		<span><span><span>&lt;</span>Context</span> <span>path</span><span><span>=</span><span>"</span><span>"</span></span> <span>docBase</span><span><span>=</span><span>"</span>patient<span>"</span></span> <span>debug</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>reloadable</span><span><span>=</span><span>"</span>true<span>"</span></span> <span>/></span></span>
            <span><span><span>&lt;/</span>Host</span><span>></span></span>
        <span><span><span>&lt;/</span>Engine</span><span>></span></span>
    <span><span><span>&lt;/</span>Service</span><span>></span></span>
<span><span><span>&lt;/</span>Server</span><span>></span></span>
[root@iZbp156pkpio44mis76wmxZ conf]# 

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div></li>
<li>
<p>注意；</p>
<div><pre><code><span>&lt;!-- 修改name的值为Catalina_patient--></span>
<span><span><span>&lt;</span>Service</span> <span>name</span><span><span>=</span><span>"</span>Catalina_patient<span>"</span></span><span>></span></span>
  		<span>&lt;!-- 修改port的值为8088--></span>
        <span><span><span>&lt;</span>Connector</span> <span>port</span><span><span>=</span><span>"</span>8088<span>"</span></span> <span>protocol</span><span><span>=</span><span>"</span>HTTP/1.1<span>"</span></span>
                   <span>connectionTimeout</span><span><span>=</span><span>"</span>20000<span>"</span></span>
                   <span>redirectPort</span><span><span>=</span><span>"</span>8443<span>"</span></span> <span>/></span></span>
        <span><span><span>&lt;</span>Connector</span> <span>port</span><span><span>=</span><span>"</span>8099<span>"</span></span> <span>protocol</span><span><span>=</span><span>"</span>AJP/1.3<span>"</span></span> <span>redirectPort</span><span><span>=</span><span>"</span>8443<span>"</span></span> <span>/></span></span>
  		<span>&lt;!-- 修改name的值为Catalina_patient--></span>
        <span><span><span>&lt;</span>Engine</span> <span>name</span><span><span>=</span><span>"</span>Catalina_patient<span>"</span></span> <span>defaultHost</span><span><span>=</span><span>"</span>localhost<span>"</span></span><span>></span></span>
            <span><span><span>&lt;</span>Realm</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.realm.LockOutRealm<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>Realm</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.realm.UserDatabaseRealm<span>"</span></span>
                       <span>resourceName</span><span><span>=</span><span>"</span>UserDatabase<span>"</span></span><span>/></span></span>
            <span><span><span>&lt;/</span>Realm</span><span>></span></span>
            <span><span><span>&lt;</span>Host</span> <span>name</span><span><span>=</span><span>"</span>localhost<span>"</span></span>  <span>appBase</span><span><span>=</span><span>"</span>webapps_patient<span>"</span></span>
                  <span>unpackWARs</span><span><span>=</span><span>"</span>true<span>"</span></span> <span>autoDeploy</span><span><span>=</span><span>"</span>true<span>"</span></span><span>></span></span>
                <span><span><span>&lt;</span>Valve</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.valves.AccessLogValve<span>"</span></span> <span>directory</span><span><span>=</span><span>"</span>logs<span>"</span></span>
                       <span>prefix</span><span><span>=</span><span>"</span>localhost_access_log<span>"</span></span> <span>suffix</span><span><span>=</span><span>"</span>.txt<span>"</span></span>
                       <span>pattern</span><span><span>=</span><span>"</span>%h %l %u %t <span title="&quot;">&amp;quot;</span>%r<span title="&quot;">&amp;quot;</span> %s %b<span>"</span></span> <span>/></span></span>
              			<span>&lt;!--我的第二个项目 path:影响访问时的路径可以为空或“/”；docBase：你的web应用的绝对路径也可以直接webname--></span>
                		<span><span><span>&lt;</span>Context</span> <span>path</span><span><span>=</span><span>"</span><span>"</span></span> <span>docBase</span><span><span>=</span><span>"</span>patient<span>"</span></span> <span>debug</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>reloadable</span><span><span>=</span><span>"</span>true<span>"</span></span> <span>/></span></span>
            <span><span><span>&lt;/</span>Host</span><span>></span></span>
        <span><span><span>&lt;/</span>Engine</span><span>></span></span>
 <span><span><span>&lt;/</span>Service</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div></li>
<li>
<p>配置安全组开放8088端口；</p>
</li>
<li>
<p>单独开放服务器的8088端口；<a href="https://www.cnblogs.com/ywnh/p/14225944.html" target="_blank" rel="noopener noreferrer">传送门</a></p>
</li>
<li>
<p>关闭并重启tomcat；</p>
</li>
<li>
<p>测试访问,如果返回html页面就说明你部署成功了；浏览器地址: <code>http://ip:8088</code></p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ bin<span>]</span><span># curl localhost:8088</span>
<span>&lt;</span><span>!</span>DOCTYPE html<span>></span>
<span>&lt;</span>html <span>lang</span><span>=</span><span>"en"</span><span>></span>
  <span>&lt;</span>head<span>></span>
    <span>&lt;</span>meta <span>charset</span><span>=</span><span>"utf-8"</span><span>></span>
    <span>&lt;</span>meta http-equiv<span>=</span><span>"X-UA-Compatible"</span> <span>content</span><span>=</span><span>"IE=edge"</span><span>></span>
    <span>&lt;</span>meta <span>name</span><span>=</span><span>"viewport"</span> <span>content</span><span>=</span><span>"width=device-width,initial-scale=1.0"</span><span>></span>
    <span>&lt;</span>link <span>rel</span><span>=</span><span>"icon"</span> <span>href</span><span>=</span><span>"favicon.ico"</span><span>></span>
    <span>&lt;</span>title<span>></span>百草堂<span>&lt;</span>/title<span>></span>
  <span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/0.js"</span> <span>rel</span><span>=</span><span>"prefetch"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/1.js"</span> <span>rel</span><span>=</span><span>"prefetch"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/2.js"</span> <span>rel</span><span>=</span><span>"prefetch"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/3.js"</span> <span>rel</span><span>=</span><span>"prefetch"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/4.js"</span> <span>rel</span><span>=</span><span>"prefetch"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/5.js"</span> <span>rel</span><span>=</span><span>"prefetch"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/6.js"</span> <span>rel</span><span>=</span><span>"prefetch"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/7.js"</span> <span>rel</span><span>=</span><span>"prefetch"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/8.js"</span> <span>rel</span><span>=</span><span>"prefetch"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/app.js"</span> <span>rel</span><span>=</span><span>"preload"</span> <span>as</span><span>=</span><span>"script"</span><span>></span><span>&lt;</span>link <span>href</span><span>=</span><span>"static/js/chunk-vendors.js"</span> <span>rel</span><span>=</span><span>"preload"</span> <span>as</span><span>=</span><span>"script"</span><span>></span><span>&lt;</span>/head<span>></span>
  <span>&lt;</span>body<span>></span>
    <span>&lt;</span>noscript<span>></span>
      <span>&lt;</span>strong<span>></span>We<span>'re sorry but patient doesn'</span>t work properly without JavaScript enabled. Please <span>enable</span> it to continue.<span>&lt;</span>/strong<span>></span>
    <span>&lt;</span>/noscript<span>></span>
    <span>&lt;</span>div <span>id</span><span>=</span><span>"app"</span><span>></span><span>&lt;</span>/div<span>></span>
    <span>&lt;</span><span>!</span>-- built files will be auto injected --<span>></span>
  <span>&lt;</span>script <span>type</span><span>=</span><span>"text/javascript"</span> <span>src</span><span>=</span><span>"static/js/chunk-vendors.js"</span><span>></span><span>&lt;</span>/script<span>></span><span>&lt;</span>script <span>type</span><span>=</span><span>"text/javascript"</span> <span>src</span><span>=</span><span>"static/js/app.js"</span><span>></span><span>&lt;</span>/script<span>></span><span>&lt;</span>/body<span>></span>
<span>&lt;</span>/html<span>></span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ bin<span>]</span><span># </span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>tomcat部署web应用</title>
      <link>https://wangyawei.top/views/backEnd/tomcat/tomcat-note-03/</link>
      <guid>https://wangyawei.top/views/backEnd/tomcat/tomcat-note-03/</guid>
      <source url="https://wangyawei.top/rss.xml">tomcat部署web应用</source>
      <category>TOMCAT</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="tomcat部署web应用"> <code>tomcat</code>部署<code>web</code>应用</h2>
<blockquote>
<p>说明：</p>
<ul>
<li>本项目部署的是vue打包好的静态资源文件；</li>
<li>我的系统是<strong>阿里云liunx</strong>服务器；</li>
<li>请确保你已经安装好tomcat；<strong>传送门</strong></li>
<li>准备好你打包好的静态资源；</li>
</ul>
</blockquote>
<h2 id="_1、上传"> 1、上传</h2>
<ul>
<li>把你自己打包好的vue静态资源上传到你的服务器上；可以使用<code>xftp</code>工具上传；</li>
<li>把你上传的文件移动到<code>tomcat</code>安装目录的<code>webapps</code>文件下;我的文件目录如下：</li>
</ul>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ tomcat<span>]</span><span># ll</span>
total <span>168</span>
drwxr-x--- <span>2</span> root root  <span>4096</span> Jul  <span>6</span>  <span>2020</span> bin
-rw-r----- <span>1</span> root root <span>19539</span> Mar <span>14</span>  <span>2019</span> BUILDING.txt
drwx------ <span>4</span> root root  <span>4096</span> Dec <span>27</span> <span>14</span>:36 conf
-rw-r----- <span>1</span> root root  <span>6090</span> Mar <span>14</span>  <span>2019</span> CONTRIBUTING.md
drwxr-x--- <span>2</span> root root  <span>4096</span> Jul  <span>6</span>  <span>2020</span> lib
-rw-r----- <span>1</span> root root <span>57092</span> Mar <span>14</span>  <span>2019</span> LICENSE
drwxr-x--- <span>2</span> root root <span>20480</span> Jan  <span>9</span> 09:16 logs
-rw-r----- <span>1</span> root root  <span>1726</span> Mar <span>14</span>  <span>2019</span> NOTICE
-rw-r----- <span>1</span> root root  <span>3255</span> Mar <span>14</span>  <span>2019</span> README.md
-rw-r----- <span>1</span> root root  <span>7142</span> Mar <span>14</span>  <span>2019</span> RELEASE-NOTES
-rw-r----- <span>1</span> root root <span>16262</span> Mar <span>14</span>  <span>2019</span> RUNNING.txt
drwxr-x--- <span>2</span> root root  <span>4096</span> Jul  <span>6</span>  <span>2020</span> temp
drwxr-x--- <span>4</span> root root  <span>4096</span> Dec <span>20</span> <span>17</span>:20 webapps
drwxr-x--- <span>4</span> root root  <span>4096</span> Dec <span>20</span> <span>16</span>:39 work
<span>[</span>root@iZbp156pkpio44mis76wmxZ tomcat<span>]</span><span># cd webapps</span>
<span># 你的webapps文件夹下的文件应该比我多，其它的都可以删除掉了，留一个 ROOT 文件即可；hero为我的web文件夹</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ webapps<span>]</span><span># ls</span>
hero  ROOT
<span>[</span>root@iZbp156pkpio44mis76wmxZ webapps<span>]</span><span># ll</span>
total <span>8</span>
drwxr-xr-x <span>3</span> root root <span>4096</span> Dec <span>19</span> <span>16</span>:51 hero <span># 我的web应用</span>
drwxr-xr-x <span>3</span> root root <span>4096</span> Jul <span>14</span> <span>22</span>:22 ROOT
<span>[</span>root@iZbp156pkpio44mis76wmxZ webapps<span>]</span><span># </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id="_2、访问"> 2、访问</h2>
<p>上传完成后，在你的<code>shell</code>中输入以下命令。</p>
<blockquote>
<p>注意：</p>
<ol>
<li>tomcat启动时默认端口号为8080；</li>
<li>你出现的html页面可能和我的不一样，因为我的是部署后的web项目；</li>
</ol>
</blockquote>
<div><pre><code><span># cd 到tomcat的bin文件夹下，</span>
<span># 关闭 tomcat 服务；</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ bin<span>]</span><span># ./shutdown.sh </span>
Using CATALINA_BASE:   /home/local/tomcat
Using CATALINA_HOME:   /home/local/tomcat
Using CATALINA_TMPDIR: /home/local/tomcat/temp
Using JRE_HOME:        /home/local/JDK/jdk1.8.0_251
Using CLASSPATH:       /home/local/tomcat/bin/bootstrap.jar:/home/local/tomcat/bin/tomcat-juli.jar
<span># 启动tomcat 服务；</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ bin<span>]</span><span># ./startup.sh </span>
Using CATALINA_BASE:   /home/local/tomcat
Using CATALINA_HOME:   /home/local/tomcat
Using CATALINA_TMPDIR: /home/local/tomcat/temp
Using JRE_HOME:        /home/local/JDK/jdk1.8.0_251
Using CLASSPATH:       /home/local/tomcat/bin/bootstrap.jar:/home/local/tomcat/bin/tomcat-juli.jar
Tomcat started.
<span>[</span>root@iZbp156pkpio44mis76wmxZ bin<span>]</span><span>#</span>
<span># 测试</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ bin<span>]</span><span># curl localhost:8080</span>
<span>&lt;</span><span>!</span>DOCTYPE html<span>></span><span>&lt;</span>html <span>lang</span><span>=</span>en<span>></span><span>&lt;</span>head<span>></span><span>&lt;</span>meta <span>charset</span><span>=</span>utf-<span><span>8</span>></span><span>&lt;</span>meta http-equiv<span>=</span>X-UA-Compatible <span>content</span><span>=</span><span>"IE=edge"</span><span>></span><span>&lt;</span>meta <span>name</span><span>=</span>viewport <span>content</span><span>=</span><span>"width=device-width,initial-scale=1"</span><span>></span><span>&lt;</span>link <span>rel</span><span>=</span>icon <span>href</span><span>=</span>/favicon.ico<span>></span><span>&lt;</span>title<span>></span>后台管理<span>&lt;</span>/title<span>></span><span>&lt;</span>link <span>href</span><span>=</span>/assets/css/chunk-218ae17c.51727cbd.css <span>rel</span><span>=</span>prefetch<span>></span><span>&lt;</span>link <span>href</span><span>=</span>/assets/css/chunk-355eb542.76446819.css <span>rel</span><span>=</span>prefetch<span>></span><span>&lt;</span>link <span>href</span><span>=</span>/assets/css/chunk-586e3666.b513479d.css <span>rel</span><span>=</span>prefetch<span>></span><span>&lt;</span>link <span>href</span><span>=</span>/assets/css/chunk-e5a2ff66.7248c2ef.css <span>rel</span><span>=</span>prefetch<span>></span><span>&lt;</span>link <span>href</span><span>=</span>/assets/js/chunk-218ae17c.4c78cffd.js <span>rel</span><span>=</span>prefetch<span>></span><span>&lt;</span>link <span>href</span><span>=</span>/assets/js/chunk-355eb542.cde109b1.js <span>rel</span><span>=</span>prefetch<span>></span><span>&lt;</span>link <span>href</span><span>=</span>/assets/js/chunk-586e3666.b2a6a25e.js <span>rel</span><span>=</span>prefetch<span>></span><span>&lt;</span>link <span>href</span><span>=</span>/assets/js/chunk-e5a2ff66.7eebb07b.js <span>rel</span><span>=</span>prefetch<span>></span><span>&lt;</span>link <span>href</span><span>=</span>/assets/css/app.93ebdc27.css <span>rel</span><span>=</span>preload <span>as</span><span>=</span>style<span>></span><span>&lt;</span>link <span>href</span><span>=</span>/assets/css/chunk-vendors.e2a05c09.css <span>rel</span><span>=</span>preload <span>as</span><span>=</span>style<span>></span><span>&lt;</span>link <span>href</span><span>=</span>/assets/js/app.a747b461.js <span>rel</span><span>=</span>preload <span>as</span><span>=</span>script<span>></span><span>&lt;</span>link <span>href</span><span>=</span>/assets/js/chunk-vendors.f4f8309a.js <span>rel</span><span>=</span>preload <span>as</span><span>=</span>script<span>></span><span>&lt;</span>link <span>href</span><span>=</span>/assets/css/chunk-vendors.e2a05c09.css <span>rel</span><span>=</span>stylesheet<span>></span><span>&lt;</span>link <span>href</span><span>=</span>/assets/css/app.93ebdc27.css <span>rel</span><span>=</span>stylesheet<span>></span><span>&lt;</span>/head<span>></span><span>&lt;</span>body<span>></span><span>&lt;</span>noscript<span>></span><span>&lt;</span>strong<span>></span>We<span>'re sorry but 后台管理 doesn'</span>t work properly without JavaScript enabled. Please <span>enable</span> it to continue.<span>&lt;</span>/strong<span>></span><span>&lt;</span>/noscript<span>></span><span>&lt;</span>div <span>id</span><span>=</span>app<span>></span><span>&lt;</span>/div<span>></span><span>&lt;</span>script <span>src</span><span>=</span>/assets/js/chunk-vendors.f4f8309a.js<span>></span><span>&lt;</span>/script<span>></span><span>&lt;</span>script <span>src</span><span>=</span>/assets/js/app.a747b461.js<span>></span><span>&lt;</span>/script<span>></span><span>&lt;</span>/body<span>></span><span>&lt;</span>/html<span>></span><span>[</span>root@iZbp156pkpio44mis76wmxZ bin<span>]</span><span># </span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><blockquote>
<p>但是你会发现页面不是自己的web应用，而是tomcat的默认页面；</p>
<p>注意：这时访问的url应该是<code>curl localhost:8080/webappName/</code></p>
</blockquote>
<h2 id="_3、问题"> 3、问题；</h2>
<h3 id="_3-1、空白页面"> 3-1、空白页面；</h3>
<blockquote>
<p>当你怀着激动的心情想要看到自己的页面时：但是它从原先的默认页面变成了空白页(有些人可能会出现这种情况)</p>
</blockquote>
<p>这个时候你<code>F12</code>查看，发现加载的静态资源都是<code>404</code>一片红。在你的vue.config.js中设置 publicPath；<a href="https://www.cnblogs.com/ywnh/p/14256851.html" target="_blank" rel="noopener noreferrer">传送门</a></p>
<div><pre><code><span>// vue.config.js</span>

module<span>.</span>exports <span>=</span> <span>{</span>
  <span>// 解决部署后访问空白页的问题；</span>
  publicPath<span>:</span> <span>'/webappName/'</span><span>,</span> <span>// !!!这里的名称应该和你的webapps文件夹下，你的web应用的文件名称一样。</span>
  <span>// 输出文件目录 默认为: dist</span>
  outputDir<span>:</span> <span>'dist'</span><span>,</span>
  <span>// 放置打包生成的静态资源 (js、css、img、fonts) 的目录。该目录相对于 outputDir 。</span>
  assetsDir<span>:</span> <span>'assets'</span><span>,</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>这个时候你再次访问你的地址： <code>curl localhost:8080/webappName/</code>页面成功加载；</p>
<h3 id="_3-2、本地浏览器无法访问自己部署的远程服务器的web页面"> 3-2、本地浏览器无法访问自己部署的远程服务器的web页面；</h3>
<blockquote>
<p>当你在服务器上，操作完以上所有的事情后，发现在本地浏览器无法访问，而在服务器上是可以的；</p>
</blockquote>
<ol>
<li>正确访问的url地址：http://ip:port/myappName/;</li>
<li>远程服务器安全组没有配置 8080端口；</li>
<li>远程服务器防火墙没有开放8080端口；<a href="https://www.cnblogs.com/ywnh/p/14225944.html" target="_blank" rel="noopener noreferrer">传送门</a></li>
</ol>
<p>以上三条解决完后，关闭并从新启动<code>tomcat</code>，访问成功，</p>
<p>恭喜你部署成功！！；</p>
<blockquote>
<p>这里提醒一下，</p>
</blockquote>
<h3 id="_3-3、无web后缀访问web页面"> 3-3、无web后缀访问web页面；</h3>
<blockquote>
<p>部署成功后你会发现，自己的web页面要在后面加上一个 web应用名字(myappName)才能访问，但是淘宝、京东就不需要 ；</p>
</blockquote>
<ol>
<li>
<p>更改tomact启动的默认文件夹，我的另外一篇说明；</p>
</li>
<li>
<p>cd 到你的tomcat文件夹里面的conf文件夹下；</p>
</li>
<li>
<p>打开 server.xml 文件；</p>
<ul>
<li>内容太多一些自有注释都已删除，直接看最后！！。</li>
</ul>
<div><pre><code>vim server.xml

<span>&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span><span><span>&lt;</span>Server</span> <span>port</span><span><span>=</span><span>"</span>8005<span>"</span></span> <span>shutdown</span><span><span>=</span><span>"</span>SHUTDOWN<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>Service</span> <span>name</span><span><span>=</span><span>"</span>Catalina<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>Connector</span> <span>port</span><span><span>=</span><span>"</span>8080<span>"</span></span> <span>protocol</span><span><span>=</span><span>"</span>HTTP/1.1<span>"</span></span>
               <span>connectionTimeout</span><span><span>=</span><span>"</span>20000<span>"</span></span>
               <span>redirectPort</span><span><span>=</span><span>"</span>8443<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>Engine</span> <span>name</span><span><span>=</span><span>"</span>Catalina<span>"</span></span> <span>defaultHost</span><span><span>=</span><span>"</span>localhost<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>Realm</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.realm.LockOutRealm<span>"</span></span><span>></span></span>
        <span>&lt;!-- This Realm uses the UserDatabase configured in the global JNDI
             resources under the key "UserDatabase".  Any edits
             that are performed against this UserDatabase are immediately
             available for use by the Realm.  --></span>
        <span><span><span>&lt;</span>Realm</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.realm.UserDatabaseRealm<span>"</span></span>
               <span>resourceName</span><span><span>=</span><span>"</span>UserDatabase<span>"</span></span><span>/></span></span>
      <span><span><span>&lt;/</span>Realm</span><span>></span></span>
      <span><span><span>&lt;</span>Host</span> <span>name</span><span><span>=</span><span>"</span>localhost<span>"</span></span>  <span>appBase</span><span><span>=</span><span>"</span>webapps<span>"</span></span>
            <span>unpackWARs</span><span><span>=</span><span>"</span>true<span>"</span></span> <span>autoDeploy</span><span><span>=</span><span>"</span>true<span>"</span></span><span>></span></span>
        <span>&lt;!-- Access log processes all example.
             Documentation at: /docs/config/valve.html
             Note: The pattern used is equivalent to using pattern="common" --></span>
        <span><span><span>&lt;</span>Valve</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.valves.AccessLogValve<span>"</span></span> <span>directory</span><span><span>=</span><span>"</span>logs<span>"</span></span>
               <span>prefix</span><span><span>=</span><span>"</span>localhost_access_log<span>"</span></span> <span>suffix</span><span><span>=</span><span>"</span>.txt<span>"</span></span>
               <span>pattern</span><span><span>=</span><span>"</span>%h %l %u %t <span title="&quot;">&amp;quot;</span>%r<span title="&quot;">&amp;quot;</span> %s %b<span>"</span></span> <span>/></span></span>
               
					<span><span><span>&lt;</span>Context</span> <span>path</span><span><span>=</span><span>"</span><span>"</span></span> <span>docBase</span><span><span>=</span><span>"</span>hero<span>"</span></span> <span>debug</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>reloadable</span><span><span>=</span><span>"</span>true<span>"</span></span> <span>/></span></span> // 此处是我添加的
					
      <span><span><span>&lt;/</span>Host</span><span>></span></span>
    <span><span><span>&lt;/</span>Engine</span><span>></span></span>
  <span><span><span>&lt;/</span>Service</span><span>></span></span>
<span><span><span>&lt;/</span>Server</span><span>></span></span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><blockquote>
<p>说明：</p>
<p>1、path：是你的文件项目路径，</p>
<p>​	1、如果为空则访问的url：http:xxxxx:8080；</p>
<p>​	2、不为空并且设置为path=&quot;test&quot;则访问的url：http:xxxxx:8080/test/  。和我们的初衷不符。另外一种作用<a href="https://www.cnblogs.com/codetime/p/5325509.html" target="_blank" rel="noopener noreferrer">传送门</a></p>
<p>2、docBase：为你的项目名和你的webapps文件夹下的web文件夹对应；</p>
</blockquote>
</li>
<li>
<p>浏览器访问：<code>http://ip:8080</code>大功告成！！</p>
</li>
</ol>
<h3 id="_3-4、不加端口访问"> 3-4、不加端口访问；</h3>
<blockquote>
<p>说明：浏览网页服务默认的端口号都是80，可以不加端口访问，如果使用其他端口访问时需要明确指定，所以我们要加8080。</p>
</blockquote>
<ol>
<li>
<p><strong>方法一</strong>：我们可以修改 server.xml 文件；</p>
<div><pre><code>vim server.xml

<span>&lt;?xml version="1.0" encoding="UTF-8"?></span>
<span><span><span>&lt;</span>Server</span> <span>port</span><span><span>=</span><span>"</span>8005<span>"</span></span> <span>shutdown</span><span><span>=</span><span>"</span>SHUTDOWN<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>Service</span> <span>name</span><span><span>=</span><span>"</span>Catalina<span>"</span></span><span>></span></span>
  // 在这里把 port 改为 80
    <span><span><span>&lt;</span>Connector</span> <span>port</span><span><span>=</span><span>"</span>80<span>"</span></span> <span>protocol</span><span><span>=</span><span>"</span>HTTP/1.1<span>"</span></span>
               <span>connectionTimeout</span><span><span>=</span><span>"</span>20000<span>"</span></span>
               <span>redirectPort</span><span><span>=</span><span>"</span>8443<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>Engine</span> <span>name</span><span><span>=</span><span>"</span>Catalina<span>"</span></span> <span>defaultHost</span><span><span>=</span><span>"</span>localhost<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>Realm</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.realm.LockOutRealm<span>"</span></span><span>></span></span>
        <span>&lt;!-- This Realm uses the UserDatabase configured in the global JNDI
             resources under the key "UserDatabase".  Any edits
             that are performed against this UserDatabase are immediately
             available for use by the Realm.  --></span>
        <span><span><span>&lt;</span>Realm</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.realm.UserDatabaseRealm<span>"</span></span>
               <span>resourceName</span><span><span>=</span><span>"</span>UserDatabase<span>"</span></span><span>/></span></span>
      <span><span><span>&lt;/</span>Realm</span><span>></span></span>
      <span><span><span>&lt;</span>Host</span> <span>name</span><span><span>=</span><span>"</span>localhost<span>"</span></span>  <span>appBase</span><span><span>=</span><span>"</span>webapps<span>"</span></span>
            <span>unpackWARs</span><span><span>=</span><span>"</span>true<span>"</span></span> <span>autoDeploy</span><span><span>=</span><span>"</span>true<span>"</span></span><span>></span></span>
        <span>&lt;!-- Access log processes all example.
             Documentation at: /docs/config/valve.html
             Note: The pattern used is equivalent to using pattern="common" --></span>
        <span><span><span>&lt;</span>Valve</span> <span>className</span><span><span>=</span><span>"</span>org.apache.catalina.valves.AccessLogValve<span>"</span></span> <span>directory</span><span><span>=</span><span>"</span>logs<span>"</span></span>
               <span>prefix</span><span><span>=</span><span>"</span>localhost_access_log<span>"</span></span> <span>suffix</span><span><span>=</span><span>"</span>.txt<span>"</span></span>
               <span>pattern</span><span><span>=</span><span>"</span>%h %l %u %t <span title="&quot;">&amp;quot;</span>%r<span title="&quot;">&amp;quot;</span> %s %b<span>"</span></span> <span>/></span></span>
               
					<span><span><span>&lt;</span>Context</span> <span>path</span><span><span>=</span><span>"</span><span>"</span></span> <span>docBase</span><span><span>=</span><span>"</span>hero<span>"</span></span> <span>debug</span><span><span>=</span><span>"</span>0<span>"</span></span> <span>reloadable</span><span><span>=</span><span>"</span>true<span>"</span></span> <span>/></span></span> // 此处是我添加的
					
      <span><span><span>&lt;/</span>Host</span><span>></span></span>
    <span><span><span>&lt;/</span>Engine</span><span>></span></span>
  <span><span><span>&lt;/</span>Service</span><span>></span></span>
<span><span><span>&lt;/</span>Server</span><span>></span></span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div></li>
<li>
<p>配置安全组和及开放防火墙80端口；</p>
</li>
<li>
<p>浏览器访问：<code>http://ip</code>大功告成！！</p>
</li>
<li>
<p><strong>方法二</strong>；在不修改端口为 80 的情况下；执行以下命令；</p>
<div><pre><code><span># 将域名默认的80端口映射到8080</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ bin<span>]</span><span># iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080</span>
<span># 查看当前80端口的转发规则:</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ bin<span>]</span><span># iptables -t nat -L -n | grep 80</span>
REDIRECT   tcp  --  <span>0.0</span>.0.0/0            <span>0.0</span>.0.0/0            tcp dpt:80 redir ports <span>8080</span>
<span># 删除当前80端口转发到8080端口的转发规则: 可以关闭先关闭tomcat的服务；</span>
iptables -t nat -D PREROUTING -p tcp --dport <span>8080</span> -j REDIRECT --to-port <span>80</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>
<p>注意：这种方式会在服务器重启后失效；</p>
</blockquote>
</li>
<li>
<p>浏览器访问：<code>http://ip</code>大功告成！！</p>
</li>
</ol>
<blockquote>
<p>建议单独开启8080端口或80端口，不建议直接关闭防火墙；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>liunx 上用tomcat部署web项目后访问空白页问题</title>
      <link>https://wangyawei.top/views/backEnd/tomcat/tomcat-note-04/</link>
      <guid>https://wangyawei.top/views/backEnd/tomcat/tomcat-note-04/</guid>
      <source url="https://wangyawei.top/rss.xml">liunx 上用tomcat部署web项目后访问空白页问题</source>
      <category>TOMCAT</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="问题描述"> 问题描述；</h2>
<blockquote>
<p>本人使用的阿里云服务器，经过几天的折腾，我怀着无比激动的心情打开浏览器访问我几天的劳动成果，然而呈现我眼前的却是空白页<strong>what？</strong></p>
</blockquote>
<h2 id="解决方案"> 解决方案；</h2>
<ol>
<li>
<p>在 <code>vue.config.js</code>中配置<code>publicPath</code>属性；</p>
<blockquote>
<p><strong>据<code>vue</code>官方介绍：</strong><code>Vue CLI</code> 会假设你的应用是被部署在一个域名的根路径上，例如 <code>https://www.my-app.com/</code>。<strong>如果应用被部署在一个子路径上</strong>，你就需要用这个选项指定这个子路径。例如，如果你的应用被部署在 <code>https://www.my-app.com/my-app/</code>，则设置 <code>publicPath</code> 为 <code>/my-app/</code>。</p>
<p>这个值也可以被设置为空字符串 (<code>''</code>) 或是相对路径 (<code>'./'</code>)，这样所有的资源都会被链接为相对路径，这样打出来的包可以被部署在任意路径</p>
</blockquote>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  <span>// 解决部署后访问空白页的问题；</span>
  publicPath<span>:</span> <span>'./'</span><span>,</span>
<span>}</span>
<span>// 我的项目部署在 http://47.114.139.71:8080/heros/#heroList 上；</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>相对路径：‘./’  会把项目名默认添加到请求的资源路径中；
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594793990333.png" alt="1594793990333" /></p>
<div><pre><code>如果是 绝对路径 ‘/’ 则请求的资源路径为 http://47.114.139.71:8080/css/app.93ebc27.css
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>以相对路径<code>./</code>设置的效果和<code>/heros/</code>或<code>heros</code>的效果一样；都会在请求的资源路径添加项目名或你设置的路径名(hero)；</p>
</blockquote>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/designMode/</link>
      <guid>https://wangyawei.top/views/designMode/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>设计模式</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些自己平时学习设计模式的一些相关的知识；</p>
</blockquote>
<h2 id="目录"> 目录</h2>
<ol>
<li><a href="./designMode-note-01.html">设计模式概论</a></li>
<li><a href="./designMode-note-02.html">封装与对象</a></li>
<li><a href="./designMode-note-03.html">工厂模式</a></li>
<li><a href="./designMode-note-04.html">建造者模式</a></li>
<li><a href="./designMode-note-05.html">单例模式</a></li>
<li>[构造函数模式]</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>设计模式概论</title>
      <link>https://wangyawei.top/views/designMode/designMode-note-01/</link>
      <guid>https://wangyawei.top/views/designMode/designMode-note-01/</guid>
      <source url="https://wangyawei.top/rss.xml">设计模式概论</source>
      <category>设计模式</category>
      <pubDate>Mon, 09 Aug 2021 21:31:22 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>设计模式是一套可以被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结，使用设计模式是为了可重用代码、让代码更容易被他人理解并且提高代码的可靠性。</p>
</blockquote>
<h2 id="扮演的角色"> 扮演的角色</h2>
<ul>
<li>帮助我们组织模块：通过一些设计模式，组织模块间的组成结构。</li>
<li>帮助我们设计沟通：有的设计模式可以帮助我们设计模块间如何沟通。</li>
<li>提高代码质量：通过设计模式，让代码更加优雅。</li>
</ul>
<h2 id="设计原则"> 设计原则</h2>
<ol>
<li><strong>开闭原则</strong>：就是说对扩展开放对修改关闭，比如：我们的程序在使用的时候要留出可以扩展的功能，但是在具体使用的使用不能让别人修改我们的源码，例：vue插件就是一些开闭原则的体现，vue留出接口通过插件来扩展vue的功能；</li>
<li><strong>单一职责原则</strong>：就是说我们的一个功能模块只做一件事情；</li>
<li><strong>依赖倒置原则</strong>：我们的上层模块不要依赖于下层模块，而是依赖与抽象；</li>
<li><strong>接口隔离原则</strong>：就是说我们的接口应该细化，功能应该单一；</li>
<li><strong>迪米特法则</strong>：迪米特法则（Law of Demeter）又叫作最少知识原则（The Least Knowledge Principle），一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解,只和朋友通信，不和陌生人说话。</li>
<li><strong>里氏替换原则</strong>：子类可以扩展父类的功能，但不能改变父类原有的功能。</li>
</ol>
<h2 id="分类"> 分类：</h2>
<p><strong>我们的设计模式可以分为4大类：</strong></p>
<ul>
<li><strong>创建型</strong>：帮助我们优雅的创建对象；
<ul>
<li>工厂模式：大量创建对象；</li>
<li>单例模式：全局只能有我一个；</li>
<li>建造者模式：精细化组合对象；</li>
<li>原型模式：javascript的灵魂；</li>
</ul>
</li>
<li><strong>结构型</strong>：帮助我们优雅的设计代码结构；
<ul>
<li>外观模式：给你的一个套餐；</li>
<li>享元模式：共享来减少数量；</li>
<li>适配器模式：用适配代替更改；</li>
<li>桥接模式：独立出来，然后再对接过去；</li>
<li>装饰者模式：更优雅的扩展需求；</li>
</ul>
</li>
<li><strong>行为型</strong>：模块之间行为的模块总结，帮助我们组织模块行为；
<ul>
<li>观察者模式：我作为第三方转发；</li>
<li>职责链模式：像生产线一样组织模块；</li>
<li>状态模式：用状态代替判断；</li>
<li>命令模式：用命令去解耦；</li>
<li>策略模式：算法工厂；</li>
<li>迭代器模式：告别for循环；</li>
</ul>
</li>
<li><strong>技巧型</strong>：帮助我们优化代码的技巧；
<ul>
<li>链模式：链式调用；</li>
<li>惰性模式：我要搞机器学习；</li>
<li>委托模式：让别人代替你收快递；</li>
<li>等待着模式：等你们都回来再吃饭；</li>
<li>数据访问模式：一个方便的数据管理器；</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>封装与对象</title>
      <link>https://wangyawei.top/views/designMode/designMode-note-02/</link>
      <guid>https://wangyawei.top/views/designMode/designMode-note-02/</guid>
      <source url="https://wangyawei.top/rss.xml">封装与对象</source>
      <category>设计模式</category>
      <pubDate>Mon, 09 Aug 2021 20:38:22 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="封装的目的"> 封装的目的</h2>
<ul>
<li>定义变量不会污染外部；</li>
<li>能够作为一个模块调用；</li>
<li>遵循开闭原则；</li>
</ul>
<h2 id="什么是好的封装"> 什么是好的封装</h2>
<ul>
<li>变量外部不可见；</li>
<li>调用接口使用；</li>
<li>留出扩展接口；</li>
</ul>
<h2 id="使用的设计模式"> 使用的设计模式</h2>
<ul>
<li>工厂模式；</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>工厂模式</title>
      <link>https://wangyawei.top/views/designMode/designMode-note-03/</link>
      <guid>https://wangyawei.top/views/designMode/designMode-note-03/</guid>
      <source url="https://wangyawei.top/rss.xml">工厂模式</source>
      <category>设计模式</category>
      <pubDate>Mon, 09 Aug 2021 20:38:22 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>定义一个创建对象的接口，让其开发者自己决定实例化哪一个工厂类。通常用于当某一个对象需要经常创建的时候，其主要目的是方便我们大量创建对象。</p>
</blockquote>
<h2 id="创建对象"> 创建对象</h2>
<div><pre><code><span>function</span> <span>Person</span> <span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>name <span>=</span> name
  <span>this</span><span>.</span>age <span>=</span> age
  <span>this</span><span>.</span><span>sayName</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span>
  <span>}</span>
<span>}</span>

<span>var</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>'Jack'</span><span>,</span> <span>18</span><span>)</span>
p1<span>.</span><span>sayName</span><span>(</span><span>)</span> <span>// => Jack</span>

<span>var</span> p2 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>'Mike'</span><span>,</span> <span>23</span><span>)</span>
p2<span>.</span><span>sayName</span><span>(</span><span>)</span> <span>// => Mike</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><blockquote>
<p>工厂模式就是写一个方法，只需调用这个方法，就能拿到你要的对象；</p>
</blockquote>
<h2 id="创建弹窗"> 创建弹窗</h2>
<blockquote>
<p>实现一个多彩的弹窗，弹窗有多种，他们之间存在内容和颜色上的差异；</p>
</blockquote>
<div><pre><code><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>// 创建3个弹窗，消息、确认、取消,分别具有不同的颜色</span>
    <span>function</span> <span>Pop</span><span>(</span><span>type<span>,</span> content<span>,</span> color</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>this</span> <span>instanceof</span> <span>Pop</span><span>)</span> <span>{</span>
            <span>return</span> <span>this</span><span>[</span><span><span>`</span><span><span>${</span>type<span>}</span></span><span>Pop</span><span>`</span></span><span>]</span><span>(</span>content<span>,</span> color<span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>return</span> <span>new</span> <span>Pop</span><span>(</span>type<span>,</span> content<span>,</span> color<span>)</span>
        <span>}</span>
    <span>}</span>
    <span>Pop</span><span>.</span>prototype<span>.</span><span>infoPop</span> <span>=</span> <span>function</span><span>(</span><span>content<span>,</span> color</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span>content<span>,</span> color<span>)</span><span>;</span>
    <span>}</span>
    <span>Pop</span><span>.</span>prototype<span>.</span><span>cancelPop</span> <span>=</span> <span>function</span><span>(</span><span>content<span>,</span> color</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span>content<span>,</span> color<span>)</span><span>;</span>
    <span>}</span>
    <span>Pop</span><span>.</span>prototype<span>.</span><span>confirmPop</span> <span>=</span> <span>function</span><span>(</span><span>content<span>,</span> color</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span>content<span>,</span> color<span>)</span><span>;</span>
    <span>}</span>
    window<span>.</span>$pop <span>=</span> Pop<span>;</span>
<span>}</span><span>)</span><span>(</span><span>)</span>

<span>$pop</span><span>(</span><span>'info'</span><span>,</span> <span>'hello word'</span><span>,</span> <span>'red'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><blockquote>
<p>你只需要去调用这个<code>$pop</code>方法即可批量创建弹窗；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>建造者模式</title>
      <link>https://wangyawei.top/views/designMode/designMode-note-04/</link>
      <guid>https://wangyawei.top/views/designMode/designMode-note-04/</guid>
      <source url="https://wangyawei.top/rss.xml">建造者模式</source>
      <category>设计模式</category>
      <pubDate>Mon, 09 Aug 2021 20:38:22 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。这种类型的设计模式属于创建型模式，它提供了一种创建对象的最佳方式。主要用于当要创建单个、庞大的组合对象时，其目的是需要组合出一个全局对象。</p>
</blockquote>
<h2 id="编辑器插件"> 编辑器插件</h2>
<blockquote>
<p>编写一个编辑器插件，我们知道编辑器有很多的功能，那么就意味着初始化的时候需要配置大量的参数，而且内部功能很多。这个时候我们就可以使用建造者模式；</p>
</blockquote>
<div><pre><code><span>//定义最终类</span>
<span>function</span> <span>Editor</span><span>(</span><span>)</span><span>{</span>
	<span>this</span><span>.</span>initer <span>=</span> <span>new</span> <span>initHtml</span><span>(</span><span>)</span><span>;</span>
    <span>this</span><span>.</span>fontControll <span>=</span> <span>new</span> <span>fontControll</span><span>(</span><span>)</span><span>;</span>
    <span>this</span><span>.</span>stateControll <span>=</span> <span>new</span> <span>stateControll</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>//html初始模块</span>
<span>function</span> <span>initHtml</span><span>(</span><span>domStyle</span><span>)</span><span>{</span>
  <span>this</span><span>.</span>template<span>=</span><span>'&lt;div style={{editorStyle}}>&lt;div>&lt;/div>&lt;div>&lt;textarea style={{areaSyle}}/>&lt;/div>&lt;/div>'</span><span>;</span>

<span>}</span>
initHtml<span>.</span>prototype<span>.</span><span>initStyle</span><span>=</span><span>function</span><span>(</span><span>)</span><span>{</span>

<span>}</span>
initHtml<span>.</span>prototype<span>.</span><span>renderDom</span><span>=</span><span>function</span><span>(</span><span>)</span><span>{</span>

<span>}</span>
<span>//字体颜色,大小控制</span>
<span>function</span> <span>fontControll</span><span>(</span><span>)</span><span>{</span>
  
<span>}</span><span>;</span>
fontControll<span>.</span>prototype<span>.</span><span>changeColor</span><span>=</span><span>function</span><span>(</span><span>)</span><span>{</span>

<span>}</span>
fontControll<span>.</span>prototype<span>.</span><span>changeFontsize</span><span>=</span><span>function</span><span>(</span><span>)</span><span>{</span>

<span>}</span>
<span>//回滚</span>
<span>function</span> <span>stateControll</span><span>(</span><span>)</span><span>{</span>

<span>}</span>
stateControll<span>.</span>prototype<span>.</span><span>saveState</span><span>=</span><span>function</span><span>(</span><span>)</span><span>{</span>

<span>}</span>
stateControll<span>.</span>prototype<span>.</span><span>stateBack</span><span>=</span><span>function</span><span>(</span><span>)</span><span>{</span>

<span>}</span>
stateControll<span>.</span>prototype<span>.</span><span>stateGo</span><span>=</span><span>function</span><span>(</span><span>)</span><span>{</span>

<span>}</span>
window<span>.</span>Editor<span>=</span>Editor<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="vue源码"> vue源码</h2>
<blockquote>
<p>在vue的源码中我们可以看到一下代码片段，<code>initMixin</code>、<code>stateMixin</code>、<code>eventsMixin</code>等都是分模块开发最后组合到一起的。</p>
</blockquote>
<div><pre><code><span>function</span> <span>Vue</span> <span>(</span><span>options</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span><span>(</span><span>this</span> <span>instanceof</span> <span>Vue</span><span>)</span>
       <span>)</span> <span>{</span>
        <span>warn</span><span>(</span><span>'Vue is a constructor and should be called with the `new` keyword'</span><span>)</span><span>;</span>
    <span>}</span>
    <span>this</span><span>.</span><span>_init</span><span>(</span>options<span>)</span><span>;</span>
<span>}</span>

<span>initMixin</span><span>(</span>Vue<span>)</span><span>;</span>
<span>stateMixin</span><span>(</span>Vue<span>)</span><span>;</span>
<span>eventsMixin</span><span>(</span>Vue<span>)</span><span>;</span>
<span>lifecycleMixin</span><span>(</span>Vue<span>)</span><span>;</span>
<span>renderMixin</span><span>(</span>Vue<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>单例模式</title>
      <link>https://wangyawei.top/views/designMode/designMode-note-05/</link>
      <guid>https://wangyawei.top/views/designMode/designMode-note-05/</guid>
      <source url="https://wangyawei.top/rss.xml">单例模式</source>
      <category>设计模式</category>
      <pubDate>Mon, 09 Aug 2021 20:38:22 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>单例对象的类只能允许一个实例存在。主要用于为了避免重复新建，避免多个对象存在互相干扰，其目的是需要确保全局只有一个对象。例：window的任务管理器</p>
</blockquote>
<h2 id="数据储存对象"> 数据储存对象</h2>
<blockquote>
<p>实现一个全局的数据储存者，这个储存者只能有一个，不然会需要进行同步，增加复杂度。</p>
</blockquote>
<div><pre><code><span>function</span> <span>store</span><span>(</span><span>)</span><span>{</span>
  <span>if</span><span>(</span>store<span>.</span>install<span>)</span><span>{</span>
  	<span>return</span> store<span>.</span>install<span>;</span>
  <span>}</span>
  <span>this</span><span>.</span>store <span>=</span> <span>{</span>

  <span>}</span>
  store<span>.</span>install<span>=</span><span>this</span><span>;</span>
<span>}</span>
store<span>.</span>install<span>=</span><span>null</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="全局唯一的vue路由"> 全局唯一的vue路由</h2>
<blockquote>
<p>在我们vue.use()的时候，保证只进行一次注册；</p>
</blockquote>
<div><pre><code><span>//vue-router</span>
<span>let</span> _Vue<span>;</span>
<span>function</span> <span>install</span> <span>(</span><span>_Vue</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>install<span>.</span>installed <span>&amp;&amp;</span> _Vue <span>===</span> Vue<span>)</span> <span>return</span>
  install<span>.</span>installed <span>=</span> <span>true</span>
  
  _Vue <span>=</span> Vue
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/frontEnd/ajax/</link>
      <guid>https://wangyawei.top/views/frontEnd/ajax/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>AJAX</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些和ajax相关的知识点；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>ajax基础</title>
      <link>https://wangyawei.top/views/frontEnd/ajax/ajax-note-00/</link>
      <guid>https://wangyawei.top/views/frontEnd/ajax/ajax-note-00/</guid>
      <source url="https://wangyawei.top/rss.xml">ajax基础</source>
      <category>AJAX</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="专业术语"> 专业术语;</h2>
<blockquote>
<ol>
<li>
<p>客户端;</p>
<ul>
<li>在上网的过程中，浏览器还有另外一个名字，叫做客户端。</li>
</ul>
</li>
<li>
<p>服务器;</p>
<ul>
<li>存储百度网页的那台计算机，叫做服务器，或者叫做Web服务器。</li>
</ul>
</li>
<li>
<p>请求;</p>
<ul>
<li>请求，或者叫做发送请求，指的是客户端向服务器“索要”页面的过程;</li>
</ul>
</li>
<li>
<p>响应;</p>
<ul>
<li>即回应，当客户端向服务器发送请求之后，服务器会根据客户端的请求，将客户端请求文件的源代码返回给浏览器，这一过程称之为响应。</li>
</ul>
</li>
<li>
<p>资源</p>
<ul>
<li>服务器上存储的东西都可以叫做资源，比如html文件、css文件、图片文件、js文件、音频视频文件、字体文件等等。</li>
</ul>
</li>
</ol>
</blockquote>
<h2 id="服务器"> 服务器;</h2>
<blockquote>
<ol>
<li>Web资源（html文件、css文件、js文件、json文件等等...）都是存储在Web服务器上的。</li>
<li>Web服务器会对客户端的请求进行处理并提供响应，</li>
<li>Web服务器的作用：
<ul>
<li>存储Web资源：比如服务器上的html文件、css文件、js文件、图片文件等等。</li>
<li>提供Web服务：能够接收并处理客户端的请求，并做出回应;</li>
</ul>
</li>
<li>Web服务器和普通计算机的区别
<ul>
<li>除了硬件设施的区别之外，`Web服务器 === 普通计算机 + 服务器软件;</li>
</ul>
</li>
<li>服务器软件
<ul>
<li>服务器和个人计算机的<strong>本质区别</strong>是，服务器上安装了服务软件，比如：
<ul>
<li>Apache</li>
<li>Nginx</li>
<li>IIS</li>
</ul>
</li>
<li>凡是叫做服务器的，肯定都安装了服务软件。</li>
</ul>
</li>
<li>计算机开启服务器后，必须用访问服务器的方式去访问，即必须使用IP地址或域名访问，不能以文件方式打开;</li>
</ol>
</blockquote>
<h2 id="ajax介绍"> Ajax介绍;</h2>
<blockquote>
<ol>
<li>通过浏览器输入 IP或域名，按下回车的方式，可以向服务器发送请求，并能接收到服务器响应的结果，浏览器的这项可以发送请求并接收结果的功能，可以认为是浏览器本能的行为。</li>
<li><img src="./assets/1570856713597.png" alt="1570856713597" /></li>
<li>Ajax是一种技术，可以实现客户端和服务器的请求响应过程。</li>
<li>使用Ajax技术，只需要让浏览器执行一段JS代码就可以实现请求响应过程了，在此期间页面不会刷新;</li>
</ol>
</blockquote>
<h2 id="数据接口"> 数据接口;</h2>
<blockquote>
<ol>
<li>通过Ajax向服务器发送请求的时候，不但可以请求服务器上的文件资源，也可以请求接口，url也可以这样写：</li>
</ol>
<div><pre><code><span>&lt;</span>script src<span>=</span><span>"./assets/jquery.js"</span><span>></span><span>&lt;</span><span>/</span>script<span>></span>
<span>&lt;</span>script<span>></span>
$<span>.</span><span>ajax</span><span>(</span><span>{</span>
url<span>:</span> <span>'/common/abc'</span><span>,</span> <span>// 这里这样写</span>
<span>success</span><span>:</span> <span>function</span> <span>(</span><span>result</span><span>)</span> <span>{</span>
   console<span>.</span><span>log</span><span>(</span>result<span>)</span><span>;</span>
<span>}</span>
<span>}</span><span>)</span><span>;</span>
<span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ol start="2">
<li>
<p>非文件的地址：我们把它叫做接口或接口地址。</p>
<ul>
<li>接口，是后端提供的。</li>
<li>接口，也是一个<strong>网址</strong>，通过客户端向这个网址发送请求，可以获取到接口返回的结果。</li>
</ul>
</li>
<li>
<p>根据提供的接口文档来确定是否需要设置请求参数；</p>
</li>
<li>
<p>我们把接口看做一个带有返回值的函数，通过客户端访问接口，就相当于调用该函数，并可以得到它的返回值。有些函数调用需要参数，接口也是如此。</p>
</li>
<li>
<p><strong>实际开发中，接口支持哪种请求方式，还得以文档为准。</strong></p>
</li>
</ol>
</blockquote>
<h2 id="接口文档"> 接口文档；</h2>
<blockquote>
<ol>
<li>
<p>接口文档中记载了接口的详细信息，大致包括，接口地址、作用、请求方式、请求参数、响应结果等等。</p>
</li>
<li>
<p>向接口发送请求只需要会套 <code>$.ajax()</code> 这个方法即可。</p>
</li>
<li>
<p>接口参数可以按下面两种方式来填写：</p>
<ul>
<li>方式一：`参数=值&amp;参数=值...</li>
<li>方式二：`{参数: 值, 参数: 值, ...}</li>
</ul>
</li>
<li>
<p><strong>请求参数是客户端额外发送到服务器的数据，告知服务器此次请求的具体信息；</strong></p>
<ul>
<li>无论使用哪种写法编写请求参数，实际发送到服务器的总是方式一那样的字符串；</li>
</ul>
</li>
</ol>
</blockquote>
<hr>
<h2 id="ajax"> $.ajax() ;</h2>
<blockquote>
<ol>
<li><strong>语法：</strong></li>
</ol>
<div><pre><code>$<span>.</span><span>ajax</span><span>(</span><span>{</span>
    type<span>:</span> <span>'请求方式'</span><span>,</span>
    data<span>:</span> <span>'请求参数'</span><span>,</span>
    url<span>:</span> <span>'接口地址'</span><span>,</span>
    dataType<span>:</span> <span>'响应数据类型'</span><span>,</span>
    <span>success</span><span>:</span> <span>function</span> <span>(</span><span>res</span><span>)</span> <span>{</span>
    <span>// res 就是响应结果</span>
    <span>}</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ol start="2">
<li>
<p><strong>type;</strong></p>
<ul>
<li>表示请求的方式;
<ul>
<li>最常见的两种请求方式;
<ul>
<li>GET;</li>
<li>POST;</li>
</ul>
</li>
<li>GET和POST的异同;
<ul>
<li>不同点：
<ul>
<li>get  ：主要用于获取；向服务器请求资源（图片，文件，数据....）。它是最常见的请求方式。<strong>只是请求，而不会改变服务器上的资源。</strong></li>
<li>post：派送，投递。用于向服务器上提交数据，<strong>可能会修改服务器上的资源。</strong></li>
</ul>
</li>
<li>相同点;
<ul>
<li>都可以在发请求时附带一些数据。</li>
<li>都能够从服务器上获取返回的数据。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>data;</strong></p>
<ul>
<li>向接口发送请求的时候，携带的数据，<strong>也就是接口文档中的请求参数;</strong></li>
<li>写法:
<ul>
<li>对象形式，形如： <code>{name: 'xxx', content: 'xxx'}</code></li>
<li>字符串形式，形如： <code>name=xxx&amp;content=xxx</code></li>
<li>无论写法如何，实际上发送给服务器的数据都是 字符串形式。多个请求参数之间，使用 &amp; 符号隔开。GET请求的时候，这个字符串和接口之间使用 ? 隔开；</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>dataType；</strong></p>
<ul>
<li>服务器响应数据的格式。</li>
<li>指定该项，jQuery会自动将服务器响应的数据处理成JS数据（数组、对象、字符串、布尔等等）</li>
<li>可选的值
<ul>
<li><code>json</code>，它是==最最常见==的数据传输格式。能够以简单的语法表示复杂的数据</li>
<li><code>text</code>，表示服务器返回的是文本类型的数据</li>
<li><code>xml</code>，表示服务器返回的是xml格式的数据，目前项目中很少使用它了，这里作为了解</li>
<li><code>jsonp</code>、<code>script</code>、<code>html</code>等其他值；</li>
</ul>
</li>
<li>当我们已经知道了服务器返回数据的格式，则最好指定 `dataType；</li>
</ul>
</li>
<li>
<p><strong>beforeSend；</strong></p>
<ul>
<li>
<p>需要加载  nprogress.css  ，nprogress.js  两个文件；</p>
</li>
<li>
<p>在发送Ajax请求之前，允许我们做一些事情；</p>
<div><pre><code>   <span>//语法</span>
    $<span>.</span><span>ajax</span><span>(</span><span>{</span>
        <span>beforeSend</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>// 发送请求之前，你需要做什么？可以写到这里</span>
          NProgress<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span><span>//进度条；</span>
        <span>}</span>
    <span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
</ul>
</li>
<li>
<p><strong>complete</strong>;</p>
<ul>
<li>
<p>在Ajax请求结束之后，允许我们做一些事情;</p>
<div><pre><code>  <span>//语法</span>
  $<span>.</span><span>ajax</span><span>(</span><span>{</span>
      <span>// 发送请求之后，你需要做什么？可以写到这里</span>
      <span>complete</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
      NProgress<span>.</span><span>done</span><span>(</span><span>)</span><span>;</span><span>//进度条</span>
      <span>}</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
</ul>
</li>
<li>
<p><strong>案例；</strong></p>
<div><pre><code><span>&lt;</span>script src<span>=</span><span>"../assets/nprogress.js"</span><span>></span><span>&lt;</span><span>/</span>script<span>></span>
<span>&lt;</span>link rel<span>=</span><span>"stylesheet"</span> href<span>=</span><span>"../assets/nprogress.css"</span><span>></span>

<span>&lt;</span>input type<span>=</span><span>"text"</span> id<span>=</span><span>"username"</span><span>></span>
<span>&lt;</span>span<span>></span><span>&lt;</span><span>/</span>span<span>></span>
    <span>&lt;</span>script<span>></span>
    <span>//获取文本框并注册change事件；</span>
    <span>$</span><span>(</span><span>'#username'</span><span>)</span><span>.</span><span>change</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
        <span>//获取用户输入的内容；</span>
        <span>var</span> text <span>=</span> <span>$</span><span>(</span><span>this</span><span>)</span><span>.</span><span>val</span><span>(</span><span>)</span><span>;</span>
        <span>//发送AJAX请求来验证用户名；</span>
        $<span>.</span><span>ajax</span><span>(</span><span>{</span>
            <span>//请求之前做什么；</span>
            <span>beforeSend</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
                NProgress<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
            <span>}</span><span>,</span>
            <span>//请求之后做什么；</span>
            <span>complete</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
                NProgress<span>.</span><span>done</span><span>(</span><span>)</span><span>;</span>
            <span>}</span><span>,</span>
            <span>//设置请求方式；</span>
            type<span>:</span> <span>'get'</span><span>,</span>
            <span>//设置请求地址；</span>
            url<span>:</span> <span>'/common/checkUser'</span><span>,</span>
            <span>//设置请求参数；</span>
            data<span>:</span> <span>{</span>
                username<span>:</span> text
            <span>}</span><span>,</span>
            <span>//设置响应数据类型；</span>
            dataType<span>:</span> <span>'json'</span><span>,</span>
            <span>//接收响应结果；</span>
            <span>success</span><span>:</span> <span>function</span><span>(</span><span>r</span><span>)</span> <span>{</span>
                <span>//判断用户名是否可用；</span>
                <span>$</span><span>(</span><span>'span'</span><span>)</span><span>.</span><span>text</span><span>(</span>r<span>.</span>msg<span>)</span><span>;</span>
                <span>//清空文本域；</span>
                <span>$</span><span>(</span><span>'#username'</span><span>)</span><span>.</span><span>val</span><span>(</span><span>''</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span>
    <span>}</span><span>)</span>
<span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div></li>
</ol>
</blockquote>
<hr>
<h2 id="原生ajax"> 原生Ajax;</h2>
<blockquote>
<ol>
<li>
<p>原生的Ajax实现，是基于浏览器内置对象 <code>XMLHttpRequest</code> 提供的API实现的。</p>
</li>
<li>
<p><strong>基本语法;</strong></p>
<ol>
<li>
<p>GET方式写法；</p>
<ul>
<li>一般是获取服务器上的资源；不会改变服务器上的资源；</li>
</ul>
</li>
</ol>
<div><pre><code> <span>// 1. 实例化 XMLHttpRequest对象</span>
 <span>var</span> xhr <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span><span>;</span>
 <span>// 2.设置请求方式和url</span>
 xhr<span>.</span><span>open</span><span>(</span><span>'GET'</span><span>,</span> <span>'/common/time'</span><span>)</span><span>;</span>
 <span>/</span><span>2.</span>如果有请求参数
 xhr<span>.</span><span>open</span><span>(</span><span>'GET'</span><span>,</span> <span>'接口地址?参数=值&amp;参数=值....'</span><span>)</span><span>;</span>
  <span>// 3. 发送请求。 ---> 此步骤，表示开始发送请求</span>
   xhr<span>.</span><span>send</span><span>(</span><span>)</span><span>;</span>
 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
</ol>
<p>// 4. 请求响应过程结束后，会触发该事件；在事件处理函数中，接收服务器响应的结果
xhr.onload = function () {
// 使用 xhr.response; 来接收结果
console.log(xhr.response);
}
```</p>
<ol start="3">
<li><strong>POST方式写法;</strong></li>
</ol>
<ul>
<li>
<p>一般提交数据给服务器，这种方式有可能改变服务器上的资源；</p>
</li>
<li>
<p>和GET请求相比，多了一行代码，并且请求参数的位置变化了。</p>
</li>
</ul>
<p>​```js
var xhr = new XMLHttpRequest();</p>
<p>xhr.open('POST', '/message/addMsg');</p>
<p>// 相比GET方式，POST方式多下面一行代码
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');</p>
<p>//参数写在send方法里面；
xhr.send('name=李白&amp;content=举杯邀明月');</p>
<p>//onload为H5新增事件，响应过程结束触发该事件；
xhr.onload = function () {
//response属性用于获取响应结果；
console.log(xhr.response);
}
```</p>
<ol start="4">
<li>
<p><strong>原生ajax中get 和 post 区别;</strong></p>
<ol>
<li>get
<ul>
<li>参数需要和url拼接在一起（<code>url?name=1&amp;age=30</code>）</li>
</ul>
</li>
</ol>
<ul>
<li><strong>由于浏览器对url长度的支持（各个浏览器均不同）是有限，所以，它只能附加少量的数据。</strong></li>
</ul>
<ol start="2">
<li>post</li>
</ol>
<ul>
<li>需要设置请求头: <code>xhr.setRequestHeader('content-type','application/x-www-form-urlencoded')；</code>
<ul>
<li>固定写法；</li>
</ul>
</li>
<li>参数需要写在send()方法中:<code>send('name=1&amp;age=30')</code>；</li>
<li><strong>相对于get 来说，没有传参大小的限制。</strong></li>
</ul>
</li>
<li>
<p><strong>验证用户名案例；</strong></p>
</li>
</ol>
<div><pre><code><span>&lt;</span>script<span>></span>
<span>//注册文本框change事件；</span>
document<span>.</span><span>querySelector</span><span>(</span><span>'input'</span><span>)</span><span>.</span><span>onchange</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
<span>//获取文本内容；</span>
<span>var</span> text <span>=</span> <span>this</span><span>.</span>value<span>;</span>
<span>//创建ajax对象；</span>
<span>var</span> xhr <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span><span>;</span>
<span>//设置请求方式并设置请求参数；</span>
xhr<span>.</span><span>open</span><span>(</span><span>'GET'</span><span>,</span> <span>'/common/checkUser?username='</span> <span>+</span> text<span>)</span><span>;</span>
<span>//发送请求；</span>
xhr<span>.</span><span>send</span><span>(</span><span>)</span><span>;</span>

<span>//第一种方式；</span>
<span>//注册事件；</span>
<span>// xhr.onload = function() {</span>
<span>//     //获取响应结果；</span>
<span>//     console.log(this.response);</span>
<span>//     //转为对象；</span>
<span>//     var obj = JSON.parse(this.response);</span>
<span>//     //获取span元素对象；</span>
<span>//     document.querySelector('span').innerText = obj.msg</span>
<span>// }</span>

<span>//第二种方式；</span>
<span>//状态发生变化的时候， 就会触发这个事件;</span>
xhr<span>.</span><span>onreadystatechange</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
<span>//判断状态为4则响应接受完成；</span>
<span>if</span> <span>(</span><span>this</span><span>.</span>readyState <span>==</span> <span>4</span><span>)</span> <span>{</span>
console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>response<span>)</span><span>;</span>
<span>//转为对象；</span>
<span>var</span> obj <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>this</span><span>.</span>response<span>)</span><span>;</span>
<span>//获取span元素对象；</span>
document<span>.</span><span>querySelector</span><span>(</span><span>'span'</span><span>)</span><span>.</span>innerText <span>=</span> obj<span>.</span>msg
<span>}</span>
<span>}</span>
<span>}</span>
<span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><ol start="6">
<li>
<p>扩展;</p>
<ol>
<li>onreadystatechange;</li>
</ol>
<ul>
<li>在H5之前，都是使用onreadystatechange。</li>
<li>当Ajax状态发生变化的时候，就会触发这个事件;</li>
</ul>
<ol start="2">
<li>readyState;</li>
</ol>
<ul>
<li>xhr 对象提供了一个属性 readyState ，用它来表示 Ajax请求到哪个阶段了。</li>
</ul>
</li>
</ol>
<div><pre><code> - 输出 xhr.readyState 会得到 0、1、2、3、4几个数字，他们分别表示 Ajax请求响应的各个阶段;
</code></pre>
</div><table>
<thead>
<tr>
<th>readyState</th>
<th>状态描述</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td>UNSENT</td>
<td>代理（XHR）被创建，但尚未调用 <code>open()</code> 方法。</td>
</tr>
<tr>
<td>1</td>
<td>OPENED</td>
<td>open()方法已经被调用，建立了连接。</td>
</tr>
<tr>
<td>2</td>
<td>HEADERS_RECEIVED</td>
<td>send()方法已经被调用，并且已经可以获取状态行和响应头;</td>
</tr>
<tr>
<td>3</td>
<td>LOADING</td>
<td>响应体（服务器返回的数据）下载中,responseText` 属性可能已经包含部分数据。</td>
</tr>
<tr>
<td>4</td>
<td>DONE</td>
<td>响应体（服务器返回的数据）下载完成，可以直接使用 <code>responseText</code>或response 获取完整的结果。</td>
</tr>
</tbody>
</table>
<div><pre><code> - 如果服务器返回的数据量非常大，xhr对象是分块接收数据的，一次性接收一部分（大小不确定），直至接收完毕为止。
   
 - 注意的是，当xhr对象接收的数据发生变化的时候，这里readyState的值不会发生变化，一直为3，但接收到的数据变化了，也表示ajax的状态变化了，此时也会触发onreadystatechange事件。
</code></pre>
</div><ol start="3">
<li>
<p>responseType；</p>
<div><pre><code> - 表示预期服务器返回的数据的类型，当设置了该属性后，通过 `response` 接收数据的时候，会根据该属性的值来自动处理结果为JS能够识别的数据。
</code></pre>
</div><ul>
<li>它相当于 $.ajax() 方法中的 dataType； <code>responseType='json'</code></li>
<li>responseType的可选值为下面几个：
<ul>
<li>“”  -- 空，表示文本，和text一样。空为默认值</li>
<li>text -- 文本</li>
<li>json -- JSON格式数据</li>
<li>document -- 文档对象。当服务器返回的结果是XML类型的时候，需要指定为document</li>
</ul>
</li>
</ul>
</li>
<li>
<p>IE中的缓存问题；</p>
</li>
<li>
<p>只有IE浏览器会有缓存问题；</p>
</li>
<li>
<p><strong>缓存问题指的是</strong>：两次或多次 AJAX GET 请求<strong>同一个</strong> URL ，IE浏览器在第二次请求的时候，并不会从新向服务器发请求，而是直接使用上次请求的结果。</p>
</li>
<li>
<p>解决方案；</p>
<ul>
<li>
<p>让每次请求的URL都不同；</p>
</li>
<li>
<p>不同的查询字符串(请求参数)会被浏览器认为是不同的地址，浏览器会忽略客户端缓存。</p>
</li>
</ul>
</li>
</ol>
<div><pre><code><span>&lt;</span>body<span>></span>
<span>&lt;</span>input type<span>=</span><span>"button"</span> id<span>=</span><span>"btn"</span> value<span>=</span><span>"请求"</span><span>></span>
<span>&lt;</span>script<span>></span>
<span>// 点击按钮的时候，发送ajax请求</span>
document<span>.</span><span>getElementById</span><span>(</span><span>'btn'</span><span>)</span><span>.</span><span>onclick</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
<span>// 1. 创建 XHR 对象</span>
<span>var</span> xhr <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span><span>;</span>
<span>// 2. 调用open方法，设置请求方式和url（接口）</span>
<span>// xhr.open('GET', '/time?abc=' + Math.random());</span>
xhr<span>.</span><span>open</span><span>(</span><span>'GET'</span><span>,</span> <span>'/time?abc='</span> <span>+</span> Date<span>.</span><span>now</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>// 3. 调用send方法，发送请求</span>
xhr<span>.</span><span>send</span><span>(</span><span>null</span><span>)</span><span>;</span>
<span>// 4. 当请求响应过程结束，才接受服务器响应的结果</span>
xhr<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
<span>// console.log(xhr.response);</span>
console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>response<span>)</span><span>;</span>
<span>}</span>
<span>}</span>
<span>&lt;</span><span>/</span>script<span>></span>
<span>&lt;</span><span>/</span>body<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><ol start="8">
<li>
<p>创建XHR对象的兼容方案；</p>
<ol>
<li>XMLHttpRequest 在老版本浏览器（IE5/6）中有兼容问题，可以通过另外一种方式代替。</li>
</ol>
</li>
</ol>
<div><pre><code><span>var</span> xhr <span>=</span> window<span>.</span>XMLHttpRequest <span>?</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span> <span>:</span> <span>new</span> <span>ActiveXObject</span><span>(</span><span>'Microsoft.XMLHTTP'</span><span>)</span>
<span>// xhr 的成员相同，即后续的open、send方法一样使用、onreadystatechange</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></blockquote>
<hr>
<h2 id="同步和异步"> 同步和异步;</h2>
<blockquote>
<ol>
<li>
<p><strong>异步操作;</strong></p>
<ul>
<li>
<p>异步指的是一段耗时的JS代码在执行时不会阻塞后续代码的执行。</p>
</li>
<li>
<p>异步操作的<strong>本质</strong>是同一个时间点，有多个操作同时执行了。</p>
</li>
</ul>
</li>
</ol>
<div><pre><code> <span>/</span>例：定时器为耗时代码，但是后面的代码也会一起执行；
 <span>// 执行一个输出</span>
 console<span>.</span><span>log</span><span>(</span><span>111</span><span>)</span><span>;</span>
 <span>// 一个耗时的定时器</span>
<span>setTimeout</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
 console<span>.</span><span>log</span><span>(</span><span>333</span><span>)</span><span>;</span>
 <span>}</span><span>,</span> <span>2000</span><span>)</span><span>;</span>
 <span>// 再执行一个输出</span>
 console<span>.</span><span>log</span><span>(</span><span>222</span><span>)</span><span>;</span>
 <span>//先输出111、然后输出222、最后输出333。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>Ajax其实也是一个耗时操作，因为从发送请求开始（调用send方法），直到<strong>完全</strong>接收到服务器响应的结果，这一过程肯定需要一定的时间。</li>
</ul>
<div><pre><code><span>// 执行一个输出</span>
console<span>.</span><span>log</span><span>(</span><span>111</span><span>)</span><span>;</span>
<span>// 中间是一个耗时的ajax请求</span>
<span>var</span> xhr <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span><span>;</span>
xhr<span>.</span><span>open</span><span>(</span><span>'GET'</span><span>,</span> <span>'/common/time'</span><span>)</span><span>;</span>
xhr<span>.</span><span>send</span><span>(</span><span>)</span><span>;</span>
xhr<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
console<span>.</span><span>log</span><span>(</span><span>333</span><span>)</span><span>;</span>
<span>}</span>
<span>// 再执行一个输出</span>
console<span>.</span><span>log</span><span>(</span><span>222</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ol>
<li><strong>同步操作;</strong></li>
</ol>
<ul>
<li>同步操作指的就是在同一个时间点只能执行一个操作;
<ul>
<li>Ajax请求，不但可以写成异步请求，也可以写成同步请求;</li>
</ul>
</li>
</ul>
<div><pre><code>
  <span>// 执行一个输出</span>
  console<span>.</span><span>log</span><span>(</span><span>111</span><span>)</span><span>;</span>
  <span>// 中间是一个耗时的ajax请求</span>
  <span>var</span> xhr <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span><span>;</span>
  xhr<span>.</span><span>open</span><span>(</span><span>'GET'</span><span>,</span> <span>'/common/time'</span><span>,</span> <span>false</span><span>)</span><span>;</span>
  <span>//onload事件放到了send之前了，否则onload事件也会被send阻塞</span>
  xhr<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>333</span><span>)</span><span>;</span>
  <span>}</span>
  xhr<span>.</span><span>send</span><span>(</span><span>)</span><span>;</span>
  <span>// 再执行一个输出</span>
  console<span>.</span><span>log</span><span>(</span><span>222</span><span>)</span><span>;</span>
  <span>//多了第三个参数`false`。 执行的结果是，先输出111、然后输出333、最后输出222.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></blockquote>
<hr>
<h2 id="封装ajax函数"> 封装ajax函数；</h2>
<blockquote>
<ol>
<li>为了简化ajax的使用，自己封装一个函数。</li>
</ol>
<div><pre><code><span>//封装一个函数;</span>
           <span>1.</span> 能够发送<span>GET</span>和<span>POST</span>方式的请求
           <span>2.</span> 发送请求的时候，可以给服务器传递参数
           <span>3.</span> 能够给不同的url发送请求
           <span>4.</span> 服务器返回的结果，应该由调用函数的人自行处理<span>;</span>
 <span>//封装；</span>
    <span>function</span> <span>ajax</span><span>(</span><span>type<span>,</span> url<span>,</span> data<span>,</span> cb</span><span>)</span> <span>{</span>
        <span>//创建ajax对象；</span>
        <span>var</span> xhr <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span><span>;</span>
        <span>//判断请求类型；</span>
        <span>if</span> <span>(</span>type <span>==</span> <span>'GET'</span><span>)</span> <span>{</span>
            url <span>=</span> url <span>+</span> <span>'?'</span> <span>+</span> data<span>;</span>
        <span>}</span>
        <span>//设置请求地址和请求参数；</span>
        xhr<span>.</span><span>open</span><span>(</span>type<span>,</span> url<span>)</span><span>;</span>
        <span>//定义空字符串；</span>
        <span>var</span> text <span>=</span> <span>''</span><span>;</span>
        <span>//判断请求类型；</span>
        <span>if</span> <span>(</span>type <span>==</span> <span>'POST'</span><span>)</span> <span>{</span>
            xhr<span>.</span><span>setRequestHeader</span><span>(</span><span>'content-type'</span><span>,</span> <span>'application/x-www-form-urlencoded'</span><span>)</span><span>;</span>
            text <span>+=</span> data<span>;</span>
        <span>}</span>
        <span>//发送请求；</span>
        xhr<span>.</span><span>send</span><span>(</span>text<span>)</span><span>;</span>
        <span>//注册事件；</span>
        xhr<span>.</span><span>onload</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
            <span>cb</span><span>(</span><span>this</span><span>.</span>response<span>)</span>
        <span>}</span>
    <span>}</span>
    <span>// ajax('GET', '/common/checkUser', 'username=早上好', function(callback) {</span>
    <span>//         console.log(callback)</span>
    <span>//     })</span>
    <span>ajax</span><span>(</span><span>'POST'</span><span>,</span> <span>'/message/addMsg'</span><span>,</span> <span>'name=下午好&amp;content=早上好'</span><span>,</span> <span>function</span><span>(</span><span>callback</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span>callback<span>)</span>
    <span>}</span><span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div></blockquote>
<hr>
<h2 id="formdata对象"> FormData对象;</h2>
<blockquote>
<ol>
<li>
<p>FormData是h5中新增的一个内置对象。</p>
<ul>
<li>FormData对象用以将数据编译成键值对，以便用<code>XMLHttpRequest</code>来发送数据。其主要用于发送表单数据，但亦可用于发送带键数据(keyed data)，而独立于表单使用。</li>
</ul>
</li>
<li>
<p>以前 AJAX 操作只能提交字符串，现在可以提交 <strong>二进制</strong> 的数据;</p>
<ol>
<li>
<p>使用方法一（有form表单）;</p>
<ul>
<li>使用FormData的时候，form表单中的各项必须有name属性。没有name属性是收集不到数据的;</li>
</ul>
</li>
</ol>
<div><pre><code><span>&lt;</span>form id<span>=</span><span>"fm"</span><span>></span>
    <span>&lt;</span>input type<span>=</span><span>"text"</span> name<span>=</span><span>"user"</span><span>></span><span>&lt;</span>br<span>></span>
    <span>&lt;</span>input type<span>=</span><span>"password"</span> name<span>=</span><span>"pwd"</span><span>></span><span>&lt;</span>br<span>></span>
    <span>&lt;</span>input type<span>=</span><span>"radio"</span> name<span>=</span><span>"sex"</span> value<span>=</span><span>"男"</span> checked<span>></span>男
<span>&lt;</span><span>/</span>form<span>></span>
<span>&lt;</span>script<span>></span>
    <span>// 当点击提交按钮的时候，需要把表单各项的值，提交给fd接口。</span>
        document<span>.</span><span>getElementById</span><span>(</span><span>'btn'</span><span>)</span><span>.</span><span>onclick</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
           
            <span>// FormData 专门用于收集表单各项值</span>
            <span>// 1. 有表单，找到表单</span>
            <span>var</span> form <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'fm'</span><span>)</span><span>;</span>
        
            <span>// 2. 实例化FormData，将表单的DOM对象传入即可</span>
            <span>var</span> fd <span>=</span> <span>new</span> <span>FormData</span><span>(</span>form<span>)</span><span>;</span> <span>// fd对象中包含了表单所有的值</span>

            <span>// 将各项值发送给fd接口</span>
            <span>var</span> xhr <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span><span>;</span>
            xhr<span>.</span><span>open</span><span>(</span><span>'POST'</span><span>,</span> <span>'/fd'</span><span>)</span><span>;</span>
            <span>// xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');</span>
            xhr<span>.</span>responseType <span>=</span> <span>'json'</span><span>;</span>
            xhr<span>.</span><span>send</span><span>(</span>fd<span>)</span><span>;</span>
            xhr<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>response<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
<span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><ol start="2">
<li>使用方法二（没有form表单）;</li>
</ol>
<div><pre><code><span>&lt;</span>input type<span>=</span><span>"text"</span> id<span>=</span><span>"user"</span><span>></span><span>&lt;</span>br<span>></span>
<span>&lt;</span>input type<span>=</span><span>"password"</span> id<span>=</span><span>"pwd"</span><span>></span><span>&lt;</span>br<span>></span>
<span>&lt;</span>input type<span>=</span><span>"file"</span> id<span>=</span><span>"pic"</span><span>></span><span>&lt;</span>br<span>/</span><span>></span>
<span>&lt;</span>input type<span>=</span><span>"button"</span> id<span>=</span><span>"btn"</span> value<span>=</span><span>"提交"</span><span>></span>
<span>&lt;</span>script<span>></span>
    <span>// 点击提交按钮的时候，把数据发送给fd接口</span>
        document<span>.</span><span>getElementById</span><span>(</span><span>'btn'</span><span>)</span><span>.</span><span>onclick</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    			<span>//如果是提交按钮则需要阻止默认行为；</span>
    			<span>//e.preventDefault()</span>
            <span>// 收集表单数据</span>
            <span>// 1. 先实例化FormData</span>
            <span>var</span> fd <span>=</span> <span>new</span> <span>FormData</span><span>(</span><span>)</span><span>;</span>
            <span>// 2. 调用FormData内置的方法append，向fd对象中，添加值</span>
            <span>// fd.append(key, value);</span>
            fd<span>.</span><span>append</span><span>(</span><span>'username'</span><span>,</span> document<span>.</span><span>getElementById</span><span>(</span><span>'user'</span><span>)</span><span>.</span>value<span>)</span><span>;</span>
            fd<span>.</span><span>append</span><span>(</span><span>'pwd'</span><span>,</span> document<span>.</span><span>getElementById</span><span>(</span><span>'pwd'</span><span>)</span><span>.</span>value<span>)</span><span>;</span>
            <span>// 如果是文件的话，必须使用文件对象</span>
            <span>var</span> file <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'pic'</span><span>)</span><span>;</span>
            <span>// console.dir(file);</span>
            <span>var</span> fileObj <span>=</span> file<span>.</span>files<span>[</span><span>0</span><span>]</span><span>;</span>
            <span>// fd.append('myfile', 文件对象);</span>
            fd<span>.</span><span>append</span><span>(</span><span>'myfile'</span><span>,</span> fileObj<span>)</span><span>;</span>

            <span>var</span> xhr <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span><span>;</span>
            xhr<span>.</span><span>open</span><span>(</span><span>'POST'</span><span>,</span> <span>'/fd'</span><span>)</span><span>;</span>
            xhr<span>.</span>responseType <span>=</span> <span>'json'</span><span>;</span>
            xhr<span>.</span><span>send</span><span>(</span>fd<span>)</span><span>;</span>
            xhr<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>response<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div></li>
</ol>
</script>
   ```
<ol start="3">
<li>jQuery中使用FormData：</li>
</ol>
<div><pre><code>	<span>&lt;</span>form id<span>=</span><span>"fm"</span><span>></span>
        <span>&lt;</span>input type<span>=</span><span>"text"</span> name<span>=</span><span>"user"</span><span>></span><span>&lt;</span>br<span>></span>
        <span>&lt;</span>input type<span>=</span><span>"password"</span> name<span>=</span><span>"pwd"</span><span>></span><span>&lt;</span>br<span>></span>
        <span>&lt;</span>input type<span>=</span><span>"radio"</span> name<span>=</span><span>"sex"</span> value<span>=</span><span>"男"</span> checked<span>></span>男
        <span>&lt;</span>input type<span>=</span><span>"radio"</span> name<span>=</span><span>"sex"</span> value<span>=</span><span>"女"</span><span>></span>女<span>&lt;</span>br<span>></span>
        <span>&lt;</span>input type<span>=</span><span>"file"</span> name<span>=</span><span>"pic"</span><span>></span><span>&lt;</span>br <span>/</span><span>></span>
        <span>&lt;</span>input type<span>=</span><span>"button"</span> id<span>=</span><span>"btn"</span> value<span>=</span><span>"提交"</span><span>></span>
    <span>&lt;</span><span>/</span>form<span>></span>

    <span>&lt;</span>script src<span>=</span><span>"/jquery.js"</span><span>></span><span>&lt;</span><span>/</span>script<span>></span>
    <span>&lt;</span>script<span>></span>

        <span>$</span><span>(</span><span>'#btn'</span><span>)</span><span>.</span><span>click</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
            <span>var</span> fm <span>=</span> <span>$</span><span>(</span><span>'#fm'</span><span>)</span><span>;</span>
            <span>var</span> fd <span>=</span> <span>new</span> <span>FormData</span><span>(</span>fm<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span> <span>// 这里fm必须是DOM对象</span>
            console<span>.</span><span>log</span><span>(</span>fd<span>)</span><span>;</span>

            $<span>.</span><span>ajax</span><span>(</span><span>{</span>
                type<span>:</span> <span>'post'</span><span>,</span>
                url<span>:</span> <span>'/fd'</span><span>,</span>

                <span>// 如果data使用的是对象，ajax方法会把对象转成字符串，</span>
                <span>// 即把{name: 'zs', age: 18}转成name=zs&amp;age=18</span>
                <span>// data: {name: 'zs', age: 18}, </span>
                data<span>:</span> fd<span>,</span>
                <span>// processData: false, 表示不让jQuery把fd对象转成字符串，而是直接发送fd对象</span>
                processData<span>:</span> <span>false</span><span>,</span>
                <span>// contentType：false，表示不让jQuery去设置content-type，让FormData去处理</span>
                contentType<span>:</span> <span>false</span><span>,</span>
                <span>success</span><span>:</span> <span>function</span> <span>(</span><span>res</span><span>)</span> <span>{</span>
                    console<span>.</span><span>log</span><span>(</span>res<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>

        <span>// xhr.send('name=zs&amp;age=18');</span>
 <span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><ol start="4">
<li>
<p>参考链接：</p>
<ul>
<li>https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects</li>
</ul>
</li>
</ol>
</blockquote>
<hr>
<h2 id="模板引擎"> 模板引擎;</h2>
<blockquote>
<ol>
<li>
<p>模板引擎: artTemplate：https://aui.github.io/art-template/;</p>
</li>
<li>
<p>模板引擎实际上就是一个 API，模板引擎有很多种，使用方式大同小异。</p>
</li>
<li>
<p>目的为了可以更容易更高效的将数据渲染到HTML字符串中。==通俗的说，模板引擎的目的就是将服务器返回的数据显示到HTML页面中==。</p>
</li>
<li>
<p><strong>使用模板引擎步骤</strong>；</p>
<ol>
<li>
<p>准备一个存放数据的盒子；（不是必须的，使用body也可以）</p>
</li>
<li>
<p>引入template-web.js文件；</p>
</li>
<li>
<p>定义模板，一定要指定script的id和type属性；</p>
</li>
<li>
<p>调用template函数，为模板分配数据，template函数有两个参数一个返回值；</p>
<ul>
<li>参数1：模板的id。</li>
<li>参数2：分配的数据，必须是一个JS对象的形式。</li>
<li>一个返回值：是数据和模板标签组合好的结果。</li>
</ul>
</li>
<li>
<p>将 “拼接” 好的结果放到准备好的盒子中（不是必须的，console出来也可以看结果）；</p>
</li>
</ol>
<p><img src="./assets/1566443384929.png" alt="1566443384929" /></p>
</li>
</ol>
<div><pre><code> <span>&lt;</span><span>!</span><span>--</span> 使用模板引擎<span>-</span><span>1.</span>加载js文件 <span>--</span><span>></span>
 <span>&lt;</span>script src<span>=</span><span>"./assets/template-web.js"</span><span>></span><span>&lt;</span><span>/</span>script<span>></span>
 <span>&lt;</span><span>!</span><span>--</span> 使用模板引擎<span>-</span><span>2.</span>设置模板 <span>--</span><span>></span>
 <span>&lt;</span>script id<span>=</span><span>"test"</span> type<span>=</span><span>"text/html"</span><span>></span>
         <span>&lt;</span>h1<span>></span><span>{</span><span>{</span>title<span>}</span><span>}</span><span>&lt;</span><span>/</span>h1<span>></span>
 <span>&lt;</span><span>/</span>script<span>></span>
 
 <span>&lt;</span>script<span>></span>
     <span>// 使用模板引擎-3.调用template函数</span>
     <span>// var 模板和数据组合好的结果 = template(模板id, 模板中使用的数据必须是js对象类型);</span>
     <span>var</span> data <span>=</span> <span>{</span>
         title<span>:</span> <span>'这是模板引擎的例子'</span>
     <span>}</span><span>;</span>
     <span>// “拼接”</span>
     <span>// 调用插件提供的方法template。将数据和模板组合起来。</span>
     <span>var</span> html <span>=</span> <span>template</span><span>(</span><span>'test'</span><span>,</span> data<span>)</span><span>;</span>
     console<span>.</span><span>log</span><span>(</span>html<span>)</span><span>;</span>
     <span>/*
         &lt;h1>这是模板引擎的例子&lt;/h1>
         */</span>
     document<span>.</span>body<span>.</span>innerHTML <span>=</span> html<span>;</span>
 
 <span>&lt;</span><span>/</span>script<span>></span>
 tempalte函数语法：<span>var</span> html <span>=</span> <span>template</span><span>(</span>模板id<span>,</span>  Object<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><blockquote>
<p>注：定义模板时的script标签一定好指定id和type；</p>
</blockquote>
</blockquote>
<h3 id="模板语法"> 模板语法</h3>
<ul>
<li>
<p>输出普通数据（字符串、数值等）</p>
<div><pre><code>// 模板写法
{{var}}

// template函数写法
var html = template(&#39;id&#39;, {
    var: &#39;hello world&#39;
});
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>条件</p>
<div><pre><code><span>// 模板写法</span>
<span>{</span><span>{</span><span>if</span> age <span>></span> <span>18</span><span>}</span><span>}</span>
	大于<span>18</span>
<span>{</span><span>{</span><span>else</span><span>}</span><span>}</span>
	小于<span>18</span>
<span>{</span><span>{</span><span>/</span><span>if</span><span>}</span><span>}</span>

<span>// template函数写法</span>
<span>var</span> html <span>=</span> <span>template</span><span>(</span><span>'id'</span><span>,</span> <span>{</span>
    age<span>:</span> <span>20</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
<li>
<p>循环</p>
<div><pre><code><span>// 模板写法</span>
<span>{</span><span>{</span>each arr<span>}</span><span>}</span>
	<span>{</span><span>{</span>$index<span>}</span><span>}</span> <span>--</span> 数组的下标
	<span>{</span><span>{</span>$value<span>}</span><span>}</span> <span>--</span> 数组的值
<span>{</span><span>{</span><span>/</span>each<span>}</span><span>}</span>

<span>// template函数写法</span>
<span>var</span> html <span>=</span> <span>template</span><span>(</span><span>'id'</span><span>,</span> <span>{</span>
    arr<span>:</span> <span>[</span><span>'apple'</span><span>,</span> <span>'banana'</span><span>,</span> <span>'orange'</span><span>]</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
</ul>
<p>完整的代码：</p>
<div><pre><code><span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>./assets/template-web.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

    <span>&lt;!-- 1. 定义模板 --></span>
    <span><span><span>&lt;</span>script</span> <span>id</span><span><span>=</span><span>"</span>abc<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>text/html<span>"</span></span><span>></span></span><span><span>
        <span>&lt;</span>h1<span>></span><span>{</span><span>{</span>name<span>}</span><span>}</span><span>&lt;</span><span>/</span>h1<span>></span>
        <span>&lt;</span>p<span>></span>我是<span>{</span><span>{</span>nickname<span>}</span><span>}</span>，我有一辆<span>{</span><span>{</span>car<span>}</span><span>}</span>，我今年<span>{</span><span>{</span>age<span>}</span><span>}</span>岁了<span>&lt;</span><span>/</span>p<span>></span>
        <span>{</span><span>{</span><span>if</span> age <span>>=</span> <span>18</span><span>}</span><span>}</span>
            <span>&lt;</span>p<span>></span>欢迎来玩<span>~</span><span>&lt;</span><span>/</span>p<span>></span>
        <span>{</span><span>{</span><span>else</span><span>}</span><span>}</span>
            <span>&lt;</span>p<span>></span>未成年人禁止进入<span>&lt;</span><span>/</span>p<span>></span>
        <span>{</span><span>{</span><span>/</span><span>if</span><span>}</span><span>}</span>
        <span>&lt;</span>p<span>></span>我有好几个女朋友，分别是：<span>&lt;</span><span>/</span>p<span>></span>
        <span>&lt;</span>ul<span>></span>
            <span>{</span><span>{</span>each girls<span>}</span><span>}</span>
            <span>&lt;</span>li<span>></span><span>{</span><span>{</span>$index<span>}</span><span>}</span> <span>--</span> <span>{</span><span>{</span>$value<span>}</span><span>}</span><span>&lt;</span><span>/</span>li<span>></span>
            <span>{</span><span>{</span><span>/</span>each<span>}</span><span>}</span>
        <span>&lt;</span><span>/</span>ul<span>></span>
    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>


    <span><span><span>&lt;</span>script</span><span>></span></span><span><span>
        <span>// 2. 调用template函数</span>
        <span>var</span> str <span>=</span> <span>template</span><span>(</span><span>'abc'</span><span>,</span> <span>{</span>
            name<span>:</span> <span>'狗哥'</span><span>,</span>
            nickname<span>:</span> <span>'北狗最光阴'</span><span>,</span>
            car<span>:</span> <span>'宝马'</span><span>,</span>
            age<span>:</span> <span>31</span><span>,</span>
            girls<span>:</span> <span>[</span><span>'王婆'</span><span>,</span> <span>'金莲'</span><span>,</span> <span>'西门大官人'</span><span>,</span> <span>'李师师'</span><span>,</span> <span>'赛金花'</span><span>]</span>
        <span>}</span><span>)</span><span>;</span>

        console<span>.</span><span>log</span><span>(</span>str<span>)</span><span>;</span>
        document<span>.</span>body<span>.</span>innerHTML <span>=</span> str<span>;</span>
    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h3 id="案例中使用模板引擎处理响应数据"> 案例中使用模板引擎处理响应数据</h3>
<div><pre><code><span>&lt;!-- 引入template-web.js --></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>./assets/template-web.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

<span>&lt;!-- 定义模板 --></span>
<span><span><span>&lt;</span>script</span> <span>id</span><span><span>=</span><span>"</span>moban<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>text/html<span>"</span></span><span>></span></span><span><span>
    <span>{</span><span>{</span>each girls<span>}</span><span>}</span>
    <span>&lt;</span>li <span>class</span><span>=</span><span>"media"</span><span>></span>
      <span>&lt;</span>img <span>class</span><span>=</span><span>"mr-3"</span> src<span>=</span><span>"avatar.png"</span> alt<span>=</span><span>""</span><span>></span>
      <span>&lt;</span>div <span>class</span><span>=</span><span>"media-body"</span><span>></span>
        <span>&lt;</span>h4<span>></span><span>{</span><span>{</span>$value<span>.</span>name<span>}</span><span>}</span><span>&lt;</span><span>/</span>h4<span>></span>
        <span>&lt;</span>p<span>></span><span>{</span><span>{</span>$value<span>.</span>content<span>}</span><span>}</span><span>&lt;</span><span>/</span>p<span>></span>
    <span>&lt;</span><span>/</span>div<span>></span>
    <span>&lt;</span><span>/</span>li<span>></span>
    <span>{</span><span>{</span><span>/</span>each<span>}</span><span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code>xhr<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>// console.log(this.response);</span>
    <span>var</span> data <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>this</span><span>.</span>response<span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>data<span>)</span><span>;</span>
    <span>// 拼接字符串</span>
    <span>var</span> str <span>=</span> <span>template</span><span>(</span><span>'moban'</span><span>,</span> <span>{</span>
        girls<span>:</span> data
    <span>}</span><span>)</span><span>;</span>
    <span>// 把变量后，拼接好的str放到 id为 messages 的ul中</span>
    document<span>.</span><span>getElementById</span><span>(</span><span>'messages'</span><span>)</span><span>.</span>innerHTML <span>=</span> str<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/frontEnd/css/</link>
      <guid>https://wangyawei.top/views/frontEnd/css/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>CSS</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些和css相关的知识点；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>css基础</title>
      <link>https://wangyawei.top/views/frontEnd/css/css-note-00/</link>
      <guid>https://wangyawei.top/views/frontEnd/css/css-note-00/</guid>
      <source url="https://wangyawei.top/rss.xml">css基础</source>
      <category>CSS</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<p>三种样式表总结（位置）</p>
<table>
<thead>
<tr>
<th>样式表</th>
<th>优点</th>
<th>缺点</th>
<th>使用情况</th>
<th>控制范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>行内样式表</td>
<td>书写方便，权重高</td>
<td>没有实现样式和结构相分离</td>
<td>较少</td>
<td>控制一个标签（少）</td>
</tr>
<tr>
<td>内部样式表</td>
<td>部分结构和样式相分离</td>
<td>没有彻底分离</td>
<td>较多</td>
<td>控制一个页面（中）</td>
</tr>
<tr>
<td>外部样式表</td>
<td>完全实现结构和样式相分离</td>
<td>需要引入</td>
<td>最多，强烈推荐</td>
<td>控制整个站点（多）</td>
</tr>
</tbody>
</table>
<h2 id="font-family-字体"> font-family:字体</h2>
<p>font-family属性用于设置字体。网页中常用的字体有宋体、微软雅黑、黑体等，</p>
<p>p{ font-family:&quot;微软雅黑&quot;;}</p>
<p>可以同时指定多个字体，中间以逗号隔开，表示如果浏览器不支持第一个字体，则会尝试下一个，直到找到合适的字体。</p>
<div><pre><code>1. 现在网页中普遍使用14px+。
2. 尽量使用偶数的数字字号。ie6等老式浏览器支持奇数会有bug。
3. 各种字体之间必须使用英文状态下的逗号隔开。
4. 中文字体需要加英文状态下的引号，英文字体一般不需要加引号。当需要设置英文字体时，英文字体名必须位于中文字体名之前。
5. 如果字体名中包含空格、#、$等符号，则该字体必须加英文状态下的单引号或双引号，例如font-family: &quot;Times New Roman&quot;;。
6. 尽量使用系统默认字体，保证在任何用户的浏览器中都能正确显示。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="css-unicode字体"> CSS Unicode字体</h2>
<p>在 CSS 中设置字体名称，直接写中文是可以的。但是在文件编码（GB2312、UTF-8 等）不匹配时会产生乱码的错误。xp 系统不支持 类似微软雅黑的中文。</p>
<p>方案一： 你可以使用英文来替代。 比如 font-family:&quot;Microsoft Yahei&quot;。</p>
<p>方案二： 在 CSS 直接使用 Unicode 编码来写字体c名称可以避免这些错误。使用 Unicode 写中文字体名称，浏览器是可以正确的解析的。
font-family: &quot;\5FAE\8F6F\96C5\9ED1&quot;，表示设置字体为“微软雅黑”。</p>
<p>可以通过escape()  来测试属于什么字体。</p>
<table>
<thead>
<tr>
<th>字体名称</th>
<th>英文名称</th>
<th>Unicode 编码</th>
</tr>
</thead>
<tbody>
<tr>
<td>宋体</td>
<td>SimSun</td>
<td>\5B8B\4F53</td>
</tr>
<tr>
<td>新宋体</td>
<td>NSimSun</td>
<td>\65B0\5B8B\4F53</td>
</tr>
<tr>
<td>黑体</td>
<td>SimHei</td>
<td>\9ED1\4F53</td>
</tr>
<tr>
<td>微软雅黑</td>
<td>Microsoft YaHei</td>
<td>\5FAE\8F6F\96C5\9ED1</td>
</tr>
<tr>
<td>楷体_GB2312</td>
<td>KaiTi_GB2312</td>
<td>\6977\4F53_GB2312</td>
</tr>
<tr>
<td>隶书</td>
<td>LiSu</td>
<td>\96B6\4E66</td>
</tr>
<tr>
<td>幼园</td>
<td>YouYuan</td>
<td>\5E7C\5706</td>
</tr>
<tr>
<td>华文细黑</td>
<td>STXihei</td>
<td>\534E\6587\7EC6\9ED1</td>
</tr>
<tr>
<td>细明体</td>
<td>MingLiU</td>
<td>\7EC6\660E\4F53</td>
</tr>
<tr>
<td>新细明体</td>
<td>PMingLiU</td>
<td>\65B0\7EC6\660E\4F53</td>
</tr>
</tbody>
</table>
<p>为了照顾不同电脑的字体安装问题，我们尽量只使用宋体和微软雅黑中文字体</p>
<h2 id="font-weight-字体粗细"> font-weight:字体粗细</h2>
<div><pre><code>font-weight属性用于定义字体的粗细，其可用属性值：normal、bold、bolder、lighter、100~900（100的整数倍）。
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>数字 400 等价于 normal，而 700 等价于 bold。  但是我们更喜欢用数字来表示。</p>
</blockquote>
<h2 id="font-style-字体风格"> font-style:字体风格</h2>
<p>字体倾斜除了用 i  和 em 标签之外，可以使用CSS 来实现，但是CSS 是没有语义的。</p>
<p>font-style属性用于定义字体风格，如设置斜体、倾斜或正常字体，其可用属性值如下：</p>
<p>normal：默认值，浏览器会显示标准的字体样式。</p>
<p>italic：浏览器会显示斜体的字体样式。</p>
<p>oblique：浏览器会显示倾斜的字体样式。</p>
<h2 id="font-综合设置字体样式-重点"> font:综合设置字体样式 (重点)</h2>
<p>font属性用于对字体样式进行综合设置，其基本语法格式如下：</p>
<div><pre><code><span>选择器</span><span>{</span><span>font</span><span>:</span> font-style  font-weight  font-size/line-height  font-family<span>;</span><span>}</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code>使用font属性时，必须按上面语法格式中的顺序书写，不能更换顺序，各个属性以空格隔开。

注意：其中不需要设置的属性可以省略（取默认值），但必须保留font-size和font-family属性，否则font属性将不起作用。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="color-文本颜色"> color:文本颜色</h2>
<p>color属性用于定义文本的颜色，其取值方式有如下3种：</p>
<p>1.预定义的颜色值，如red，green，blue等。</p>
<p>2.十六进制，如#FF0000，#FF6600，#29D794等。实际工作中，十六进制是最常用的定义颜色的方式。</p>
<p>3.RGB代码，如红色可以表示为rgb(255,0,0)或rgb(100%,0%,0%)。</p>
<p>需要注意的是，如果使用RGB代码的百分比颜色值，取值为0时也不能省略百分号，必须写为0%。</p>
<h2 id="line-height-行间距"> line-height:行间距</h2>
<p>ine-height属性用于设置行间距，就是行与行之间的距离，即字符的垂直间距，一般称为行高。line-height常用的属性值单位有三种，分别为像素px，相对值em和百分比%</p>
<p>一般情况下，行距比字号大7.8像素左右就可以了。</p>
<h2 id="text-align-水平对齐方式"> text-align:水平对齐方式</h2>
<div><pre><code>text-align属性用于设置文本内容的水平对齐，相当于html中的align对齐属性。其可用属性值如下：
</code></pre>
<div><span>1</span><br></div></div><p>left：左对齐（默认值）</p>
<p>right：右对齐</p>
<p>center：居中对齐</p>
<p>是让盒子里面的内容水平居中， 而不是让盒子居中对齐</p>
<h2 id="text-indent-首行缩进"> text-indent:首行缩进</h2>
<p>text-indent属性用于设置首行文本的缩进，其属性值可为不同单位的数值、em字符宽度的倍数、或相对于浏览器窗口宽度的百分比%，允许使用负值, 建议使用em作为设置单位。</p>
<p>1em 就是一个字的宽度   如果是汉字的段落， 1em 就是一个汉字的宽度</p>
<h2 id="text-decoration-文本的装饰"> text-decoration 文本的装饰</h2>
<p>text-decoration   通常我们用于给链接修改装饰效果</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>none</td>
<td>默认。定义标准的文本。</td>
</tr>
<tr>
<td>underline</td>
<td>定义文本下的一条线。下划线 也是我们链接自带的</td>
</tr>
<tr>
<td>overline</td>
<td>定义文本上的一条线。</td>
</tr>
<tr>
<td>line-through</td>
<td>定义穿过文本下的一条线。</td>
</tr>
</tbody>
</table>
<h2 id="伪类选择器"> 伪类选择器</h2>
<p>伪类选择器用于向某些选择器添加特殊的效果。比如给链接添加特殊效果， 比如可以选择 第1个，第n个元素。</p>
<p>类  .one</p>
<p>伪类 :link</p>
<div><pre><code><span>为了和我们刚才学的类选择器相区别，  类选择器是一个点 比如 .demo</span> <span>{</span><span>}</span>   <span>而我们的伪类 用 2个点 就是 冒号  比如  :link</span><span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="链接伪类选择器"> 链接伪类选择器</h3>
<ul>
<li>
<p>:link      /* 未访问的链接 */</p>
</li>
<li>
<p>:visited   /* 已访问的链接 */</p>
</li>
<li>
<p>:hover     /* 鼠标移动到链接上 */</p>
</li>
<li>
<p>:active    /* 选定的链接 */</p>
<p>注意写的时候，他们的顺序尽量不要颠倒  按照  lvha 的顺序。   love   hate  爱上了讨厌 记忆法    或者   lv 包包 非常 hao</p>
</li>
</ul>
<div><pre><code><span>a</span> <span>{</span>   <span>/* a是标签选择器  所有的链接 */</span>
			<span>font-weight</span><span>:</span> 700<span>;</span>
			<span>font-size</span><span>:</span> 16px<span>;</span>
			<span>color</span><span>:</span> gray<span>;</span>
		<span>}</span>
<span>a:hover</span> <span>{</span>   <span>/* :hover 是链接伪类选择器 鼠标经过 */</span>
			<span>color</span><span>:</span> red<span>;</span> <span>/*  鼠标经过的时候，由原来的 灰色 变成了红色 */</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="块级元素"> 块级元素</h2>
<p>每个块元素通常都会独自占据一整行或多整行，可以对其设置宽度、高度、对齐等属性，常用于网页布局和网页结构的搭建。 霸道</p>
<div><pre><code>常见的块元素有&lt;h1&gt;~&lt;h6&gt;、&lt;p&gt;、&lt;div&gt;、&lt;ul&gt;、&lt;ol&gt;、&lt;li&gt;等，其中&lt;div&gt;标签是最典型的块元素。
</code></pre>
<div><span>1</span><br></div></div><p>块级元素的特点：</p>
<p>（1）总是从新行开始</p>
<p>（2）高度，行高、外边距以及内边距都可以控制。</p>
<p>（3）宽度默认是容器的100%</p>
<p>（4）可以容纳内联元素和其他块元素。</p>
<h2 id="行内元素"> 行内元素;</h2>
<p>行内元素（内联元素）不占有独立的区域，仅仅靠自身的字体大小和图像尺寸来支撑结构，一般不可以设置宽度、高度、对齐等属性，常用于控制页面中文本的样式。</p>
<div><pre><code>常见的行内元素有&lt;a&gt;、&lt;strong&gt;、&lt;b&gt;、&lt;em&gt;、&lt;i&gt;、&lt;del&gt;、&lt;s&gt;、&lt;ins&gt;、&lt;u&gt;、&lt;span&gt;等，其中&lt;span&gt;标签最典型的行内元素。
</code></pre>
<div><span>1</span><br></div></div><p>行内元素的特点：</p>
<p>（1）和相邻行内元素在一行上。</p>
<p>（2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。</p>
<p>（3）默认宽度就是它本身内容的宽度。</p>
<p>（4）行内元素只能容纳文本或则其他行内元素。（a特殊）</p>
<p>​      注意：</p>
<ol>
<li>只有 文字才 能组成段落  因此 p  里面不能放块级元素，同理还有这些标签h1,h2,h3,h4,h5,h6,dt，他们都是文字类块级标签，里面不能放其他块级元素。</li>
<li>链接里面不能再放链接。</li>
</ol>
<h2 id="块级元素和行内元素区别"> 块级元素和行内元素区别</h2>
<div><pre><code>块级元素的特点：
（1）总是从新行开始
（2）高度，行高、外边距以及内边距都可以控制。
（3）宽度默认是容器的100%
（4）可以容纳内联元素和其他块元素。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>行内元素的特点：
（1）和相邻行内元素在一行上。
（2）高、宽无效，但水平方向的padding和margin可以设置，垂直方向的无效。
（3）默认宽度就是它本身内容的宽度。
（4）行内元素只能容纳文本或则其他行内元素。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="行内块元素-inline-block"> 行内块元素（inline-block）</h2>
<div><pre><code>在行内元素中有几个特殊的标签——&lt;img /&gt;、&lt;input /&gt;、&lt;td&gt;，可以对它们设置宽高和对齐属性，有些资料可能会称它们为行内块元素。

行内块元素的特点：
（1）和相邻行内元素（行内块）在一行上,但是之间会有空白缝隙。
（2）默认宽度就是它本身内容的宽度。
（3）高度，行高、外边距以及内边距都可以控制。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="标签显示模式转换-display"> 标签显示模式转换 display</h2>
<p>块转行内：display:inline;</p>
<p>行内转块：display:block;</p>
<p>块、行内元素转换为行内块： display: inline-block;</p>
<h2 id="css-三大特性"> CSS 三大特性</h2>
<h3 id="css层叠性"> CSS层叠性</h3>
<p>所谓层叠性是指多种CSS样式的叠加。</p>
<p>是浏览器处理冲突的一个能力,如果一个属性通过两个相同选择器设置到同一个元素上，那么这个时候一个属性就会将另一个属性层叠掉</p>
<p>比如先给某个标签指定了内部文字颜色为红色，接着又指定了颜色为蓝色，此时出现一个标签指定了相同样式不同值的情况，这就是样式冲突。</p>
<p>一般情况下，如果出现样式冲突，则会按照CSS书写的顺序，以最后的样式为准。</p>
<ol>
<li>样式冲突，遵循的原则是就近原则。 那个样式离着结构近，就执行那个样式。</li>
<li>样式不冲突，不会层叠</li>
</ol>
<h3 id="css继承性"> CSS继承性</h3>
<p>所谓继承性是指书写CSS样式表时，子标签会继承父标签的某些样式，如文本颜色和字号。想要设置一个可继承的属性，只需将它应用于父元素即可。</p>
<blockquote>
<p>恰当地使用继承可以简化代码，降低CSS样式的复杂性。子元素可以继承父元素的样式（text-，font-，line-这些元素开头的都可以继承，以及color属性）；
a标签自带颜色，color不会被继承，需要单独设置；</p>
</blockquote>
<h2 id="css优先级"> CSS优先级</h2>
<p>定义CSS样式时，经常出现两个或更多规则应用在同一元素上，这时就会出现优先级的问题。</p>
<p>在考虑权重时，初学者还需要注意一些特殊的情况，具体如下：</p>
<div><pre><code>继承样式的权重为0。即在嵌套结构中，不管父元素样式的权重多大，被子元素继承时，他的权重都为0，也就是说子元素定义的样式会覆盖继承来的样式。

行内样式优先。应用style属性的元素，其行内样式的权重非常高，可以理解为远大于100。总之，他拥有比上面提高的选择器都大的优先级。

权重相同时，CSS遵循就近原则。也就是说靠近元素的样式具有最大的优先级，或者说排在最后的样式优先级最大。

CSS定义了一个!important命令，该命令被赋予最大的优先级。也就是说不管权重如何以及样式位置的远近，!important都具有最大优先级。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="css特殊性-specificity"> CSS特殊性（Specificity）</h3>
<p>关于CSS权重，我们需要一套计算公式来去计算，这个就是 CSS Specificity，我们称为CSS 特性或称非凡性，它是一个衡量CSS值优先级的一个标准 具体规范入如下：</p>
<p>specificity用一个四位的数 字串(CSS2是三位)来表示，更像四个级别，值从左到右，左面的最大，一级大于一级，数位之间没有进制，级别之间不可超越。</p>
<table>
<thead>
<tr>
<th>继承或者* 的贡献值</th>
<th>0,0,0,0</th>
</tr>
</thead>
<tbody>
<tr>
<td>每个元素（标签）贡献值为</td>
<td>0,0,0,1</td>
</tr>
<tr>
<td>每个类，伪类贡献值为</td>
<td>0,0,1,0</td>
</tr>
<tr>
<td>每个ID贡献值为</td>
<td>0,1,0,0</td>
</tr>
<tr>
<td>每个行内样式贡献值</td>
<td>1,0,0,0</td>
</tr>
<tr>
<td>每个!important贡献值</td>
<td>∞ 无穷大</td>
</tr>
</tbody>
</table>
<p>权重是可以叠加的</p>
<p>比如的例子：</p>
<div><pre><code>div ul  li   ------&gt;      0,0,0,3

.nav ul li   ------&gt;      0,0,1,2

a:hover      -----—&gt;      0,0,1,1

.nav a       ------&gt;      0,0,1,1   

#nav p       -----&gt;       0,1,0,1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>1.数位之间没有进制 比如说： 0,0,0,5 + 0,0,0,5 =0,0,0,10 而不是 0,0, 1, 0， 所以不会存在10个div能赶上一个类选择器的情况。</p>
<ol>
<li>继承的 权重是 0</li>
</ol>
<p>总结优先级：</p>
<ol>
<li>使用了 !important声明的规则。</li>
<li>内嵌在 HTML 元素的 style属性里面的声明。</li>
<li>使用了 ID 选择器的规则。</li>
<li>使用了类选择器、属性选择器、伪元素和伪类选择器的规则。</li>
<li>使用了元素选择器的规则。</li>
<li>只包含一个通用选择器的规则。</li>
<li>同一类选择器则遵循就近原则。</li>
</ol>
<div><pre><code>总结：权重是优先级的算法，层叠是优先级的表现
</code></pre>
<div><span>1</span><br></div></div><h2 id="css-背景-background"> CSS 背景(background)</h2>
<p>CSS 可以添加背景颜色和背景图片，以及来进行图片设置。</p>
<table>
<thead>
<tr>
<th>background-color</th>
<th>背景颜色</th>
</tr>
</thead>
<tbody>
<tr>
<td>background-image</td>
<td>背景图片地址</td>
</tr>
<tr>
<td>background-repeat</td>
<td>是否平铺</td>
</tr>
<tr>
<td>background-position</td>
<td>背景位置</td>
</tr>
<tr>
<td>background-attachment</td>
<td>背景固定还是滚动</td>
</tr>
<tr>
<td>背景的合写（复合属性）</td>
<td></td>
</tr>
<tr>
<td>background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置</td>
<td></td>
</tr>
</tbody>
</table>
<h2 id="背景图片-image"> 背景图片(image)</h2>
<p>语法：</p>
<div><pre><code><span>background-image</span> <span>:</span> none | url <span>(</span>url<span>)</span> 
</code></pre>
<div><span>1</span><br></div></div><p>参数：</p>
<p>none : 　无背景图（默认的）
url : 　使用绝对或相对地址指定背景图像</p>
<p>background-image 属性允许指定一个图片展示在背景中（只有CSS3才可以多背景）可以和 background-color 连用。 如果图片不重复地话，图片覆盖不到地地方都会被背景色填充。 如果有背景图片平铺，则会覆盖背景颜色。</p>
<p>小技巧：  我们提倡 背景图片后面的地址，url不要加引号。</p>
<h2 id="背景平铺-repeat"> 背景平铺（repeat）</h2>
<p>语法：</p>
<div><pre><code><span>background-repeat</span> <span>:</span> repeat | no-repeat | repeat-x | repeat-y 
</code></pre>
<div><span>1</span><br></div></div><p>参数：</p>
<p>repeat : 　背景图像在纵向和横向上平铺（默认的）</p>
<p>no-repeat : 　背景图像不平铺</p>
<p>repeat-x : 　背景图像在横向上平铺</p>
<p>repeat-y : 　背景图像在纵向平铺</p>
<p>设置背景图片时，默认把图片在水平和垂直方向平铺以铺满整个元素。</p>
<p>repeat-x : 　背景图像在横向上平铺</p>
<p>repeat-y : 　背景图像在纵向平铺</p>
<p>设置背景图片时，默认把图片在水平和垂直方向平铺以铺满整个元素</p>
<h2 id="背景位置-position"> 背景位置(position)</h2>
<p>语法：</p>
<div><pre><code><span>background-position</span> <span>:</span> length || length

<span>background-position</span> <span>:</span> position || position 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>参数：</p>
<p>length : 　百分数 | 由浮点数字和单位标识符组成的长度值。请参阅长度单位
position : 　top | center | bottom | left | center | right</p>
<p>说明：</p>
<p>设置或检索对象的背景图像位置。必须先指定background-image属性。默认值为：(0% 0%)。
如果只指定了一个值，该值将用于横坐标。纵坐标将默认为50%。第二个值将用于纵坐标。</p>
<p>注意：</p>
<ol>
<li>position 后面是x坐标和y坐标。 可以使用方位名词或者 精确单位。</li>
<li>如果和精确单位和方位名字混合使用，则必须是x坐标在前，y坐标后面。比如 background-position: 15px top;   则 15px 一定是  x坐标   top是 y坐标。</li>
</ol>
<p>实际工作用的最多的，就是背景图片居中对齐了。</p>
<h2 id="背景附着"> 背景附着</h2>
<p>语法：</p>
<div><pre><code><span>background-attachment</span> <span>:</span> scroll | fixed 
</code></pre>
<div><span>1</span><br></div></div><p>参数：</p>
<p>scroll : 　背景图像是随对象内容滚动
fixed : 　背景图像固定</p>
<p>说明：</p>
<p>设置或检索背景图像是随对象内容滚动还是固定的。</p>
<h2 id="背景简写"> 背景简写</h2>
<p>background属性的值的书写顺序官方并没有强制标准的。为了可读性，建议大家如下写：</p>
<p>background:背景颜色 背景图片地址 背景平铺 背景滚动 背景位置</p>
<div><pre><code><span>background</span><span>:</span> transparent <span><span>url</span><span>(</span>image.jpg<span>)</span></span> repeat-y  scroll 50% 0 <span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="背景透明-css3"> 背景透明(CSS3)</h2>
<p>CSS3支持背景半透明的写法语法格式是:</p>
<div><pre><code><span>background</span><span>:</span> <span>rgba</span><span>(</span>0<span>,</span>0<span>,</span>0<span>,</span>0.3<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>最后一个参数是alpha 透明度  取值范围 0~1之间</p>
<p>注意：  背景半透明是指盒子背景半透明， 盒子里面的内容不收影响。</p>
<h2 id="盒子模型"> 盒子模型</h2>
<p>其实，CSS就三个大模块：  盒子模型 、 浮动 、 定位，其余的都是细节。</p>
<p>所谓盒子模型就是把HTML页面中的元素看作是一个矩形的盒子，也就是一个盛装内容的容器。每个矩形都由元素的内容、内边距（padding）、边框（border）和外边距（margin）组成。</p>
<h2 id="盒子模型-box-model"> 盒子模型（Box Model）</h2>
<p>这里略过 老旧的ie盒子模型（IE6以下），对不起，我都没见过IE5的浏览器。</p>
<p>所有的文档元素（标签）都会生成一个矩形框，我们成为元素框（element box），它描述了一个文档元素再网页布局汇总所占的位置大小。因此，每个盒子除了有自己大小和位置外，还影响着其他盒子的大小和位置。</p>
<h2 id="盒子边框-border"> 盒子边框（border）</h2>
<p>边框就是那层皮。  橘子皮。。柚子皮。。橙子皮。。。</p>
<p>语法：</p>
<div><pre><code><span>border</span> <span>:</span> border-width || border-style || border-color 
</code></pre>
<div><span>1</span><br></div></div><p>边框属性—设置边框样式（border-style）</p>
<p>边框样式用于定义页面中边框的风格，常用属性值如下：</p>
<div><pre><code>none：没有边框即忽略所有边框的宽度（默认值）

solid：边框为单实线(最为常用的)

dashed：边框为虚线  

dotted：边框为点线

double：边框为双实线
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="盒子边框写法总结表"> 盒子边框写法总结表</h3>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody>
<tr>
<td>设置内容</td>
<td>样式属性</td>
<td>常用属性值</td>
</tr>
<tr>
<td>上边框</td>
<td>border-top-style:样式; border-top-width:宽度;border-top-color:颜色;border-top:宽度 样式 颜色;</td>
<td></td>
</tr>
<tr>
<td>下边框</td>
<td>border-bottom-style:样式;border- bottom-width:宽度;border- bottom-color:颜色;border-bottom:宽度 样式 颜色;</td>
<td></td>
</tr>
<tr>
<td>左边框</td>
<td>border-left-style:样式; border-left-width:宽度;border-left-color:颜色;border-left:宽度 样式 颜色;</td>
<td></td>
</tr>
<tr>
<td>右边框</td>
<td>border-right-style:样式;border-right-width:宽度;border-right-color:颜色;border-right:宽度 样式 颜色;</td>
<td></td>
</tr>
<tr>
<td>样式综合设置</td>
<td>border-style:上边 [右边 下边 左边];</td>
<td>none无（默认）、solid单实线、dashed虚线、dotted点线、double双实线</td>
</tr>
<tr>
<td>宽度综合设置</td>
<td>border-width:上边 [右边 下边 左边];</td>
<td>像素值</td>
</tr>
<tr>
<td>颜色综合设置</td>
<td>border-color:上边 [右边 下边 左边];</td>
<td>颜色值、#十六进制、rgb(r,g,b)、rgb(r%,g%,b%)</td>
</tr>
<tr>
<td>边框综合设置</td>
<td>border:四边宽度 四边样式 四边颜色;</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="表格的细线边框"> 表格的细线边框</h3>
<p>table{ border-collapse:collapse; }  collapse 单词是合并的意思</p>
<p>border-collapse:collapse; 表示边框合并在一起。</p>
<h3 id="圆角边框-css3"> 圆角边框(CSS3)</h3>
<p>从此以后，我们的世界不只有矩形。radius 半径（距离）</p>
<p>语法格式：</p>
<div><pre><code><span>border-radius</span><span>:</span> 左上角  右上角  右下角  左下角<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="内边距-padding"> 内边距（padding）</h2>
<p>padding属性用于设置内边距。  是指 边框与内容之间的距离。</p>
<p>padding-top:上内边距</p>
<p>padding-right:右内边距</p>
<p>padding-bottom:下内边距</p>
<p>padding-left:左内边距</p>
<table>
<thead>
<tr>
<th>值的个数</th>
<th>表达意思</th>
</tr>
</thead>
<tbody>
<tr>
<td>1个值</td>
<td>padding：上下左右边距 比如padding: 3px; 表示上下左右都是3像素</td>
</tr>
<tr>
<td>2个值</td>
<td>padding: 上下边距 左右边距 比如 padding: 3px 5px; 表示 上下3像素 左右 5像素</td>
</tr>
<tr>
<td>3个值</td>
<td>padding：上边距 左右边距 下边距 比如 padding: 3px 5px 10px; 表示 上是3像素 左右是5像素 下是10像素</td>
</tr>
<tr>
<td>4个值</td>
<td>padding:上内边距 右内边距 下内边距 左内边距 比如: padding: 3px 5px 10px 15px; 表示 上3px 右是5px 下 10px 左15px 顺时针</td>
</tr>
</tbody>
</table>
<h2 id="外边距-margin"> 外边距（margin）</h2>
<p>margin属性用于设置外边距。  设置外边距会在元素之间创建“空白”， 这段空白通常不能放置其他内容。</p>
<p>margin-top:上外边距</p>
<p>margin-right:右外边距</p>
<p>margin-bottom:下外边距</p>
<p>margin-left:上外边距</p>
<p>margin:上外边距 右外边距  下外边距  左外边</p>
<p>取值顺序跟内边距相同。</p>
<h3 id="外边距实现盒子居中"> 外边距实现盒子居中</h3>
<p>可以让一个盒子实现水平居中，需要满足一下两个条件：</p>
<ol>
<li>必须是块级元素。</li>
<li>盒子必须指定了宽度（width）</li>
</ol>
<p>然后就给<strong>左右的外边距都设置为auto</strong>，就可使块级元素水平居中。</p>
<h3 id="文字盒子居中图片和背景区别"> 文字盒子居中图片和背景区别</h3>
<ol>
<li>文字水平居中是  text-align: center</li>
<li>盒子水平居中  左右margin 改为 auto</li>
</ol>
<div><pre><code><span>text-align</span><span>:</span> center<span>;</span> <span>/*  文字居中水平 */</span>
<span>margin</span><span>:</span> 10px auto<span>;</span>  <span>/* 盒子水平居中  左右margin 改为 auto 就阔以了 */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ol start="3">
<li>插入图片 我们用的最多 比如产品展示类</li>
<li>背景图片我们一般用于小图标背景 或者 超大背景图片</li>
</ol>
<div><pre><code><span>section img</span> <span>{</span>  
		<span>width</span><span>:</span> 200px<span>;</span><span>/* 插入图片更改大小 width 和 height */</span>
		<span>height</span><span>:</span> 210px<span>;</span>
		<span>margin-top</span><span>:</span> 30px<span>;</span>  <span>/* 插入图片更改位置 可以用margin 或padding  盒模型 */</span>
		<span>margin-left</span><span>:</span> 50px<span>;</span> <span>/* 插入当图片也是一个盒子 */</span>
	<span>}</span>

<span>aside</span> <span>{</span>
		<span>width</span><span>:</span> 400px<span>;</span>
		<span>height</span><span>:</span> 400px<span>;</span>
		<span>border</span><span>:</span> 1px solid purple<span>;</span>
		<span>background</span><span>:</span> #fff <span><span>url</span><span>(</span>images/sun.jpg<span>)</span></span> no-repeat<span>;</span>
	
		<span>background-size</span><span>:</span> 200px 210px<span>;</span> <span>/*  背景图片更改大小只能用 background-size */</span>
		<span>background-position</span><span>:</span> 30px 50px<span>;</span> <span>/* 背景图片更该位置 我用 background-position */</span>
	<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="清除元素的默认内外边距"> 清除元素的默认内外边距</h3>
<p>为了更方便地控制网页中的元素，制作网页时，可使用如下代码清除元素的默认内外边距：</p>
<div><pre><code><span>*</span> <span>{</span>
   <span>padding</span><span>:</span>0<span>;</span>         <span>/* 清除内边距 */</span>
   <span>margin</span><span>:</span>0<span>;</span>          <span>/* 清除外边距 */</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注意：  <strong>行内元素是只有左右外边距的，是没有上下外边距的。</strong> 内边距，在ie6等低版本浏览器也会有问题。</p>
<p>我们尽量不要给行内元素指定上下的内外边距就好了。</p>
<h2 id="外边距合并"> 外边距合并</h2>
<p>使用margin定义块元素的垂直外边距时，可能会出现外边距的合并。</p>
<h3 id="相邻块元素垂直外边距的合并"> 相邻块元素垂直外边距的合并</h3>
<p>当上下相邻的两个块元素相遇时，如果上面的元素有下外边距margin-bottom，下面的元素有上外边距margin-top，则他们之间的垂直间距不是margin-bottom与margin-top之和，而是两者中的较大者。这种现象被称为相邻块元素垂直外边距的合并（也称外边距塌陷）。</p>
<h3 id="嵌套块元素垂直外边距的合并"> 嵌套块元素垂直外边距的合并</h3>
<p>对于两个嵌套关系的块元素，如果父元素没有上内边距及边框，则父元素的上外边距会与子元素的上外边距发生合并，合并后的外边距为两者中的较大者，即使父元素的上外边距为0，也会发生合并。</p>
<p>解决方案：</p>
<ol>
<li>可以为父元素定义1像素的上边框或上内边距。</li>
<li>可以为父元素添加overflow:hidden。</li>
</ol>
<h2 id="content宽度和高度"> content宽度和高度</h2>
<p>使用宽度属性width和高度属性height可以对盒子的大小进行控制。</p>
<p>width和height的属性值可以为不同单位的数值或相对于父元素的百分比%，</p>
<p>大多数浏览器，如Firefox、IE6及以上版本都采用了W3C规范，符合CSS规范的盒子模型的总宽度和总高度的计算原则是：</p>
<div><pre><code>  /*外盒尺寸计算（元素空间尺寸）*/
  Element空间高度 = content height + padding + border + margin
  Element 空间宽度 = content width + padding + border + margin
  /*内盒尺寸计算（元素实际大小）*/
  Element Height = content height + padding + border （Height为内容高度）
  Element Width = content width + padding + border （Width为内容宽度）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>注意：</p>
<p>1、宽度属性width和高度属性height仅适用于块级元素，对行内元素无效（ img 标签和 input除外）。</p>
<p>2、计算盒子模型的总高度时，还应考虑上下两个盒子垂直外边距合并的情况。</p>
<p>3、<strong>如果一个盒子没有给定宽度/高度或者继承父亲的宽度/高度，则padding 不会影响本盒子大小</strong>。</p>
<h2 id="盒子模型布局稳定性"> 盒子模型布局稳定性</h2>
<p>我们根据稳定性来分，建议如下：优先使用  宽度 （width）  其次 使用内边距（padding）    再次  外边距（margin）。</p>
<div><pre><code>  width &gt;  padding  &gt;   margin   
</code></pre>
<div><span>1</span><br></div></div><p>原因：</p>
<ol>
<li>
<p>margin 会有外边距合并 还有 ie6下面margin 加倍的bug（讨厌）所以最后使用。</p>
</li>
<li>
<p>padding  会影响盒子大小， 需要进行加减计算（麻烦） 其次使用。</p>
</li>
<li>
<p>width   没有问题（嗨皮）我们经常使用宽度剩余法 高度剩余法来做。</p>
</li>
</ol>
<h2 id="盒子阴影"> 盒子阴影</h2>
<p>语法格式：</p>
<div><pre><code><span>box-shadow</span><span>:</span>水平阴影 垂直阴影 模糊距离 阴影尺寸 阴影颜色  内/外阴影；
</code></pre>
<div><span>1</span><br></div></div><ol>
<li>前两个属性是必须写的。其余的可以省略。</li>
<li>外阴影 (outset) 但是不能写    默认      想要内阴影  inset</li>
</ol>
<div><pre><code><span>div</span> <span>{</span>
			<span>width</span><span>:</span> 200px<span>;</span>
			<span>height</span><span>:</span> 200px<span>;</span>
			<span>border</span><span>:</span> 10px solid red<span>;</span>
			<span>/* box-shadow: 5px 5px 3px 4px rgba(0, 0, 0, .4);  */</span>
			<span>/* box-shadow:水平位置 垂直位置 模糊距离 阴影尺寸（影子大小） 阴影颜色  内/外阴影； */</span>
			<span>box-shadow</span><span>:</span> 0 15px 30px  <span>rgba</span><span>(</span>0<span>,</span> 0<span>,</span> 0<span>,</span> .4<span>)</span><span>;</span>
			
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="浮动-float"> 浮动(float)</h2>
<h2 id="普通流-normal-flow"> 普通流(normal flow)</h2>
<p>CSS的定位机制有3种：普通流（标准流）、浮动和定位。</p>
<p>html语言当中另外一个相当重要的概念----------标准流！或者普通流。普通流实际上就是一个网页内标签元素正常从上到下，从左到右排列顺序的意思，比如块级元素会独占一行，行内元素会按顺序依次前后排列；按照这种大前提的布局排列之下绝对不会出现例外的情况叫做普通流布局。</p>
<h2 id="什么是浮动"> 什么是浮动？</h2>
<p>元素的浮动是指设置了浮动属性的元素会脱离标准普通流的控制，移动到其父元素中指定位置的过程。</p>
<p>在CSS中，通过float属性来定义浮动，其基本语法格式如下：</p>
<div><pre><code>选择器{float:属性值;}
</code></pre>
<div><span>1</span><br></div></div><table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>left</td>
<td>元素向左浮动</td>
</tr>
<tr>
<td>right</td>
<td>元素向右浮动</td>
</tr>
<tr>
<td>none</td>
<td>元素不浮动（默认值）</td>
</tr>
</tbody>
</table>
<h2 id="浮动详细内幕特性"> 浮动详细内幕特性</h2>
<p>浮动脱离标准流，不占位置，会影响标准流。浮动只有左右浮动。</p>
<div><pre><code>浮动首先创建包含块的概念（包裹）。就是说， 浮动的元素总是找理它最近的父级元素对齐。但是不会超出内边距的范围。 
元素添加浮动后，元素会具有行内块元素的特性。元素的大小完全取决于定义的大小或者默认的内容多少浮动根据元素书写的位置来显示相应的浮动。
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>总结：  浮动 ---&gt;    浮动的目的就是为了让多个块级元素同一行上显示。</p>
<h2 id="版心"> 版心</h2>
<p>“版心”(可视区) 是指网页中主体内容所在的区域。一般在浏览器窗口中水平居中显示，常见的宽度值为960px、980px、1000px、1200px等。</p>
<h2 id="清除浮动"> 清除浮动</h2>
<h2 id="为什么要清除浮动"> 为什么要清除浮动</h2>
<p>由于浮动元素不再占用原文档流的位置，所以它会对后面的元素排版产生影响，为了解决这些问题，此时就需要在该元素中清除浮动。</p>
<p>准确地说，并不是清除浮动，而是<strong>清除浮动后造成的影响</strong></p>
<h2 id="清除浮动本质"> 清除浮动本质</h2>
<p><strong>清除浮动主要为了解决父级元素因为子级浮动引起内部高度为0 的问题</strong>。</p>
<h2 id="清除浮动的方法"> 清除浮动的方法</h2>
<p>其实本质叫做闭合浮动更好一些, 记住，清除浮动就是把浮动的盒子圈到里面，让父盒子闭合出口和入口不让他们出来影响其他元素。</p>
<p>在CSS中，clear属性用于清除浮动，其基本语法格式如下：</p>
<div><pre><code>选择器{clear:属性值;}
</code></pre>
<div><span>1</span><br></div></div><table>
<thead>
<tr>
<th>属性值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>left</td>
<td>不允许左侧有浮动元素（清除左侧浮动的影响）</td>
</tr>
<tr>
<td>right</td>
<td>不允许右侧有浮动元素（清除右侧浮动的影响）</td>
</tr>
<tr>
<td>both</td>
<td>同时清除左右两侧浮动的影响</td>
</tr>
</tbody>
</table>
<h3 id="额外标签法"> 额外标签法</h3>
<div><pre><code>是W3C推荐的做法是通过在浮动元素末尾添加一个空的标签例如 <span><span><span>&lt;</span>div</span> <span><span>style</span><span><span>=</span><span><span>”clear</span><span>:</span>both”</span></span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>，或则其他标签br等亦可。
</code></pre>
<div><span>1</span><br></div></div><p>优点： 通俗易懂，书写方便</p>
<p>缺点： 添加许多无意义的标签，结构化较差。  我只能说，w3c你推荐的方法我不接受，你不值得拥有。。。</p>
<h3 id="父级添加overflow属性方法"> 父级添加overflow属性方法</h3>
<p>可以通过触发BFC的方式，可以实现清除浮动效果。</p>
<div><pre><code>可以给父级添加： overflow为 hidden|auto|scroll  都可以实现。
</code></pre>
<div><span>1</span><br></div></div><p>优点：  代码简洁</p>
<p>缺点：  内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素。</p>
<h3 id="使用after伪元素清除浮动"> 使用after伪元素清除浮动</h3>
<p><strong>:after 方式为空元素的升级版，好处是不用单独加标签了</strong></p>
<p>使用方法：</p>
<div><pre><code> <span>.clearfix:after</span> <span>{</span>  <span>content</span><span>:</span> <span>"."</span><span>;</span> <span>display</span><span>:</span> block<span>;</span> <span>height</span><span>:</span> 0<span>;</span> <span>clear</span><span>:</span> both<span>;</span> <span>visibility</span><span>:</span> hidden<span>;</span>  <span>}</span>   

 <span>.clearfix</span> <span>{</span>*<span>zoom</span><span>:</span> 1<span>;</span><span>}</span>   <span>/* IE6、7 专有 */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>优点： 符合闭合浮动思想  结构语义化正确</p>
<p>缺点： 由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。</p>
<p>注意： content:&quot;.&quot;  里面尽量跟一个小点，或者其他，尽量不要为空，否则再firefox 7.0前的版本会有生成空格。</p>
<h3 id="使用before和after双伪元素清除浮动"> 使用before和after双伪元素清除浮动</h3>
<p>使用方法：</p>
<div><pre><code><span>.clearfix:before,.clearfix:after</span> <span>{</span> 
  <span>content</span><span>:</span><span>""</span><span>;</span>
  <span>display</span><span>:</span>table<span>;</span>  <span>/* 这句话可以出发BFC BFC可以清除浮动,BFC我们后面讲 */</span>
<span>}</span>
<span>.clearfix:after</span> <span>{</span>
 <span>clear</span><span>:</span>both<span>;</span>
<span>}</span>
<span>.clearfix</span> <span>{</span>
  *<span>zoom</span><span>:</span>1<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>优点：  代码更简洁</p>
<p>缺点：  由于IE6-7不支持:after，使用 zoom:1触发 hasLayout。</p>
<h2 id="元素的定位属性"> 元素的定位属性</h2>
<p>元素的定位属性主要包括定位模式和边偏移两部分。</p>
<p>1、边偏移</p>
<table>
<thead>
<tr>
<th>边偏移属性</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>top</td>
<td>顶端偏移量，定义元素相对于其父元素上边线的距离</td>
</tr>
<tr>
<td>bottom</td>
<td>底部偏移量，定义元素相对于其父元素下边线的距离</td>
</tr>
<tr>
<td>left</td>
<td>左侧偏移量，定义元素相对于其父元素左边线的距离</td>
</tr>
<tr>
<td>right</td>
<td>右侧偏移量，定义元素相对于其父元素右边线的距离</td>
</tr>
</tbody>
</table>
<p>也就说，以后定位要和这边偏移搭配使用了， 比如 top: 100px;  left: 30px; 等等</p>
<p>2、定位模式(定位的分类)</p>
<p>在CSS中，position属性用于定义元素的定位模式，其基本语法格式如下：</p>
<p>选择器{position:属性值;}</p>
<p>position属性的常用值</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>static</td>
<td>自动定位（默认定位方式）</td>
</tr>
<tr>
<td>relative</td>
<td>相对定位，相对于其原文档流的位置进行定位</td>
</tr>
<tr>
<td>absolute</td>
<td>绝对定位，相对于其上一个已经定位的父元素进行定位</td>
</tr>
<tr>
<td>fixed</td>
<td>固定定位，相对于浏览器窗口进行定位</td>
</tr>
</tbody>
</table>
<h2 id="静态定位-static"> 静态定位(static)</h2>
<p>静态定位是所有元素的默认定位方式，当position属性的取值为static时，可以将元素定位于静态位置。 所谓静态位置就是各个元素在HTML文档流中默认的位置。</p>
<p>上面的话翻译成白话：  就是网页中所有元素都默认的是静态定位哦！ 其实就是标准流的特性。</p>
<p>在静态定位状态下，无法通过边偏移属性（top、bottom、left或right）来改变元素的位置。</p>
<h2 id="相对定位relative"> 相对定位relative</h2>
<p>相对定位是将元素相对于它在标准流中的位置进行定位，当position属性的取值为relative时，可以将元素定位于相对位置。</p>
<p>对元素设置相对定位后，可以通过边偏移属性改变元素的位置，但是它在文档流中的位置仍然保留。如下图所示，即是一个相对定位的效果展示：</p>
<p>注意：</p>
<ol>
<li>相对定位最重要的一点是，它可以通过边偏移移动位置，但是原来的所占的位置，继续占有。</li>
<li>其次，每次移动的位置，是以自己的左上角为基点移动（相对于自己来移动位置）</li>
</ol>
<p>就是说，相对定位的盒子仍在标准流中，它后面的盒子仍以标准流方式对待它。（相对定位不脱标）</p>
<p>如果说浮动的主要目的是 让多个块级元素一行显示，那么定位的主要价值就是 移动位置， 让盒子到我们想要的位置上去。</p>
<h2 id="绝对定位absolute"> 绝对定位absolute</h2>
<p>[注意] 如果文档可滚动，绝对定位元素会随着它滚动，因为元素最终会相对于正常流的某一部分定位。</p>
<p>当position属性的取值为absolute时，可以将元素的定位模式设置为绝对定位。</p>
<p>注意：    绝对定位最重要的一点是，它可以通过边偏移移动位置，但是它完全脱标，完全不占位置。</p>
<h3 id="父级没有定位"> 父级没有定位</h3>
<p>若所有父元素都没有定位，以浏览器为准对齐(document文档)。</p>
<h3 id="父级有定位"> 父级有定位</h3>
<p>绝对定位是将元素依据最近的已经定位（绝对、固定或相对定位）的父元素（祖先）进行定位。</p>
<h3 id="子绝父相"> 子绝父相</h3>
<p>这句话的意思是 子级是绝对定位的话， 父级要用相对定位。</p>
<p>首先， 我们说下， 绝对定位是将元素依据最近的已经定位绝对、固定或相对定位）的父元素（祖先）进行定位。</p>
<p>就是说， 子级是绝对定位，父亲只要是定位即可（不管父亲是绝对定位还是相对定位，甚至是固定定位都可以），就是说， 子绝父绝，子绝父相都是正确的。</p>
<p>因为子级是绝对定位，不会占有位置， 可以放到父盒子里面的任何一个地方。</p>
<p>父盒子布局时，需要占有位置，因此父亲只能是 相对定位.</p>
<p>这就是子绝父相的由来。</p>
<h2 id="绝对定位的盒子水平-垂直居中"> 绝对定位的盒子水平/垂直居中</h2>
<p>普通的盒子是左右margin 改为 auto就可， 但是对于绝对定位就无效了</p>
<p>定位的盒子也可以水平或者垂直居中，有一个算法。</p>
<ol>
<li>
<p>首先left 50%   父盒子的一半大小</p>
</li>
<li>
<p>然后走自己外边距负的一半值就可以了 margin-left。</p>
</li>
</ol>
<h2 id="固定定位fixed"> 固定定位fixed</h2>
<p>固定定位是绝对定位的一种特殊形式，类似于 正方形是一个特殊的 矩形。它以浏览器窗口作为参照物来定义网页元素。当position属性的取值为fixed时，即可将元素的定位模式设置为固定定位。</p>
<p>当对元素设置固定定位后，它将脱离标准文档流的控制，始终依据浏览器窗口来定义自己的显示位置。不管浏览器滚动条如何滚动也不管浏览器窗口的大小如何变化，该元素都会始终显示在浏览器窗口的固定位置。</p>
<p>固定定位有两点：</p>
<ol>
<li>固定定位的元素跟父亲没有任何关系，只认浏览器。</li>
<li>固定定位完全脱标，不占有位置，不随着滚动条滚动。</li>
</ol>
<h2 id="叠放次序"> 叠放次序</h2>
<p>当对多个元素同时设置定位时，定位元素之间有可能会发生重叠。</p>
<p>在CSS中，要想调整重叠定位元素的堆叠顺序，可以对定位元素应用z-index层叠等级属性，其取值可为正整数、负整数和0。</p>
<p>比如：  z-index: 2;</p>
<p>注意：</p>
<ol>
<li>
<p>z-index的默认属性值是0，取值越大，定位元素在层叠元素中越居上。</p>
</li>
<li>
<p>如果取值相同，则根据书写顺序，后来居上。</p>
</li>
<li>
<p>后面数字一定不能加单位。</p>
</li>
<li>
<p>只有相对定位，绝对定位，固定定位有此属性，其余标准流，浮动，静态定位都无此属性，亦不可指定此属性。</p>
</li>
</ol>
<h2 id="四种定位总结"> 四种定位总结</h2>
<table>
<thead>
<tr>
<th>定位模式</th>
<th>是否脱标占有位置</th>
<th>是否可以使用边偏移</th>
<th>移动位置基准</th>
</tr>
</thead>
<tbody>
<tr>
<td>静态static</td>
<td>不脱标，正常模式</td>
<td>不可以</td>
<td>正常模式</td>
</tr>
<tr>
<td>相对定位relative</td>
<td>不脱标，占有位置</td>
<td>可以</td>
<td>相对自身位置移动（自恋型）</td>
</tr>
<tr>
<td>绝对定位absolute</td>
<td>完全脱标，不占有位置</td>
<td>可以</td>
<td>相对于定位父级移动位置（拼爹型）</td>
</tr>
<tr>
<td>固定定位fixed</td>
<td>完全脱标，不占有位置</td>
<td>可以</td>
<td>相对于浏览器移动位置（认死理型）</td>
</tr>
</tbody>
</table>
<h2 id="定位模式转换"> 定位模式转换</h2>
<p>跟 浮动一样， 元素添加了 绝对定位和固定定位之后， 元素模式也会发生转换， 都转换为 行内块模式，</p>
<p>** 因此 比如 行内元素 如果添加了 绝对定位或者 固定定位后 浮动后，可以不用转换模式，直接给高度和宽度就可以了。**</p>
<h2 id="元素的显示与隐藏"> 元素的显示与隐藏</h2>
<p>display visibility 和 overflow。</p>
<p>他们的主要目的是让一个元素在页面中消失，但是不在文档源码中删除。</p>
<h2 id="display-显示"> display 显示</h2>
<p>display 设置或检索对象是否及如何显示。</p>
<p>display : none 隐藏对象 与它相反的是 display:block 除了转换为块级元素之外，同时还有显示元素的意思。</p>
<p><strong>特点： 隐藏之后，不再保留位置。</strong></p>
<h2 id="visibility-可见性"> visibility 可见性</h2>
<p>设置或检索是否显示对象。</p>
<p>visible : 　对象可视</p>
<p>hidden : 　对象隐藏</p>
<p><strong>特点： 隐藏之后，继续保留原有位置。（停职留薪）</strong></p>
<h2 id="overflow-溢出"> overflow 溢出</h2>
<p>检索或设置当对象的内容超过其指定高度及宽度时如何管理内容。</p>
<p>visible : 　不剪切内容也不添加滚动条。</p>
<p>auto : 　 超出自动显示滚动条，不超出不显示滚动条</p>
<p>hidden : 　不显示超过对象尺寸的内容，超出的部分隐藏掉</p>
<p>scroll : 　不管超出内容否，总是显示滚动条</p>
<h2 id="css高级技巧"> CSS高级技巧</h2>
<h2 id="css用户界面样式"> CSS用户界面样式</h2>
<p>所谓的界面样式， 就是更改一些用户操作样式， 比如 更改用户的鼠标样式， 表单轮廓等。但是比如滚动条的样式改动受到了很多浏览器的抵制，因此我们就放弃了。 防止表单域拖拽</p>
<h3 id="鼠标样式cursor"> 鼠标样式cursor</h3>
<p>设置或检索在对象上移动的鼠标指针采用何种系统预定义的光标形状。</p>
<div><pre><code>cursor :  default  小白 | pointer  小手  | move  移动  |  text  文本
</code></pre>
<div><span>1</span><br></div></div><p>鼠标放我身上查看效果哦：</p>
<div><pre><code><span><span><span>&lt;</span>ul</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>cursor</span><span>:</span>default</span><span>"</span></span></span><span>></span></span>我是小白<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>cursor</span><span>:</span>pointer</span><span>"</span></span></span><span>></span></span>我是小手<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>cursor</span><span>:</span>move</span><span>"</span></span></span><span>></span></span>我是移动<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span> <span><span>style</span><span><span>=</span><span>"</span><span><span>cursor</span><span>:</span>text</span><span>"</span></span></span><span>></span></span>我是文本<span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>尽量不要用hand  因为 火狐不支持     pointer ie6以上都支持的尽量用</p>
<h3 id="轮廓-outline"> 轮廓 outline</h3>
<p>是绘制于元素周围的一条线，位于边框边缘的外围，可起到突出元素的作用。</p>
<div><pre><code> <span>outline</span> <span>:</span> outline-color ||outline-style || outline-width 
</code></pre>
<div><span>1</span><br></div></div><p>但是我们都不关心可以设置多少，我们平时都是去掉的。</p>
<p>最直接的写法是 ：  outline: 0;   或者  outline: none;</p>
<div><pre><code> <span><span><span>&lt;</span>input</span>  <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span>  <span><span>style</span><span><span>=</span><span>"</span><span><span>outline</span><span>:</span> 0<span>;</span></span><span>"</span></span></span><span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="防止拖拽文本域resize"> 防止拖拽文本域resize</h3>
<p>resize：none    这个单词可以防止 火狐 谷歌等浏览器随意的拖动 文本域。</p>
<p>右下角可以拖拽：</p>
<p><textarea></textarea>
右下角不可以拖拽：</p>
<div><pre><code><span><span><span>&lt;</span>textarea</span>  <span><span>style</span><span><span>=</span><span>"</span><span><span>resize</span><span>:</span> none<span>;</span></span><span>"</span></span></span><span>></span></span><span><span><span>&lt;/</span>textarea</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="vertical-align-垂直对齐"> vertical-align 垂直对齐</h2>
<p>以前我们讲过让带有宽度的块级元素居中对齐，是margin: 0 auto;</p>
<p>以前我们还讲过让文字居中对齐，是 text-align: center;</p>
<p>但是我们从来没有讲过有垂直居中的属性， 我们的妈妈一直很担心我们的垂直居中怎么做。</p>
<p>vertical-align 垂直对齐， 这个看上去很美好的一个属性， 实际有着不可捉摸的脾气，否则我们也不会这么晚来讲解。</p>
<div><pre><code><span>vertical-align</span> <span>:</span> baseline |top |middle |bottom 
</code></pre>
<div><span>1</span><br></div></div><p>设置或检索对象内容的垂直对其方式。</p>
<p>vertical-align 不影响块级元素中的内容对齐，它只针对于 行内元素或者行内块元素，特别是行内块元素， <strong>通常用来控制图片/表单与文字的对齐</strong>。</p>
<h3 id="图片、表单和文字对齐"> 图片、表单和文字对齐</h3>
<p>所以我们知道，我们可以通过vertical-align 控制图片和文字的垂直关系了。 默认的图片会和文字基线对齐。</p>
<h3 id="去除图片底侧空白缝隙"> 去除图片底侧空白缝隙</h3>
<p>有个很重要特性你要记住： 图片或者表单等行内块元素，他的底线会和父级盒子的基线对齐。这样会造成一个问题，就是图片底侧会有一个空白缝隙。</p>
<p>解决的方法就是：</p>
<ol>
<li>
<p>给img vertical-align:middle | top等等。  让图片不要和基线对齐。</p>
</li>
<li>
<p>给img 添加 display：block; 转换为块级元素就不会存在问题了</p>
</li>
</ol>
<h2 id="word-break-自动换行"> word-break:自动换行</h2>
<p>normal   使用浏览器默认的换行规则。</p>
<p>break-all   允许在单词内换行。</p>
<p>keep-all    只能在半角空格或连字符处换行。</p>
<p>主要处理英文单词</p>
<h2 id="white-space"> white-space</h2>
<p>white-space设置或检索对象内文本显示方式。通常我们使用于强制一行显示内容</p>
<p>normal : 　默认处理方式
nowrap : 　强制在同一行内显示所有文本，直到文本结束或者遭遇br标签对象才换行。</p>
<p>可以处理中文</p>
<h2 id="text-overflow-文字溢出"> text-overflow 文字溢出</h2>
<p>text-overflow : clip | ellipsis</p>
<p>设置或检索是否使用一个省略标记（...）标示对象内文本的溢出</p>
<p>clip : 　不显示省略标记（...），而是简单的裁切</p>
<p>ellipsis : 　当对象内文本溢出时显示省略标记（...）</p>
<p>注意一定要首先强制一行内显示，再次和overflow属性  搭配使用</p>
<div><pre><code><span>.box</span> <span>{</span>
			<span>width</span><span>:</span> 200px<span>;</span>
			<span>height</span><span>:</span> 300px<span>;</span>
			<span>background-color</span><span>:</span> #ccc<span>;</span>
			<span>/*文字强制一行显示*/</span>
			<span>white-space</span><span>:</span> nowrap<span>;</span>
			<span>/*溢出隐藏*/</span>
			<span>overflow</span><span>:</span> hidden<span>;</span>
			<span>/*溢出省略号*/</span>
			<span>text-overflow</span><span>:</span> ellipsis<span>;</span>
			<span>/*实现单行文本省略号,white-space: nowrap;overflow: hidden;text-overflow: ellipsis; 
			缺一不可*/</span>
		<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>#CSS精灵技术（sprite） 小妖精  雪碧</p>
<h2 id="精灵技术产生的背景"> 精灵技术产生的背景</h2>
<p>当用户访问一个网站时，需要向服务器发送请求，网页上的每张图像都要经过一次请求才能展现给用户。</p>
<p>然而，一个网页中往往会应用很多小的背景图像作为修饰，当网页中的图像过多时，服务器就会频繁地接受和发送请求，这将大大降低页面的加载速度。为了有效地减少服务器接受和发送请求的次数，提高页面的加载速度，出现了CSS精灵技术（也称CSS Sprites、CSS雪碧）。</p>
<h3 id="精灵技术本质"> 精灵技术本质</h3>
<p>简单地说，CSS精灵是一种处理网页背景图像的方式。它将一个页面涉及到的所有零星背景图像都集中到一张大图中去，然后将大图应用于网页，这样，当用户访问该页面时，只需向服务发送一次请求，网页中的背景图像即可全部展示出来。通常情况下，这个由很多小的背景图像合成的大图被称为精灵图（雪碧图），如下图所示为京东网站中的一个精灵图。</p>
<h3 id="精灵技术的使用"> 精灵技术的使用</h3>
<p>CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），然而，各个网页元素通常只需要精灵图中不同位置的某个小图，要想精确定位到精灵图中的某个小图，就需要使用CSS的background-image、background-repeat和background-position属性进行背景定位，其中最关键的是使用background-position属性精确地定位。</p>
<h3 id="制作精灵图"> 制作精灵图</h3>
<p>CSS 精灵其实是将网页中的一些背景图像整合到一张大图中（精灵图），那我们要做的，就是把小图拼合成一张大图。</p>
<p>大部分情况下，精灵图都是网页美工做。</p>
<div><pre><code>我们精灵图上放的都是小的装饰性质的背景图片。 插入图片不能往上放。
我们精灵图的宽度取决于最宽的那个背景。 
我们可以横向摆放也可以纵向摆放，但是每个图片之间，间隔至少隔开偶数像素合适。
在我们精灵图的最低端，留一片空隙，方便我们以后添加其他精灵图。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="字体图标"> 字体图标</h2>
<p>图片是有诸多优点的，但是缺点很明显，比如图片不但增加了总文件的大小，还增加了很多额外的&quot;http请求&quot;，这都会大大降低网页的性能的。更重要的是图片不能很好的进行“缩放”，因为图片放大和缩小会失真。 我们后面会学习移动端响应式，很多情况下希望我们的图标是可以缩放的。此时，一个非常重要的技术出现了，额不是出现了，是以前就有，是被从新&quot;宠幸&quot;啦。。 这就是字体图标（iconfont).</p>
<h2 id="字体图标优点"> 字体图标优点</h2>
<div><pre><code>可以做出跟图片一样可以做的事情,改变透明度、旋转度，等..
但是本质其实是文字，可以很随意的改变颜色、产生阴影、透明效果等等...
本身体积更小，但携带的信息并没有削减。
几乎支持所有的浏览器
移动端设备必备良药...
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="网站优化三大标签"> 网站优化三大标签</h3>
<p>SEO是由英文Search Engine Optimization缩写而来， 中文意译为“搜索引擎优化”！SEO是指通过对网站进行站内优化、网站结构调整、网站内容建设、网站代码优化等)和站外优化，从而提高网站的关键词排名以及公司产品的曝光度。 简单的说就是，把产品做好，搜索引擎就会介绍客户来。</p>
<h4 id="网页title-标题"> 网页title 标题</h4>
<p>title具有不可替代性，是我们的内页第一个重要标签，是搜索引擎了解网页的入口，和对网页主题归属的最佳判断点。</p>
<p>建议：</p>
<p>首页标题：网站名（产品名）- 网站的介绍</p>
<h4 id="description-网站说明"> Description  网站说明</h4>
<p>对于关键词的作用明显降低，但由于很多搜索引擎，仍然大量采用网页的MATA标签中描述部分作为搜索结果的“内容摘要”。 就是简要说明我们网站的主要做什么的。
我们提倡，Description作为网站的总体业务和主题概括，多采用“我们是…”“我们提供…”“×××网作为…”“电话：010…”之类语句。</p>
<p>京东网：</p>
<div><pre><code>&lt;meta name=&quot;description&quot; content=&quot;京东JD.COM-专业的综合网上购物商城,销售家电、数码通讯、电脑、家居百货、服装服饰、母婴、图书、食品等数万个品牌优质商品.便捷、诚信的服务，为您提供愉悦的网上购物体验!&quot; /&gt;
</code></pre>
<div><span>1</span><br></div></div><p>注意点：</p>
<ol>
<li>描述中出现关键词，与正文内容相关，这部分内容是给人看的，所以要写的很详细，让人感兴趣， 吸引用户点击。</li>
<li>同样遵循简短原则，字符数含空格在内不要超过 120  个汉字。</li>
<li>补充在 title  和 keywords  中未能充分表述的说明.</li>
<li>用英文逗号 关键词1,关键词2</li>
</ol>
<div><pre><code>&lt;meta name=&quot;description&quot; content=&quot;小米商城直营小米公司旗下所有产品，囊括小米手机系列小米MIX、小米Note 2，红米手机系列红米Note 4、红米4，智能硬件，配件及小米生活周边，同时提供小米客户服务及售后支持。&quot; /&gt;
</code></pre>
<div><span>1</span><br></div></div><h4 id="keywords-关键字"> Keywords 关键字</h4>
<p>Keywords是页面关键词，是搜索引擎关注点之一。Keywords应该限制在6～8个关键词左右，电商类网站可以多 少许。</p>
<p>京东网：</p>
<div><pre><code>&lt;meta name=&quot;Keywords&quot; content=&quot;网上购物,网上商城,手机,笔记本,电脑,MP3,CD,VCD,DV,相机,数码,配件,手表,存储卡,京东&quot; /&gt;
</code></pre>
<div><span>1</span><br></div></div><p>小米网：</p>
<div><pre><code>&lt;meta name=&quot;keywords&quot; content=&quot;小米,小米6,红米Note4,小米MIX,小米商城&quot; /&gt;
</code></pre>
<div><span>1</span><br></div></div><h2 id="bfc-块级格式化上下文"> BFC(块级格式化上下文)</h2>
<p>BFC(Block formatting context)</p>
<p>直译为&quot;块级格式化上下文&quot;。</p>
<h3 id="元素的显示模式"> 元素的显示模式</h3>
<h3 id="那些元素会具有bfc的条件"> 那些元素会具有BFC的条件</h3>
<p>不是所有的元素模式都能产生BFC，w3c 规范：</p>
<p>display 属性为 block, list-item, table 的元素，会产生BFC.</p>
<p>这个BFC 有着具体的布局特性：</p>
<p>有宽度和高度 ， 有 外边距margin  有内边距padding 有边框 border。</p>
<h3 id="什么情况下可以让元素产生bfc"> 什么情况下可以让元素产生BFC</h3>
<p>同样，要给这些元素添加如下属性就可以触发BFC。</p>
<p>-float属性不为none</p>
<p>-position为absolute或fixed</p>
<p>-display为inline-block, table-cell, table-caption, flex, inline-flex</p>
<p>-overflow不为visible。</p>
<h3 id="bfc元素所具有的特性"> BFC元素所具有的特性</h3>
<p>BFC布局规则特性：</p>
<p>1.在BFC中，盒子从顶端开始垂直地一个接一个地排列.</p>
<p>2.盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠</p>
<p>3.在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。</p>
<ol>
<li>BFC的区域不会与浮动盒子产生交集，而是紧贴浮动边缘。</li>
<li>计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。</li>
</ol>
<p>它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>
<p>白话文： 孩子在家里愿意怎么折腾都行，但是出了家门口，你就的乖乖的，不能影响外面的任何人。</p>
<h3 id="bfc的主要用途"> BFC的主要用途</h3>
<p>BFC能用来做什么？</p>
<p>(1) 清除元素内部浮动</p>
<p>只要把父元素设为BFC就可以清理子元素的浮动了，最常见的用法就是在父元素上设置overflow: hidden样式，对于IE6加上zoom:1就可以了。</p>
<p>主要用到</p>
<div><pre><code>计算BFC的高度时，自然也会检测浮动或者定位的盒子高度。
(2) 解决外边距合并问题
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>外边距合并的问题。</p>
<p>主要用到</p>
<div><pre><code>盒子垂直方向的距离由margin决定。属于同一个BFC的两个相邻盒子的margin会发生重叠
</code></pre>
<div><span>1</span><br></div></div><p>属于同一个BFC的两个相邻盒子的margin会发生重叠，那么我们创建不属于同一个BFC，就不会发生margin重叠了。</p>
<p>(3) 制作右侧自适应的盒子问题</p>
<p>主要用到</p>
<div><pre><code>普通流体元素BFC后，为了和浮动元素不产生任何交集，顺着浮动边缘形成自己的封闭上下文
</code></pre>
<div><span>1</span><br></div></div><h2 id="优雅降级和渐进增强"> 优雅降级和渐进增强</h2>
<p>什么是渐进增强（progressive enhancement）、优雅降级（graceful degradation）呢？</p>
<p>渐进增强 progressive enhancement：</p>
<p>针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。</p>
<p>类似 爬山，由低出往高处爬</p>
<p><b>优雅降级 graceful degradation：</b></p>
<p>一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。</p>
<p>类似蹦极，由高处往低处下落</p>
<p>区别：渐进增强是向上兼容，优雅降级是向下兼容。</p>
<p>个人建议： 现在互联网发展很快， 连微软公司都抛弃了ie浏览器，转而支持 edge这样的高版本浏览器，我们很多情况下没有必要再时刻想着低版本浏览器了，而是一开始就构建完整的效果，根据实际情况，修补低版本浏览器问题。</p>
<h2 id="浏览器前缀"> 浏览器前缀</h2>
<table>
<thead>
<tr>
<th>浏览器前缀</th>
<th>浏览器</th>
</tr>
</thead>
<tbody>
<tr>
<td>-webkit-</td>
<td>Google Chrome, Safari, Android Browser</td>
</tr>
<tr>
<td>-moz-</td>
<td>Firefox</td>
</tr>
<tr>
<td>-o-</td>
<td>Opera</td>
</tr>
<tr>
<td>-ms-</td>
<td>Internet Explorer, Edge</td>
</tr>
<tr>
<td>-khtml-</td>
<td>Konqueror</td>
</tr>
</tbody>
</table>
<h2 id="背景渐变"> 背景渐变</h2>
<p>在线性渐变过程中，颜色沿着一条直线过渡：从左侧到右侧、从右侧到左侧、从顶部到底部、从底部到顶部或着沿任何任意轴。</p>
<p>语法格式：</p>
<div><pre><code><span>background</span><span>:</span><span>-webkit-linear-gradient</span><span>(</span>渐变的起始位置， 起始颜色， 结束颜色<span>)</span>；
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>background</span><span>:</span><span>-webkit-linear-gradient</span><span>(</span>渐变的起始位置， 颜色 位置， 颜色位置....<span>)</span>；
</code></pre>
<div><span>1</span><br></div></div><h2 id="文档类型设定"> 文档类型设定</h2>
<ul>
<li>document
<ul>
<li>HTML:        sublime 输入  html:4s</li>
<li>XHTML:      sublime 输入  html:xt</li>
<li>HTML5        sublime 输入  html:5       <!DOCTYPE html></li>
</ul>
</li>
</ul>
<h2 id="字符设定"> 字符设定</h2>
<ul>
<li>
<meta http-equiv="charset" content="utf-8">：HTML与XHTML中建议这样去写
</li>
<li>
<meta charset="utf-8">：HTML5的标签中建议这样去写
</li>
</ul>
<h2 id="常用新标签"> 常用新标签</h2>
<ul>
<li>
<p>header：定义文档的页眉 头部</p>
</li>
<li>
<p>nav：定义导航链接的部分</p>
</li>
<li>
<p>footer：定义文档或节的页脚 底部</p>
</li>
<li>
<p>article：定义文章。</p>
</li>
<li>
<p>section：定义文档中的节（section、区段）</p>
</li>
<li>
<p>aside：定义其所处内容之外的内容 侧边</p>
<div><pre><code><span><span><span>&lt;</span>header</span><span>></span></span> 语义 :定义页面的头部  页眉<span><span><span>&lt;/</span>header</span><span>></span></span>
<span><span><span>&lt;</span>nav</span><span>></span></span>  语义 :定义导航栏 <span><span><span>&lt;/</span>nav</span><span>></span></span> 
<span><span><span>&lt;</span>footer</span><span>></span></span> 语义: 定义 页面底部 页脚<span><span><span>&lt;/</span>footer</span><span>></span></span>
<span><span><span>&lt;</span>article</span><span>></span></span> 语义:  定义文章<span><span><span>&lt;/</span>article</span><span>></span></span>
<span><span><span>&lt;</span>section</span><span>></span></span> 语义： 定义区域<span><span><span>&lt;/</span>section</span><span>></span></span>
<span><span><span>&lt;</span>aside</span><span>></span></span> 语义： 定义其所处内容之外的内容 侧边<span><span><span>&lt;/</span>aside</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>datalist   标签定义选项列表。请与 input 元素配合使用该元素</p>
<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>输入明星<span>"</span></span> <span>list</span><span><span>=</span><span>"</span>star<span>"</span></span><span>/></span></span> <span>&lt;!--  input里面用 list --></span>
<span><span><span>&lt;</span>datalist</span> <span>id</span><span><span>=</span><span>"</span>star<span>"</span></span><span>></span></span>   <span>&lt;!-- datalist 里面用 id  来实现和 input 链接 --></span>  
    		<span><span><span>&lt;</span>option</span><span>></span></span>刘德华<span><span><span>&lt;/</span>option</span><span>></span></span>
    		<span><span><span>&lt;</span>option</span><span>></span></span>刘若英<span><span><span>&lt;/</span>option</span><span>></span></span>
    		<span><span><span>&lt;</span>option</span><span>></span></span>刘晓庆<span><span><span>&lt;/</span>option</span><span>></span></span>
    		<span><span><span>&lt;</span>option</span><span>></span></span>郭富城<span><span><span>&lt;/</span>option</span><span>></span></span>
    		<span><span><span>&lt;</span>option</span><span>></span></span>张学友<span><span><span>&lt;/</span>option</span><span>></span></span>
    		<span><span><span>&lt;</span>option</span><span>></span></span>郭郭<span><span><span>&lt;/</span>option</span><span>></span></span>
<span><span><span>&lt;/</span>datalist</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
<li>
<p>fieldset 元素可将表单内的相关元素分组，打包      legend 搭配使用</p>
<div><pre><code><span><span><span>&lt;</span>fieldset</span><span>></span></span>
    		<span><span><span>&lt;</span>legend</span><span>></span></span>用户登录<span><span><span>&lt;/</span>legend</span><span>></span></span>  标题
    		用户名: <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span><span>></span></span><span><span><span>&lt;</span>br</span> <span>/></span></span><span><span><span>&lt;</span>br</span> <span>/></span></span>
    		密　码: <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>password<span>"</span></span><span>></span></span>
<span><span><span>&lt;/</span>fieldset</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
</ul>
<h2 id="新增的input-type属性值"> 新增的input type属性值：</h2>
<table>
<thead>
<tr>
<th><strong>类型</strong>****</th>
<th><strong>使用示例</strong>****</th>
<th><strong>含义</strong>****</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>email</strong>****</td>
<td><input type="email"></td>
<td>输入邮箱格式</td>
</tr>
<tr>
<td><strong>tel</strong>****</td>
<td><input type="tel"></td>
<td>输入手机号码格式</td>
</tr>
<tr>
<td><strong>url</strong>****</td>
<td><input type="url"></td>
<td>输入url格式</td>
</tr>
<tr>
<td><strong>number</strong>****</td>
<td><input type="number"></td>
<td>输入数字格式</td>
</tr>
<tr>
<td><strong>search</strong>****</td>
<td><input type="search"></td>
<td>搜索框（体现语义化）</td>
</tr>
<tr>
<td><strong>range</strong>****</td>
<td><input type="range"></td>
<td>自由拖动滑块</td>
</tr>
<tr>
<td><strong>time</strong>****</td>
<td><input type="time"></td>
<td>小时分钟</td>
</tr>
<tr>
<td><strong>date</strong>****</td>
<td><input type="date"></td>
<td>年月日</td>
</tr>
<tr>
<td><strong>datetime</strong>****</td>
<td><input type="datetime"></td>
<td>时间</td>
</tr>
<tr>
<td><strong>month</strong>****</td>
<td><input type="month"></td>
<td>月年</td>
</tr>
<tr>
<td><strong>week</strong>****</td>
<td><input type="week"></td>
<td>星期 年</td>
</tr>
</tbody>
</table>
<h2 id="常用新属性"> 常用新属性</h2>
<table>
<thead>
<tr>
<th><strong>属性</strong></th>
<th><strong>用法</strong></th>
<th><strong>含义</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>placeholder</strong>**</td>
<td><input type="text" placeholder="请输入用户名"></td>
<td>占位符  当用户输入的时候 里面的文字消失  删除所有文字，自动返回。<em>修改占位符的样式</em>   input::placeholder { }</td>
</tr>
<tr>
<td><strong>autofocus</strong></td>
<td><input type="text" autofocus></td>
<td>规定当页面加载时 input 元素应该自动获得焦点</td>
</tr>
<tr>
<td><strong>multiple</strong></td>
<td><input type="file" multiple></td>
<td>多文件上传</td>
</tr>
<tr>
<td><strong>autocomplete</strong></td>
<td><input type="text" autocomplete="off"></td>
<td>规定表单是否应该启用自动完成功能  有2个值，一个是on 一个是off      on 代表记录已经输入的值  1.autocomplete 首先需要提交按钮 <br/>2.这个表单您必须给他名字</td>
</tr>
<tr>
<td><strong>required</strong></td>
<td><input type="text" required></td>
<td>必填项  内容不能为空</td>
</tr>
<tr>
<td><strong>accesskey</strong></td>
<td><input type="text" accesskey="s"></td>
<td>规定激活（使元素获得焦点）元素的快捷键   采用 alt + s的形式</td>
</tr>
</tbody>
</table>
<h2 id="css3-新增选择器"> CSS3 新增选择器</h2>
<h3 id="结构-位置-伪类选择器-css3"> 结构(位置)伪类选择器（CSS3)</h3>
<ul>
<li>:first-child :选取属于其父元素的首个子元素的指定选择器</li>
<li>:last-child :选取属于其父元素的最后一个子元素的指定选择器</li>
<li>:nth-child(n) ： 匹配属于其父元素的第 N 个子元素，不论元素的类型</li>
<li>:nth-last-child(n) ：选择器匹配属于其元素的第 N 个子元素的每个元素，不论元素的类型，从最后一个子元素开始计数。
n 可以是数字、关键词或公式</li>
<li></li>
</ul>
<div><pre><code><span>li:first-child</span> <span>{</span> <span>/*  选择第一个孩子 */</span>
        		<span>color</span><span>:</span> pink<span>;</span> 
        	<span>}</span>
<span>li:last-child</span> <span>{</span>   <span>/* 最后一个孩子 */</span>
        		<span>color</span><span>:</span> purple<span>;</span>
        	<span>}</span>
<span>li:nth-child(4)</span> <span>{</span>   <span>/* 选择第4个孩子  n  代表 第几个的意思 */</span> 
				<span>color</span><span>:</span> skyblue<span>;</span>
        	<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="目标伪类选择器-css3"> 目标伪类选择器(CSS3)</h3>
<p>:target目标伪类选择器 :选择器可用于选取当前活动的目标元素</p>
<div><pre><code><span>:target</span> <span>{</span>
		<span>color</span><span>:</span> red<span>;</span>
		<span>font-size</span><span>:</span> 30px<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="属性选择器"> 属性选择器</h2>
<p>选取标签带有某些特殊属性的选择器 我们成为属性选择器</p>
<div><pre><code><span>/* 获取到 拥有 该属性的元素 */</span>
<span>div[class^=font]</span> <span>{</span> <span>/*  class^=font 表示 font 开始位置就行了 */</span>
			<span>color</span><span>:</span> pink<span>;</span>
		<span>}</span>
<span>div[class$=footer]</span> <span>{</span> <span>/*  class$=footer 表示 footer 结束位置就行了 */</span>
			<span>color</span><span>:</span> skyblue<span>;</span>
		<span>}</span>
<span>div[class*=tao]</span> <span>{</span> <span>/* class*=tao  *=  表示tao 在任意位置都可以 */</span>
			<span>color</span><span>:</span> green<span>;</span>
		<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>font12<span>"</span></span><span>></span></span>属性选择器<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>font12<span>"</span></span><span>></span></span>属性选择器<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>font24<span>"</span></span><span>></span></span>属性选择器<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>font24<span>"</span></span><span>></span></span>属性选择器<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>font24<span>"</span></span><span>></span></span>属性选择器<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>24font<span>"</span></span><span>></span></span>属性选择器123<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>sub-footer<span>"</span></span><span>></span></span>属性选择器footer<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>jd-footer<span>"</span></span><span>></span></span>属性选择器footer<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>news-tao-nav<span>"</span></span><span>></span></span>属性选择器<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>news-tao-header<span>"</span></span><span>></span></span>属性选择器<span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>tao-header<span>"</span></span><span>></span></span>属性选择器<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="伪元素选择器-css3"> 伪元素选择器（CSS3)</h2>
<ol>
<li>E::first-letter文本的第一个单词或字（如中文、日文、韩文等）</li>
<li>E::first-line 文本第一行；</li>
<li>E::selection 可改变选中文本的样式；</li>
</ol>
<div><pre><code><span>p::first-letter</span> <span>{</span>
  <span>font-size</span><span>:</span> 20px<span>;</span>
  <span>color</span><span>:</span> hotpink<span>;</span>
<span>}</span>

<span>/* 首行特殊样式 */</span>
<span>p::first-line</span> <span>{</span>
  <span>color</span><span>:</span> skyblue<span>;</span>
<span>}</span>

<span>p::selection</span> <span>{</span>
  <span>/* font-size: 50px; */</span>
  <span>color</span><span>:</span> orange<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>4、E::before和E::after</p>
<p>在E元素内部的开始位置和结束位创建一个元素，该元素为行内元素，且必须要结合content属性使用。</p>
<div><pre><code><span>div::befor</span> <span>{</span>
  <span>content</span><span>:</span><span>"开始"</span><span>;</span>
<span>}</span>
<span>div::after</span> <span>{</span>
  <span>content</span><span>:</span><span>"结束"</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>E:after、E:before 在旧版本里是伪元素，CSS3的规范里“:”用来表示伪类，“::”用来表示伪元素，但是在高版本浏览器下E:after、E:before会被自动识别为E::after、E::before，这样做的目的是用来做兼容处理。</p>
<p>&quot;:&quot; 与 &quot;::&quot; 区别在于区分伪类和伪元素</p>
<p>之所以被称为伪元素，是因为他们不是真正的页面元素，html没有对应的元素，但是其所有用法和表现行为与真正的页面元素一样，可以对其使用诸如页面元素一样的css样式，表面上看上去貌似是页面的某些元素来展现，实际上是css样式展现的行为，因此被称为伪元素。是伪元素在html代码机构中的展现，可以看出无法伪元素的结构无法审查</p>
<p><strong>注意</strong></p>
<p>伪元素:before和:after添加的内容默认是inline元素**；这个两个伪元素的<code>content</code>属性，表示伪元素的内容,设置:before和:after时必须设置其<code>content</code>属性，否则伪元素就不起作用。</p>
<h2 id="背景缩放-css3"> 背景缩放(CSS3)</h2>
<p>通过background-size设置背景图片的尺寸，就像我们设置img的尺寸一样，在移动Web开发中做屏幕适配应用非常广泛。</p>
<p>其参数设置如下：</p>
<p>a) 可以设置长度单位(px)或百分比（设置百分比时，参照盒子的宽高）</p>
<p>b) 设置为cover时，会自动调整缩放比例，保证图片始终填充满背景区域，如有溢出部分则会被隐藏。我们平时用的cover 最多</p>
<p>c) 设置为contain会自动调整缩放比例，保证图片始终完整显示在背景区域。</p>
<div><pre><code><span>background-image</span><span>:</span> <span><span>url</span><span>(</span><span>'images/gyt.jpg'</span><span>)</span></span><span>;</span>
			<span>background-size</span><span>:</span> 300px 100px<span>;</span>
			<span>/* background-size: contain; */</span>
			<span>/* background-size: cover; */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="多背景-css3"> 多背景(CSS3)</h2>
<p>以逗号分隔可以设置多背景，可用于自适应布局  做法就是 用逗号隔开就好了。</p>
<ul>
<li>一个元素可以设置多重背景图像。</li>
<li>每组属性间使用逗号分隔。</li>
<li>如果设置的多重背景图之间存在着交集（即存在着重叠关系），前面的背景图会覆盖在后面的背景图之上。</li>
<li>为了避免背景色将图像盖住，背景色通常都定义在最后一组上，</li>
</ul>
<div><pre><code><span>background</span><span>:</span><span><span>url</span><span>(</span>test1.jpg<span>)</span></span> no-repeat scroll 10px 20px/50px 60px  <span>,</span>
	   <span><span>url</span><span>(</span>test1.jpg<span>)</span></span> no-repeat scroll 10px 20px/70px 90px <span>,</span>
	   <span><span>url</span><span>(</span>test1.jpg<span>)</span></span> no-repeat scroll 10px 20px/110px 130px c #aaa<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li></li>
</ul>
<h2 id="凹凸文字"> 凹凸文字</h2>
<div><pre><code><span>&lt;head>
        &lt;meta charset="utf-8">
        &lt;style>
        body</span> <span>{</span>
        	<span>background-color</span><span>:</span> #ccc<span>;</span>
        <span>}</span>
		<span>div</span> <span>{</span>
			<span>color</span><span>:</span> #ccc<span>;</span>
			<span>font</span><span>:</span> 700 80px <span>"微软雅黑"</span><span>;</span>
		<span>}</span>
		<span>div:first-child</span> <span>{</span>
			<span>/* text-shadow: 水平位置  垂直位置  模糊距离 阴影颜色; */</span>
			<span>text-shadow</span><span>:</span> 1px 1px 1px #000<span>,</span> -1px -1px 1px #fff<span>;</span>
		<span>}</span>
		<span>div:last-child</span> <span>{</span>
			<span>/* text-shadow: 水平位置  垂直位置  模糊距离 阴影颜色; */</span>
			<span>text-shadow</span><span>:</span> -1px -1px 1px #000<span>,</span> 1px 1px 1px #fff<span>;</span>
		<span>}</span>

        &lt;/style>
    &lt;/head>
    &lt;body>
    &lt;div>我是凸起的文字&lt;/div>
    &lt;div>我是凹下的文字&lt;/div>
    &lt;/body>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id="css3盒模型"> CSS3盒模型</h2>
<p>box-sizing: border-box  盒子大小为 width    就是说  padding 和 border 是包含到width里面的</p>
<p>注：上面的标注的width指的是CSS属性里设置的width: length，content的值是会自动调整的。</p>
<div><pre><code><span>div:first-child</span> <span>{</span>
			<span>width</span><span>:</span> 200px<span>;</span>
			<span>height</span><span>:</span> 200px<span>;</span>
			<span>background-color</span><span>:</span> pink<span>;</span> 
			<span>box-sizing</span><span>:</span> content-box<span>;</span>  <span>/*  就是以前的标准盒模型  w3c */</span>
			<span>padding</span><span>:</span> 10px<span>;</span>
			<span>border</span><span>:</span> 15px solid red<span>;</span>
			<span>/* 盒子大小为 width + padding + border   content-box:此值为其默认值，其让元素维持W3C的标准Box Mode */</span>
		<span>}</span>
		<span>div:last-child</span> <span>{</span>
			<span>width</span><span>:</span> 200px<span>;</span>
			<span>height</span><span>:</span> 200px<span>;</span>
			<span>background-color</span><span>:</span> purple<span>;</span>
			<span>padding</span><span>:</span> 10px<span>;</span>
			<span>box-sizing</span><span>:</span> border-box<span>;</span>   <span>/* padding border  不撑开盒子 */</span>
			<span>border</span><span>:</span> 15px solid red<span>;</span>
			<span>/* margin: 10px; */</span>
			<span>/* 盒子大小为 width    就是说  padding 和 border 是包含到width里面的 */</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="过渡-css3"> 过渡(CSS3)</h2>
<p>过渡（transition)是CSS3中具有颠覆性的特征之一，我们可以在不使用 Flash 动画或 JavaScript 的情况下，当元素从一种样式变换为另一种样式时为元素添加效果。</p>
<p>帧动画：通过一帧一帧的画面按照固定顺序和速度播放。如电影胶片</p>
<p>在CSS3里使用transition可以实现补间动画（过渡效果），并且当前元素只要有“属性”发生变化时即存在两种状态(我们用A和B代指），就可以实现平滑的过渡，为了方便演示采用hover切换两种状态，但是并不仅仅局限于hover状态来实现过渡。</p>
<p>语法格式:</p>
<div><pre><code>transition: 要过渡的属性  花费时间  运动曲线  何时开始;
如果有多组属性变化，还是用逗号隔开。
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><table>
<thead>
<tr>
<th>属性</th>
<th>描述</th>
<th>CSS</th>
</tr>
</thead>
<tbody>
<tr>
<td>transition</td>
<td>简写属性，用于在一个属性中设置四个过渡属性。</td>
<td>3</td>
</tr>
<tr>
<td>transition-property</td>
<td>规定应用过渡的 CSS 属性的名称。</td>
<td>3</td>
</tr>
<tr>
<td>transition-duration</td>
<td>定义过渡效果花费的时间。默认是 0。</td>
<td>3</td>
</tr>
<tr>
<td>transition-timing-function</td>
<td>规定过渡效果的时间曲线。默认是 &quot;ease&quot;。</td>
<td>3</td>
</tr>
<tr>
<td>transition-delay</td>
<td>规定过渡效果何时开始。默认是 0。</td>
<td>3</td>
</tr>
</tbody>
</table>
<p>如果想要所有的属性都变化过渡， 写一个all 就可以</p>
<p>transition-duration  花费时间  单位是  秒     s    比如 0.5s    这个s单位必须写      ms 毫秒</p>
<p>运动曲线   默认是 ease</p>
<p>何时开始  默认是 0s  立马开始</p>
<div><pre><code><span>div</span> <span>{</span>
			<span>width</span><span>:</span> 200px<span>;</span>
			<span>height</span><span>:</span> 100px<span>;</span>
			<span>background-color</span><span>:</span> pink<span>;</span>
			<span>/* transition: 要过渡的属性  花费时间  运动曲线  何时开始; */</span>
			<span>transition</span><span>:</span> width 0.6s ease 0s<span>,</span> height 0.3s ease-in 1s<span>;</span>
			<span>/* transtion 过渡的意思  这句话写到div里面而不是 hover里面 */</span>
  
			
<span>}</span>
<span>div:hover</span> <span>{</span>  <span>/* 鼠标经过盒子，我们的宽度变为400 */</span>

			<span>width</span><span>:</span> 600px<span>;</span>
			<span>height</span><span>:</span> 300px
<span>}</span>

<span>transition</span><span>:</span> all 0.6s<span>;</span>  <span>/* 所有属性都变化用all 就可以了  后面俩个属性可以省略 */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="_2d变形-css3-transform"> 2D变形(CSS3) transform</h2>
<p>transform是CSS3中具有颠覆性的特征之一，可以实现元素的位移、旋转、倾斜、缩放，甚至支持矩阵方式，配合过渡和即将学习的动画知识，可以取代大量之前只能靠Flash才可以实现的效果。</p>
<p>变形转换 transform    transform  变换 变形的意思             《 transformers 变形金刚》</p>
<h3 id="移动-translate-x-y"> 移动 translate(x, y)</h3>
<p>translate 移动平移的意思</p>
<div><pre><code><span>translate</span><span>(</span>50px<span>,</span>50px<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>使用translate方法来将文字或图像在水平方向和垂直方向上分别垂直移动50像素。</p>
<p>可以改变元素的位置，x、y可为负值；</p>
<div><pre><code> translate(x,y)水平方向和垂直方向同时移动（也就是X轴和Y轴同时移动）
 translateX(x)仅水平方向移动（X轴移动）
 translateY(Y)仅垂直方向移动（Y轴移动）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>.box</span> <span>{</span>
  <span>width</span><span>:</span> 499.9999px<span>;</span>
  <span>height</span><span>:</span> 400px<span>;</span>
  <span>background</span><span>:</span> pink<span>;</span>
  <span>position</span><span>:</span> absolute<span>;</span>
  <span>left</span><span>:</span>50%<span>;</span>
  <span>top</span><span>:</span>50%<span>;</span>
  <span>transform</span><span>:</span><span>translate</span><span>(</span>-50%<span>,</span>-50%<span>)</span><span>;</span>  <span>/* 走的自己的一半 */</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>让定位的盒子水平居中</p>
<h3 id="缩放-scale-x-y"> 缩放 scale(x, y)</h3>
<div><pre><code><span>transform</span><span>:</span><span>scale</span><span>(</span>0.8<span>,</span>1<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>可以对元素进行水平和垂直方向的缩放。该语句使用scale方法使该元素在水平方向上缩小了20%，垂直方向上不缩放。</p>
<div><pre><code>scale(X,Y)使元素水平方向和垂直方向同时缩放（也就是X轴和Y轴同时缩放）
scaleX(x)元素仅水平方向缩放（X轴缩放）
scaleY(y)元素仅垂直方向缩放（Y轴缩放）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>scale()的取值默认的值为1，当值设置为0.01到0.99之间的任何值，作用使一个元素缩小；而任何大于或等于1.01的值，作用是让元素放大</p>
<h3 id="旋转-rotate-deg"> 旋转 rotate(deg)</h3>
<p>可以对元素进行旋转，正值为顺时针，负值为逆时针；</p>
<div><pre><code><span>transform</span><span>:</span><span>rotate</span><span>(</span>45deg<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>注意单位是 deg 度数</p>
<h3 id="transform-origin可以调整元素转换变形的原点"> transform-origin可以调整元素转换变形的原点</h3>
<div><pre><code> <span>div</span><span>{</span><span>transform-origin</span><span>:</span> left top<span>;</span><span>transform</span><span>:</span> <span>rotate</span><span>(</span>45deg<span>)</span><span>;</span> <span>}</span>  <span>/* 改变元素原点到左上角，然后进行顺时旋转45度 */</span>    
</code></pre>
<div><span>1</span><br></div></div><p>如果是4个角，可以用 left top这些，如果想要精确的位置， 可以用  px 像素。</p>
<div><pre><code> <span>div</span><span>{</span><span>transform-origin</span><span>:</span> 10px 10px<span>;</span><span>transform</span><span>:</span> <span>rotate</span><span>(</span>45deg<span>)</span><span>;</span> <span>}</span>  <span>/* 改变元素原点到x 为10  y 为10，然后进行顺时旋转45度 */</span> 
</code></pre>
<div><span>1</span><br></div></div><h2 id="_3d变形-css3-transform"> 3D变形(CSS3) transform</h2>
<p>2d    x  y</p>
<p>3d  x  y  z</p>
<p>左手坐标系</p>
<p>伸出左手，让拇指和食指成“L”形，大拇指向右，食指向上，中指指向前方。这样我们就建立了一个左手坐标系，拇指、食指和中指分别代表X、Y、Z轴的正方向。如下图</p>
<p>CSS3中的3D坐标系与上述的3D坐标系是有一定区别的，相当于其绕着X轴旋转了180度，如下图</p>
<p>简单记住他们的坐标：</p>
<p>x左边是负的，右边是正的</p>
<p>y 上面是负的， 下面是正的</p>
<p>z 里面是负的， 外面是正的</p>
<h3 id="rotatex"> rotateX()</h3>
<p>就是沿着 x 立体旋转.</p>
<div><pre><code><span>img</span> <span>{</span>
  <span>transition</span><span>:</span>all 0.5s ease 0s<span>;</span>
<span>}</span>
<span>img:hove</span> <span>{</span>

  <span>transform</span><span>:</span><span>rotateX</span><span>(</span>180deg<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="rotatey"> rotateY()</h3>
<p>沿着y轴进行旋转</p>
<div><pre><code><span>img</span> <span>{</span>
  <span>transition</span><span>:</span>all 0.5s ease 0s<span>;</span>
<span>}</span>
<span>img:hove</span> <span>{</span>

  <span>transform</span><span>:</span><span>rotateX</span><span>(</span>180deg<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="rotatez-"> rotateZ()</h3>
<p>沿着z轴进行旋转</p>
<div><pre><code><span>img</span> <span>{</span>
  <span>transition</span><span>:</span>all .25s ease-in 0s<span>;</span>
<span>}</span>
<span>img:hover</span> <span>{</span>
  <span>/* transform:rotateX(180deg); */</span>
  <span>/* transform:rotateY(180deg); */</span>
  <span>/* transform:rotateZ(180deg); */</span>
  <span>/* transform:rotateX(45deg) rotateY(180deg) rotateZ(90deg) skew(0,10deg); */</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="透视-perspective"> 透视(perspective)</h3>
<p>电脑显示屏是一个2D平面，图像之所以具有立体感（3D效果），其实只是一种视觉呈现，通过透视可以实现此目的。</p>
<p>透视可以将一个2D平面，在转换的过程当中，呈现3D效果。</p>
<ul>
<li>透视原理： 近大远小 。</li>
<li>浏览器透视：把近大远小的所有图像，透视在屏幕上。</li>
<li>perspective：视距，表示视点距离屏幕的长短。视点，用于模拟透视效果时人眼的位置</li>
</ul>
<p>注：并非任何情况下需要透视效果，根据开发需要进行设置。</p>
<p>perspective 一般作为一个属性，设置给父元素，作用于所有3D转换的子元素</p>
<p>理解透视距离原理：</p>
<h3 id="translatex-x"> translateX(x)</h3>
<p>仅水平方向移动**（X轴移动）</p>
<p>主要目的实现移动效果</p>
<h3 id="translatey-y"> translateY(y)</h3>
<p>仅垂直方向移动（Y轴移动）</p>
<h3 id="translatez-z"> translateZ(z)</h3>
<p>transformZ的直观表现形式就是大小变化，实质是XY平面相对于视点的远近变化（说远近就一定会说到离什么参照物远或近，在这里参照物就是perspective属性）。比如设置了perspective为200px;那么transformZ的值越接近200，就是离的越近，看上去也就越大，超过200就看不到了，因为相当于跑到后脑勺去了，我相信你正常情况下，是看不到自己的后脑勺的。</p>
<h3 id="translate3d-x-y-z"> translate3d(x,y,z)</h3>
<h3 id="backface-visibility"> backface-visibility</h3>
<p>backface-visibility 属性定义当元素不面向屏幕时是否可见。</p>
<h3 id="翻转盒子案例"> 翻转盒子案例</h3>
<h2 id="动画-css3-animation"> 动画(CSS3) animation</h2>
<p>动画是CSS3中具有颠覆性的特征之一，可通过设置多个节点来精确控制一个或一组动画，常用来实现复杂的动画效果。</p>
<p>语法格式：</p>
<div><pre><code><span>animation</span><span>:</span>动画名称 动画时间 运动曲线  何时开始  播放次数  是否反方向<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>关于几个值，除了名字，动画时间，延时有严格顺序要求其它随意r</p>
<div><pre><code><span><span>@keyframes</span> 动画名称</span> <span>{</span>
  <span>from</span><span>{</span> 开始位置 <span>}</span>  <span>0%
  to</span><span>{</span>  结束  <span>}</span>  100%
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code>animation-iteration-count:infinite;  无限循环播放
animation-play-state:paused;   暂停动画&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="伸缩布局-css3"> 伸缩布局(CSS3)</h2>
<p>CSS3在布局方面做了非常大的改进，使得我们对块级元素的布局排列变得十分灵活，适应性非常强，其强大的伸缩性，在响应式开中可以发挥极大的作用。</p>
<p>主轴：Flex容器的主轴主要用来配置Flex项目，默认是水平方向</p>
<p>侧轴：与主轴垂直的轴称作侧轴，默认是垂直方向的</p>
<p>方向：默认主轴从左向右，侧轴默认从上到下</p>
<p>主轴和侧轴并不是固定不变的，通过flex-direction可以互换。</p>
<p>Flex布局的语法规范经过几年发生了很大的变化，也给Flexbox的使用带来一定的局限性，因为语法规范版本众多，浏览器支持不一致，致使Flexbox布局使用不多</p>
<p><strong>2、各属性详解</strong>****</p>
<p>1.flex子项目在主轴的缩放比例，不指定flex属性，则不参与伸缩分配</p>
<p>min-width  最小值      min-width: 280px  最小宽度  不能小于 280</p>
<p>max-width: 1280px  最大宽度  不能大于 1280</p>
<p>2.flex-direction调整主轴方向（默认为水平方向）</p>
<p>flex-direction: column 垂直排列</p>
<p>flex-direction: row  水平排列</p>
<p>http://m.ctrip.com/html5/   携程网手机端地址</p>
<p>3、justify-content调整主轴对齐（水平对齐）</p>
<p>子盒子如何在父盒子里面水平对齐</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
<th>白话文</th>
</tr>
</thead>
<tbody>
<tr>
<td>flex-start</td>
<td>默认值。项目位于容器的开头。</td>
<td>让子元素从父容器的开头开始排序但是盒子顺序不变</td>
</tr>
<tr>
<td>flex-end</td>
<td>项目位于容器的结尾。</td>
<td>让子元素从父容器的后面开始排序但是盒子顺序不变</td>
</tr>
<tr>
<td>center</td>
<td>项目位于容器的中心。</td>
<td>让子元素在父容器中间显示</td>
</tr>
<tr>
<td>space-between</td>
<td>项目位于各行之间留有空白的容器内。</td>
<td>左右的盒子贴近父盒子，中间的平均分布空白间距</td>
</tr>
<tr>
<td>space-around</td>
<td>项目位于各行之前、之间、之后都留有空白的容器内。</td>
<td>相当于给每个盒子添加了左右margin外边距</td>
</tr>
</tbody>
</table>
<p>4、align-items调整侧轴对齐（垂直对齐）</p>
<p>子盒子如何在父盒子里面垂直对齐（单行）</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
<th>白话文</th>
</tr>
</thead>
<tbody>
<tr>
<td>stretch</td>
<td>默认值。项目被拉伸以适应容器。</td>
<td>让子元素的高度拉伸适用父容器（子元素不给高度的前提下)</td>
</tr>
<tr>
<td>center</td>
<td>项目位于容器的中心。</td>
<td>垂直居中</td>
</tr>
<tr>
<td>flex-start</td>
<td>项目位于容器的开头。</td>
<td>垂直对齐开始位置 上对齐</td>
</tr>
<tr>
<td>flex-end</td>
<td>项目位于容器的结尾。</td>
<td>垂直对齐结束位置 底对齐</td>
</tr>
</tbody>
</table>
<p>5、flex-wrap控制是否换行</p>
<p>当我们子盒子内容宽度多于父盒子的时候如何处理</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>nowrap</td>
<td>默认值。规定灵活的项目不拆行或不拆列。  不换行，则 收缩（压缩） 显示  强制一行内显示</td>
</tr>
<tr>
<td>wrap</td>
<td>规定灵活的项目在必要的时候拆行或拆列。</td>
</tr>
<tr>
<td>wrap-reverse</td>
<td>规定灵活的项目在必要的时候拆行或拆列，但是以相反的顺序。</td>
</tr>
</tbody>
</table>
<p>6、flex-flow是flex-direction、flex-wrap的简写形式</p>
<div><pre><code><span>flex-flow</span><span>:</span> flex-direction  flex-wrap<span>;</span>  
</code></pre>
<div><span>1</span><br></div></div><p>两个中间用空格</p>
<p>例如：</p>
<div><pre><code><span>display</span><span>:</span> flex<span>;</span>
<span>/* flex-direction: row;
flex-wrap: wrap;   这两句话等价于下面的这句话*/</span>
<span>flex-flow</span><span>:</span> column wrap<span>;</span>  <span>/* 两者的综合 */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>7、align-content堆栈（由flex-wrap产生的独立行）多行垂直对齐方式齐</p>
<p>align-content是针对flex容器里面多轴(多行)的情况,align-items是针对一行的情况进行排列。</p>
<p>必须对父元素设置自由盒属性display:flex;，并且设置排列方式为横向排列flex-direction:row;并且设置换行，flex-wrap:wrap;这样这个属性的设置才会起作用。</p>
<table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
<th>测试</th>
</tr>
</thead>
<tbody>
<tr>
<td>stretch</td>
<td>默认值。项目被拉伸以适应容器。</td>
<td></td>
</tr>
<tr>
<td>center</td>
<td>项目位于容器的中心。</td>
<td></td>
</tr>
<tr>
<td>flex-start</td>
<td>项目位于容器的开头。</td>
<td></td>
</tr>
<tr>
<td>flex-end</td>
<td>项目位于容器的结尾。</td>
<td></td>
</tr>
<tr>
<td>space-between</td>
<td>项目位于各行之间留有空白的容器内。</td>
<td></td>
</tr>
<tr>
<td>space-around</td>
<td>项目位于各行之前、之间、之后都留有空白的容器内。</td>
<td></td>
</tr>
</tbody>
</table>
<p>8、order控制子项目的排列顺序，正序方式排序，从小到大</p>
<p>用css 来控制盒子的前后顺序。  用order 就可以</p>
<p>用整数值来定义排列顺序，数值小的排在前面。可以为负值。 默认值是 0</p>
<div><pre><code><span>order</span><span>:</span> 1<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="文字阴影-css3"> 文字阴影(CSS3)</h2>
<p>以后我们可以给我们的文字添加阴影效果了  Shadow  影子</p>
<div><pre><code><span>text-shadow</span><span>:</span>水平位置 垂直位置 模糊距离 阴影颜色<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ol>
<li>前两项是必须写的。  后两项可以选写。</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/frontEnd/html/</link>
      <guid>https://wangyawei.top/views/frontEnd/html/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>HTML</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些和html相关的知识点；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>ES6</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-00/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-00/</guid>
      <source url="https://wangyawei.top/rss.xml">ES6</source>
      <category>es6</category>
      <pubDate>Sun, 02 May 2021 16:07:22 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p><code>ES6</code>代表着 JS 这门语言最新的标准。目前以<code>Chrome</code>为首的现代浏览器已经基本实现了ES6的大多数新特性，即使在不支持ES6的浏览器上，开发者也可以通过转译工具如<code>Babel</code>将ES6代码转译为ES5代码来实现兼容。</p>
</blockquote>
<h2 id="symbol"> Symbol</h2>
<h3 id="概述"> 概述</h3>
<ol>
<li>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示<strong>独一无二的值</strong>。它是 JavaScript 语言的<strong>第七种数据类型</strong>，前六种是：<code>undefined</code>、<code>null</code>、<code>Boolean</code>、<code>String</code>、<code>Number</code>、<code>Object</code></li>
<li>直接调用<code>Symbol</code>函数即可生成一个Symbol。
<ul>
<li><strong>注意：</strong><code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。</li>
</ul>
</li>
<li><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</li>
</ol>
<div><pre><code><span>let</span> s1 <span>=</span> <span>Symbol</span><span>(</span><span>'foo'</span><span>)</span><span>;</span>
<span>let</span> s2 <span>=</span> <span>Symbol</span><span>(</span><span>'bar'</span><span>)</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>s1<span>)</span> <span>// Symbol(foo)</span>
console<span>.</span><span>log</span><span>(</span>s2<span>)</span> <span>// Symbol(bar)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>
<p><strong>注意</strong>:<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p>
</blockquote>
<div><pre><code><span>// 没有参数的情况</span>
<span>let</span> s1 <span>=</span> <span>Symbol</span><span>(</span><span>)</span><span>;</span>
<span>let</span> s2 <span>=</span> <span>Symbol</span><span>(</span><span>)</span><span>;</span>

s1 <span>===</span> s2 <span>// false</span>

<span>// 有参数的情况</span>
<span>let</span> s1 <span>=</span> <span>Symbol</span><span>(</span><span>'foo'</span><span>)</span><span>;</span>
<span>let</span> s2 <span>=</span> <span>Symbol</span><span>(</span><span>'foo'</span><span>)</span><span>;</span>

s1 <span>===</span> s2 <span>// false</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="symbol作为属性"> Symbol作为属性</h3>
<p>Symbol 值可以作为标识符，用于对象的属性名，由于每一个 Symbol 值都是不相等的，这意味着就能保证不会出现同名的属性，能防止某一个键被不小心改写或覆盖的情况。</p>
<blockquote>
<p><strong>注意</strong>：在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
</blockquote>
<div><pre><code><span>let</span> mySymbol <span>=</span> <span>Symbol</span><span>(</span><span>)</span><span>;</span>

<span>// 第一种写法</span>
<span>let</span> a <span>=</span> <span>{</span><span>}</span><span>;</span>
a<span>[</span>mySymbol<span>]</span> <span>=</span> <span>'Hello!'</span><span>;</span>

<span>// 第二种写法</span>
<span>let</span> a <span>=</span> <span>{</span>
  <span>[</span>mySymbol<span>]</span><span>:</span> <span>'Hello!'</span>
<span>}</span><span>;</span>

<span>// 第三种写法</span>
<span>let</span> a <span>=</span> <span>{</span><span>}</span><span>;</span>
Object<span>.</span><span>defineProperty</span><span>(</span>a<span>,</span> mySymbol<span>,</span> <span>{</span> value<span>:</span> <span>'Hello!'</span> <span>}</span><span>)</span><span>;</span>

<span>// 以上写法都得到同样结果</span>
a<span>[</span>mySymbol<span>]</span> <span>// "Hello!"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有 Symbol 属性名。</p>
<h3 id="symbol-for"> Symbol.for</h3>
<p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p>
<div><pre><code><span>let</span> s1 <span>=</span> Symbol<span>.</span><span>for</span><span>(</span><span>'foo'</span><span>)</span><span>;</span>
<span>let</span> s2 <span>=</span> Symbol<span>.</span><span>for</span><span>(</span><span>'foo'</span><span>)</span><span>;</span>

s1 <span>===</span> s2 <span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值。</p>
<h3 id="内置symbol"> 内置Symbol</h3>
<p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p>
<ul>
<li><code>Symbol.hasInstance</code></li>
<li><code>Symbol.isConcatSpreadable</code></li>
<li><code>Symbol.species</code></li>
<li><code>Symbol.match</code></li>
<li><code>Symbol.replace</code></li>
<li><code>Symbol.search</code></li>
<li><code>Symbol.split</code></li>
<li><code>Symbol.toPrimitive</code></li>
<li><code>Symbol.toStringTag</code></li>
<li><code>Symbol.unscopables</code></li>
<li><code>Symbol.iterator</code>，对象的<code>Symbol.iterator</code>属性，指向该对象的默认生成<code>遍历器</code>的方法。</li>
</ul>
<h3 id="实例"> 实例：</h3>
<h4 id="消除魔术字符串"> 消除魔术字符串</h4>
<div><pre><code><span>function</span> <span>getArea</span><span>(</span><span>shape<span>,</span> options</span><span>)</span> <span>{</span>
  <span>let</span> area <span>=</span> <span>0</span><span>;</span>

  <span>switch</span> <span>(</span>shape<span>)</span> <span>{</span>
    <span>case</span> <span>'Triangle'</span><span>:</span> <span>// 魔术字符串</span>
      area <span>=</span> <span>.5</span> <span>*</span> options<span>.</span>width <span>*</span> options<span>.</span>height<span>;</span>
      <span>break</span><span>;</span>
    <span>/* ... more code ... */</span>
  <span>}</span>

  <span>return</span> area<span>;</span>
<span>}</span>

<span>getArea</span><span>(</span><span>'Triangle'</span><span>,</span> <span>{</span> width<span>:</span> <span>100</span><span>,</span> height<span>:</span> <span>100</span> <span>}</span><span>)</span><span>;</span> <span>// 魔术字符串</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>上面代码中，字符串<code>Triangle</code>就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p>
<p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p>
<div><pre><code><span>const</span> shapeType <span>=</span> <span>{</span>
  triangle<span>:</span> <span>'Triangle'</span>
<span>}</span><span>;</span>

<span>function</span> <span>getArea</span><span>(</span><span>shape<span>,</span> options</span><span>)</span> <span>{</span>
  <span>let</span> area <span>=</span> <span>0</span><span>;</span>
  <span>switch</span> <span>(</span>shape<span>)</span> <span>{</span>
    <span>case</span> shapeType<span>.</span>triangle<span>:</span>
      area <span>=</span> <span>.5</span> <span>*</span> options<span>.</span>width <span>*</span> options<span>.</span>height<span>;</span>
      <span>break</span><span>;</span>
  <span>}</span>
  <span>return</span> area<span>;</span>
<span>}</span>

<span>getArea</span><span>(</span>shapeType<span>.</span>triangle<span>,</span> <span>{</span> width<span>:</span> <span>100</span><span>,</span> height<span>:</span> <span>100</span> <span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>但是如果没有办法保证有人写了一句</p>
<div><pre><code><span>const</span> shapeType <span>=</span> <span>{</span>
  triangle<span>:</span> <span>'Triangle'</span><span>,</span>
  rectangle<span>:</span><span>'Triangle'</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>接下来一旦出现bug会很难调试</p>
<p>如果仔细分析，可以发现<code>shapeType.triangle</code>等于哪个值并不重要，只要确保不会跟其他<code>shapeType</code>属性的值冲突即可。因此，这里就很适合改用 Symbol 值。</p>
<div><pre><code><span>const</span> shapeType <span>=</span> <span>{</span>
  triangle<span>:</span> <span>Symbol</span><span>(</span><span>)</span><span>,</span>
  rectangle<span>:</span><span>Symbol</span><span>(</span><span>)</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="实现私有属性"> 实现私有属性</h4>
<blockquote>
<p>可以简单的理解为：在函数的内部用 变量 声明的属性为私有属性；</p>
</blockquote>
<p>第一种方式：用一个字符串或者下划线的方式(和别人约定的)</p>
<div><pre><code><span>var</span> Person <span>=</span> <span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> _name <span>=</span> <span><span>`</span><span>_name</span><span>`</span></span> <span>// 私有属性</span>
    <span>// 或者 let name = 'shfjkshfkjsjkf'</span>
    <span>function</span> <span>Person</span><span>(</span><span>name</span><span>)</span> <span>{</span>
        <span>this</span><span>[</span>_name<span>]</span> <span>=</span> name<span>;</span>
    <span>}</span>

    <span>Person</span><span>.</span>prototype<span>.</span><span>getName</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>this</span><span>[</span>_name<span>]</span><span>;</span>
    <span>}</span><span>;</span>

    <span>return</span> Person<span>;</span>
<span>}</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>缺点很显然，不是真正的私有，依然可以遍历<code>Object.keys()</code></p>
<p>第二种方式：闭包</p>
<div><pre><code><span>var</span> Person <span>=</span> <span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>function</span> <span>Person</span><span>(</span><span>name</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>getName</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
            <span>return</span> name<span>;</span>
        <span>}</span><span>;</span>
    <span>}</span>

    <span>return</span> Person<span>;</span>
<span>}</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>真的私有了，但是仍然存在缺点：实例无法共享方法，浪费内存空间</p>
<p>第三种方式：使用<code>Symbol</code></p>
<div><pre><code><span>var</span> Person <span>=</span> <span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>var</span> nameSymbol <span>=</span> <span>Symbol</span><span>(</span><span>'name'</span><span>)</span><span>;</span>

    <span>function</span> <span>Person</span><span>(</span><span>name</span><span>)</span> <span>{</span>
        <span>this</span><span>[</span>nameSymbol<span>]</span> <span>=</span> name<span>;</span>
    <span>}</span>

    <span>Person</span><span>.</span>prototype<span>.</span><span>getName</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>this</span><span>[</span>nameSymbol<span>]</span><span>;</span>
    <span>}</span><span>;</span>

    <span>return</span> Person<span>;</span>
<span>}</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>缺陷：仍然会被<code>Object.getOwnPropertySymbols</code>获取到属性，进而修改该属性对应的值</p>
<h2 id="set和weakset"> Set和WeakSet</h2>
<h3 id="set"> Set</h3>
<p>ES6 提供了新的数据结构 <code>Set</code>。它类似于数组，但是成员的值都是唯一的，<strong>没有重复的值</strong>。需要记录不同成员的又不希望重复记录的情况下可以用到<code>Set</code></p>
<p>如何生成Set：</p>
<div><pre><code><span>let</span> set1 <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span>
<span>let</span> set2 <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>]</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>Set 实例的属性：</p>
<ul>
<li><code>Set.prototype.size</code>：返回<code>Set</code>实例的成员总数。</li>
</ul>
<p>Set 实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。</p>
<p>四个操作方法：</p>
<ul>
<li><code>Set.prototype.add(value)</code>：添加某个值，返回 Set 结构本身。</li>
<li><code>Set.prototype.delete(value)</code>：删除某个值，返回一个布尔值，表示删除是否成功。</li>
<li><code>Set.prototype.has(value)</code>：返回一个布尔值，表示该值是否为<code>Set</code>的成员。</li>
<li><code>Set.prototype.clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<p>由于Set中值不会重复，可以用来Set来做数组去重</p>
<p>四个遍历方法：</p>
<ul>
<li><code>Set.prototype.keys()</code>：返回键名遍历器</li>
<li><code>Set.prototype.values()</code>：返回键值遍历器</li>
<li><code>Set.prototype.entries()</code>：返回键值对遍历器</li>
<li><code>Set.prototype.forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
<p>注意：Set实例中key和value是一样的，所以<code>keys()</code>和<code>values()</code>这两个方法的结果是一样的</p>
<h4 id="实例-2"> 实例</h4>
<p>Set中查找某个值是否已经存在的时间复杂度是O(1)，而数组的<code>indexOf</code>方法时间复杂度是O(n)，又由于Set中值不会重复，所以可以使用Set做数组去重：</p>
<div><pre><code><span>//使用indexOf 缺点：时间复杂度O(n^2)性能低下, NaN要做特殊处理</span>
<span>function</span> <span>deduplicate1</span><span>(</span><span>arr</span><span>)</span> <span>{</span>
  <span>let</span> temp <span>=</span><span>[</span><span>]</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span><span>(</span>temp<span>.</span><span>indexOf</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span> <span>===</span> <span>-</span><span>1</span><span>)</span><span>{</span>
      temp<span>.</span><span>push</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> temp
<span>}</span>

<span>//使用对象解决性能问题 但是数组里不能有对象，null，undefined，Boolean值，也无法区分字符串和数字</span>
<span>function</span> <span>deduplicate2</span><span>(</span><span>arr</span><span>)</span> <span>{</span>
  <span>let</span> temp <span>=</span> <span>{</span><span>}</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span><span>(</span><span>!</span>temp<span>[</span>arr<span>[</span>i<span>]</span><span>]</span><span>)</span><span>{</span>
      temp<span>[</span>arr<span>[</span>i<span>]</span><span>]</span> <span>=</span> <span>true</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> Object<span>.</span><span>keys</span><span>(</span>temp<span>)</span>
<span>}</span>

<span>//使用Set来去重</span>
<span>function</span> <span>deduplicate3</span><span>(</span><span>arr</span><span>)</span> <span>{</span>
  <span>let</span> temp <span>=</span> <span>[</span><span>...</span><span>(</span><span>new</span> <span>Set</span><span>(</span>arr<span>)</span><span>)</span><span>]</span>
  <span>return</span> temp
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="weakset"> WeakSet</h3>
<p><code>WeakSet</code> 结构与 <code>Set</code> 类似，也是不重复的值的集合。但是，它与 <code>Set</code> 有两个区别。</p>
<ul>
<li>
<p><code>WeakSet</code> 的成员只能是对象，而不能是其他类型的值。</p>
</li>
<li>
<p><code>WeakSet</code> 中的对象都是弱引用</p>
</li>
</ul>
<p>如果一个对象没有任何引用，那么此对象会尽快被垃圾回收，释放掉它占用的内存。</p>
<p>即垃圾回收机制不考虑 <code>WeakSet</code> 对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于 <code>WeakSet</code> 之中。</p>
<p><code>WeakSet</code> 结构有以下三个方法。</p>
<ul>
<li><code>WeakSet.prototype.add(value)</code>：向 WeakSet 实例添加一个新成员。</li>
<li><code>WeakSet.prototype.delete(value)</code>：清除 WeakSet 实例的指定成员。</li>
<li><code>WeakSet.prototype.has(value)</code>：返回一个布尔值，表示某个值是否在<code>WeakSet</code> 实例之中。</li>
</ul>
<p><strong><code>WeakSet</code> 不能遍历</strong>，是因为成员都是弱引用，随时可能消失。</p>
<p>示例：</p>
<div><pre><code><span>let</span> div <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>'div'</span><span>)</span>
<span>let</span> set <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span>
set<span>.</span><span>add</span><span>(</span>div<span>)</span>
<span>//...some code</span>
document<span>.</span>body<span>.</span><span>removeChild</span><span>(</span>div<span>)</span>
div <span>=</span> <span>null</span> <span>//dom对象仍在内存中，因为Set中仍然引用此对象</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>let</span> div <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>'div'</span><span>)</span>
<span>let</span> weakset <span>=</span> <span>new</span> <span>WeakSet</span><span>(</span><span>)</span>
weakset<span>.</span><span>add</span><span>(</span>div<span>)</span>
<span>//...some code</span>
document<span>.</span>body<span>.</span><span>removeChild</span><span>(</span>div<span>)</span>
div <span>=</span> <span>null</span> <span>//dom对象的已经没有引用，将被垃圾回收机制回收</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="map和weakmap"> Map和WeakMap</h2>
<h3 id="map"> Map</h3>
<p>JavaScript 的对象（Object），本质上是键值对的集合（Hash 结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。</p>
<p>为了解决这个问题，ES6 提供了 Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键，是一种更完善的 Hash 结构实现。</p>
<p>生成Map实例：</p>
<div><pre><code><span>const</span> map1 <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>;</span>
<span>const</span> map2 <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>[</span>
  <span>[</span><span>'name'</span><span>,</span> <span>'张三'</span><span>]</span><span>,</span>
  <span>[</span><span>'title'</span><span>,</span> <span>'Author'</span><span>]</span>
<span>]</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>Map 实例的属性：</p>
<ul>
<li><code>Map.prototype.size</code>：返回<code>Map</code>实例的成员总数。</li>
</ul>
<p>Map实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。</p>
<p>四个操作方法：</p>
<ul>
<li><code>Map.prototype.set(key,value)</code>：设置键名<code>key</code>对应的键值为<code>value</code>，然后返回整个 Map 结构。如果<code>key</code>已经有值，则键值会被更新，否则就新生成该键。</li>
<li><code>Map.prototype.get(key)</code>：读取<code>key</code>对应的键值，如果找不到<code>key</code>，返回<code>undefined</code>。</li>
<li><code>Map.prototype.has(key)</code>：返回一个布尔值，表示某个键是否在当前 Map 对象之中。</li>
<li><code>Map.prototype.delete(key)</code>：删除某个键，返回<code>true</code>。如果删除失败，返回<code>false</code>。</li>
<li><code>Map.prototype.clear()</code>：清除所有成员，没有返回值。</li>
</ul>
<p>四个遍历方法：</p>
<ul>
<li><code>Map.prototype.keys()</code>：返回键名遍历器</li>
<li><code>Map.prototype.values()</code>：返回键值遍历器</li>
<li><code>Map.prototype.entries()</code>：返回键值对遍历器</li>
<li><code>Map.prototype.forEach()</code>：使用回调函数遍历每个成员</li>
</ul>
<h4 id="实例1-扩展对象"> 实例1：扩展对象</h4>
<p>当我们有一系列对象，想记录每个对象一种属性。假设有100只鸡，需要记录每只鸡的重量，有两种思路：</p>
<ol>
<li>想办法用笔写到鸡身上</li>
<li>记录到一个本本上</li>
</ol>
<div><pre><code><span>class</span> <span>Chicken</span> <span>{</span>
<span>}</span>
<span>// 100只鸡</span>
<span>let</span> chickenList <span>=</span> <span>[</span><span>]</span>
<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>100</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
  chickenList<span>.</span><span>push</span><span>(</span><span>new</span> <span>Chicken</span><span>(</span><span>)</span><span>)</span>
<span>}</span>
                   
<span>// 方法1:记录到鸡身上</span>
chickenList<span>.</span><span>forEach</span><span>(</span><span>function</span><span>(</span><span>chicken<span>,</span> index</span><span>)</span><span>{</span>
	chicken<span>.</span>weight <span>=</span> <span>getWeight</span><span>(</span>chicken<span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>// 方法2:记录到本本上</span>
<span>let</span> notebook <span>=</span> <span>[</span><span>]</span><span>;</span>
chickenList<span>.</span><span>forEach</span><span>(</span><span>function</span><span>(</span><span>chicken<span>,</span> index</span><span>)</span><span>{</span>
	notebook<span>[</span>index<span>]</span> <span>=</span> <span>getWeight</span><span>(</span>chicken<span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>第1种思路存在以下问题：</p>
<ol>
<li>破坏了鸡的卖相，有时候这是很严重的事情，比如你想把一只5斤的鸡当成6斤卖出去，结果鸡身上直接写“我只有5斤”（修改了原有对象，可能导致意外的行为）</li>
<li>可能碰到一些战斗鸡，一个字都写不上去（对象冻结了或者有不可覆盖的属性）</li>
<li>可能写到一些本来就写了字的地方，导致根本看不清（与对象原有属性冲突）</li>
</ol>
<p>再看第2种方法，存在以下问题：</p>
<ol>
<li>本本无法和鸡精准地一一对应，只能靠一些索引或者标记（例如给每只鸡起一个名字）去（不可靠）地记录对应关系（无法精准地对比到是哪一个对象）</li>
</ol>
<p>这时候就可以使用<code>Map</code>扩展对象</p>
<div><pre><code><span>// 记录到另一个本本上</span>
<span>let</span> notebook <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>;</span>
chickenList<span>.</span><span>forEach</span><span>(</span><span>function</span><span>(</span><span>chicken<span>,</span> index</span><span>)</span><span>{</span>
	notebook<span>.</span><span>set</span><span>(</span>chicken<span>,</span> <span>getWeight</span><span>(</span>chicken<span>)</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h4 id="实例2-完善私有属性的实现"> 实例2：完善私有属性的实现</h4>
<p>回顾之前的<code>Symbol</code>实现的私有属性的版本里，仍然存在着可以被特殊api遍历的缺陷。</p>
<p>基于<code>Map</code>的解决思路：</p>
<p>用一个闭包内的<code>Map</code>来扩展每个生成的对象</p>
<div><pre><code><span>var</span> Person <span>=</span> <span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> map <span>=</span> <span>new</span> <span>Map</span><span>(</span><span>)</span><span>;</span>

  <span>function</span> <span>Person</span><span>(</span><span>name</span><span>)</span> <span>{</span>
    map<span>.</span><span>set</span><span>(</span><span>this</span><span>,</span>name<span>)</span><span>;</span>
  <span>}</span>

  <span>Person</span><span>.</span>prototype<span>.</span><span>getName</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> map<span>.</span><span>get</span><span>(</span><span>this</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>

  <span>return</span> Person<span>;</span>
<span>}</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="weakmap"> WeakMap</h3>
<p>与之前介绍的<code>WeakSet</code>  类似，<code>WeakMap</code>与 <code>Map</code> 有两个区别。</p>
<ul>
<li><code>WeakMap</code>的键只能是对象，而不能是其他类型的值。</li>
<li><code>WeakMap</code> 中对键的引用是弱引用</li>
</ul>
<p>同样地，<strong><code>WeakMap</code> 不能遍历</strong>，是因为成员都是弱引用，随时可能消失。</p>
<p><code>WeakMap</code>只有四个方法可用：<code>get()</code>、<code>set()</code>、<code>has()</code>、<code>delete()</code>。</p>
<p>注意：<code>WeakMap</code> 弱引用的只是键名，而不是键值。键值依然是正常引用。</p>
<div><pre><code><span>const</span> wm <span>=</span> <span>new</span> <span>WeakMap</span><span>(</span><span>)</span><span>;</span>
<span>let</span> key <span>=</span> <span>{</span><span>}</span><span>;</span>
<span>let</span> obj <span>=</span> <span>{</span>foo<span>:</span> <span>1</span><span>}</span><span>;</span>

wm<span>.</span><span>set</span><span>(</span>key<span>,</span> obj<span>)</span><span>;</span>
obj <span>=</span> <span>null</span><span>;</span>
wm<span>.</span><span>get</span><span>(</span>key<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h4 id="实例-完善私有属性的实现"> 实例：完善私有属性的实现</h4>
<p>前面基于<code>Map</code>的实现还存在一个问题：</p>
<p>当<code>Person</code>实例的外部引用消除时，闭包中的<code>Map</code>仍然有<code>Person</code>实例作为键的引用，<code>Person</code>实例不会被垃圾回收，必须等到所有的<code>Person</code>实例的外部引用消除，<code>Map</code>所在的闭包也会消除,最后<code>Person</code>实例才会被垃圾回收</p>
<p>为了解决这个问题，使用<code>WeakMap</code>进一步完善：</p>
<div><pre><code><span>var</span> Person <span>=</span> <span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> wm <span>=</span> <span>new</span> <span>WeakMap</span><span>(</span><span>)</span><span>;</span>

  <span>function</span> <span>Person</span><span>(</span><span>name</span><span>)</span> <span>{</span>
    wm<span>.</span><span>set</span><span>(</span><span>this</span><span>,</span>name<span>)</span><span>;</span>
  <span>}</span>

  <span>Person</span><span>.</span>prototype<span>.</span><span>getName</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> wm<span>.</span><span>get</span><span>(</span><span>this</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>

  <span>return</span> Person<span>;</span>
<span>}</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="proxy"> Proxy</h2>
<p>在ES6之前<code>Object.defineProperty</code>可以拦截对象属性的读取和修改操作，Proxy 可以理解成比这个API更强大的，在目标对象之前架设一层的“拦截”。外界对该Proxy对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。</p>
<p>注意：只有对生成的 Proxy 实例操作才能起到拦截的作用</p>
<p>生成Proxy实例：</p>
<div><pre><code><span>var</span> proxy <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>target<span>,</span> handler<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>target ：需要代理的对象</li>
<li>handler ：拦截函数的集合</li>
</ul>
<p>如果handler是空对象则代表任何操作都不会拦截</p>
<div><pre><code><span>let</span> obj <span>=</span> <span>{</span><span>}</span>

<span>/*handler为空对象*/</span>
<span>let</span> proxy <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>obj<span>,</span> <span>{</span><span>}</span><span>)</span><span>;</span>
proxy<span>.</span>a <span>=</span> <span>1</span>
<span>//obj.a  //1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>对属性的读取进行拦截：</p>
<div><pre><code><span>var</span> proxy <span>=</span> <span>new</span> <span>Proxy</span><span>(</span><span>{</span><span>}</span><span>,</span> <span>{</span>
  <span>get</span><span>:</span> <span>function</span><span>(</span><span>target<span>,</span> property</span><span>)</span> <span>{</span>
    <span>return</span> <span>35</span><span>;</span>
  <span>}</span>
<span>}</span><span>)</span><span>;</span>

proxy<span>.</span>time <span>// 35</span>
proxy<span>.</span>name <span>// 35</span>
proxy<span>.</span>title <span>// 35</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>下面是 Proxy 支持的拦截操作一览，一共 13 种。</p>
<ul>
<li><strong>get(target, propKey, receiver)</strong>：拦截对象属性的读取，比如<code>proxy.foo</code>和<code>proxy['foo']</code>。</li>
<li><strong>set(target, propKey, value, receiver)</strong>：拦截对象属性的设置，比如<code>proxy.foo = v</code>或<code>proxy['foo'] = v</code>，返回一个布尔值。</li>
<li><strong>has(target, propKey)</strong>：拦截<code>propKey in proxy</code>的操作，返回一个布尔值。</li>
<li><strong>deleteProperty(target, propKey)</strong>：拦截<code>delete proxy[propKey]</code>的操作，返回一个布尔值。</li>
<li><strong>ownKeys(target)</strong>：拦截<code>Object.getOwnPropertyNames(proxy)</code>、<code>Object.getOwnPropertySymbols(proxy)</code>、<code>Object.keys(proxy)</code>、<code>for...in</code>循环，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而<code>Object.keys()</code>的返回结果仅包括目标对象自身的可遍历属性。</li>
<li><strong>getOwnPropertyDescriptor(target, propKey)</strong>：拦截<code>Object.getOwnPropertyDescriptor(proxy, propKey)</code>，返回属性的描述对象。</li>
<li><strong>defineProperty(target, propKey, propDesc)</strong>：拦截<code>Object.defineProperty(proxy, propKey, propDesc）</code>、<code>Object.defineProperties(proxy, propDescs)</code>，返回一个布尔值。</li>
<li><strong>getPrototypeOf(target)</strong>：拦截<code>Object.getPrototypeOf(proxy)</code>，返回一个对象。</li>
<li><strong>setPrototypeOf(target, proto)</strong>：拦截<code>Object.setPrototypeOf(proxy, proto)</code>，返回一个布尔值。如果目标对象是函数，那么还有两种额外操作可以拦截。</li>
<li><strong>apply(target, object, args)</strong>：拦截 Proxy 实例作为函数调用的操作，比如<code>proxy(...args)</code>、<code>proxy.call(object, ...args)</code>、<code>proxy.apply(...)</code>。</li>
<li><strong>construct(target, args)</strong>：拦截 Proxy 实例作为构造函数调用的操作，比如<code>new proxy(...args)</code>。</li>
<li><strong>isExtensible(target)</strong>：拦截<code>Object.isExtensible(proxy)</code>，返回一个布尔值。</li>
<li><strong>preventExtensions(target)</strong>：拦截<code>Object.preventExtensions(proxy)</code>，返回一个布尔值。</li>
</ul>
<p>Proxy给了开发者拦截语言默认行为的权限，可以不改变原有对象或函数的情况下，轻松运用在很多场景。例如：统计函数调用次数，实现响应式数据观测（Vue 3.0），实现不可变数据（Immutable）等等</p>
<h2 id="reflect"> Reflect</h2>
<p><code>Reflect</code>是 ES6 为了操作对象而提供的新 API。ES6把原先版本中很多语言层面的API，比如<code>Object.defineProperty</code> <code>delete</code> <code>in</code>等集中在了<code>Reflect</code>的静态方法上，引入<code>Reflect</code>的目的有这样几个。</p>
<p>（1） 将<code>Object</code>对象的一些明显属于语言内部的方法（比如<code>Object.defineProperty</code>），放到<code>Reflect</code>对象上。现阶段，某些方法同时在<code>Object</code>和<code>Reflect</code>对象上部署，未来的新方法将只部署在<code>Reflect</code>对象上。也就是说，从<code>Reflect</code>对象上可以拿到语言内部的方法。</p>
<p>（2） 修改某些<code>Object</code>方法的返回结果，让其变得更合理。</p>
<div><pre><code><span>// 老写法</span>
<span>try</span> <span>{</span>
  Object<span>.</span><span>defineProperty</span><span>(</span>target<span>,</span> property<span>,</span> attributes<span>)</span><span>;</span>
  <span>// success</span>
<span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
  <span>// failure</span>
<span>}</span>

<span>// 新写法</span>
<span>if</span> <span>(</span>Reflect<span>.</span><span>defineProperty</span><span>(</span>target<span>,</span> property<span>,</span> attributes<span>)</span><span>)</span> <span>{</span>
  <span>// success</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>// failure</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>（3）将命令式操作转变为函数调用，避免更多的保留字占用。比如<code>name in obj</code>和<code>delete obj[name]</code>，对应<code>Reflect.has(obj, name)</code>和<code>Reflect.deleteProperty(obj, name)</code></p>
<div><pre><code><span>// 老写法</span>
<span>'assign'</span> <span>in</span> Object <span>// true</span>

<span>// 新写法</span>
Reflect<span>.</span><span>has</span><span>(</span>Object<span>,</span> <span>'assign'</span><span>)</span> <span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>（4）<code>Reflect</code>对象的方法与<code>Proxy</code>对象的方法一一对应，想要调用默认行为，直接在<code>Reflect</code>上调用同名方法，简单可靠，省去人工写默认行为的代码。</p>
<div><pre><code><span>let</span> proxy <span>=</span> <span>new</span> <span>Proxy</span><span>(</span><span>{</span><span>}</span><span>,</span> <span>{</span>
  <span>set</span><span>:</span> <span>function</span><span>(</span><span>target<span>,</span> name<span>,</span> value<span>,</span> receiver</span><span>)</span> <span>{</span>
    <span>var</span> success <span>=</span> Reflect<span>.</span><span>set</span><span>(</span>target<span>,</span> name<span>,</span> value<span>,</span> receiver<span>)</span><span>;</span>
    <span>if</span> <span>(</span>success<span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'property '</span> <span>+</span> name <span>+</span> <span>' on '</span> <span>+</span> target <span>+</span> <span>' set to '</span> <span>+</span> value<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> success<span>;</span>
  <span>}</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>Reflect</code>对象一共有 13 个静态方法。</p>
<ul>
<li>Reflect.apply(target, thisArg, args)</li>
<li>Reflect.construct(target, args)</li>
<li>Reflect.get(target, name, receiver)</li>
<li>Reflect.set(target, name, value, receiver)</li>
<li>Reflect.defineProperty(target, name, desc)</li>
<li>Reflect.deleteProperty(target, name)</li>
<li>Reflect.has(target, name)</li>
<li>Reflect.ownKeys(target)</li>
<li>Reflect.isExtensible(target)</li>
<li>Reflect.preventExtensions(target)</li>
<li>Reflect.getOwnPropertyDescriptor(target, name)</li>
<li>Reflect.getPrototypeOf(target)</li>
<li>Reflect.setPrototypeOf(target, prototype)</li>
</ul>
<p>上面这些方法的作用，与<code>Proxy</code>对象<code>handler</code>的方法是一一对应的。</p>
<h2 id="iterator"> Iterator</h2>
<p><code>Iterator</code>（遍历器、迭代器） 是一个对象，<code>Iterator</code>对象需要包含一个<code>next</code>方法，该方法返回一个对象，此对象有两个属性，一个<code>value</code>表示当前结果，一个<code>done</code>表示是否可以继续迭代</p>
<div><pre><code><span>let</span> it <span>=</span> <span>makeIterator</span><span>(</span><span>)</span><span>;</span>

<span>function</span> <span>makeIterator</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> nextIndex <span>=</span> <span>0</span><span>;</span>
  <span>return</span> <span>{</span>
    <span>next</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
      <span>return</span> nextIndex <span>&lt;</span> <span>5</span> <span>?</span>
      <span>{</span>value<span>:</span> nextIndex<span>++</span><span>,</span> done<span>:</span> <span>false</span><span>}</span> <span>:</span>
      <span>{</span>value<span>:</span> <span>undefined</span><span>,</span> done<span>:</span> <span>true</span><span>}</span><span>;</span>
    <span>}</span>
  <span>}</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>ES6 规定，如果数据结构的<code>Symbol.iterator</code>属性是一个方法，该方法返回<code>Iterator</code>对象，就可以认为此数据结构是“可遍历的”（iterable）</p>
<div><pre><code><span>interface</span> <span>Iterable</span> <span>{</span>
  <span>[</span>Symbol<span>.</span>iterator<span>]</span><span>(</span><span>)</span> <span>:</span> Iterator<span>,</span>
<span>}</span>

<span>interface</span> <span>Iterator</span> <span>{</span>
  <span>next</span><span>(</span>value<span>?</span><span>:</span> <span>any</span><span>)</span> <span>:</span> IterationResult<span>,</span>
<span>}</span>

<span>interface</span> <span>IterationResult</span> <span>{</span>
  value<span>:</span> <span>any</span><span>,</span>
  done<span>:</span> <span>boolean</span><span>,</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>实例：</p>
<div><pre><code><span>let</span> obj <span>=</span> <span>{</span>
  <span>[</span>Symbol<span>.</span>iterator<span>]</span><span>:</span>makeIterator
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>ES6中以下场合会默认调用 <code>Iterator</code> 接口（即<code>Symbol.iterator</code>方法），</p>
<ul>
<li><code>for...of</code>循环</li>
<li>数组解构</li>
<li>扩展运算符</li>
<li><code>yield*</code></li>
<li>其他隐式调用的地方，例如 <code>new Set(['a','b'])</code>,<code>Promise.all()</code>等</li>
</ul>
<p>ES6中以下数据结构默认为可遍历对象，即默认部署了<code>Symbol.iterator</code>属性</p>
<ul>
<li>Array</li>
<li>Map</li>
<li>Set</li>
<li>String</li>
<li>函数的 arguments 对象</li>
<li>NodeList 对象</li>
</ul>
<h2 id="generator函数"> Generator函数</h2>
<h3 id="generator"> Generator</h3>
<p>Generator 函数是 ES6 提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍 Generator 函数的语法和 API，它的异步编程应用请看《Generator 函数的异步应用》一章。</p>
<p>Generator 函数有多种理解角度。语法上，首先可以把它理解成，Generator 函数是一个状态机，封装了多个内部状态。</p>
<p>执行 Generator 函数会返回一个遍历器对象，也就是说，Generator 函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历 Generator 函数内部的每一个状态。</p>
<p>形式上，Generator 函数是一个普通函数，但是有两个特征。一是，<code>function</code>关键字与函数名之间有一个星号；二是，函数体内部使用<code>yield</code>表达式，定义不同的内部状态（<code>yield</code>在英语里的意思就是“产出”）。</p>
<h2 id="async函数"> async函数</h2>
<h3 id="async"> async</h3>
]]></content:encoded>
    </item>
    <item>
      <title>基础</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-000/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-000/</guid>
      <source url="https://wangyawei.top/rss.xml">基础</source>
      <category>javascript</category>
      <pubDate>Sun, 02 May 2021 16:07:22 GMT</pubDate>
      <content:encoded><![CDATA[<h3 id="输入和输出"> 输入和输出：</h3>
<ul>
<li>prompt(&quot;请输入您的银行卡密码：&quot;);  引导信息；</li>
<li>alert('你真好看');  弹出框；</li>
<li>console.log(&quot;控制台输出的信息&quot;);</li>
<li>document.write(&quot;<h1>页面中输出123</h1>&quot;);  可以识别html标签；</li>
</ul>
<h3 id="变量的命名规范"> 变量的命名规范：</h3>
<ul>
<li>变量以字母、数字、下划线、$符号组成；</li>
<li>变量名字不能用数字作为开头、不能使用关键字或保留字；</li>
<li>变量名字是区分大小写的；</li>
</ul>
<h3 id="数据类型"> 数据类型：</h3>
<ul>
<li>简单数类型：numder(NaN)数字类型、string(字符串类型)、Boolean(布尔类型)、undefined、Null、</li>
<li>复杂数据类型：Object(对象)</li>
<li>NaN：即非数值（Not a Numder) 是一种特殊的number类型值；任何和NaN运算的结果都为NaN;和自己也不相等；</li>
</ul>
<h3 id="数据类型的相互转换"> 数据类型的相互转换：</h3>
<h4 id="其他类型转数字类型"> 其他类型转数字类型：</h4>
<ul>
<li>
<p>typeof 用来检测数据类型；</p>
</li>
<li>
<p>Number();    较为严格；</p>
<ul>
<li>一定可以转出数字类型；</li>
<li>字符串转数字：字符串中有一个不是数字字符则为NaN；</li>
<li>Boolean(布尔类型)：NaN；</li>
<li>undefined: NaN；</li>
<li>Null：0；</li>
</ul>
</li>
<li>
<p>parseInt();  转整数：</p>
<ul>
<li>字符串转整数:只要在字符串中，数字前面没有非数字字符，那么都可以将非数字前面的所有数转出整数，
否则为NaN；</li>
<li>Boolean(布尔类型)：NaN；</li>
<li>undefined: NaN；</li>
<li>NaN:  NaN;</li>
<li>Null：NaN；</li>
</ul>
</li>
<li>
<p>parseFloat();  转浮点数；</p>
</li>
</ul>
<h3 id="操作符"> 操作符：</h3>
<p>分支语句：</p>
<ul>
<li>判断的是布尔类型（隐式转换）；</li>
</ul>
<div><pre><code><span>if</span> <span>(</span><span>/* 条件表达式 */</span><span>)</span> <span>{</span>
  <span>// 执行语句</span>
<span>}</span>

<span>if</span> <span>(</span><span>/* 条件表达式 */</span><span>)</span><span>{</span>
  <span>// 成立执行语句</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>// 否则执行语句</span>
<span>}</span>

<span>if</span> <span>(</span><span>/* 条件1 */</span><span>)</span><span>{</span>
  <span>// 成立执行语句</span>
<span>}</span> <span>else</span> <span>if</span> <span>(</span><span>/* 条件2 */</span><span>)</span><span>{</span>
  <span>// 成立执行语句</span>
<span>}</span> <span>else</span> <span>if</span> <span>(</span><span>/* 条件3 */</span><span>)</span><span>{</span>
  <span>// 成立执行语句</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>// 最后默认执行语句</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id="三元表达式"> 三元表达式：</h3>
<ul>
<li>
<p>三元表达的可以说是if.....else语法的一种简化写法；</p>
</li>
<li>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>script</span><span>></span></span><span><span>
        <span>var</span> a <span>=</span> <span>10</span><span>;</span>
        <span>var</span> b <span>=</span> <span>20</span><span>;</span>
        <span>//三元表达式：</span>
        <span>var</span> c <span>=</span> a <span>=</span> b <span>?</span> a <span>:</span> b<span>;</span>
        console<span>.</span><span>log</span><span>(</span>c<span>)</span><span>;</span> <span>//10</span>
    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div></li>
</ul>
<h3 id="switch语句"> switch语句：</h3>
<ul>
<li>判断结果和常量1进行比较，若成立则执行里面的代码；所不成立则继续和常量2比较，若成立则执行里面的代码....</li>
<li>switch语句的判断是<strong>严格模式（全等比较）</strong>；</li>
<li>break可以省略，若是省略则代码会继续向下执行；</li>
</ul>
<div><pre><code><span>switch</span> <span>(</span>expression<span>)</span> <span>{</span>
  <span>case</span> 常量<span>1</span><span>:</span>
    语句<span>;</span>
    <span>break</span><span>;</span>
  <span>case</span> 常量<span>2</span><span>:</span>
    语句<span>;</span>
    <span>break</span><span>;</span>
  <span>case</span> 常量<span>3</span><span>:</span>
    语句<span>;</span>
    <span>break</span><span>;</span>
  …
  <span>case</span> 常量n<span>:</span>
    语句<span>;</span>
    <span>break</span><span>;</span>
  <span>default</span><span>:</span>
    语句<span>;</span>
    <span>break</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p>​</p>
<h3 id="清空数组"> 清空数组：</h3>
<ul>
<li>重点： arr.length = 0;可以用于清空数组；</li>
</ul>
<div><pre><code><span><span>&lt;!</span><span>doctype</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>ie=edge<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>script</span><span>></span></span><span><span>
        <span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>]</span><span>;</span>
        console<span>.</span><span>log</span><span>(</span>arr<span>.</span>length<span>)</span><span>;</span>
         <span>// 清空数组</span>
        arr<span>.</span>length <span>=</span> <span>0</span><span>;</span>
        console<span>.</span><span>log</span><span>(</span>arr<span>)</span><span>;</span>
        
        <span>// 字面量的方式创建数组有一个情况：只有一个数据</span>
      	<span>var</span> arr_1 <span>=</span> <span>[</span><span>90</span><span>]</span><span>;</span>
      	console<span>.</span><span>log</span><span>(</span>arr_1<span>)</span><span>;</span>
		<span>//构造函数的方式创建数组，如果只有一个数据，则表示长度为90的空数组；</span>
      	<span>var</span> arr_2 <span>=</span> <span>new</span> <span>Array</span><span>(</span><span>90</span><span>)</span><span>;</span> <span>// 长度为90的空数组；</span>
      	console<span>.</span><span>log</span><span>(</span>arr_2<span>)</span><span>;</span>
    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="求数组中的最大值"> 求数组中的最大值：</h3>
<ul>
<li>定义一个变量（假设为最大值）用于做比较；</li>
</ul>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>ie=edge<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>script</span><span>></span></span><span><span>
        <span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>28</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>10</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>]</span><span>;</span>
        <span>// 声明一个变量假设第一个为最大值；</span>
        <span>var</span> max <span>=</span> arr<span>[</span><span>0</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;=</span> arr<span>.</span>length <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>// 每次循环都让max做比较；</span>
            <span>// 如果假设的最大值（max）小于某个数，则把它从新赋值给max；</span>
            <span>// 如果判断不成立则继续下一次循环直到和所有的数字比较完毕；</span>
            
            <span>// 不能写成arr[0]&lt;arr[i];因为会被替换掉；要把arr[0]赋值给变量；</span>
            
            <span>// 变量max只是改变了指向，arr[0]的值没有被替换；</span>
            <span>if</span> <span>(</span>max <span>&lt;</span> arr<span>[</span>i<span>]</span><span>)</span> <span>{</span>
                max <span>=</span> arr<span>[</span>i<span>]</span>
            <span>}</span>
        <span>}</span>
        console<span>.</span><span>log</span><span>(</span>max<span>)</span><span>;</span>
    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id="求数组中的最小值"> 求数组中的最小值：</h3>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>ie=edge<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>script</span><span>></span></span><span><span>
        <span>var</span> arr <span>=</span> <span>[</span><span>12</span><span>,</span> <span>18</span><span>,</span> <span>14</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>1</span><span>]</span><span>;</span>
        <span>var</span> min <span>=</span> arr<span>[</span><span>0</span><span>]</span><span>;</span>
        <span>var</span> a<span>;</span>
        <span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;=</span> arr<span>.</span>length<span>-</span><span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>min <span>></span> arr<span>[</span>i<span>]</span><span>)</span> <span>{</span>
                min <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>
        console<span>.</span><span>log</span><span>(</span>min<span>)</span><span>;</span>
    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h3 id="求数组的平均值"> 求数组的平均值：</h3>
<ul>
<li>注意：此时的sum不能只声明不赋值；</li>
<li>平均值的结果不能放在循环里面，因为每次都会除一次。</li>
</ul>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>ie=edge<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>script</span><span>></span></span><span><span>
        <span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>]</span><span>;</span>
        <span>//注意此时的sum不能只声明不赋值；</span>
        <span>var</span> sum <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            sum <span>+=</span> arr<span>[</span>i<span>]</span><span>;</span>
            <span>//jun = sum / arr.length;===不正确！！！</span>
        <span>}</span>
        <span>// 平均值的结果不能放在循环里面，因为每次都会除一次。！！！</span>
        <span>// 之所以打印的结果是正确的，是因为最后一次是用和相除得到的结果；</span>
        <span>// 所以要放在循环外面，</span>
        <span>//定义一个变量用于接收平均值；</span>
        <span>var</span> jun <span>=</span> sum <span>/</span> arr<span>.</span>length<span>;</span>
        console<span>.</span><span>log</span><span>(</span>jun<span>)</span><span>;</span>
    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id="求数组中相同元素的次数"> 求数组中相同元素的次数：</h3>
<div><pre><code><span>&lt;</span>script<span>></span>
    <span>var</span> arr <span>=</span> <span>[</span><span>"c"</span><span>,</span> <span>"a"</span><span>,</span> <span>"z"</span><span>,</span> <span>"a"</span><span>,</span> <span>'c'</span><span>,</span><span>"x"</span><span>,</span> <span>"a"</span><span>]</span><span>;</span>
    <span>//定义：一个空对象用于存放键和值；</span>
    <span>var</span> obj <span>=</span> <span>{</span><span>}</span><span>;</span>
    <span>//循环遍历数组；</span>
    <span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>// 把当前循环的元素赋值给变量用于判断；</span>
        <span>var</span> item <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>
        <span>/*判断对象中是否有当前元素（键）；
        * 若没有则存到对象中并赋值为1，
        * 若有则在原来的基础上（值）上加1；
        * */</span>
        <span>if</span> <span>(</span>obj<span>[</span>item<span>]</span><span>)</span> <span>{</span>
            obj<span>[</span>item<span>]</span> <span>=</span> obj<span>[</span>item<span>]</span> <span>+</span> <span>1</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            obj<span>[</span>item<span>]</span> <span>=</span> <span>1</span><span>;</span>
        <span>}</span>
    <span>}</span>
    console<span>.</span><span>log</span><span>(</span>obj<span>)</span><span>;</span>
<span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="求数组最大值的下标"> 求数组最大值的下标：</h3>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>ie=edge<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>script</span><span>></span></span><span><span>
        <span>var</span> arr <span>=</span> <span>[</span><span>12</span><span>,</span> <span>18</span><span>,</span> <span>14</span><span>,</span> <span>0</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>1</span><span>]</span><span>;</span>
        <span>// 声明一个变量用于存放下标；</span>
        <span>var</span> a<span>;</span>
        <span>//假设Max是最大值，则对应的i便是最大值的下标；</span>
        <span>var</span> max <span>=</span> arr<span>[</span><span>0</span><span>]</span><span>;</span>
        <span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>max <span>&lt;</span> arr<span>[</span>i<span>]</span><span>)</span> <span>{</span>
                max <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>
                <span>/* 只要进入这个判断就说明当前
                   的这个i是这个max的下标；
                   那就把i赋值给a；
                */</span>
                a <span>=</span> i<span>;</span>
            <span>}</span>
        <span>}</span>
        console<span>.</span><span>log</span><span>(</span>max<span>,</span> a<span>)</span><span>;</span>
    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><h3 id="根据用户的输入-求一组数中的和"> 根据用户的输入，求一组数中的和：</h3>
<ul>
<li>重点：字符串的分割；数字类型的转换；</li>
<li>需注意：分割后得到的是数组；但此时还是字符串；需要转换；</li>
</ul>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>ie=edge<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>script</span><span>></span></span><span><span>
        <span>// 定义变量获取用户的输入；</span>
        <span>var</span> asus <span>=</span> <span>prompt</span><span>(</span><span>'请输入一组数字例：1，2，3'</span><span>)</span><span>;</span>
        <span>// 分割：因为我们得到的是字符串；</span>
        <span>// 分割后得到的是数组；但此时还是字符串；需要转换</span>
        <span>var</span> arr <span>=</span> asus<span>.</span><span>split</span><span>(</span><span>'，'</span><span>)</span>
        <span>// 遍历数组；</span>
        <span>// 定义变量用于求和；初始和为0；</span>
        <span>var</span> sum <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>// 获取每个字符串，并转换</span>
            <span>var</span> nam <span>=</span> <span>parseFloat</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>;</span>
            sum <span>+=</span> nam<span>;</span>
        <span>}</span>
        <span>alert</span><span>(</span><span>'和为：'</span> <span>+</span> sum<span>)</span><span>;</span>
    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="冒泡排序"> 冒泡排序：</h3>
<ul>
<li>第一步：找规律：</li>
<li>第二部：理解每个数字的比较的过程；</li>
<li>第三步：要熟练运用第三方变量的交换理念；</li>
</ul>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>ie=edge<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>script</span><span>></span></span><span><span>
        <span>// 需求: 一组数据实现从小到大或从大到少排列；</span>
        <span>var</span> arr <span>=</span> <span>[</span><span>2</span><span>,</span> <span>4</span><span>,</span> <span>16</span><span>,</span> <span>6</span><span>,</span> <span>21</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>0</span><span>]</span><span>;</span>
        <span>//分析：</span>
        <span>/* 因为每个数字都要进行一次的比较；
           而比较过的数字在下一轮不需要进行比较了；
           所以一共比较arr.length - 1轮次；
           而每个数字则比较arr.length-i次；
         */</span>
        <span>//  外循环控制比较的轮次；</span>
        <span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length <span>-</span> <span>1</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>// 内循环控制每个数字比较的次数；</span>
            <span>for</span> <span>(</span><span>var</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> arr<span>.</span>length <span>-</span> <span>1</span> <span>-</span> i<span>;</span> j<span>++</span><span>)</span> <span>{</span>
                <span>// 如果成立则进入判断；若不成立则进入下一次循环；</span>
                <span>if</span> <span>(</span>arr<span>[</span>j<span>]</span> <span>></span> arr<span>[</span>j <span>+</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
                    <span>// 第三方变量用于存放待交换的数据；</span>
                    <span>// 原理就是arr[j+1]的数据暂时赋值给a，</span>
                    <span>// 然后arr[j]的数据赋值给arr[j+1]，</span>
                    <span>// 此时的结果是arr[j+1]和arr[j]的结果相同，</span>
                    <span>// 然后把暂时存在a里面的数据从新赋值给arr[j]；</span>
                    <span>// 此时便实现了交换；</span>
                    <span>var</span> a <span>=</span> arr<span>[</span>j <span>+</span> <span>1</span><span>]</span><span>;</span>
                    arr<span>[</span>j <span>+</span> <span>1</span><span>]</span> <span>=</span> arr<span>[</span>j<span>]</span><span>;</span>
                    arr<span>[</span>j<span>]</span> <span>=</span> a<span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        console<span>.</span><span>log</span><span>(</span>arr<span>)</span><span>;</span>
    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><h3 id="知识点小节"> 知识点小节：</h3>
<ul>
<li>函数的调用若要拿到值则要有返回值；</li>
<li>返回值可以修改；若后面有值，则返回，若没有值；默认是undefined；</li>
<li>函数的调用或方法的调用若不给返回值则打印undefined;</li>
<li>return中止函数的执行；在函数的执行过程中若遇到return则立即跳出函数体；</li>
</ul>
<h3 id="形参和实参"> 形参和实参：</h3>
<ul>
<li>
<p><b>若函数定义了形参并且参与了运算，那么函数的调用就要传入实参；否则打印NaN;</b></p>
</li>
<li>
<p>形参没有赋值和变量一样为undefined;</p>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>

<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>

<span><span><span>&lt;</span>body</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>//第一种情况    </span>
    <span>function</span> <span>f1</span><span>(</span><span>a</span><span>)</span> <span>{</span>
        <span>var</span> b<span>=</span><span>8</span><span>+</span>a<span>;</span>
        console<span>.</span><span>log</span><span>(</span>b<span>)</span>
    <span>}</span>
    <span>f1</span><span>(</span><span>)</span><span>;</span><span>//NaN</span>
    
    <span>//第二种情况：</span>
     <span>function</span> <span>f1</span><span>(</span><span>a</span><span>)</span> <span>{</span>
        <span>// var b=8+a;</span>
        console<span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span>
    <span>}</span>
    <span>f1</span><span>(</span><span>)</span><span>;</span><span>//undefined</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div></li>
</ul>
<h3 id="arguments伪数组"> arguments伪数组：</h3>
<ul>
<li>arguments伪数组:可以获取所有实参的对象，<b>函数内部的变量（不是我们声明的，也不需要我们声明）</b>;</li>
<li>有下标，有长度，可遍历；</li>
<li>应用场景：当我们不知道我们的参数个数的时候；</li>
</ul>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>ie=edge<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>script</span><span>></span></span><span><span>
        <span>function</span> <span>f1</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span>arguments<span>.</span>length<span>)</span><span>;</span>
            <span>var</span> sum <span>=</span> <span>0</span><span>;</span>
            <span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arguments<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
                <span>// var sum = 0; 不能写在这里，因为每次循环都会被重新赋值给覆盖掉；</span>
                sum <span>+=</span> arguments<span>[</span>i<span>]</span><span>;</span>
            <span>}</span>
            console<span>.</span><span>log</span><span>(</span>sum<span>)</span><span>;</span>
            <span>return</span> sum<span>;</span>
        <span>}</span>
        <span>f1</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>)</span>
    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="匿名函数"> 匿名函数：</h3>
<ul>
<li>
<p>匿名函数：没有名字的函数，但是在js的语法中，是不允许匿名函数单独存在的，要配合其它语法使用；</p>
</li>
<li>
<p>匿名函数的自调用，加载页面后，自动执行一个函数；</p>
</li>
<li>
<p>也可以称为：<strong>沙箱</strong>；</p>
<ul>
<li>防止全局变量被污染；</li>
<li>沙箱不能主动去影响外部的世界；为保证沙箱的封闭；
<ul>
<li>需要传入实参：window;</li>
<li>定义形参接收window;</li>
<li>形参可以该名字，全局变量window不能改名字；</li>
</ul>
</li>
</ul>
</li>
</ul>
<div><pre><code>  <span>// 定义之后，立刻调用，输出10</span>
  <span>(</span><span>function</span><span>(</span><span>)</span><span>{</span>  
    console<span>.</span><span>log</span><span>(</span><span>10</span><span>)</span><span>;</span>  
  <span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="回调函数"> 回调函数：</h3>
<ul>
<li>
<p>函数也是数据类型，也可以作为别的函数的参数；</p>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>ie=edge<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>script</span><span>></span></span><span><span>
        <span>// fn 只不过在函数内部是一个形参，内部变量；</span>
        <span>function</span> <span>f1</span><span>(</span><span>a<span>,</span> fn</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span> <span>//10；</span>
            <span>// 函数的调用，在函数名的后面加括号；</span>
            <span>// 这样，把函数作为实参传入，传入的函数对外面函数的调用叫回调函数；</span>
            <span>fn</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>

        <span>function</span> <span>f2</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>'f2函数执行了'</span><span>)</span><span>;</span> <span>//f2函数执行了</span>
        <span>}</span>
        <span>f1</span><span>(</span><span>10</span><span>,</span> f2<span>)</span><span>;</span> <span>// 输出 10 和 'f2函数执行了' f2是f1的回调函数；</span>
    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></li>
</ul>
<h3 id="作用域"> 作用域：</h3>
<ul>
<li>
<p>全局变量：在全局作用域下用var声明的变量是全局变量；全局变量任何地方都可以访问的；</p>
</li>
<li>
<p>隐式全局变量：不使用var声明的变量；</p>
<ul>
<li>全局变量不能删除；</li>
<li>隐式全局变量可以删除；</li>
</ul>
</li>
<li>
<p>局部变量：在局部作用域下声明的变量是局部变量；</p>
</li>
<li>
<p>全局作用域：全局变量的生效范围区域；</p>
</li>
<li>
<p>局部作用域：局部变量的生效范围区域；</p>
<div><pre><code>局部变量退出作用域之后会销毁，全局变量关闭网页或浏览器才会销毁；
在es5之前没有块级作用域的的概念,只有函数作用域**，
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
<h3 id="作用域链"> 作用域链：</h3>
<ul>
<li>
<div><pre><code>只有函数可以制造作用域结构， 那么只要是代码，就至少有一个作用域, 即全局作用域。凡是代码中有函数，那么这个函数就构成另一个作用域。如果函数中还有函数，那么在这个作用域中就又可以诞生一个作用域。

将这样的所有的作用域列出来，可以有一个结构: 函数内指向函数外的链式结构。就称作作用域链。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ul>
<p><img src="./assets/20190913175051.png" alt="" /></p>
<h3 id="预解析"> 预解析：</h3>
<ul>
<li>
<p>在代码执行的过程中，js引擎会进行预解析；</p>
<ul>
<li>
<p>预解析时，变量声明在前，函数声明在后；</p>
<ul>
<li><b>在函数名和var变量名冲突的时候，预解析会舍弃var声明的变量；</b></li>
<li>原因：后来者居上；</li>
<li><b>在函数的名字和变量的名字相同的时候，若a函数的调用顺序在变量下面则会报错；</b></li>
</ul>
<p><img src="./assets/20190913180016.png" alt="" /></p>
</li>
<li>
<p><b>只能预解析用var声明的变量，没有用var声明的变量（隐式全局变量）不会被解析；</b></p>
</li>
<li>
<p>预解析会把用var声明的变量，提到当前作用域的最顶端（只是声明提前）；</p>
</li>
<li>
<p>预解析会把函数声明，提到当前作用域的最顶端（只是声明提前）；</p>
<div><pre><code>   <span>// 观察下面的代码，说出执行结果</span>
    <span>var</span> num <span>=</span> <span>10</span><span>;</span>
    <span>fun</span><span>(</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>num<span>)</span><span>;</span>

    <span>function</span> <span>fun</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span>num<span>)</span><span>;</span>
        <span>var</span> num <span>=</span> <span>20</span><span>;</span>
    <span>}</span>

<span>//结果：  undefined   10</span>

	<span>function</span> <span>fun</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span>num<span>)</span><span>;</span>
    <span>}</span>
    <span>var</span> num <span>=</span> <span>10</span><span>;</span>
    <span>fun</span><span>(</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>num<span>)</span><span>;</span>
<span>//结果：  10   10</span>

	 <span>var</span> num <span>=</span> <span>10</span><span>;</span>
    <span>fun</span><span>(</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>num<span>)</span><span>;</span>

    <span>function</span> <span>fun</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span>num<span>)</span><span>;</span>
        num <span>=</span> <span>20</span><span>;</span>
    <span>}</span>
<span>//结果：  10   20</span>


 <span>function</span> <span>f1</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span>num<span>)</span>
    <span>}</span>
    <span>// var num=20;//20</span>
    <span>f1</span><span>(</span><span>)</span><span>;</span>
    <span>var</span> num<span>=</span><span>20</span><span>;</span><span>//undefined</span>
    <span>/*
    *分析：
    *第一步预解析；
    * 函数调用的时候，var 虽然是全局变量，
    * 但是f1执行的时候，num=20还未执行，
    * 所以为undefined;
    * */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div></li>
</ul>
</li>
</ul>
<h3 id="创建对象及添加属性的方式"> 创建对象及添加属性的方式：</h3>
<ul>
<li>
<p>字面量的方式创建对象；</p>
<div><pre><code><span>//注意：属性与属性之间或属性与方法之间又 , 隔开；</span>
<span>// 字面量的方式创建对象的同时添加属性和方法；</span>
        <span>var</span> obj <span>=</span> <span>{</span>
            name<span>:</span> <span>'小明'</span><span>,</span>
            <span>say</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span>'我叫'</span> <span>+</span> obj<span>.</span>name<span>)</span><span>;</span> <span>//我叫小明</span>
                <span>//若没有返回值则打印undefined;</span>
                <span>return</span> <span>'我叫'</span> <span>+</span> obj<span>.</span>name<span>;</span>
            <span>}</span>
        <span>}</span><span>;</span>
        console<span>.</span><span>log</span><span>(</span>obj<span>.</span><span>say</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>//我叫小明</span>


<span>// 字面量的方式创建对象,并以 . 的方式添加属性和方法；</span>
<span>//注意：属性与属性之间或属性与方法之间又 ; 隔开；</span>
        <span>var</span> obj <span>=</span> <span>{</span><span>}</span><span>;</span>
        obj<span>.</span>name <span>=</span> <span>'小明'</span><span>;</span>
        obj<span>.</span><span>say</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>'我叫'</span> <span>+</span> obj<span>.</span>name<span>)</span><span>;</span> <span>//我叫小明</span>
            <span>return</span> <span>'我叫'</span> <span>+</span> obj<span>.</span>name<span>;</span>
        <span>}</span>
        console<span>.</span><span>log</span><span>(</span>obj<span>.</span><span>say</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>//我叫小明</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div></li>
<li>
<p>通过内置的构造函数创建对象；</p>
<div><pre><code><span>// 通过内置的构造函数创建对象,并以 . 的方式添加属性和方法；</span>
<span>// 注意：Object的首字母要大写；属性值要加引号！！</span>
        <span>var</span> obj <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
        obj<span>.</span>name <span>=</span> <span>'小明'</span><span>;</span>
        obj<span>.</span><span>say</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>'我叫'</span> <span>+</span> obj<span>.</span>name<span>)</span><span>;</span> <span>//我叫小明</span>
            <span>return</span> <span>'我叫'</span> <span>+</span> obj<span>.</span>name<span>;</span>
        <span>}</span>
        console<span>.</span><span>log</span><span>(</span>obj<span>.</span><span>say</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>//我叫小明</span>


<span>// 通过内置的构造函数创建对象,并以键值对的方式添加属性和方法；</span>
        <span>var</span> obj <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
        obj<span>[</span><span>'name'</span><span>]</span> <span>=</span> <span>'小明'</span><span>;</span>
        obj<span>[</span><span>'say'</span><span>]</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>'我叫'</span> <span>+</span> obj<span>.</span>name<span>)</span><span>;</span> <span>//我叫小明</span>
            <span>return</span> <span>'我叫'</span> <span>+</span> obj<span>.</span>name<span>;</span>
        <span>}</span><span>;</span>
        console<span>.</span><span>log</span><span>(</span>obj<span>.</span><span>say</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>//我叫小明</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div></li>
</ul>
<h3 id="遍历对象"> 遍历对象：</h3>
<ul>
<li>
<p>对象是一些属性和方法的集合；</p>
</li>
<li>
<p><strong>可以遍历任意形式的对象；</strong></p>
</li>
<li>
<p>对象的遍历是以键值对的方式进行的；</p>
</li>
<li>
<p><strong>此种方法不仅可以遍历对象，还可以遍历数组，此时key代表下标（从0开始）；</strong></p>
<div><pre><code> <span>var</span> obj <span>=</span> <span>{</span><span>}</span><span>;</span>
        <span>// 以键值对的方式添加属性和方法；</span>
        <span>// 语法： 对象['名字'] = "值";</span>
        <span>// 属性和属性之间以, 隔开；</span>
        obj<span>.</span>key <span>=</span> <span>'小红'</span><span>,</span>
            obj<span>[</span><span>'name'</span><span>]</span> <span>=</span> <span>"小明"</span><span>,</span>
            obj<span>[</span><span>'say'</span><span>]</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span>23</span><span>)</span><span>;</span>
            <span>}</span>
            <span>// key代表键（name  say）是字符串类型，可以自定义字母，</span>
        <span>for</span> <span>(</span><span>var</span> key <span>in</span> obj<span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span>key<span>,</span> <span>typeof</span> key<span>,</span> obj<span>[</span>key<span>]</span><span>)</span><span>;</span> <span>//say string 小红；</span>
            <span>// 若没有  obj.key = '小红',则打印 say string undefined；</span>
            console<span>.</span><span>log</span><span>(</span>key<span>,</span> <span>typeof</span> key<span>,</span> obj<span>.</span>key<span>)</span><span>;</span> <span>//say string 小红；</span>
        <span>}</span>

<span>//遍历数组；</span>
 <span>var</span> arr<span>=</span><span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>'a'</span><span>,</span><span>'ss'</span><span>,</span><span>'d'</span><span>,</span><span>'f'</span><span>]</span>
    <span>for</span> <span>(</span><span>var</span> key <span>in</span> arr<span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span>key<span>,</span>arr<span>[</span>key<span>]</span><span>)</span><span>;</span>
    <span>}</span>；
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></li>
</ul>
<h3 id="往内置对象math上添加范围随机数"> 往内置对象Math上添加范围随机数:</h3>
<div><pre><code><span>&lt;</span>script<span>></span>
        <span>// 需求：获取n-m之间的随机数、n&lt;m；</span>
        <span>// 封装函数；传入形参；设置返回值；</span>
        <span>function</span> <span>f1</span><span>(</span><span>n<span>,</span> m</span><span>)</span> <span>{</span>
            <span>// 定义变量，通过Math方法来获取随机数；</span>
            <span>// Math方法获取随机数；</span>
            <span>// var random_num = Math.random();</span>
            <span>// 先获取0~(m - n + 1)之间范围的数；</span>
            <span>// random_num = Math.random() * (m - n + 1);</span>
            <span>// 因为得到是小数所以要下取整（包含零、包含n）之所以能取到n是因为+1；</span>
            <span>// random_num = Math.floor(Math.random() * (m - n + 1));</span>
            <span>// +n 获取m-n之间的数；</span>
            <span>// var scope = random_num + n;</span>
            <span>// 简写；scope==范围</span>
            <span>var</span> scope <span>=</span> Math<span>.</span><span>floor</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> <span>(</span>m <span>-</span> n <span>+</span> <span>1</span><span>)</span><span>)</span> <span>+</span> n<span>;</span>
            <span>// 设置返回值；</span>
            <span>return</span> scope<span>;</span>
        <span>}</span>
        <span>// 往内置对象Math上添加方法；</span>
        Math<span>.</span><span>f1</span> <span>=</span> <span>function</span><span>(</span><span>n<span>,</span> m</span><span>)</span> <span>{</span>
                <span>var</span> scope <span>=</span> Math<span>.</span><span>floor</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> <span>(</span>m <span>-</span> n <span>+</span> <span>1</span><span>)</span><span>)</span> <span>+</span> n<span>;</span>
                <span>// 设置返回值；</span>
             	<span>// 传入的实参之所以可以随意调换位置，是因为后面加了一个很大的数n,加为正值了；</span>
                <span>return</span> scope<span>;</span>
            <span>}</span>
            <span>// 调用方法并传入实参；</span>
        console<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>f1</span><span>(</span><span>80</span><span>,</span> <span>50</span><span>)</span><span>)</span><span>;</span>
    <span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h3 id="内置对象"> 内置对象：</h3>
<h4 id="math-数学对象"> Math：数学对象；</h4>
<ul>
<li>方法；</li>
</ul>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>script</span><span>></span></span><span><span>
      <span>//方法直接调用即可；  </span>
        Math<span>.</span><span>random</span><span>(</span><span>)</span><span>;</span><span>//随机数、范围[0-1);</span>
        Math<span>.</span><span>ceil</span><span>(</span><span>)</span><span>;</span><span>//上取整；</span>
        Math<span>.</span><span>floor</span><span>(</span><span>)</span><span>;</span><span>//下取整；</span>
        Math<span>.</span><span>abs</span><span>(</span>x<span>)</span><span>;</span><span>//返回值是x的绝对值；</span>
        Math<span>.</span><span>round</span><span>(</span>x<span>)</span><span>;</span><span>//把x四舍五入取整;</span>
        Math<span>.</span><span>max</span><span>(</span>x<span>,</span>y<span>...</span><span>)</span><span>;</span><span>//求多个数字中的最大值;</span>
        Math<span>.</span><span>min</span><span>(</span>x<span>,</span>y<span>...</span><span>)</span><span>;</span><span>//求多个数字中的最小值;</span>
    </span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h4 id="date-日期-时间对象"> Date：日期/时间对象；</h4>
<div><pre><code><span>// 创建一个日期对象；</span>
<span>var</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span> <span>//直接输出：当前标准时间；</span>
	date<span>.</span><span>getFullYear</span><span>(</span><span>)</span>；<span>//年份</span>
    date<span>.</span><span>getMonth</span><span>(</span><span>)</span>；<span>//月份 从0开始的；0-11</span>
    date<span>.</span><span>getDate</span><span>(</span><span>)</span>；<span>//日</span>
    date<span>.</span><span>getHours</span><span>(</span><span>)</span>；<span>//小时； 0-23；</span>
    date<span>.</span><span>getMinutes</span><span>(</span><span>)</span>；<span>//分钟；0-59；</span>
    date<span>.</span><span>getSeconds</span><span>(</span><span>)</span>；<span>//秒数；0-59；</span>
    date<span>.</span><span>getMilliseconds</span><span>(</span><span>)</span>；<span>//毫秒0-999；</span>
<span>// 给一个日期格式字符串；</span>
<span>var</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>'2019-01-01'</span><span>)</span><span>;</span>
<span>// 分别传入年月日时分秒。注意传入的月份是从0开始算的</span>
<span>var</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>2019</span><span>,</span><span>0</span><span>,</span><span>1</span><span>,</span><span>12</span><span>,</span><span>33</span><span>,</span><span>12</span><span>)</span><span>;</span>

<span>//例：特点获得唯一的数字；</span>
<span>// 获取毫秒数 时间戳</span>
  <span>var</span> date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
  <span>// 从1970 1 1 到现在的毫秒数</span>
<span>//获取毫秒数的四种方法；</span>
  console<span>.</span><span>log</span><span>(</span>date<span>.</span><span>valueOf</span><span>(</span><span>)</span><span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>date<span>.</span><span>getTime</span><span>(</span><span>)</span><span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span><span>1</span> <span>*</span> date<span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>Date<span>.</span><span>now</span><span>(</span><span>)</span><span>)</span><span>;</span>
  <span>// 要求：绝对的是唯一的数值；</span>
  Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> date<span>.</span><span>valueOf</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>javascript高级</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-01/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-01/</guid>
      <source url="https://wangyawei.top/rss.xml">javascript高级</source>
      <category>javascript</category>
      <pubDate>Sun, 02 May 2021 22:22:34 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="javascript-的组成"> JavaScript 的组成</h2>
<table>
<thead>
<tr>
<th>组成部分</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Ecmascript</td>
<td>描述了该语言的语法和基本对象</td>
</tr>
<tr>
<td>DOM</td>
<td>描述了处理网页内容的方法和接口</td>
</tr>
<tr>
<td>BOM</td>
<td>描述了与浏览器进行交互的方法和接口</td>
</tr>
</tbody>
</table>
<h2 id="复杂类型-引用类型"> 复杂类型（引用类型）</h2>
<ul>
<li>Object</li>
<li>Array</li>
<li>Date</li>
<li>RegExp</li>
<li>Function</li>
<li>基本包装类型
<ul>
<li>Boolean</li>
<li>Number</li>
<li>String</li>
</ul>
</li>
<li>单体内置对象
<ul>
<li>Global</li>
<li>Math</li>
</ul>
</li>
</ul>
<h4 id="类型检测"> 类型检测</h4>
<ul>
<li><code>typeof</code></li>
<li><code>instanceof</code></li>
<li><code>Object.prototype.toString.call()</code></li>
</ul>
<h3 id="javascript-执行过程"> JavaScript 执行过程</h3>
<p>JavaScript 运行分为两个阶段：</p>
<ul>
<li>预解析
<ul>
<li><b style="color: red">全局预解析（所有变量和函数声明都会提前；同名的函数和变量函数的优先级高）</b></li>
<li>函数内部预解析（所有的变量、函数和形参都会参与预解析）
<ul>
<li>函数</li>
<li>形参</li>
<li>普通变量</li>
</ul>
</li>
</ul>
</li>
<li>执行；
<ul>
<li>先预解析全局作用域，然后执行全局作用域中的代码，在执行全局代码的过程中遇到函数调用就会先进行函数预解析，然后再执行函数内代码。</li>
</ul>
</li>
</ul>
<h2 id="两大编程思想"> 两大编程思想：</h2>
<ol>
<li>面向过程；</li>
<li>面向对象
<ul>
<li>面向对象编程 ；简称 OOP ，是一种编程开发思想。</li>
<li>对象是单个事物的抽象。</li>
<li>对象是一个容器，封装了属性（property）和方法（method）。</li>
<li>所以，面向对象的设计思想是：
<ul>
<li>抽象出 Class（类）；</li>
<li>根据 Class 创建实例；</li>
<li>指挥实例 得结果；</li>
<li>面向对象的抽象程度又比函数要高，因为一个 Class 既包含数据，又包含操作数据的方法。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="面向对象和过程优缺点"> 面向对象和过程优缺点；</h2>
<blockquote>
<p>简单程序面向过程，复杂程序用面向对象</p>
</blockquote>
<ul>
<li>
<p><strong>面向过程：</strong></p>
<ul>
<li>优点：性能比面向对象高，步骤练习紧密；</li>
<li>缺点：不好维护，不易多次使用及扩展；</li>
</ul>
<p><strong>面向对象：</strong></p>
<p>​		优点：易维护，可复用，可扩展，灵活性高</p>
<p>​		缺点性能没有面向过程高</p>
<p>​		缺点性能没有面向过程高</p>
</li>
</ul>
<h2 id="面向对象三大特性"> 面向对象三大特性；</h2>
<ol>
<li>封装性；</li>
<li>继承性；</li>
<li>多态性；</li>
</ol>
<h2 id="es6中的类和对象"> ES6中的类和对象</h2>
<p>ES5：没有类，ES6：类</p>
<p>ES：ECMAscript</p>
<p>类是在ES6中新加进入的;</p>
<p><strong>类：</strong></p>
<p>​	1、抽取，把对象的属性和行为封装成一个类</p>
<p>​	2、对类进行实例化, 获取类的对象</p>
<p><strong>对象：</strong></p>
<p>​	对象：类中的具体的某个实例【属性和方法的集合体】</p>
<p>​	在JavaScript 中，对象是一组<strong>无序</strong>的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。</p>
<p><strong>对象是由属性和方法组成的</strong>；</p>
<p><strong>面向对象的思维特点:</strong></p>
<p>​	 1.抽取（抽象）对象共用的属性和方法组织(封装)成一个类(模板)</p>
<p>​	 2.对类进行实例化, 获取类的对象；</p>
<h2 id="类class"> 类class</h2>
<blockquote>
<p>可以使用class关键字声明一个类，之后以这个类来实例化对象。【构造函数实例化对象】;</p>
</blockquote>
<ul>
<li>类抽象了对象的公共部分，它泛指某一大类（class）</li>
</ul>
<h2 id="创建类"> 创建类</h2>
<ul>
<li>类里面的方法不带function，直接写既可；</li>
<li>类里面要有属性方法，属性方法要是想放到类里面，我们用constructor构造器；</li>
<li>constructor 构造函数里面主要放一些公共的属性；</li>
</ul>
<div><pre><code><span>//语法：class 类名 {属性和方法}；【构造函数语法糖】</span>
<span>//注意类名首字母大写；</span>
<span>//类要抽取公共属性方法，定义一个类；</span>
 <span>class</span> <span>Person</span> <span>{</span>
     <span>//公共属性写在constructor构造函数中；</span>
        <span>constructor</span> <span>(</span><span>name<span>,</span>age<span>,</span>sex</span><span>)</span> <span>{</span>
            <span>//this指当前new出来的实例对象；谁使用，this就是指谁；</span>
            <span>this</span><span>.</span>name<span>=</span>name<span>;</span>
            <span>this</span><span>.</span>age<span>=</span>age<span>;</span>
            <span>this</span><span>.</span>sex<span>=</span>sex<span>;</span>
            <span>this</span><span>.</span><span>haha</span><span>=</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span>'晚上阿红'</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
     <span>//方法与方法之间不能加 ; 或 ,</span>
        <span>eat</span> <span>(</span><span>)</span> <span>{</span>
            <span>//普通函数中的this是谁调用就是谁；</span>
            console<span>.</span><span>log</span><span>(</span><span>'我叫'</span><span>+</span><span>this</span><span>.</span>name<span>+</span><span>'今年'</span><span>+</span><span>this</span><span>.</span>age<span>)</span>
        <span>}</span>
        <span>pao</span> <span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>345</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>//用类实例化一个对象；</span>
<span>var</span> obj<span>=</span><span>new</span> <span>Person</span><span>(</span><span>'小明'</span><span>,</span><span>22</span><span>,</span><span>'男'</span><span>)</span><span>;</span>
<span>//类就是构造函数的语法糖；</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><blockquote>
<p>constructor() 方法是类的构造函数(默认方法)，用于传递参数,返回实例对象，通过new命令生成对象实例时，自动调用该方法。</p>
<p>注意：每个类里面<strong>一定</strong>有构造函数，如果没有显示定义, 类内部会自动给我们创建一个constructor() ，</p>
<p>注意：this代表当前实例化对象，谁new就代表谁；</p>
</blockquote>
<div><pre><code><span>class</span> 类名 <span>{</span> <span>constructor</span><span>(</span><span>)</span><span>{</span><span>}</span>   <span>方法名</span><span>(</span><span>)</span><span>{</span><span>}</span> <span>}</span>

<span>//注意：类中定义属性，调用方法都得用this</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>总结：类有对象的公共属性和方法，用class创建，class里面包含constructor和方法，我们把公共属性放到constructor里面，把公共方法直接往后写既可，但是注意不要加逗号</strong></p>
<h2 id="类的继承"> 类的继承；</h2>
<ol>
<li>
<p>extends</p>
<div><pre><code>//语法：
​	class Father {};
//在类中的构造函数的下面添加的方法，实例化对象后，并打印该对象，此时添加的方法是在实例对象的原型对象中；
//在类中的构造函数中添加的属性和方法在实例化对象后，该属性和方法便存在于该实例对象中；
​	class Son extends Father{}
// 子类里面不写东西  extends 可以继承父类的全部属性和方法；

//注意：是子类继承父类
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
</ol>
<p><img src="./assets/1570591396877.png" alt="" /></p>
<ol start="2">
<li>
<p>super</p>
<blockquote>
<p>super关键字用于访问和调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数；</p>
<p>当子类没有constructor的时候可以随意用父类的，但是如果子类也含有的话，constructor会返回实例，this的指向不同，不可以再直接使用父类的东西；</p>
</blockquote>
</li>
</ol>
<p><strong>调用父类构造函数</strong>；</p>
<div><pre><code><span>class</span> <span>F</span> <span>{</span> 
    <span>constructor</span><span>(</span><span>name<span>,</span> age</span><span>)</span><span>{</span><span>}</span>
<span>}</span>
<span>//如果子类里面不写东西，那么直接继承父类的全部属性和方法；</span>
<span>class</span> <span>S</span> <span>extends</span> <span>F</span> <span>{</span> 
    <span>constructor</span> <span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span> 
        <span>//通过super关键字可以添加属于 S 自己的属性；在关键字的下面添加；</span>
        <span>//注意要传入形参和父类相对应；</span>
        <span>super</span><span>(</span>name<span>,</span>age<span>)</span><span>;</span> <span>//super关键字 改变this指向；实现既能访问父类的属性又能添加自己的属性；</span>
    <span>}</span> 
<span>}</span>

<span>//注意: 子类在构造函数中使用super, 必须放到this 前面(必须先调用父类的构造方法,在使用子类构造方法）；</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong>调用父类普通函数</strong>；</p>
<div><pre><code><span>class</span> <span>F</span> <span>{</span> 
    <span>constructor</span><span>(</span><span>name<span>,</span> age</span><span>)</span><span>{</span><span>}</span> 
    <span>say</span> <span>(</span><span>)</span> <span>{</span><span>}</span>
<span>}</span>
<span>//如果子类里面不写东西，那么直接继承父类的全部属性和方法；</span>
<span>class</span> <span>S</span> <span>extends</span> <span>F</span> <span>{</span> 
    <span>constructor</span> <span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span> 
        <span>super</span><span>(</span>name<span>,</span>age<span>)</span><span>;</span> 
    <span>}</span> 
    <span>say</span> <span>(</span><span>)</span> <span>{</span> 
        <span>super</span><span>.</span><span>say</span><span>(</span><span>)</span> <span>//改变指向；  实现既能调用父类的方法又能调用子类的方法；</span>
    <span>}</span> 
<span>}</span>

<span>//注意：如果子类没有 super 关键字，同时子类也有与父类相同的方法，则优先指向子类，就近原则；</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><strong>总结：super调用父类的属性和方法，那么查找属性和方法的原则就近原则</strong></p>
<div><pre><code><span>&lt;</span>script<span>></span>
    <span>//定义一个人的类 ，类的首字母一般要大写，属于规范；</span>
    <span>class</span> <span>Person</span> <span>{</span>
        <span>constructor</span> <span>(</span><span>name<span>,</span>age<span>,</span>sex</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span>name<span>=</span>name<span>;</span>
            <span>this</span><span>.</span>age<span>=</span>age<span>;</span>
            <span>this</span><span>.</span>sex<span>=</span>sex<span>;</span>
        <span>}</span>
        <span>//添加方法；</span>
        <span>eat</span> <span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>'我叫'</span><span>+</span><span>this</span><span>.</span>name<span>+</span><span>'今年'</span><span>+</span><span>this</span><span>.</span>age<span>)</span>
        <span>}</span>
        <span>pao</span> <span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>'整它一个亿'</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>class</span> <span>Son</span> <span>extends</span> <span>Person</span><span>{</span>
        <span>constructor</span> <span>(</span><span>name<span>,</span>age<span>,</span>sex<span>,</span>taio</span><span>)</span> <span>{</span>
            <span>super</span><span>(</span>name<span>,</span> age<span>,</span>sex<span>)</span><span>;</span>
            <span>this</span><span>.</span>tiao<span>=</span>taio<span>;</span>
        <span>}</span>
        <span>//如果子类没有pao方法则直接继承父类的；</span>
        <span>//若子类也有和父类相同的方法；则采取就近原则；执行子类中的方法；</span>
        <span>//若既调用子类也想调用父类的方法则需要用 super 关键字；用super去调用；</span>
        <span>pao</span> <span>(</span><span>)</span> <span>{</span>
            <span>super</span><span>.</span><span>pao</span><span>(</span><span>)</span><span>;</span>
            console<span>.</span><span>log</span><span>(</span><span>'赚他两毛钱'</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>//使用类实例化一个对象；并传入实参；</span>
    <span>var</span> obj1<span>=</span><span>new</span> <span>Son</span><span>(</span><span>'小红'</span><span>,</span><span>28</span><span>,</span><span>'男'</span><span>)</span><span>;</span>
    <span>// 访问人的属性；</span>
    obj1<span>.</span><span>eat</span><span>(</span><span>)</span><span>;</span>
    obj1<span>.</span><span>pao</span><span>(</span><span>)</span><span>;</span> <span>//可以同时调用父类和子类的；</span>
    console<span>.</span><span>log</span><span>(</span>obj1<span>)</span><span>;</span>
<span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h2 id="三个注意点"> 三个注意点</h2>
<ul>
<li>在ES6中类没有变量提升，所以必须先定义类，才能通过类实例化对象；</li>
<li>类里面的共有属性和方法一定要加this使用.【this&lt;==&gt;对象 调用属性和方法】;</li>
<li>类里面的this指向问题.；</li>
<li><strong>constructor 里面的this指向实例对象, 方法里面的this 指向这个方法的调用者</strong>；</li>
</ul>
<div><pre><code><span>class</span> <span>Button</span> <span>{</span>
	<span>constructor</span> <span>(</span><span>)</span> <span>{</span>
		<span>var</span> btn <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>'input'</span><span>)</span><span>;</span>
		btn<span>.</span>onclick <span>=</span> <span>this</span><span>.</span>cli<span>;</span>
	<span>}</span>
	<span>cli</span> <span>(</span><span>)</span> <span>{</span>
		console<span>.</span><span>log</span><span>(</span><span>'点击了'</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
<span>var</span> anniu <span>=</span> <span>new</span> <span>Button</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="类里面的this指向"> 类里面的this指向</h2>
<ul>
<li>
<p>构造函数的this指向实例对象;</p>
</li>
<li>
<p>普通函数的this是调用者，谁调用this是谁;</p>
</li>
</ul>
<h2 id="构造函数和原型"> 构造函数和原型</h2>
<div><pre><code><span>//在典型的OOP 的语言中（如Java），都存在类的概念，类就是对象的模板，对象就是类的实例，但在ES6之前，JS 中并没用引入类的概念。</span>

<span>//ES6，全称ECMAScript6.0 ，2015.06 发版。但是目前浏览器的JavaScript 是ES5 版本，大多数高版本的浏览器也支持ES6，不过只实现了ES6 的部分特性和功能。</span>

<span>//在ES6之前，对象不是基于类创建的，而是用一种称为构建函数的特殊函数来定义对象和它们的特征。</span>

<span>/</span>构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与<span>new</span>一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。
<span>function</span> <span>Fn</span> <span>(</span><span>)</span> <span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>在JS 中，使用构造函数时要注意以下两点：</strong></p>
<p>1.构造函数用于创建某一类对象，其首字母要大写</p>
<p>2.构造函数要和new 一起使用才有意义；</p>
<h2 id="创建对象可以通过以下四种方式"> 创建对象可以通过以下四种方式；</h2>
<ul>
<li>
<p>字面量；</p>
<div><pre><code><span>var</span> person <span>=</span> <span>{</span>
  name<span>:</span> <span>'Jack'</span><span>,</span>
  age<span>:</span> <span>18</span><span>,</span>
  <span>sayName</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>new Object()； 系统内置构造函数创建对象；</p>
<div><pre><code><span>var</span> person <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span>
person<span>.</span>name <span>=</span> <span>'Jack'</span>
person<span>.</span>age <span>=</span> <span>18</span>

person<span>.</span><span>sayName</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>自定义构造函数；</p>
<ul>
<li>首字母小写；</li>
</ul>
</li>
<li>
<p>工厂模式创建对象；</p>
<div><pre><code><span>//不用！</span>
<span>function</span> <span>createPerson</span> <span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
  <span>return</span> <span>{</span>
    name<span>:</span> name<span>,</span>
    age<span>:</span> age<span>,</span>
    <span>sayName</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
<span>//然后生成实例对象；</span>
<span>var</span> p1 <span>=</span> <span>createPerson</span><span>(</span><span>'Jack'</span><span>,</span> <span>18</span><span>)</span>
<span>var</span> p2 <span>=</span> <span>createPerson</span><span>(</span><span>'Mike'</span><span>,</span> <span>18</span><span>)</span>


<span>//一种更好的工厂模式创建对象的方式；常用！</span>
<span>//缺点：会造成内存空间浪费；所以共用的方法会放在原型对象中，利用继承获取；</span>
<span>function</span> <span>Person</span> <span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>name <span>=</span> name
  <span>this</span><span>.</span>age <span>=</span> age
  <span>this</span><span>.</span><span>sayName</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span>
  <span>}</span>
<span>}</span>

<span>var</span> p1 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>'Jack'</span><span>,</span> <span>18</span><span>)</span>
p1<span>.</span><span>sayName</span><span>(</span><span>)</span> <span>// => Jack</span>

<span>var</span> p2 <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>'Mike'</span><span>,</span> <span>23</span><span>)</span>
p2<span>.</span><span>sayName</span><span>(</span><span>)</span> <span>// => Mike</span>
<span>//而要创建 `Person` 实例，则必须使用 `new` 操作符。</span>
<span>//以这种方式调用构造函数会经历以下 4 个步骤：</span>
<span>1.</span> 在内存中创建一个新的空对象。
<span>2.</span> 让<span>this</span>指向这个新的对象。
<span>3.</span> 执行构造函数里面的代码，给这个新对象添加属性和方法。
<span>4.</span> 返回这个新对象（所以构造函数里面不需要<span>return</span>）。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div></li>
</ul>
<h2 id="静态成员和实例成员"> 静态成员和实例成员</h2>
<div><pre><code>JavaScript 的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的<span>this</span> 上添加。通过这两种方式添加的成员，就分别称为静态成员和实例成员。
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>静态成员：在构造函数本上添加的成员称为静态成员，只能由构造函数本身来访问</li>
<li>实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问</li>
</ul>
<div><pre><code><span>function</span> <span>Person</span> <span>(</span><span>uname<span>,</span> age</span><span>)</span> <span>{</span>
			<span>this</span><span>.</span>uname <span>=</span> uname<span>;</span>
			<span>this</span><span>.</span>age <span>=</span> age<span>;</span> <span>// 实例属性</span>

		<span>this</span><span>.</span><span>say</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
			console<span>.</span><span>log</span><span>(</span><span>123</span><span>)</span><span>;</span>
		<span>}</span>

<span>}</span>

	<span>var</span> obj <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>'张三丰'</span><span>,</span><span>22</span><span>)</span><span>;</span>	
	console<span>.</span><span>log</span><span>(</span>obj<span>.</span>uname<span>)</span><span>;</span>

	<span>// console.log( Person.uname );</span>
	Person<span>.</span>leibie <span>=</span> <span>'人'</span><span>;</span> <span>// 静态属性</span>

	console<span>.</span><span>log</span><span>(</span>Person<span>.</span>leibie<span>)</span><span>;</span>
	console<span>.</span><span>log</span><span>(</span>obj<span>.</span>leibie<span>)</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><strong>构造函数小问题：</strong></p>
<div><pre><code><span>//当实例化对象的时候，因为方法是函数，函数是复杂数据类型，而每创建一个对象，都会有一个函数，每个函数都得开辟一个内存空间，此时浪费内存了，那么如何节省内存呢，我们需要用到原型方法放到构造函数里面，以此来节省内存空间浪费；</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="构造函数原型prototype"> 构造函数原型prototype</h2>
<ul>
<li>
<p>是一个属性，是构造函数的属性，这个属性是一个对象，我们也称呼，prototype 为原型对象。</p>
</li>
<li>
<p>作用：是为了共享方法，从而达到节省内存</p>
</li>
<li>
<p><strong>注意：每一个构造函数都有prototype属性</strong></p>
</li>
</ul>
<blockquote>
<p>JavaScript 规定，每一个构造函数都有一个prototype 属性，指向构造函数的原型对象。</p>
</blockquote>
<div><pre><code><span>function</span> <span>Star</span> <span>(</span><span>uname<span>,</span> age</span><span>)</span> <span>{</span>

​		<span>this</span><span>.</span>uname <span>=</span> uname<span>;</span>
​		<span>this</span><span>.</span>age <span>=</span> age<span>;</span>
​		<span>// this.sing = function () {</span>
​		<span>// 	console.log(this.name + '在唱歌');</span>
​		<span>// }</span>
​	<span>}</span>
<span>//把方法添加在原型对象上，既能节省空间又能实现方法共享；</span>
​	<span>Star</span><span>.</span>prototype<span>.</span><span>sing</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
​		console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>uname <span>+</span> <span>'在唱歌'</span><span>)</span><span>;</span>
​	<span>}</span>
​	<span>var</span> zxc <span>=</span> <span>new</span> <span>Star</span><span>(</span><span>'周星驰'</span><span>,</span> <span>22</span><span>)</span><span>;</span>
​	<span>var</span> ldh <span>=</span> <span>new</span> <span>Star</span><span>(</span><span>'刘德华'</span><span>,</span> <span>22</span><span>)</span><span>;</span>
​	ldh<span>.</span><span>sing</span><span>(</span><span>)</span><span>;</span>
​	zxc<span>.</span><span>sing</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><strong>总结：所有的公共属性写到构造函数里面，所有的公共方法写到原型对象里面</strong></p>
<h2 id="对象原型-proto"> 对象原型：<strong><strong>proto</strong></strong></h2>
<p><strong>主要作用：指向prototype原型对象</strong>；</p>
<p>构造函数和原型对象都会有一个属性, 指向构造函数的prototype 原型对象，之所以我们对象可以使用构造函数prototype 原型对象的属性和方法，就是因为对象有__proto__ 原型的存在。</p>
<blockquote>
<div><pre><code>注意：____proto____是一个非标准属性，不可以拿来赋值或者设置【只读属性】
</code></pre>
<div><span>1</span><br></div></div></blockquote>
<ul>
<li>
<div><pre><code>1.____proto____对象原型和原型对象prototype 是等价的

2.____proto____对象原型的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象prototype
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ul>
<p><strong>总结：每一个对象都有一个原型，作用是指向原型对象prototype</strong></p>
<p><strong>统一称呼：____proto____原型，prototype成为原型对象</strong></p>
<h2 id="constructor-构造函数"> constructor  构造函数</h2>
<blockquote>
<p>记录是哪个构造函数创建出来的 <strong>指回构造函数本身；</strong></p>
</blockquote>
<p>原型（<strong>proto</strong>）和构造函数（prototype）原型对象里面都有一个属性constructor属性，constructor 我们称为构造函数，因为它指回构造函数本身。constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象constructor  就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个constructor 指向原来的构造函数。</p>
<p><strong>总结：constructor  主要作用可以指回原来的构造函数</strong></p>
<p>原型对象：prototype，方法</p>
<p>对象原型：<strong><strong>proto</strong></strong>，指向原型对象</p>
<p>构造函数：constructor：指回构造函数</p>
<h2 id="构造函数、实例、原型对象三者之间的关系"> 构造函数、实例、原型对象三者之间的关系</h2>
<p><img src="./assets/1127.png" alt="" /></p>
<h2 id="原型链"> 原型链</h2>
<blockquote>
<p>作用：提供一个成员的查找机制，或者查找规则</p>
</blockquote>
<div><pre><code>当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。

如果没有就查找它的原型（也就是__proto__指向的prototype 原型对象）。

如果还没有就查找原型对象的原型（Object的原型对象）。

依此类推一直找到Object 为止（null）。

__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。

// console.log(Star.prototype.__proto__.__proto__);
// console.log(Object.prototype);

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="扩展内置对象"> 扩展内置对象</h2>
<div><pre><code>可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。

</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code>console<span>.</span><span>log</span><span>(</span> <span>Array</span><span>.</span>prototype <span>)</span><span>;</span>
	<span>// 添加求和方法</span>
	<span>Array</span><span>.</span>prototype<span>.</span><span>sum</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
		<span>var</span> sum <span>=</span> <span>0</span><span>;</span>
		<span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>this</span><span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
			sum <span>+=</span> <span>this</span><span>[</span>i<span>]</span><span>;</span>
		<span>}</span>
		<span>return</span> sum<span>;</span>
	<span>}</span>

	<span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>]</span><span>;</span>
	console<span>.</span><span>log</span><span>(</span> arr<span>.</span><span>sum</span><span>(</span><span>)</span> <span>)</span><span>;</span>

	<span>var</span> newArr <span>=</span> <span>[</span><span>6</span><span>,</span><span>7</span><span>,</span><span>8</span><span>,</span><span>9</span><span>]</span><span>;</span>
	console<span>.</span><span>log</span><span>(</span> newArr<span>.</span><span>sum</span><span>(</span><span>)</span> <span>)</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="继承"> 继承；</h2>
<div><pre><code><span>//ES6之前并没有给我们提供extends 继承。我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承。</span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>call</span><span>(</span><span>)</span><span>;</span>

<span>//调用这个函数, 并且修改函数运行时的this 指向</span>

<span>//fun.call(thisArg, arg1, arg2, ...);call把父类的this指向子类</span>

<span>//thisArg ：当前调用函数this 的指向对象</span>

<span>//arg1，arg2：传递的其他参数；</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="属性的继承"> <strong>属性的继承</strong></h2>
<div><pre><code><span>function</span> <span>Father</span> <span>(</span><span>uname<span>,</span>age</span><span>)</span> <span>{</span>
			<span>// this指向父类的实例对象</span>
			<span>this</span><span>.</span>uname <span>=</span> uname<span>;</span>
			<span>this</span><span>.</span>age <span>=</span> age<span>;</span>
			<span>// 要想让子类访问父类的属性，只需要把父类的this指向子类的this既可</span>
		<span>}</span>
		<span>function</span> <span>Son</span> <span>(</span><span>uname<span>,</span> age<span>,</span>score</span><span>)</span> <span>{</span>
			<span>// this指向子类构造函数</span>
			<span>Father</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span>uname<span>,</span>age<span>)</span><span>;</span><span>//把父类的this指向给子类的this，子类的this为Son的实例对象；</span>
			<span>this</span><span>.</span>score <span>=</span> score<span>;</span><span>//添加自己的属性；</span>
		<span>}</span>
		<span>Son</span><span>.</span>prototype<span>.</span><span>sing</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
			console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>uname <span>+</span> <span>'唱歌'</span><span>)</span>
		<span>}</span>
		<span>var</span> obj <span>=</span> <span>new</span> <span>Son</span><span>(</span><span>'刘德华'</span><span>,</span><span>22</span><span>,</span><span>99</span><span>)</span><span>;</span>
		console<span>.</span><span>log</span><span>(</span>obj<span>.</span>uname<span>)</span><span>;</span>
		console<span>.</span><span>log</span><span>(</span>obj<span>.</span>score<span>)</span><span>;</span>
		obj<span>.</span><span>sing</span><span>(</span><span>)</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="方法的继承"> <strong>方法的继承：</strong></h2>
<p><strong>实现方法把父类的实例对象保存给子类的原型对象</strong></p>
<div><pre><code>一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。核心原理：

①将子类所共享的方法提取出来，让子类的prototype 原型对象= new 父类()  

②本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象

③将子类的constructor 

把父类的实例对象赋值给子类的原型

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code>		<span>function</span> <span>Father</span> <span>(</span><span>)</span> <span>{</span>

		<span>}</span>
		<span>Father</span><span>.</span>prototype<span>.</span><span>chang</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
			console<span>.</span><span>log</span><span>(</span><span>'唱歌'</span><span>)</span><span>;</span>
		<span>}</span>

		<span>function</span> <span>Son</span> <span>(</span><span>)</span> <span>{</span>

		<span>}</span>
		<span>// Son.prototype = Father.prototype;此种方式不可用；</span>
		<span>//因为1、子项无法添加自己的方法；2、若添加的子项的方法名与父项相同则父项被覆盖；</span>
		<span>Son</span><span>.</span>prototype <span>=</span> <span>new</span> <span>Father</span><span>(</span><span>)</span><span>;</span><span>//是我们想要的结果；但是要在方法添加之前改变指向；</span>
		<span>//指向改变之后要指回原构造函数；</span>
		<span>Son</span><span>.</span>prototype<span>.</span>constructor<span>=</span>Son<span>;</span>
		<span>var</span> obj <span>=</span> <span>new</span> <span>Son</span><span>(</span><span>)</span><span>;</span>
		obj<span>.</span><span>chang</span><span>(</span><span>)</span><span>;</span>

		<span>Son</span><span>.</span>prototype<span>.</span><span>score</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
			console<span>.</span><span>log</span><span>(</span><span>'考试'</span><span>)</span><span>;</span>
		<span>}</span>

		<span>// obj.score();</span>
		<span>// console.log(Son.prototype);</span>
		console<span>.</span><span>log</span><span>(</span><span>Father</span><span>.</span>prototype<span>)</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p><strong>注意：一定要让Son指回构造函数</strong></p>
<div><pre><code>实现继承后，让Son指回原构造函数

<span>Son</span><span>.</span>prototype <span>=</span> <span>new</span> <span>Father</span><span>(</span><span>)</span><span>;</span>

<span>Son</span><span>.</span>prototype<span>.</span>constructor <span>=</span> Son<span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>总结：用构造函数实现属性继承，用原型对象实现方法继承</strong></p>
<h2 id="拷贝继承"> 拷贝继承;</h2>
<p>常见的做法是用一个包含方法的对象字面量来重写整个原型对象：</p>
<div><pre><code><span>function</span> <span>Person</span> <span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>name <span>=</span> name
  <span>this</span><span>.</span>age <span>=</span> age
<span>}</span>
<span>//这样做的好处就是为 `Person.prototype` 添加成员简单了，但是也会带来一个问题，那就是原型对象丢失了 `constructor` 成员。</span>
<span>Person</span><span>.</span>prototype <span>=</span> <span>{</span>
  constructor<span>:</span> Person<span>,</span> <span>// => 手动将 constructor 指向正确的构造函数</span>
  <span>sayHello</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'我叫'</span> <span>+</span> <span>this</span><span>.</span>name <span>+</span> <span>'，我今年'</span> <span>+</span> <span>this</span><span>.</span>age <span>+</span> <span>'岁了'</span><span>)</span>
  <span>}</span><span>,</span>
   <span>say</span><span>:</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>908</span><span>)</span><span>;</span>
        <span>}</span><span>,</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="构造函数的原型方法继承-拷贝继承-for-in"> 构造函数的原型方法继承：拷贝继承（for-in）</h3>
<div><pre><code><span>function</span> <span>Person</span> <span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>type <span>=</span> <span>'human'</span>
  <span>this</span><span>.</span>name <span>=</span> name
  <span>this</span><span>.</span>age <span>=</span> age
<span>}</span>

<span>Person</span><span>.</span>prototype<span>.</span><span>sayName</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'hello '</span> <span>+</span> <span>this</span><span>.</span>name<span>)</span>
<span>}</span>

<span>function</span> <span>Student</span> <span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
  <span>Person</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> name<span>,</span> age<span>)</span>
<span>}</span>

<span>// 原型对象拷贝继承原型对象成员</span>
<span>for</span><span>(</span><span>var</span> key <span>in</span> <span>Person</span><span>.</span>prototype<span>)</span> <span>{</span>
  <span>Student</span><span>.</span>prototype<span>[</span>key<span>]</span> <span>=</span> <span>Person</span><span>.</span>prototype<span>[</span>key<span>]</span>
<span>}</span>

<span>var</span> s1 <span>=</span><span>new</span> <span>Student</span><span>(</span><span>'张三'</span><span>,</span> <span>18</span><span>)</span>

s1<span>.</span><span>sayName</span><span>(</span><span>)</span> <span>// => hello 张三</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="类的本质"> 类的本质</h2>
<div><pre><code><span>class</span>本质还是<span>function</span>

类的所有方法都定义在类的prototype属性上

类创建的实例<span>,</span>里面也有__proto__ 指向类的prototype原型对象

所以<span>ES6</span>的类它的绝大部分功能，<span>ES5</span>都可以做到，新的<span>class</span>写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。

所以<span>ES6</span>的类其实就是语法糖<span>.</span>

语法糖<span>:</span>语法糖就是一种便捷写法<span>.</span>   简单理解<span>,</span> 有两种方法可以实现同样的功能<span>,</span> 但是一种写法更加清晰、方便<span>,</span>那么这个方法就是语法糖

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code>	<span>class</span> <span>Star</span> <span>{</span><span>}</span>
	console<span>.</span><span>log</span><span>(</span> <span>typeof</span> Star <span>)</span><span>;</span>
	<span>var</span> obj <span>=</span> <span>new</span> <span>Star</span><span>(</span><span>)</span><span>;</span>
	console<span>.</span><span>log</span><span>(</span>obj<span>.</span>__proto__<span>)</span><span>;</span>
	console<span>.</span><span>log</span><span>(</span><span>Star</span><span>.</span>prototype<span>)</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="es5-中的新增方法"> ES5 中的新增方法</h2>
<div><pre><code><span>//ES5 中给我们新增了一些方法，可以很方便的操作数组或者字符串，这些方法主要包括：</span>

<span>//1、数组方法：forEach()、map()、filter()、some()、every()；这些方法都是遍历数组的;</span>
<span>//2、字符串方法: trim()  主要作用：删除字符串两侧的空白符</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>some()</strong></p>
<div><pre><code><span>/</span>array<span>.</span><span>some</span><span>(</span><span>function</span><span>(</span><span>currentValue<span>,</span> index<span>,</span> arr</span><span>)</span><span>)</span> 【注意：找到或者满足条件立刻停止】

<span>// currentValue: 数组当前项的值; index：数组当前项的索引</span>

<span>//some() 方法用于检测数组中的元素是否满足指定条件. 通俗点查找数组中是否有满足条件的元素</span>

<span>//arr：数组对象本身</span>
<span>var</span> arr <span>=</span> <span>[</span><span>100</span><span>,</span><span>200</span><span>,</span><span>300</span><span>,</span><span>400</span><span>]</span><span>;</span>
<span>var</span> re <span>=</span> arr<span>.</span><span>some</span><span>(</span><span>function</span> <span>(</span><span>item<span>,</span>index<span>,</span>arr</span><span>)</span> <span>{</span>
		<span>// console.log(item,index,arr);</span>
		console<span>.</span><span>log</span><span>(</span>index<span>)</span><span>;</span>
   		<span>//如果找到第一个满足条件的元素,则终止循环. 不在继续查找.</span>
    	<span>//注意:它返回值是布尔值, 如果查找到这个元素, 就返回true , 如果查找不到就返回false.</span>
		<span>return</span> item <span>>=</span> <span>200</span><span>;</span>
	<span>}</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>re<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><strong>trim()；</strong></p>
<ul>
<li>
<p>作用：清除两侧空白符；</p>
</li>
<li>
<p>返回值：清除后的新字符串；不改变原字符串；</p>
</li>
</ul>
<div><pre><code> <span>var</span> str<span>=</span><span>'    下午好    '</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>str<span>)</span><span>;</span>
    <span>//应用场景：发布信息是不能为空；</span>
    <span>//  var str="    ";&lt;=====>也是字符串；</span>
    <span>var</span> b<span>=</span>str<span>.</span><span>trim</span><span>(</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>b<span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>str<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="函数进阶"> 函数进阶；</h2>
<h3 id="函数的定义方式"> 函数的定义方式</h3>
<ul>
<li>
<p>函数的定义要有function 关键字；</p>
</li>
<li>
<p>匿名函数：</p>
</li>
<li>
<p>命名函数(函数表达式);</p>
</li>
<li>
<p><code>new Function</code></p>
<ul>
<li>
<div><pre><code>new Function()   var fn = new Function(&#39;参数1&#39;,&#39;参数2&#39;..., &#39;函数体&#39;)

var fn = new Function(&#39;a&#39;,&#39;b&#39;,&#39;console.log(a,b);&#39;);
  
fn(123,456);
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>Function 里面参数都必须是字符串格式</p>
</li>
<li>
<p>第三种方式执行效率低，也不方便书写，因此较少使用</p>
</li>
<li>
<p>所有函数都是Function 的实例(对象)</p>
</li>
<li>
<p>函数也属于对象</p>
</li>
</ul>
</li>
</ul>
<h4 id="函数声明与函数表达式的区别"> 函数声明与函数表达式的区别</h4>
<ul>
<li>函数声明必须有名字</li>
<li>函数声明会函数提升，在预解析阶段就已创建，声明前后都可以调用</li>
<li>函数表达式类似于变量赋值</li>
<li><strong>函数表达式可以没有名字，例如匿名函数</strong></li>
<li>函数表达式没有变量提升，在执行阶段创建，必须在表达式执行之后才可以调用</li>
</ul>
<p>下面是一个根据条件定义函数的例子：</p>
<div><pre><code><span>if</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
  <span>function</span> <span>f</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span>
  <span>}</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>function</span> <span>f</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>2</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>以上代码执行结果在不同浏览器中结果不一致。</p>
<p>不过我们可以使用函数表达式解决上面的问题：</p>
<div><pre><code><span>var</span> f

<span>if</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
  <span>f</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span>
  <span>}</span>
<span>}</span> <span>else</span> <span>{</span>
  <span>f</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>2</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="函数的调用方式"> 函数的调用方式;</h3>
<ul>
<li>函数的调用：好多种；</li>
</ul>
<div><pre><code><span>1.</span> <span>普通函数【fn</span><span>(</span><span>)</span>】
<span>2.</span> 对象的方法【对象<span>.</span><span>方法</span><span>(</span><span>)</span>】
<span>3.</span> 构造函数【<span>new</span> <span>Fn</span><span>(</span><span>)</span>】
<span>4.</span> 绑定事件函数【obj<span>.</span><span>onclick</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span><span>}</span>】
<span>5.</span> 定时器函数【window<span>.</span><span>setInterval</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span><span>}</span><span>,</span><span>1000</span><span>)</span>】
<span>6.</span> <span>立即执行函数【</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span><span>}</span><span>)</span><span>(</span><span>)</span>】
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="函数内-this-指向的不同场景"> 函数内 <code>this</code> 指向的不同场景</h3>
<ul>
<li>this指向当前调用者，始终成立；</li>
<li>this的指向，是当我们调用函数的时候确定的；</li>
<li>函数的调用方式决定了 <code>this</code> 指向的不同：</li>
</ul>
<table>
<thead>
<tr>
<th>调用方式</th>
<th>非严格模式</th>
<th>备注</th>
</tr>
</thead>
<tbody>
<tr>
<td>普通函数调用</td>
<td>window</td>
<td>严格模式下是 undefined</td>
</tr>
<tr>
<td>构造函数调用</td>
<td>实例对象</td>
<td>原型方法中 this 也是实例对象</td>
</tr>
<tr>
<td>对象方法调用</td>
<td>该方法所属对象</td>
<td>紧挨着的对象</td>
</tr>
<tr>
<td>事件绑定方法</td>
<td>绑定事件对象</td>
<td></td>
</tr>
<tr>
<td>定时器函数</td>
<td>window</td>
<td></td>
</tr>
<tr>
<td>立即执行函数</td>
<td>window</td>
<td></td>
</tr>
</tbody>
</table>
<h3 id="改变函数内部this-指向"> 改变函数内部this 指向：</h3>
<blockquote>
<p>JavaScript 为我们专门提供了一些函数方法用来帮我们更优雅的处理函数内部 this 指向问题。</p>
<p>常用的有bind()、call()、apply() 三种方法。</p>
</blockquote>
<h4 id="call"> <strong>call();</strong></h4>
<blockquote>
<ul>
<li>语法：fun.call(obj,参数1，参数2);   obj 在 fun 函数运行时指定的 this 值；</li>
</ul>
<p>​	   如果指定了 null 或者 undefined 则函数内部 this 指向 window；</p>
<ul>
<li>
<p>call() 方法：调用一个对象，并改变调用对象(fun)的this指向；</p>
</li>
<li>
<p>注意点：1、call 方法改变this指向，函数会被调用；</p>
</li>
</ul>
<p>​	       2、该方法的作用和 <code>apply()</code> 方法类似，只有一个区别，就是 <code>call()</code> 方法接受的是若干个参数的列表，而 <code>apply()</code> 方法接受的是一个包含多个参数的数组。</p>
</blockquote>
<div><pre><code><span>function</span> <span>fn</span><span>(</span><span>a<span>,</span>b</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>this</span><span>)</span><span>;</span>
    	console<span>.</span><span>log</span><span>(</span>a<span>+</span>b<span>)</span><span>;</span>
    <span>}</span>
    <span>var</span> obj <span>=</span> <span>{</span>
        name<span>:</span> <span>'小明'</span><span>,</span>
        <span>eat</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>this</span><span>)</span>
        <span>}</span>
    <span>}</span>
    <span>// 只要是函数就有this；</span>
    <span>//改变this指向；</span>
    <span>fn</span><span>.</span><span>call</span><span>(</span>obj<span>,</span><span>1</span><span>,</span><span>2</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id="apply"> <strong>apply();</strong></h4>
<blockquote>
<p>语法：fun.apply(obj,[参数1，参数2]);</p>
<p>注意点：1、传递的值，必须包含在数组里面;</p>
<p>​	       2、返回值就是函数的返回值，因为它就是调用函数；</p>
<p>​		3、apply()<code>与</code>call()` 非常相似，不同之处在于提供参数的方式。</p>
<p>​		      就是 <code>call()</code> 方法接受的是若干个参数的列表；</p>
<p>​		      而 <code>apply()</code> 方法接受的是一个包含多个参数的数组。</p>
<p>扩展：配合Math.max()使用可以求数组的最大值；</p>
</blockquote>
<div><pre><code> <span>function</span> <span>fn</span><span>(</span><span>a<span>,</span>b</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>this</span><span>)</span><span>;</span>
        console<span>.</span><span>log</span><span>(</span>a<span>+</span>b<span>)</span><span>;</span>
    <span>}</span>
    <span>var</span> obj <span>=</span> <span>{</span>
        name<span>:</span> <span>'小明'</span><span>,</span>
        <span>eat</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>this</span><span>)</span>
        <span>}</span>
    <span>}</span>
    <span>//改变this指向；</span>
    <span>fn</span><span>.</span><span>apply</span><span>(</span>obj<span>,</span><span>[</span><span>1</span><span>,</span><span>2</span><span>]</span><span>)</span><span>;</span>
<span>/</span>例：
    <span>/*
    * 需求：求数组中的最大值；
    * max() 最大的方法为 Math.max() 所共有的；
    * 那么可以利用apply改变this指向的方法来使用  max() 的方法；*/</span>
    <span>var</span> arr<span>=</span><span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>,</span><span>7</span><span>,</span><span>8</span><span>,</span><span>9</span><span>]</span><span>;</span>
    <span>var</span> Max<span>=</span>Math<span>.</span><span>max</span><span>.</span><span>apply</span><span>(</span>arr<span>,</span>arr<span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>Max<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h4 id="bind"> <strong>bind();</strong></h4>
<blockquote>
<div><pre><code><span>//用法为：fun.bind(obj,参数1，参数2);</span>
<span>1</span><span>、bind</span><span>(</span><span>)</span> 函数会创建一个新函数（称为绑定函数），新函数与被调函数（绑定函数的目标函数）具有相同的函	数体（在 ECMAScript <span>5</span> 规范中内置的call属性）。
<span>2</span>、当目标函数被调用时 <span>this</span> 值绑定到 <span>bind</span><span>(</span><span>)</span> 的第一个参数，该参数不能被重写。绑定函数被调用时，	      <span>bind</span><span>(</span><span>)</span> 也接受预设的参数提供给原函数。
<span>3</span>、一个绑定函数也能使用<span>new</span>操作符创建对象：这种行为就像把原函数当成构造器。提供的 <span>this</span> 值被忽略，同    时调用时的参数被提供给模拟函数。
<span>//返回值：返回由指定的this值和初始化参数改造的原函数拷贝。</span>
<span>//因此当我们只是想改变this 指向，并且不想调用这个函数的时候，可以使用bind；</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></blockquote>
<p>示例1：</p>
<div><pre><code>  <span>function</span> <span>fn</span><span>(</span><span>a<span>,</span>b</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>this</span><span>)</span><span>;</span>
        console<span>.</span><span>log</span><span>(</span>a<span>+</span>b<span>)</span><span>;</span>

    <span>}</span>
    <span>function</span> <span>so</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>name<span>=</span><span>'小明'</span><span>;</span>
        <span>this</span><span>.</span><span>eat</span><span>=</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>name<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    
    <span>//改变this指向；</span>
    <span>fn</span><span>.</span><span>bind</span><span>(</span>so<span>,</span><span>1</span><span>,</span><span>3</span><span>)</span><span>;</span>
    <span>//会创建一个新函数，和旧函数拥有相同的函数体；但是不共用一个；</span>
    <span>var</span> obj_1<span>=</span><span>fn</span><span>.</span><span>bind</span><span>(</span>so<span>)</span><span>;</span>
    <span>var</span> obj<span>=</span> <span>new</span> <span>obj_1</span><span>;</span>
    obj<span>.</span>name<span>=</span><span>'小明'</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>obj<span>)</span><span>;</span>

    <span>var</span> obj_2<span>=</span><span>new</span> <span>fn</span><span>(</span><span>)</span><span>;</span>
    obj_2<span>.</span>name<span>=</span><span>'小红'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>示例2：</p>
<div><pre><code><span>function</span> <span>LateBloomer</span><span>(</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>petalCount <span>=</span> Math<span>.</span><span>ceil</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> <span>12</span><span>)</span> <span>+</span> <span>1</span><span>;</span>
<span>}</span>

<span>// Declare bloom after a delay of 1 second</span>
<span>LateBloomer</span><span>.</span>prototype<span>.</span><span>bloom</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  window<span>.</span><span>setTimeout</span><span>(</span><span>this</span><span>.</span><span>declare</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>LateBloomer</span><span>.</span>prototype<span>.</span><span>declare</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'I am a beautiful flower with '</span> <span>+</span>
    <span>this</span><span>.</span>petalCount <span>+</span> <span>' petals!'</span><span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>var</span> flower <span>=</span> <span>new</span> <span>LateBloomer</span><span>(</span><span>)</span><span>;</span>
flower<span>.</span><span>bloom</span><span>(</span><span>)</span><span>;</span>  <span>// 一秒钟后, 调用'declare'方法</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id="小结"> 小结</h4>
<ul>
<li>call 和 apply 特性一样
<ul>
<li>都是用来调用函数，而且是立即调用</li>
<li>但是可以在调用函数的同时，通过第一个参数指定函数内部 <code>this</code> 的指向</li>
<li>传递的参数不一样, call 传递参数aru1, aru2..形式；apply 必须数组的形式[arg]；</li>
<li>apply 调用的时候，参数必须是一个数组，然后在执行的时候，会将数组内部的元素一个一个拿出来，与形参一一对应进行传递</li>
<li>如果第一个参数指定了 <code>null</code> 或者 <code>undefined</code> 则内部 this 指向 window</li>
</ul>
</li>
<li>bind
<ul>
<li>可以用来指定内部 this 的指向，然后生成一个改变了 this 指向的新的函数</li>
<li>它和 call、apply 最大的区别是：bind 不会调用</li>
<li>bind 支持传递参数，它的传参方式比较特殊，一共有两个位置可以传递
<ul>
<li>
<ol>
<li>在 bind 的同时，以参数列表的形式进行传递</li>
</ol>
</li>
<li>
<ol start="2">
<li>在调用的时候，以参数列表的形式进行传递</li>
</ol>
</li>
<li>那到底以谁 bind 的时候传递的参数为准呢还是以调用的时候传递的参数为准</li>
<li>两者合并：bind 的时候传递的参数和调用的时候传递的参数会合并到一起，传递到函数内部</li>
</ul>
</li>
</ul>
</li>
<li>使用场景：
<ul>
<li>1.call 经常做继承.
2.apply 经常跟数组有关系.比如借助于数学对象实现数组最大值最小值
3.bind  不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向</li>
</ul>
</li>
</ul>
<h3 id="函数的其它成员"> 函数的其它成员</h3>
<ul>
<li>arguments
<ul>
<li>实参集合</li>
</ul>
</li>
<li>caller
<ul>
<li>函数的调用者</li>
</ul>
</li>
<li>length
<ul>
<li>形参的个数</li>
</ul>
</li>
<li>name
<ul>
<li>函数的名称</li>
</ul>
</li>
</ul>
<div><pre><code><span>function</span> <span>fn</span><span>(</span><span>x<span>,</span> y<span>,</span> z</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>fn<span>.</span>length<span>)</span> <span>// => 形参的个数</span>
  console<span>.</span><span>log</span><span>(</span>arguments<span>)</span> <span>// 伪数组实参参数集合</span>
  console<span>.</span><span>log</span><span>(</span>arguments<span>.</span>callee <span>===</span> fn<span>)</span> <span>// 函数本身</span>
  console<span>.</span><span>log</span><span>(</span>fn<span>.</span>caller<span>)</span> <span>// 函数的调用者</span>
  console<span>.</span><span>log</span><span>(</span>fn<span>.</span>name<span>)</span> <span>// => 函数的名字</span>
<span>}</span>

<span>function</span> <span>f</span><span>(</span><span>)</span> <span>{</span>
  <span>fn</span><span>(</span><span>10</span><span>,</span> <span>20</span><span>,</span> <span>30</span><span>)</span>
<span>}</span>

<span>f</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="严格模式"> 严格模式；</h3>
<p>JS：两种模式[类似于HTML版本]；</p>
<blockquote>
<p>1、严格模式；</p>
<p>2、正常模式；</p>
<div><pre><code>什么是严格模式

<span>ES5</span> 的严格模式是采用具有限制性JavaScript 变体的一种方式，即在严格的条件下运行<span>JS</span> 代码。
严格模式在<span>IE10</span> 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。
严格模式对正常的JavaScript 语义做了一些更改：

<span>1.</span>消除了Javascript语法的一些不合理、不严谨之处，减少了一些怪异行为。【例如变量，不声明就报错】
<span>2.</span>消除代码运行的一些不安全之处，保证代码运行的安全。
<span>3.</span>提高编译器效率，增加运行速度。
<span>4.</span>禁用了在ECMAScript的未来版本中可能会定义的一些语法，为未来新版本的Javascript做好铺垫。比如一些保留字如：<span>class</span><span>,</span> <span>enum</span><span>,</span> <span>export</span><span>,</span> <span>extends</span><span>,</span> <span>import</span><span>,</span> <span>super</span> 不能做变量名
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></blockquote>
<h5 id="开启严格模式"> <strong>开启严格模式；</strong></h5>
<blockquote>
<div><pre><code>开启严格模式：<span>"use strict"</span>
为整个脚本文件开启严格模式，需要在所有语句之前放一个特定语句“use strict”<span>;</span>（或‘use strict’<span>;</span>）。
因为<span>"use strict"</span>加了引号，所以老版本的浏览器会把它当作一行普通字符串而忽略。
<span>&lt;</span>script<span>></span>
	<span>"use strict"</span><span>;</span>
	console<span>.</span><span>log</span><span>(</span><span>"这是严格模式。"</span><span>)</span><span>;</span>
<span>&lt;</span><span>/</span>script<span>></span>


<span>//将"use strict"放在函数体的第一行，则整个函数以"严格模式"运行。</span>
<span>&lt;</span>script<span>></span>
 <span>function</span> <span>fn</span> <span>(</span><span>)</span> <span>{</span><span>"use strict"</span><span>}</span>
<span>&lt;</span><span>/</span>script<span>></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></blockquote>
<h5 id="严格模式中的变化"> 严格模式中的变化；</h5>
<blockquote>
<ol>
<li>变量规定：
<ul>
<li>变量申明必须加var，而且不准删除变量。</li>
<li>严禁删除已经声明变量。例如，delete x; 语法是错误的。</li>
</ul>
</li>
<li>严格模式下this 指向问题；
<ul>
<li>严格模式下，普通函数this是undefined。</li>
<li>严格模式下,如果构造函数不加new调用, this 指向的是undefined 如果给他赋值则会报错。</li>
</ul>
</li>
<li>函数变化；
<ul>
<li>函数不能有重名的参数。</li>
<li>函数必须声明在顶层.新版本的JavaScript 会引入“块级作用域”（ES6 中已引入）。为了与新版本接轨，不允许在非函数的代码块内声明函数。【if，for等里面定义函数也不可以，但是现在不可以】</li>
<li>错误写法:
function fn (a,a) {console.log(a+a);}
fn(1,2);</li>
</ul>
</li>
</ol>
</blockquote>
<h3 id="高阶函数"> 高阶函数</h3>
<blockquote>
<ol>
<li>高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。</li>
<li>函数也是一种数据类型，同样可以作为参数，传递给另外一个参数使用。最典型的就是作为回调函数。</li>
<li>同理函数也可以作为返回值传递回来。</li>
</ol>
<p>作为参数：</p>
<div><pre><code><span>function</span> <span>eat</span> <span>(</span><span>callback</span><span>)</span> <span>{</span>
  <span>setTimeout</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'吃完了'</span><span>)</span>
    <span>callback</span><span>(</span><span>)</span>
  <span>}</span><span>,</span> <span>1000</span><span>)</span>
<span>}</span>

<span>eat</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'去唱歌'</span><span>)</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>作为返回值；</p>
<div><pre><code><span>function</span> <span>genFun</span> <span>(</span><span>type</span><span>)</span> <span>{</span>
  <span>return</span> <span>function</span> <span>(</span><span>obj</span><span>)</span> <span>{</span>
    <span>return</span> <span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span>obj<span>)</span> <span>===</span> type
  <span>}</span>
<span>}</span>

<span>var</span> isArray <span>=</span> <span>genFun</span><span>(</span><span>'[object Array]'</span><span>)</span>
<span>var</span> isObject <span>=</span> <span>genFun</span><span>(</span><span>'[object Object]'</span><span>)</span>

console<span>.</span><span>log</span><span>(</span><span>isArray</span><span>(</span><span>[</span><span>]</span><span>)</span><span>)</span> <span>// => true</span>
console<span>.</span><span>log</span><span>(</span><span>isArray</span><span>(</span><span>{</span><span>}</span><span>)</span><span>)</span> <span>// => true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></blockquote>
<h3 id="函数闭包"> 函数闭包；</h3>
<blockquote>
<ol>
<li>
<p>闭包的概念：一个作用域可以访问另外一个函数内部的局部变量。</p>
</li>
<li>
<p>闭包的作用：延伸变量的作用范围。</p>
</li>
<li>
<p>在本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</p>
</li>
<li>
<p>如果函数内部有使用此变量，那么此变量便不会被销毁，否则会被销毁；</p>
</li>
<li>
<p>闭包的用途：</p>
<ul>
<li>可以在函数外部读取函数内部成员</li>
<li>让函数内成员始终存活在内存中</li>
</ul>
<div><pre><code><span>&lt;</span>script<span>></span>
	<span>function</span> <span>fn1</span><span>(</span><span>)</span><span>{</span>
		<span>// fn1 就是闭包函数</span>
		<span>var</span> num <span>=</span> <span>10</span><span>;</span>
		<span>function</span> <span>fn2</span><span>(</span><span>)</span><span>{</span>
			console<span>.</span><span>log</span><span>(</span>num<span>)</span><span>;</span> <span>// 10</span>
		<span>}</span>
		<span>fn2</span><span>(</span><span>)</span>
	<span>}</span>
	<span>fn1</span><span>(</span><span>)</span><span>;</span>
<span>&lt;</span><span>/</span>script<span>></span>
<span>//示例1：</span>
<span>var</span> arr <span>=</span> <span>[</span><span>10</span><span>,</span> <span>20</span><span>,</span> <span>30</span><span>]</span>
<span>for</span><span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
  arr<span>[</span>i<span>]</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>i<span>)</span>
  <span>}</span>
<span>}</span>
<span>//示例2；</span>
console<span>.</span><span>log</span><span>(</span><span>111</span><span>)</span>
                     
<span>for</span><span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>3</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
  <span>setTimeout</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>i<span>)</span>
  <span>}</span><span>,</span> <span>0</span><span>)</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>222</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div></li>
</ol>
</blockquote>
<h4 id="闭包的思考题"> 闭包的思考题；</h4>
<blockquote>
<p>思考题1；</p>
<div><pre><code><span>var</span> name <span>=</span> <span>"The Window"</span><span>;</span>
<span>var</span> object <span>=</span> <span>{</span>
  name<span>:</span> <span>"My Object"</span><span>,</span>
  <span>getNameFunc</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>return</span> <span>this</span><span>.</span>name<span>;</span>
    <span>}</span><span>;</span>
  <span>}</span>
<span>}</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>object<span>.</span><span>getNameFunc</span><span>(</span><span>)</span><span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>思考题2：</p>
<div><pre><code><span>var</span> name <span>=</span> <span>"The Window"</span><span>;</span>　　
<span>var</span> object <span>=</span> <span>{</span>　　　　
  name<span>:</span> <span>"My Object"</span><span>,</span>
  <span>getNameFunc</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>var</span> that <span>=</span> <span>this</span><span>;</span>
    <span>return</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>return</span> that<span>.</span>name<span>;</span>
    <span>}</span><span>;</span>
  <span>}</span>
<span>}</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>object<span>.</span><span>getNameFunc</span><span>(</span><span>)</span><span>(</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></blockquote>
<h4 id="变量作用域"> 变量作用域；</h4>
<blockquote>
<ol>
<li>
<p>全局作用域.</p>
</li>
<li>
<p>局部作用域(函数作用域);</p>
</li>
<li>
<p>es5中 没有块级作用域的概念;</p>
</li>
<li>
<p>内层作用域可以访问外层作用域反之不行；</p>
</li>
<li>
<p><strong>当函数执行完毕，本作用域内的局部变量会销毁。</strong></p>
<div><pre><code><span>{</span>
  <span>var</span> foo <span>=</span> <span>'bar'</span>
<span>}</span>
                     
console<span>.</span><span>log</span><span>(</span>foo<span>)</span>
                     
<span>if</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
  <span>var</span> a <span>=</span> <span>123</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span>a<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
</ol>
</blockquote>
<h3 id="函数递归"> 函数递归；</h3>
<blockquote>
<p>**递归：**如果一个函数在内部可以调用其本身，那么这个函数就是递归函数。</p>
<p>**递归：**函数调用函数其本身;</p>
<p>**注意：**递归函数的作用和循环效果一样，由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件return。</p>
</blockquote>
<h4 id="计算阶乘"> 计算阶乘;</h4>
<div><pre><code><span>function</span> <span>factorial</span> <span>(</span><span>num</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>num <span>&lt;=</span> <span>1</span><span>)</span> <span>{</span>
    <span>return</span> <span>1</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>return</span> num <span>*</span> <span>factorial</span><span>(</span>num <span>-</span> <span>1</span><span>)</span>
  <span>}</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>factorial</span><span>(</span>num<span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id="递归求斐波那契数列"> 递归求斐波那契数列;</h4>
<div><pre><code><span>// 利用递归函数求斐波那契数列(兔子序列)  1、1、2、3、5、8、13、21...</span>
<span>// 用户输入一个数字 n 就可以求出 这个数字对应的兔子序列值</span>
<span>// 我们只需要知道用户输入的n 的前面两项(n-1 n-2)就可以计算出n 对应的序列值</span>
<span>function</span> <span>fb</span><span>(</span><span>n</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>n <span>===</span> <span>1</span> <span>||</span> n <span>===</span> <span>2</span><span>)</span> <span>{</span>
        <span>return</span> <span>1</span><span>;</span>
  <span>}</span>
  <span>return</span> <span>fb</span><span>(</span>n <span>-</span> <span>1</span><span>)</span> <span>+</span> <span>fb</span><span>(</span>n <span>-</span> <span>2</span><span>)</span><span>;</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>fb</span><span>(</span><span>3</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h4 id="递归应用场景"> 递归应用场景</h4>
<ul>
<li>深拷贝</li>
<li>菜单树</li>
<li>遍历 DOM 树</li>
</ul>
<hr>
<h4 id="浅拷贝"> 浅拷贝；</h4>
<blockquote>
<p>拷贝不能直接赋值，对象赋值的是地址;</p>
<div><pre><code><span>//不可取；</span>
<span>var</span> obj <span>=</span> <span>{</span>
		name <span>:</span> <span>'张三丰'</span><span>,</span>
		age <span>:</span> <span>22</span>
	<span>}</span><span>;</span>
<span>var</span> newObj <span>=</span> obj<span>;</span>
console<span>.</span><span>log</span><span>(</span>newObj<span>)</span><span>;</span>

<span>//浅拷贝；只能拷贝到最外面一层；</span>
<span>var</span> obj <span>=</span> <span>{</span>
			name <span>:</span> <span>'张三丰'</span><span>,</span>
			age <span>:</span> <span>22</span>
		<span>}</span><span>;</span>

		<span>var</span> newObj <span>=</span> <span>{</span><span>}</span><span>;</span>
		<span>for</span> <span>(</span>key <span>in</span> obj<span>)</span> <span>{</span>
			newObj<span>[</span>key<span>]</span> <span>=</span> obj<span>[</span>key<span>]</span><span>;</span>
		<span>}</span>

		console<span>.</span><span>log</span><span>(</span>newObj<span>)</span><span>;</span>
		
<span>//es6：新方法</span>
Object<span>.</span><span>assign</span><span>(</span>target<span>,</span> sources<span>)</span><span>;</span><span>//用于浅拷贝；深拷贝不可取；</span>

console<span>.</span><span>log</span><span>(</span>newObj<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></blockquote>
<h4 id="深拷贝"> 深拷贝；</h4>
<blockquote>
<div><pre><code><span>var</span> obj <span>=</span> <span>{</span>
			name <span>:</span> <span>'1张三丰'</span><span>,</span>
			age <span>:</span> <span>22</span><span>,</span>
			messige <span>:</span> <span>{</span>
				sex <span>:</span> <span>'男'</span><span>,</span>
				score <span>:</span> <span>16</span>
			<span>}</span><span>,</span>
			color <span>:</span> <span>[</span><span>'red'</span><span>,</span><span>'purple'</span><span>,</span><span>'qing'</span><span>]</span>

		<span>}</span>
		<span>var</span> newObj <span>=</span> <span>{</span><span>}</span><span>;</span>
		<span>function</span> <span>kaobei</span> <span>(</span><span>newObj<span>,</span>obj</span><span>)</span> <span>{</span>

			<span>for</span> <span>(</span>key <span>in</span> obj<span>)</span> <span>{</span>

				<span>if</span> <span>(</span>obj<span>[</span>key<span>]</span> <span>instanceof</span> <span>Array</span><span>)</span> <span>{</span>
					newObj<span>[</span>key<span>]</span> <span>=</span> <span>[</span><span>]</span><span>;</span>
					<span>kaobei</span><span>(</span>newObj<span>[</span>key<span>]</span><span>,</span>obj<span>[</span>key<span>]</span><span>)</span><span>;</span>
				<span>}</span> <span>else</span> <span>if</span> <span>(</span>obj<span>[</span>key<span>]</span> <span>instanceof</span> <span>Object</span><span>)</span> <span>{</span>
					newObj<span>[</span>key<span>]</span> <span>=</span> <span>{</span><span>}</span><span>;</span>
					<span>kaobei</span><span>(</span>newObj<span>[</span>key<span>]</span><span>,</span>obj<span>[</span>key<span>]</span><span>)</span>
				<span>}</span> <span>else</span> <span>{</span>
					newObj<span>[</span>key<span>]</span> <span>=</span> obj<span>[</span>key<span>]</span><span>;</span>
				<span>}</span>
			<span>}</span>
		<span>}</span>
		obj<span>.</span>messige<span>.</span>sex <span>=</span> <span>99</span><span>;</span>
		<span>kaobei</span><span>(</span>newObj<span>,</span>obj<span>)</span><span>;</span>
		console<span>.</span><span>log</span><span>(</span>newObj<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div></blockquote>
<h2 id="正则表达式"> 正则表达式</h2>
<h4 id="什么是正则表达式"> 什么是正则表达式；</h4>
<blockquote>
<div><pre><code><span>//正则表达式（ Regular Expression ）是用于匹配字符串中字符组合的模式。</span>
<span>//在JavaScript中，正则表达式也是对象。</span>

作用：检索关键字，过滤敏感字符，表单验证<span>;</span><span>强大的字符串替换能力</span><span>(</span>替换<span>)</span>

正则表通常被用来检索、替换那些符合某个模式（规则）的文本<span>;</span>
例如验证表单：用户名表单只能输入英文字母、数字或者下划线， <span>昵称输入框中可以输入中文</span><span>(</span>匹配<span>)</span>。
<span>此外，正则表达式还常用于过滤掉页面内容中的一些敏感词</span><span>(</span>替换<span>)</span><span>，或从字符串中获取我们想要的特定部分</span><span>(</span>提取<span>)</span>等 。

其他语言也会使用正则表达式<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></blockquote>
<h4 id="正则表达式的特点"> 正则表达式的特点;</h4>
<blockquote>
<ol>
<li>灵活性、逻辑性和功能性非常的强。</li>
<li>可以迅速地用极简单的方式达到字符串的复杂控制。</li>
<li>实际开发,一般都是直接复制写好的正则表达式. 但是要求会使用正则表达式并且根据实际情况修改正则表达式.   比如用户名:   /^[a-z0-9_-]{3,16}$/</li>
</ol>
</blockquote>
<h3 id="正则表达式的测试"> 正则表达式的测试</h3>
<blockquote>
<p>1、test() 正则对象的方法：用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是待测试字符串；</p>
<p>2、jQuery 手册：正则表达式部分；正则测试工具 ： http://tool.oschina.net/regex；</p>
<p>3、正则表达式在线测试 ： https://c.runoob.com；</p>
<p>注意：正则里面没有引号；
regexObj.test(str);
regexObj：正则表达式
str：用户输入字符串</p>
<p>var rg = /123/;
console.log(rg.test(123));//匹配字符中是否出现123  出现结果为true
console.log(rg.test('abc'));//匹配字符中是否出现123 未出现结果为false</p>
</blockquote>
<h3 id="正则表达式的组成"> 正则表达式的组成</h3>
<blockquote>
<div><pre><code>正则表达式可以由简单的字符构成，比如 <span>/</span>abc<span>/</span>，也可以是简单和特殊字符的组合，比如 <span>/</span>ab<span>*</span>c<span>/</span> 。其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，如 <span>^</span> 、$ 、<span>+</span> 等。

正则表达式的组成：简单字符 和 <span>特殊字符</span><span>(</span>元字符<span>)</span>；

<span>//特殊字符非常多，可以参考： </span>

<span>MDN</span>：https<span>:</span><span>/</span><span>/</span>developer<span>.</span>mozilla<span>.</span>org<span>/</span>zh<span>-</span><span>CN</span><span>/</span>docs<span>/</span>Web<span>/</span>JavaScript<span>/</span>Guide<span>/</span>Regular_Expressions

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></blockquote>
<h3 id="元字符串"> 元字符串；</h3>
<h4 id="常用元字符"> 常用元字符；</h4>
<p><img src="./assets/1570794584491.png" alt="" /></p>
<table>
<thead>
<tr>
<th>边界符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>.</td>
<td>匹配除换行符以外的任意单个字符</td>
</tr>
<tr>
<td>^</td>
<td>表示匹配行首的文本(以谁开始) ；和&amp;一起使用可以达到精确匹配；</td>
</tr>
<tr>
<td>$</td>
<td>表示匹配行尾的文本(以谁结束)</td>
</tr>
</tbody>
</table>
<h4 id="量词符"> 量词符</h4>
<blockquote>
<p>量词符可以用来设定某个模式出现的次数。</p>
</blockquote>
<table>
<thead>
<tr>
<th>量词符</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>*</td>
<td>重复零次或更多次</td>
</tr>
<tr>
<td>+</td>
<td>重复一次或更多次</td>
</tr>
<tr>
<td>?</td>
<td>重复零次或一次</td>
</tr>
<tr>
<td>{n}</td>
<td>重复n次</td>
</tr>
<tr>
<td>{n,}</td>
<td>重复n次或更多次</td>
</tr>
<tr>
<td>{n,m}</td>
<td>重复n到m次</td>
</tr>
</tbody>
</table>
<h4 id="其它"> 其它；</h4>
<div><pre><code>[] 字符串用中括号括起来，表示匹配其中的任一字符， 多选一   相当于或的意思 ； 
[^]  取反；匹配除了中括号以内的所有内容；
\ 转义符
| 或者，选择两者中的一个。注意|将左右两边分为两部分，而不管左右两边有多长多乱
() 从两个直接量中选择一个，分组
   eg：gr(a|e)y匹配gray和grey
[\u4e00-\u9fa5]  匹配汉字
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="用户表单验证案例"> 用户表单验证案例；</h3>
<ul>
<li>如果用户名输入合法, 则后面提示信息为:  用户名合法,并且颜色为绿色；</li>
<li>如果用户名输入不合法, 则后面提示信息为:  用户名不符合规范, 并且颜色为红色；</li>
</ul>
<blockquote>
<div><pre><code><span>var</span> input <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>'input'</span><span>)</span><span>;</span>
		<span>var</span> span <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>'span'</span><span>)</span><span>;</span>

		<span>var</span> reg <span>=</span> <span><span>/</span><span>^[a-zA-Z0-9_-]{6,16}$</span><span>/</span></span><span>;</span>

		input<span>.</span><span>onblur</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>

			<span>if</span> <span>(</span>reg<span>.</span><span>test</span><span>(</span><span>this</span><span>.</span>value<span>)</span><span>)</span> <span>{</span>
				span<span>.</span>innerHTML <span>=</span> <span>'输入正确'</span><span>;</span>
				span<span>.</span>className <span>=</span> <span>'right'</span><span>;</span>
			<span>}</span><span>else</span> <span>{</span>
				span<span>.</span>innerHTML <span>=</span> <span>'错误内容'</span><span>;</span>
				span<span>.</span>className <span>=</span> <span>'error'</span><span>;</span>
			<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></blockquote>
<h2 id="javascript-中使用正则表达式"> JavaScript 中使用正则表达式</h2>
<h3 id="创建正则对象"> 创建正则对象</h3>
<p>方式1：</p>
<div><pre><code><span>var</span> reg <span>=</span> <span>new</span> <span>Regex</span><span>(</span><span>'\d'</span><span>,</span> <span>'i'</span><span>)</span><span>;</span>
<span>var</span> reg <span>=</span> <span>new</span> <span>Regex</span><span>(</span><span>'\d'</span><span>,</span> <span>'gi'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>方式2：</p>
<div><pre><code><span>var</span> reg <span>=</span> <span><span>/</span><span>\d</span><span>/</span><span>i</span></span><span>;</span>
<span>var</span> reg <span>=</span> <span><span>/</span><span>\d</span><span>/</span><span>gi</span></span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="参数"> 参数</h4>
<table>
<thead>
<tr>
<th>标志</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>i</td>
<td>忽略大小写</td>
</tr>
<tr>
<td>g</td>
<td>全局匹配</td>
</tr>
<tr>
<td>gi</td>
<td>全局匹配+忽略大小写</td>
</tr>
</tbody>
</table>
<h3 id="正则匹配"> 正则匹配</h3>
<div><pre><code><span>// 匹配日期</span>
<span>var</span> dateStr <span>=</span> <span>'2015-10-10'</span><span>;</span>
<span>var</span> reg <span>=</span> <span><span>/</span><span>^\d{4}-\d{1,2}-\d{1,2}$</span><span>/</span></span>
console<span>.</span><span>log</span><span>(</span>reg<span>.</span><span>test</span><span>(</span>dateStr<span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h4 id="匹配正则表达式"> 匹配正则表达式</h4>
<div><pre><code><span>// console.log(/./.test("除了回车换行以外的任意字符"));//true</span>
<span>// console.log(/.*/.test("0个到多个"));//true</span>
<span>// console.log(/.+/.test("1个到多个"));//true</span>
<span>// console.log(/.?/.test("哈哈"));//true</span>
<span>// console.log(/[0-9]/.test("9527"));//true</span>
<span>// console.log(/[a-z]/.test("what"));//true</span>
<span>// console.log(/[A-Z]/.test("Are"));//true</span>
<span>// console.log(/[a-zA-Z]/.test("干啥子"));//false</span>
<span>// console.log(/[0-9a-zA-Z]/.test("9ebg"));//true</span>
<span>// console.log(/b|(ara)/.test("abra"));//true</span>
<span>// console.log(/[a-z]{2,3}/.test("arfsf"));//true</span>
    console<span>.</span><span>log</span><span>(</span><span><span>/</span><span>\d</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>"998"</span><span>)</span><span>)</span><span>;</span><span>//true</span>
    console<span>.</span><span>log</span><span>(</span><span><span>/</span><span>\d*</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>"998"</span><span>)</span><span>)</span><span>;</span><span>//true</span>
    console<span>.</span><span>log</span><span>(</span><span><span>/</span><span>\d+</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>"998"</span><span>)</span><span>)</span><span>;</span><span>//true</span>
    console<span>.</span><span>log</span><span>(</span><span><span>/</span><span>\d{0,}</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>"998"</span><span>)</span><span>)</span><span>;</span><span>//true</span>
    console<span>.</span><span>log</span><span>(</span><span><span>/</span><span>\d{2,3}</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>"998"</span><span>)</span><span>)</span><span>;</span><span>//true</span>
    console<span>.</span><span>log</span><span>(</span><span><span>/</span><span>\D</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>"eat"</span><span>)</span><span>)</span><span>;</span><span>//true</span>
    console<span>.</span><span>log</span><span>(</span><span><span>/</span><span>\s</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>"  "</span><span>)</span><span>)</span><span>;</span><span>//true</span>
    console<span>.</span><span>log</span><span>(</span><span><span>/</span><span>\S</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>"嘎嘎"</span><span>)</span><span>)</span><span>;</span><span>//true</span>
    console<span>.</span><span>log</span><span>(</span><span><span>/</span><span>\w</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>"_"</span><span>)</span><span>)</span><span>;</span><span>//true</span>
    console<span>.</span><span>log</span><span>(</span><span><span>/</span><span>\W</span><span>/</span></span><span>.</span><span>test</span><span>(</span><span>"_"</span><span>)</span><span>)</span><span>;</span><span>//true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id="正则提取"> 正则提取</h3>
<div><pre><code><span>// 1. 提取工资</span>
<span>var</span> str <span>=</span> <span>"张三：1000，李四：5000，王五：8000。"</span><span>;</span>
<span>var</span> array <span>=</span> str<span>.</span><span>match</span><span>(</span><span><span>/</span><span>\d+</span><span>/</span><span>g</span></span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>array<span>)</span><span>;</span>

<span>// 2. 提取email地址</span>
<span>var</span> str <span>=</span> <span>"123123@xx.com,fangfang@valuedopinions.cn 286669312@qq.com 2、emailenglish@emailenglish.englishtown.com 286669312@qq.com..."</span><span>;</span>
<span>var</span> array <span>=</span> str<span>.</span><span>match</span><span>(</span><span><span>/</span><span>\w+@\w+\.\w+(\.\w+)?</span><span>/</span><span>g</span></span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>array<span>)</span><span>;</span>

<span>// 3. 分组提取  </span>
<span>// 3. 提取日期中的年部分  2015-5-10</span>
<span>var</span> dateStr <span>=</span> <span>'2016-1-5'</span><span>;</span>
<span>// 正则表达式中的()作为分组来使用，获取分组匹配到的结果用Regex.$1 $2 $3....来获取</span>
<span>var</span> reg <span>=</span> <span><span>/</span><span>(\d{4})-\d{1,2}-\d{1,2}</span><span>/</span></span><span>;</span>
<span>if</span> <span>(</span>reg<span>.</span><span>test</span><span>(</span>dateStr<span>)</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>RegExp<span>.</span>$<span>1</span><span>)</span><span>;</span>
<span>}</span>

<span>// 4. 提取邮件中的每一部分</span>
<span>var</span> reg <span>=</span> <span><span>/</span><span>(\w+)@(\w+)\.(\w+)(\.\w+)?</span><span>/</span></span><span>;</span>
<span>var</span> str <span>=</span> <span>"123123@xx.com"</span><span>;</span>
<span>if</span> <span>(</span>reg<span>.</span><span>test</span><span>(</span>str<span>)</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>RegExp<span>.</span>$<span>1</span><span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>RegExp<span>.</span>$<span>2</span><span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>RegExp<span>.</span>$<span>3</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="正则替换"> 正则替换</h3>
<div><pre><code><span>// 1. 替换所有空白</span>
<span>var</span> str <span>=</span> <span>"   123AD  asadf   asadfasf  adf "</span><span>;</span>
str <span>=</span> str<span>.</span><span>replace</span><span>(</span><span><span>/</span><span>\s</span><span>/</span><span>g</span></span><span>,</span><span>"xx"</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>str<span>)</span><span>;</span>

<span>// 2. 替换所有,|，</span>
<span>var</span> str <span>=</span> <span>"abc,efg,123，abc,123，a"</span><span>;</span>
str <span>=</span> str<span>.</span><span>replace</span><span>(</span><span><span>/</span><span>,|，</span><span>/</span><span>g</span></span><span>,</span> <span>"."</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>str<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="案例-表单验证"> 案例：表单验证</h3>
<div><pre><code>QQ号：<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>id</span><span><span>=</span><span>"</span>txtQQ<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>br</span><span>></span></span>
邮箱：<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>id</span><span><span>=</span><span>"</span>txtEMail<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>br</span><span>></span></span>
手机：<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>id</span><span><span>=</span><span>"</span>txtPhone<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>br</span><span>></span></span>
生日：<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>id</span><span><span>=</span><span>"</span>txtBirthday<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>br</span><span>></span></span>
姓名：<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>id</span><span><span>=</span><span>"</span>txtName<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>br</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>//获取文本框</span>
<span>var</span> txtQQ <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>"txtQQ"</span><span>)</span><span>;</span>
<span>var</span> txtEMail <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>"txtEMail"</span><span>)</span><span>;</span>
<span>var</span> txtPhone <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>"txtPhone"</span><span>)</span><span>;</span>
<span>var</span> txtBirthday <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>"txtBirthday"</span><span>)</span><span>;</span>
<span>var</span> txtName <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>"txtName"</span><span>)</span><span>;</span>

<span>//</span>
txtQQ<span>.</span><span>onblur</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>//获取当前文本框对应的span</span>
  <span>var</span> span <span>=</span> <span>this</span><span>.</span>nextElementSibling<span>;</span>
  <span>var</span> reg <span>=</span> <span><span>/</span><span>^\d{5,12}$</span><span>/</span></span><span>;</span>
  <span>//判断验证是否成功</span>
  <span>if</span><span>(</span><span>!</span>reg<span>.</span><span>test</span><span>(</span><span>this</span><span>.</span>value<span>)</span> <span>)</span><span>{</span>
    <span>//验证不成功</span>
    span<span>.</span>innerText <span>=</span> <span>"请输入正确的QQ号"</span><span>;</span>
    span<span>.</span>style<span>.</span>color <span>=</span> <span>"red"</span><span>;</span>
  <span>}</span><span>else</span><span>{</span>
    <span>//验证成功</span>
    span<span>.</span>innerText <span>=</span> <span>""</span><span>;</span>
    span<span>.</span>style<span>.</span>color <span>=</span> <span>""</span><span>;</span>
  <span>}</span>
<span>}</span><span>;</span>

<span>//txtEMail</span>
txtEMail<span>.</span><span>onblur</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>//获取当前文本框对应的span</span>
  <span>var</span> span <span>=</span> <span>this</span><span>.</span>nextElementSibling<span>;</span>
  <span>var</span> reg <span>=</span> <span><span>/</span><span>^\w+@\w+\.\w+(\.\w+)?$</span><span>/</span></span><span>;</span>
  <span>//判断验证是否成功</span>
  <span>if</span><span>(</span><span>!</span>reg<span>.</span><span>test</span><span>(</span><span>this</span><span>.</span>value<span>)</span> <span>)</span><span>{</span>
    <span>//验证不成功</span>
    span<span>.</span>innerText <span>=</span> <span>"请输入正确的EMail地址"</span><span>;</span>
    span<span>.</span>style<span>.</span>color <span>=</span> <span>"red"</span><span>;</span>
  <span>}</span><span>else</span><span>{</span>
    <span>//验证成功</span>
    span<span>.</span>innerText <span>=</span> <span>""</span><span>;</span>
    span<span>.</span>style<span>.</span>color <span>=</span> <span>""</span><span>;</span>
  <span>}</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><p>表单验证部分，封装成函数：</p>
<div><pre><code><span>var</span> regBirthday <span>=</span> <span><span>/</span><span>^\d{4}-\d{1,2}-\d{1,2}$</span><span>/</span></span><span>;</span>
<span>addCheck</span><span>(</span>txtBirthday<span>,</span> regBirthday<span>,</span> <span>"请输入正确的出生日期"</span><span>)</span><span>;</span>
<span>//给文本框添加验证</span>
<span>function</span> <span>addCheck</span><span>(</span><span>element<span>,</span> reg<span>,</span> tip</span><span>)</span> <span>{</span>
  element<span>.</span><span>onblur</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>//获取当前文本框对应的span</span>
    <span>var</span> span <span>=</span> <span>this</span><span>.</span>nextElementSibling<span>;</span>
    <span>//判断验证是否成功</span>
    <span>if</span><span>(</span><span>!</span>reg<span>.</span><span>test</span><span>(</span><span>this</span><span>.</span>value<span>)</span> <span>)</span><span>{</span>
      <span>//验证不成功</span>
      span<span>.</span>innerText <span>=</span> tip<span>;</span>
      span<span>.</span>style<span>.</span>color <span>=</span> <span>"red"</span><span>;</span>
    <span>}</span><span>else</span><span>{</span>
      <span>//验证成功</span>
      span<span>.</span>innerText <span>=</span> <span>""</span><span>;</span>
      span<span>.</span>style<span>.</span>color <span>=</span> <span>""</span><span>;</span>
    <span>}</span>
  <span>}</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p>通过给元素增加自定义验证属性对表单进行验证：</p>
<div><pre><code><span><span><span>&lt;</span>form</span> <span>id</span><span><span>=</span><span>"</span>frm<span>"</span></span><span>></span></span>
  QQ号：<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>txtQQ<span>"</span></span> <span>data-rule</span><span><span>=</span><span>"</span>qq<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>br</span><span>></span></span>
  邮箱：<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>txtEMail<span>"</span></span> <span>data-rule</span><span><span>=</span><span>"</span>email<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>br</span><span>></span></span>
  手机：<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>txtPhone<span>"</span></span> <span>data-rule</span><span><span>=</span><span>"</span>phone<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>br</span><span>></span></span>
  生日：<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>txtBirthday<span>"</span></span> <span>data-rule</span><span><span>=</span><span>"</span>date<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>br</span><span>></span></span>
  姓名：<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>txtName<span>"</span></span> <span>data-rule</span><span><span>=</span><span>"</span>cn<span>"</span></span><span>></span></span><span><span><span>&lt;</span>span</span><span>></span></span><span><span><span>&lt;/</span>span</span><span>></span></span><span><span><span>&lt;</span>br</span><span>></span></span>
<span><span><span>&lt;/</span>form</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code><span>// 所有的验证规则</span>
<span>var</span> rules <span>=</span> <span>[</span>
  <span>{</span>
    name<span>:</span> <span>'qq'</span><span>,</span>
    reg<span>:</span> <span><span>/</span><span>^\d{5,12}$</span><span>/</span></span><span>,</span>
    tip<span>:</span> <span>"请输入正确的QQ"</span>
  <span>}</span><span>,</span>
  <span>{</span>
    name<span>:</span> <span>'email'</span><span>,</span>
    reg<span>:</span> <span><span>/</span><span>^\w+@\w+\.\w+(\.\w+)?$</span><span>/</span></span><span>,</span>
    tip<span>:</span> <span>"请输入正确的邮箱地址"</span>
  <span>}</span><span>,</span>
  <span>{</span>
    name<span>:</span> <span>'phone'</span><span>,</span>
    reg<span>:</span> <span><span>/</span><span>^\d{11}$</span><span>/</span></span><span>,</span>
    tip<span>:</span> <span>"请输入正确的手机号码"</span>
  <span>}</span><span>,</span>
  <span>{</span>
    name<span>:</span> <span>'date'</span><span>,</span>
    reg<span>:</span> <span><span>/</span><span>^\d{4}-\d{1,2}-\d{1,2}$</span><span>/</span></span><span>,</span>
    tip<span>:</span> <span>"请输入正确的出生日期"</span>
  <span>}</span><span>,</span>
  <span>{</span>
    name<span>:</span> <span>'cn'</span><span>,</span>
    reg<span>:</span> <span><span>/</span><span>^[\u4e00-\u9fa5]{2,4}$</span><span>/</span></span><span>,</span>
    tip<span>:</span> <span>"请输入正确的姓名"</span>
  <span>}</span><span>]</span><span>;</span>

<span>addCheck</span><span>(</span><span>'frm'</span><span>)</span><span>;</span>


<span>//给文本框添加验证</span>
<span>function</span> <span>addCheck</span><span>(</span><span>formId</span><span>)</span> <span>{</span>
  <span>var</span> i <span>=</span> <span>0</span><span>,</span>
      len <span>=</span> <span>0</span><span>,</span>
      frm <span>=</span>document<span>.</span><span>getElementById</span><span>(</span>formId<span>)</span><span>;</span>
  len <span>=</span> frm<span>.</span>children<span>.</span>length<span>;</span>
  <span>for</span> <span>(</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>var</span> element <span>=</span> frm<span>.</span>children<span>[</span>i<span>]</span><span>;</span>
    <span>// 表单元素中有name属性的元素添加验证</span>
    <span>if</span> <span>(</span>element<span>.</span>name<span>)</span> <span>{</span>
      element<span>.</span><span>onblur</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>// 使用dataset获取data-自定义属性的值</span>
        <span>var</span> ruleName <span>=</span> <span>this</span><span>.</span>dataset<span>.</span>rule<span>;</span>
        <span>var</span> rule <span>=</span><span>getRuleByRuleName</span><span>(</span>rules<span>,</span> ruleName<span>)</span><span>;</span>

        <span>var</span> span <span>=</span> <span>this</span><span>.</span>nextElementSibling<span>;</span>
        <span>//判断验证是否成功</span>
        <span>if</span><span>(</span><span>!</span>rule<span>.</span>reg<span>.</span><span>test</span><span>(</span><span>this</span><span>.</span>value<span>)</span> <span>)</span><span>{</span>
          <span>//验证不成功</span>
          span<span>.</span>innerText <span>=</span> rule<span>.</span>tip<span>;</span>
          span<span>.</span>style<span>.</span>color <span>=</span> <span>"red"</span><span>;</span>
        <span>}</span><span>else</span><span>{</span>
          <span>//验证成功</span>
          span<span>.</span>innerText <span>=</span> <span>""</span><span>;</span>
          span<span>.</span>style<span>.</span>color <span>=</span> <span>""</span><span>;</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>// 根据规则的名称获取规则对象</span>
<span>function</span> <span>getRuleByRuleName</span><span>(</span><span>rules<span>,</span> ruleName</span><span>)</span> <span>{</span>
  <span>var</span> i <span>=</span> <span>0</span><span>,</span>
      len <span>=</span> rules<span>.</span>length<span>;</span>
  <span>var</span> rule <span>=</span> <span>null</span><span>;</span>
  <span>for</span> <span>(</span><span>;</span> i <span>&lt;</span> len<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>rules<span>[</span>i<span>]</span><span>.</span>name <span>==</span> ruleName<span>)</span> <span>{</span>
      rule <span>=</span> rules<span>[</span>i<span>]</span><span>;</span>
      <span>break</span><span>;</span>
    <span>}</span>
  <span>}</span>
  <span>return</span> rule<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div><h2 id="补充"> 补充；</h2>
<h3 id="伪数组和数组"> 伪数组和数组</h3>
<p>在JavaScript中，除了5种原始数据类型之外，其他所有的都是对象，包括函数（Function）。</p>
<h4 id="对象与数组的关系"> 对象与数组的关系</h4>
<p>在说区别之前，需要先提到另外一个知识，就是 JavaScript 的原型继承。
所有 JavaScript 的内置构造函数都是继承自 <code>Object.prototype</code> 。
在这个前提下，可以理解为使用 <code>new Array()</code> 或 <code>[]</code> 创建出来的数组对象，都会拥有 <code>Object.prototype</code> 的属性值。</p>
<div><pre><code><span>var</span> obj <span>=</span> <span>{</span><span>}</span><span>;</span><span>// 拥有 Object.prototype 的属性值</span>
<span>var</span> arr <span>=</span> <span>[</span><span>]</span><span>;</span>
<span>//使用数组直接量创建的数组，由于 Array.prototype 的属性继承自 Object.prototype，</span>
<span>//那么，它将同时拥有 Array.prototype 和 Object.prototype 的属性值</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>可以得到对象和数组的第一个区别：对象没有数组 Array.prototype 的属性值。</p>
<h4 id="什么是数组"> 什么是数组</h4>
<p>数组具有一个最基本特征：索引，这是对象所没有的，下面来看一段代码：</p>
<div><pre><code><span>var</span> obj <span>=</span> <span>{</span><span>}</span><span>;</span>
<span>var</span> arr <span>=</span> <span>[</span><span>]</span><span>;</span>
 
obj<span>[</span><span>2</span><span>]</span> <span>=</span> <span>'a'</span><span>;</span>
arr<span>[</span><span>2</span><span>]</span> <span>=</span> <span>'a'</span><span>;</span>
 
console<span>.</span><span>log</span><span>(</span>obj<span>[</span><span>2</span><span>]</span><span>)</span><span>;</span> <span>// => a</span>
console<span>.</span><span>log</span><span>(</span>arr<span>[</span><span>2</span><span>]</span><span>)</span><span>;</span> <span>// => a</span>
console<span>.</span><span>log</span><span>(</span>obj<span>.</span>length<span>)</span><span>;</span> <span>// => undefined</span>
console<span>.</span><span>log</span><span>(</span>arr<span>.</span>length<span>)</span><span>;</span> <span>// => 3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><ul>
<li>obj[2]输出'a'，是因为对象就是普通的键值对存取数据</li>
<li>而arr[2]输出'a' 则不同，数组是通过索引来存取数据，arr[2]之所以输出'a'，是因为数组arr索引2的位置已经存储了数据</li>
<li>obj.length并不具有数组的特性，并且obj没有保存属性length，那么自然就会输出undefined</li>
<li>而对于数组来说，length是数组的一个内置属性，数组会根据索引长度来更改length的值</li>
<li>为什么arr.length输出3，而不是1
<ul>
<li>在给数组添加元素时，并没有按照连续的索引添加，所以导致数组的索引不连续，那么就导致索引长度大于元素个数</li>
</ul>
</li>
</ul>
<h4 id="什么是伪数组"> 什么是伪数组</h4>
<ol>
<li>拥有 length 属性，其它属性（索引）为非负整数(对象中的索引会被当做字符串来处理，这里你可以当做是个非负整数串来理解)</li>
<li>不具有数组所具有的方法</li>
</ol>
<p>伪数组，就是像数组一样有 <code>length</code> 属性，也有 <code>0、1、2、3</code> 等属性的对象，看起来就像数组一样，但不是数组，比如:</p>
<div><pre><code><span>var</span> fakeArray <span>=</span> <span>{</span>
  <span>"0"</span><span>:</span> <span>"first"</span><span>,</span>
  <span>"1"</span><span>:</span> <span>"second"</span><span>,</span>
  <span>"2"</span><span>:</span> <span>"third"</span><span>,</span>
  length<span>:</span> <span>3</span>
<span>}</span><span>;</span>
 
<span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> fakeArray<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>fakeArray<span>[</span>i<span>]</span><span>)</span><span>;</span>
<span>}</span>
 
<span>Array</span><span>.</span>prototype<span>.</span><span>join</span><span>.</span><span>call</span><span>(</span>fakeArray<span>,</span><span>'+'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>常见的伪数组有：</p>
<ul>
<li>函数内部的 <code>arguments</code></li>
<li>DOM 对象列表（比如通过 <code>document.getElementsByTags</code> 得到的列表）</li>
<li>jQuery 对象（比如 <code>$(&quot;div&quot;)</code> ）</li>
</ul>
<p>伪数组是一个 Object，而真实的数组是一个 Array。</p>
<p>伪数组存在的意义，是可以让普通的对象也能正常使用数组的很多方法，比如：</p>
<div><pre><code><span>var</span> arr <span>=</span> <span>Array</span><span>.</span>prototype<span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span>arguments<span>)</span><span>;</span>
 
<span>Array</span><span>.</span>prototype<span>.</span><span>forEach</span><span>.</span><span>call</span><span>(</span>arguments<span>,</span> <span>function</span><span>(</span><span>v</span><span>)</span> <span>{</span>
  <span>// 循环arguments对象</span>
<span>}</span><span>)</span><span>;</span>

<span>// push</span>
<span>// some</span>
<span>// every</span>
<span>// filter</span>
<span>// map</span>
<span>// ...</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>以上在借用数组的原型方法的时候都可以通过数组直接量来简化使用：</p>
<div><pre><code><span>var</span> obj <span>=</span> <span>{</span>
  <span>0</span><span>:</span> <span>'a'</span><span>,</span>
  <span>1</span><span>:</span> <span>'b'</span><span>,</span>
  <span>2</span><span>:</span> <span>'c'</span><span>,</span>
  length<span>:</span> <span>3</span>
<span>}</span>

<span>;</span><span>[</span><span>]</span><span>.</span><span>push</span><span>.</span><span>call</span><span>(</span>obj<span>,</span> <span>'d'</span><span>)</span>

console<span>.</span><span>log</span><span>(</span><span>[</span><span>]</span><span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span>obj<span>)</span><span>)</span>

<span>;</span><span>[</span><span>]</span><span>.</span><span>forEach</span><span>.</span><span>call</span><span>(</span>obj<span>,</span> <span>function</span> <span>(</span><span>num<span>,</span> index</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>num<span>)</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h4 id="小结-2"> 小结</h4>
<ul>
<li>对象没有数组 Array.prototype 的属性值，类型是 Object ，而数组类型是 Array</li>
<li>数组是基于索引的实现， length 会自动更新，而对象是键值对</li>
<li>使用对象可以创建伪数组，伪数组可以正常使用数组的大部分方法</li>
</ul>
<h3 id="javascript-垃圾回收机制"> JavaScript 垃圾回收机制</h3>
<h3 id="javascript-运行机制-event-loop"> JavaScript 运行机制：Event Loop</h3>
<h3 id="object"> Object</h3>
<h4 id="静态成员"> 静态成员</h4>
<ul>
<li>Object.assign()</li>
<li>Object.create()</li>
<li>Object.keys()</li>
<li>Object.defineProperty()</li>
</ul>
<h4 id="实例成员"> 实例成员</h4>
<ul>
<li>constructor</li>
<li>hasOwnProperty()</li>
<li>isPrototypeOf</li>
<li>propertyIsEnumerable()</li>
<li>toString()</li>
<li>valueOf()</li>
</ul>
<hr>
<h2 id="附录"> 附录</h2>
<h4 id="校验工具"> 校验工具</h4>
<ul>
<li><a href="https://github.com/douglascrockford/JSLint" target="_blank" rel="noopener noreferrer">JSLint</a></li>
<li><a href="https://github.com/jshint/jshint" target="_blank" rel="noopener noreferrer">JSHint</a></li>
<li><a href="https://github.com/eslint/eslint" target="_blank" rel="noopener noreferrer">ESLint</a></li>
</ul>
<h3 id="文档相关工具"> 文档相关工具</h3>
<ul>
<li>电子文档制作工具: <a href="https://github.com/egoist/docute" target="_blank" rel="noopener noreferrer">docute</a></li>
<li>流程图工具：<a href="http://logicnet.dk/DiagramDesigner/" target="_blank" rel="noopener noreferrer">DiagramDesigner</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>对象拷贝</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-02/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-02/</guid>
      <source url="https://wangyawei.top/rss.xml">对象拷贝</source>
      <category>javascript</category>
      <pubDate>Sun, 02 May 2021 22:22:34 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="浅拷贝"> 浅拷贝；</h2>
<blockquote>
<p>拷贝就是拷贝指向对象的<a href="https://baike.baidu.com/item/%E6%8C%87%E9%92%88/2878304" target="_blank" rel="noopener noreferrer">指针</a>，意思就是说：拷贝出来的目标对象的指针和源对象的指针指向的内存空间是同一块空间，浅拷贝只是一种简单的拷贝，让几个对象公用一个内存。</p>
</blockquote>
<div><pre><code><span>// 人的对象；</span>
    <span>var</span> Proson <span>=</span> <span>{</span>
      name<span>:</span> <span>'小红'</span><span>,</span>
      age<span>:</span> <span>18</span><span>,</span>
      score<span>:</span> <span>99</span><span>,</span>
      arr<span>:</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span><span>,</span>
      interest<span>:</span> <span>{</span>
        song<span>:</span> <span>'大约在冬季'</span><span>,</span>
        skill<span>:</span> <span>'技能'</span><span>,</span>
        dance<span>:</span> <span>'跳舞'</span>
      <span>}</span>
    <span>}</span>

    <span>// 学生的对象；</span>
    <span>var</span> Student <span>=</span> <span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="_1、方法一"> 1、方法一；</h3>
<div><pre><code>    <span>// 利用for in 进行拷贝；</span>
    <span>for</span> <span>(</span><span>const</span> key <span>in</span> Proson<span>)</span> <span>{</span>
      Student<span>[</span>key<span>]</span> <span>=</span> Proson<span>[</span>key<span>]</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>修改原对象的属性值；</strong></p>
<div><pre><code>	<span>// 修改原对象的属性值；</span>
    Proson<span>.</span>name <span>=</span> <span>'赵丽颖'</span>
    Proson<span>.</span>interest<span>.</span>skill <span>=</span> <span>'射手'</span>
 	console<span>.</span><span>log</span><span>(</span>Proson<span>)</span>
    console<span>.</span><span>log</span><span>(</span>Student<span>)</span>
	<span>// 打印的结果如下；</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src="./assets/1581859040922.png" alt="1581859040922" /></p>
<blockquote>
<p>通过打印结果我们可以看到：</p>
<p>1、属性值是简单数据类型的那么原数据的修改不会影响拷贝对象，</p>
<p>2、但是属性值是引用类型的那么原数据的修改会影响拷贝对象；</p>
<p>3、这是因为对于简单数据类型来说拷贝的是值，而对于复杂数据来说拷贝的只是引用的地址，指向的内存还是同一个；</p>
<p><strong>缺点</strong>：只能拷贝第一层，第二层拷贝的是地址；</p>
</blockquote>
<h3 id="_2、方法二"> 2、方法二；</h3>
<blockquote>
<p><code>es6</code>提供的新方法实现浅拷贝；</p>
</blockquote>
<div><pre><code>Object<span>.</span><span>assign</span><span>(</span>Student<span>,</span> Proson<span>)</span>

    Proson<span>.</span>name <span>=</span> <span>'赵丽颖'</span>
    Proson<span>.</span>interest<span>.</span>skill <span>=</span> <span>'射手'</span>
    console<span>.</span><span>log</span><span>(</span>Proson<span>)</span>
    console<span>.</span><span>log</span><span>(</span>Student<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>
<p>打印结果与上图一样；</p>
</blockquote>
<h2 id="深拷贝"> 深拷贝；</h2>
<blockquote>
<p>概述：会完全的克隆出一份对象，新对象与原对象数据相同，但是引用地址不同，一个对象的修改不会影响另一个对象的数据；</p>
</blockquote>
<div><pre><code> <span>// 人的对象；</span>
    <span>var</span> Proson <span>=</span> <span>{</span>
      name<span>:</span> <span>'小红'</span><span>,</span>
      age<span>:</span> <span>18</span><span>,</span>
      score<span>:</span> <span>99</span><span>,</span>
      arr<span>:</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span><span>,</span>
      interest<span>:</span> <span>{</span>
        song<span>:</span> <span>'大约在冬季'</span><span>,</span>
        skill<span>:</span> <span>'技能'</span><span>,</span>
        dance<span>:</span> <span>'跳舞'</span>
      <span>}</span>
    <span>}</span>

 <span>// 学生的对象；</span>
    <span>var</span> student <span>=</span> <span>{</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="_1、方法一-2"> 1、方法一；</h3>
<blockquote>
<p>利用原生的<code>js</code>方法 <code>JSON.stringify()</code>和<code>JSON.parse()</code>实现深拷贝；</p>
</blockquote>
<div><pre><code><span>var</span> student <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>Proson<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="_2、方法二-2"> 2、方法二；</h3>
<blockquote>
<p>利用<strong>递归</strong>进行深拷贝；</p>
</blockquote>
<div><pre><code>    <span>/**
     * 参数1：待拷贝对象；
     * 参数2：原对象
     */</span>
    <span>function</span> <span>deepCopy</span><span>(</span><span>copyObject<span>,</span> sourceObject</span><span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>const</span> key <span>in</span> sourceObject<span>)</span> <span>{</span>
        <span>// 判断值是否为引用类型，若是则进行深遍历，若不是则直接赋值；</span>
        <span>if</span> <span>(</span>sourceObject<span>[</span>key<span>]</span> <span>instanceof</span> <span>Array</span><span>)</span> <span>{</span>
          <span>// 定义空对象；</span>
          copyObject<span>[</span>key<span>]</span> <span>=</span> <span>[</span><span>]</span>
          <span>deepCopy</span><span>(</span>copyObject<span>[</span>key<span>]</span><span>,</span> sourceObject<span>[</span>key<span>]</span><span>)</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>sourceObject<span>[</span>key<span>]</span> <span>instanceof</span> <span>Object</span><span>)</span> <span>{</span>
          <span>// 定义空数组</span>
          copyObject<span>[</span>key<span>]</span> <span>=</span> <span>{</span><span>}</span>
          <span>deepCopy</span><span>(</span>copyObject<span>[</span>key<span>]</span><span>,</span> sourceObject<span>[</span>key<span>]</span><span>)</span>
        <span>}</span> <span>else</span> <span>{</span>
          copyObject<span>[</span>key<span>]</span> <span>=</span> sourceObject<span>[</span>key<span>]</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>

    <span>// 调用深拷贝的方法</span>
    <span>deepCopy</span><span>(</span>student<span>,</span> Proson<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><blockquote>
<p>注意：在做判断时，要先判断数组类型，在判断对象类型，因为<code>instanceof</code>会把<strong>数组</strong>(引用类型)判断为<code>object</code>;</p>
</blockquote>
<p><strong>修改学生的数据</strong></p>
<div><pre><code> student<span>.</span>name <span>=</span> <span>'小明'</span>
 student<span>.</span>arr<span>[</span><span>2</span><span>]</span> <span>=</span> <span>8</span>
 student<span>.</span>interest<span>.</span>skill <span>=</span> <span>'火箭'</span>
<span>// 打印结果如下；</span>
 console<span>.</span><span>log</span><span>(</span>student<span>,</span> Proson<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><img src="./assets/1582449852808.png" alt="1582449852808" /></p>
<blockquote>
<p>通过打印结果我们得知：学生的数据的修改，不会影响人的对象的数据；</p>
</blockquote>
<h2 id="问题"> 问题；</h2>
<blockquote>
<p>进行深拷贝时，我们如果用 <code>JSON.stringify()</code>和<code>JSON.parse()</code>实现深拷贝；则会遇到一下问题；</p>
</blockquote>
<div><pre><code><span>let</span> Obj <span>=</span> <span>{</span>
      test1<span>:</span> <span>null</span><span>,</span>
      test2<span>:</span> <span>undefined</span><span>,</span>
      <span>fn</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'fn'</span><span>)</span>
      <span>}</span><span>,</span>
      date<span>:</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>,</span>
      RegExp<span>:</span> <span><span>/</span><span>(a|b)</span><span>/</span></span><span>,</span>
      Error<span>:</span> <span>new</span> <span>Error</span><span>(</span><span>'err'</span><span>)</span><span>,</span>
      <span>NaN</span><span>:</span> <span>Number</span><span>(</span><span>'NaN'</span><span>)</span>
    <span>}</span>

    <span>let</span> newObj <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>Obj<span>)</span><span>)</span>
    console<span>.</span><span>log</span><span>(</span>newObj<span>,</span> Obj<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><img src="./assets/1582450576713.png" alt="1582450576713" /></p>
<blockquote>
<p>通过打印结果我们得出新对象：</p>
<p>1、 丢失 function、undefined</p>
<p>2、 Error、<code>RegExp</code>为空对象</p>
<p>3、 <code>NaN</code>变为 null</p>
<p>4、 date 对象变为 string</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>函数防抖</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-03/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-03/</guid>
      <source url="https://wangyawei.top/rss.xml">函数防抖</source>
      <category>javascript</category>
      <pubDate>Sun, 02 May 2021 22:22:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>概述：一个处理函数会在延迟n秒后触发，如果在n秒内再次触发那么回重新计时；</p>
</blockquote>
<ol>
<li>
<p>影响：</p>
<div><pre><code>前端开发过程中的resize，scroll，mousemove，mousehover等，会被频繁地出发，不做限制的话，有可能一秒之内执行几十次，几百次，如果在这些函数内部执行了其他函数，尤其是执行了操作了DOM的函数，那不仅会造成计算机资源的浪费，还会降低程序运行速度，甚至造成浏览器卡死，崩溃。
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>例：</p>
<div><pre><code><span>&lt;</span>script<span>></span>
    <span>var</span> <span>throttle</span> <span>=</span> <span>function</span><span>(</span><span>func<span>,</span> delay</span><span>)</span> <span>{</span>
      <span>// 存储定时器id;</span>
      <span>var</span> timer <span>=</span> <span>null</span>
      <span>return</span> <span>function</span><span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>
        <span>// 判断定时器是否在执行中；</span>
        <span>if</span> <span>(</span>timer<span>)</span> <span>{</span>
          <span>// 在每次开始之前清除以前的定时器；</span>
          <span>clearTimeout</span><span>(</span>timer<span>)</span>
        <span>}</span>
        timer <span>=</span> <span>setTimeout</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
          <span>func</span><span>(</span><span>...</span>args<span>)</span>
        <span>}</span><span>,</span> delay<span>)</span>
      <span>}</span>
    <span>}</span>
    <span>// 要进行处理的函数；</span>
    <span>function</span> <span>handle</span><span>(</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span><span>)</span>
    <span>}</span>
    window<span>.</span><span>addEventListener</span><span>(</span><span>'mousemove'</span><span>,</span> <span>throttle</span><span>(</span>handle<span>,</span> <span>1000</span><span>)</span><span>)</span>
  <span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></li>
</ol>
<blockquote>
<p>优点：防止用户由于过快的操作而发起的无用的请求；</p>
<p>使用场景：</p>
<p>1、淘宝的导航列表;</p>
<p>2、搜索框搜索输入。只需用户最后一次输入完成，在发送请求；</p>
<p>3、浏览器的窗口大小改变后，只需窗口调整完成后，在执行<code>resize</code>里面是代码，防止重新渲染；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>函数节流</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-04/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-04/</guid>
      <source url="https://wangyawei.top/rss.xml">函数节流</source>
      <category>javascript</category>
      <pubDate>Sun, 02 May 2021 22:22:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>概述：限制一个函数再一定时间内只能执行一次；</p>
</blockquote>
<div><pre><code><span>&lt;</span>script<span>></span>
    <span>var</span> <span>throttle</span> <span>=</span> <span>function</span><span>(</span><span>func<span>,</span> delay</span><span>)</span> <span>{</span>
      <span>// 初始化定时器的id；</span>
      <span>var</span> timer <span>=</span> <span>null</span>
      <span>// 定义开关属性</span>
      <span>var</span> key <span>=</span> <span>true</span>
      <span>return</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        <span>// 第一次立即调用</span>
        <span>if</span> <span>(</span>key<span>)</span> <span>{</span>
          <span>func</span><span>(</span><span>)</span>
          key <span>=</span> <span>false</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>!</span>timer<span>)</span> <span>{</span>
          <span>// 若上次的定时器执行完毕则立即调用，否则不调用；</span>
          timer <span>=</span> <span>setTimeout</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
            <span>func</span><span>(</span><span>)</span>
            timer <span>=</span> <span>null</span>
          <span>}</span><span>,</span> delay<span>)</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>

    <span>// 要进行处理的函数； </span>
    <span>function</span> <span>handle</span><span>(</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span>Math<span>.</span><span>random</span><span>(</span><span>)</span><span>)</span>
    <span>}</span>

    window<span>.</span><span>addEventListener</span><span>(</span><span>'mousemove'</span><span>,</span> <span>throttle</span><span>(</span>handle<span>,</span> <span>1000</span><span>)</span><span>)</span>
  <span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><blockquote>
<p>使用场景：</p>
<p>1、懒加载、滚动加载、加载更多、监听滚动条位置；</p>
<p>2、百度搜索框、搜索联想功能；</p>
<p>3、防止高频点击提交、防止表单重复提交；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>函数继承</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-05/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-05/</guid>
      <source url="https://wangyawei.top/rss.xml">函数继承</source>
      <category>javascript</category>
      <pubDate>Sun, 02 May 2021 22:22:34 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="通过原型实现继承"> 通过原型实现继承</h2>
<div><pre><code><span>&lt;</span>script<span>></span>
    <span>// 父类构造函数；</span>
    <span>function</span> <span>Proson</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
      <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
      <span>this</span><span>.</span><span>eat</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'我叫'</span><span>+</span><span>this</span><span>.</span>name<span>+</span><span>'今年'</span><span>+</span><span>this</span><span>.</span>age<span>)</span>
      <span>}</span>
    <span>}</span>
    <span>Proson</span><span>.</span>prototype<span>.</span><span>sleep</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'我的技能是睡觉'</span><span>)</span>
    <span>}</span>

	<span>// 子类构造函数；</span>
    <span>function</span> <span>Son</span><span>(</span><span>)</span> <span>{</span><span>}</span>

    <span>/**
     *  只能继承实例的属性和方法不能继承原型的属性和方法；
     *  同时 constructor 指向错误不在指向原来的构造函数；
     */</span>
    <span>// Son.prototype =  Proson.prototype</span>
    
    <span>// 让son的原型指向proosn的实例(一个新的实例)，通过原型达到继承；</span>
    <span>Son</span><span>.</span>prototype <span>=</span> <span>new</span> <span>Proson</span><span>(</span><span>'小红'</span><span>,</span> <span>18</span><span>)</span>

    <span>//指向改变之后要指回原构造函数；</span>
    <span>Son</span><span>.</span>prototype<span>.</span>constructor<span>=</span>Son<span>;</span>
    
    <span>// 在改变指向后添加方法，</span>
    <span>Son</span><span>.</span>prototype<span>.</span><span>run</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'run'</span><span>)</span>
    <span>}</span>

    <span>var</span> fa <span>=</span> <span>new</span> <span>Proson</span><span>(</span><span>)</span>
    <span>var</span> so <span>=</span> <span>new</span> <span>Son</span><span>(</span><span>)</span>
    console<span>.</span><span>log</span><span>(</span>fa<span>)</span>
    console<span>.</span><span>log</span><span>(</span>so<span>)</span>
    console<span>.</span><span>log</span><span>(</span>so<span>.</span><span>sleep</span><span>(</span><span>)</span><span>)</span>
    console<span>.</span><span>dir</span><span>(</span>Proson<span>)</span>
    console<span>.</span><span>dir</span><span>(</span>Son<span>)</span>
  <span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><blockquote>
<p>优点：简单易于实现，父类实例属性和方法，子类都可以访问；</p>
<p>缺点：创建子实例时，不能向父类的构造函数中传入参数；只能在改变指向的时候传入。</p>
</blockquote>
<h2 id="通过构造函数实现继承"> 通过构造函数实现继承；</h2>
<div><pre><code><span>&lt;</span>script<span>></span>
    <span>function</span> <span>Proson</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
      <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
      <span>this</span><span>.</span><span>eat</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'我叫'</span> <span>+</span> <span>this</span><span>.</span>name <span>+</span> <span>'今年'</span> <span>+</span> <span>this</span><span>.</span>age<span>)</span>
      <span>}</span>
    <span>}</span>
    
    <span>Proson</span><span>.</span>prototype<span>.</span><span>sleep</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'我的技能是睡觉'</span><span>)</span>
    <span>}</span>

    <span>function</span> <span>Son</span><span>(</span><span>name<span>,</span> age<span>,</span> score</span><span>)</span> <span>{</span>
      <span>// 通过构造函数实现继承，</span>
      <span>// 只能继承实例的属性和方法，不能原型的方法</span>
      <span>Proson</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> name<span>,</span> age<span>)</span>
      <span>this</span><span>.</span>score <span>=</span> score<span>;</span>
    <span>}</span>

    <span>var</span> fa <span>=</span> <span>new</span> <span>Proson</span><span>(</span><span>)</span>
    <span>var</span> so <span>=</span> <span>new</span> <span>Son</span><span>(</span><span>'小红'</span><span>,</span> <span>18</span><span>,</span> <span>90</span><span>)</span>

    console<span>.</span><span>log</span><span>(</span>fa<span>)</span>
    console<span>.</span><span>log</span><span>(</span>so<span>)</span>
    console<span>.</span><span>log</span><span>(</span>so<span>.</span><span>eat</span><span>(</span><span>)</span><span>)</span>
    console<span>.</span><span>dir</span><span>(</span>Proson<span>)</span>
    console<span>.</span><span>dir</span><span>(</span>Son<span>)</span>
  <span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><blockquote>
<p>优点：</p>
<p>1、解决了子类构造函数向父类构造函数中传递参数的问题；</p>
<p>2、可以实现多继承(call或apply多个多个父类)</p>
<p>缺点：</p>
<p>1、不能继承原型上的属性或方法，只能继承父类实例上的属性和方法；</p>
</blockquote>
<h2 id="组合继承-原型-构造函数"> 组合继承(原型+构造函数)</h2>
<div><pre><code><span>&lt;</span>script<span>></span>
    <span>// 父类的构造函数；</span>
    <span>function</span> <span>Proson</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>name <span>=</span> name
      <span>this</span><span>.</span>age <span>=</span> age
      <span>this</span><span>.</span><span>eat</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'我叫'</span> <span>+</span> <span>this</span><span>.</span>name <span>+</span> <span>'今年'</span> <span>+</span> <span>this</span><span>.</span>age<span>)</span>
      <span>}</span>
    <span>}</span>
    <span>Proson</span><span>.</span>prototype<span>.</span><span>sleep</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'我的技能是睡觉'</span><span>)</span>
    <span>}</span>

    <span>// 子类构造函数；</span>
    <span>function</span> <span>Son</span><span>(</span><span>name<span>,</span> age<span>,</span> score</span><span>)</span> <span>{</span>
      <span>/**
       * 通过构造函数实现继承父类的全部属性；
       */</span>
      <span>Proson</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> name<span>,</span> age<span>)</span>
      <span>this</span><span>.</span>score <span>=</span> score
    <span>}</span>

    <span>/**
     * 通过原型继承父类的原型上的方法
     */</span>
    <span>Son</span><span>.</span>prototype <span>=</span> <span>new</span> <span>Proson</span><span>(</span><span>)</span>
    <span>Son</span><span>.</span>prototype<span>.</span><span>skill</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>'skill'</span><span>)</span><span>;</span>
    <span>}</span>
    <span>// 实例化对象；</span>
    <span>var</span> pro <span>=</span> <span>new</span> <span>Proson</span><span>(</span><span>)</span>
    <span>var</span> so <span>=</span> <span>new</span> <span>Son</span><span>(</span><span>'小明'</span><span>,</span> <span>18</span><span>)</span>

    console<span>.</span><span>log</span><span>(</span>pro<span>,</span> so<span>)</span>
    console<span>.</span><span>log</span><span>(</span>so<span>.</span>name<span>)</span>
    console<span>.</span><span>log</span><span>(</span>so<span>.</span><span>skill</span><span>(</span><span>)</span><span>)</span>
	console<span>.</span><span>log</span><span>(</span>so<span>.</span><span>eat</span><span>(</span><span>)</span><span>)</span>
  <span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><blockquote>
<p>优点：</p>
<p>1、既可以继承父类的全部属性又可以继承父类的原型方法；</p>
<p>2、可以在实例化子类时，传入参数；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>Async 函数</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-06/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-06/</guid>
      <source url="https://wangyawei.top/rss.xml">Async 函数</source>
      <category>javascript</category>
      <pubDate>Sun, 02 May 2021 22:22:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>ES2017 标准引入了 async 函数，使得异步操作变得更加方便。</p>
<p><code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p>
</blockquote>
<h2 id="基本用法"> 基本用法；</h2>
<blockquote>
<p>使用 Async-await 来简化获取 Promise 的结果  ;</p>
</blockquote>
<div><pre><code>  <span>&lt;</span>script<span>></span>
    <span>async</span> <span>function</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
      <span>// 遇到await便会等待响应结果；</span>
      <span>const</span> 成员 <span>=</span> <span>await</span> Promise对象
      <span>// 请求出错或响应回来后继续往后执行</span>
    <span>}</span>
  <span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="任何函数都可以使用async"> 任何函数都可以使用<code>async</code></h2>
<div><pre><code><span>&lt;</span>script<span>></span>
    <span>//  具名函数</span>
    <span>async</span> <span>function</span> <span>main</span> <span>(</span><span>)</span> <span>{</span><span>}</span>
    <span>// 匿名函数</span>
    <span>async</span> <span>function</span> <span>(</span><span>)</span> <span>{</span><span>}</span>
    <span>// 箭头函数</span>
    <span>async</span> <span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span>
    <span>// 对象成员函数简写</span>
    <span>async</span> <span>hello</span> <span>(</span><span>)</span> <span>{</span><span>}</span>
  <span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="返回promise"> 返回<code>promise</code></h2>
<div><pre><code><span>&lt;</span>script<span>></span>
      <span>async</span> <span>function</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
        <span>// async 函数始终返回 Promise</span>
        <span>// async 函数的返回值</span>
        <span>// 如果是普通数据，则直接把它包装到 promise 对象中</span>
        <span>// 数据就是 resolve 的结果</span>
        <span>return</span> <span>123</span>

        <span>// 如果你返回的直接就是一个 promise 对象，则不作任何处理</span>
        <span>// return new Promise((resolve) => {</span>
        <span>// setTimeout(() => {</span>
        <span>// resolve(123)</span>
        <span>// }, 2000)</span>
        <span>// })</span>
      <span>}</span>
      <span>// 通过 then 方法来获取 async 函数的返回值</span>
      <span>// .then(data => {</span>
      <span>// console.log(data)</span>
      <span>// })</span>
      <span>main2</span><span>(</span><span>)</span>
    <span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="错误处理"> 错误处理；</h2>
<div><pre><code> <span>&lt;</span>script<span>></span>
      <span>async</span> <span>function</span> <span>main</span><span>(</span><span>)</span> <span>{</span>
        <span>// 还是使用 .catch 来处理异常</span>
        <span>// const data = await request('dsanlksas')</span>
        <span>// .catch(err => {</span>
        <span>// console.log('请求失败了')</span>
        <span>// })</span>
        <span>// console.log(data)</span>
        console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span>
     
        <span>// 更推荐使用 try-catch 来捕获异常</span>
        <span>try</span> <span>{</span>
          <span>// try 捕获不到它的异常</span>
          <span>// request('dsabjdsdsa').then(data => {</span>
          <span>// console.log(data)</span>
          <span>// })</span>
          <span>// JSON.parse('dnsakdnsa')</span>
          console<span>.</span><span>log</span><span>(</span><span>2</span><span>)</span>
            
          <span>const</span> data <span>=</span> <span>await</span> <span>request</span><span>(</span>
            <span>'http://jsonplaceholder.typicode.com/posts'</span>
          <span>)</span>
          console<span>.</span><span>log</span><span>(</span><span>3</span><span>)</span>
          <span>const</span> data2 <span>=</span> <span>await</span> <span>request</span><span>(</span><span>'dnsandlksa'</span><span>)</span>
          console<span>.</span><span>log</span><span>(</span><span>4</span><span>)</span>
        <span>}</span> <span>catch</span> <span>(</span>err<span>)</span> <span>{</span>
          console<span>.</span><span>log</span><span>(</span><span>'请求失败了'</span><span>,</span> err<span>)</span>
        <span>}</span>
        
        console<span>.</span><span>log</span><span>(</span><span>5</span><span>)</span>
      <span>}</span>

      <span>main</span><span>(</span><span>)</span>
    <span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>jsonp跨域的实现原理</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-07/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-07/</guid>
      <source url="https://wangyawei.top/rss.xml">jsonp跨域的实现原理</source>
      <category>javascript</category>
      <pubDate>Sun, 02 May 2021 22:22:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p><strong>利用javascript里边的src属性的开放原则实现跨域:</strong></p>
</blockquote>
<h3 id="_1、我们先看一段代码"> 1、我们先看一段代码；</h3>
<div><pre><code><span>&lt;</span>script<span>></span>
    <span>function</span> <span>Fn</span><span>(</span><span>val</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>333</span><span>)</span>
      console<span>.</span><span>log</span><span>(</span>val<span>)</span>
    <span>}</span>
  <span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>上面的代码中我们要想执行函数必须进行调用；</p>
<div><pre><code><span>Fn</span><span>(</span><span>'晚上好'</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="_2、看第二段代码"> 2、看第二段代码；</h3>
<div><pre><code><span>&lt;</span>script<span>></span>
    <span>function</span> <span>Fn</span><span>(</span><span>val</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span><span>333</span><span>)</span>
      console<span>.</span><span>log</span><span>(</span>val<span>)</span>
    <span>}</span>
  <span>&lt;</span><span>/</span>script<span>></span>
  <span>&lt;</span>script src<span>=</span><span>"http://jsonplaceholder.typicode.com/posts?callback=Fn"</span><span>></span><span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>
<p>通过上面的代码中我们不难看出，<code>src</code>的属性值中有一个<code>callback</code>参数，值为我们要执行的函数的名字；</p>
<p><strong>注意</strong>：<code>http</code>链接为我的在线接口测试地址，当然你也可以使用；</p>
</blockquote>
<ul>
<li>上面的代码运行之后你会惊奇的发现<code>Fn</code>函数执行了，而且<code>val</code>为接口响应回来的数据；</li>
</ul>
<h2 id="总结"> 总结；</h2>
<p>这就是<code>jsonp</code>的跨域实现原理；</p>
<ol>
<li>在<code>src</code>中用<code>callback</code>关键字作为参数，值为要执行的函数；</li>
<li>当响应成功时，响应回来的数据会作为参数传入<code>Fn(responseData)</code>;</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>new的实现原理</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-08/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-08/</guid>
      <source url="https://wangyawei.top/rss.xml">new的实现原理</source>
      <category>javascript</category>
      <pubDate>Sun, 02 May 2021 22:22:34 GMT</pubDate>
      <content:encoded><![CDATA[<div><pre><code><span>&lt;</span>script<span>></span>
    <span>// 创建一个构造函数</span>
    <span>function</span> <span>Father</span><span>(</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>name <span>=</span> <span>'小红'</span><span>;</span>
      <span>this</span><span>.</span><span>eat</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'我叫'</span><span>+</span><span>this</span><span>.</span>name<span>)</span><span>;</span>
      <span>}</span>
    <span>}</span>
    <span>/**
     * 1、在内存中创建一个新的对象；
     * 2、让this指向这个新的对象；
     * 3、执行构造函数里面的代码并给这个对象添加属性和方法；
     * 4、返回这个新对象；
     */</span>
    <span>// 使用new关键字来创建一个对象；</span>
    <span>var</span> fa <span>=</span> <span>new</span> <span>Father</span><span>(</span><span>)</span>
    console<span>.</span><span>log</span><span>(</span>fa<span>)</span><span>;</span>

    <span>// ----------------------------------------</span>

    <span>/**
     * 实现new的过程
     */</span>
    <span>function</span> <span>_new</span><span>(</span><span>)</span> <span>{</span>
      <span>// 1、创建一个空对象；</span>
      <span>var</span> obj <span>=</span> <span>{</span><span>}</span>

      <span>// 利用 es6 数组的结构特点可以把函数的参数结构出来</span>
      <span>var</span> <span>[</span>newfn<span>,</span> <span>...</span>args<span>]</span> <span>=</span> <span>[</span><span>...</span>arguments<span>]</span>

      <span>// 2、将该对象 obj 的原型链 __proto__ 指向构造函数的原型 prototype，</span>
      obj<span>.</span>__proto__ <span>=</span> newfn<span>.</span>prototype

      <span>// 并且在原型链 __proto__ 上设置构造函数 constructor 为要实例化的 newfn</span>
      obj<span>.</span><span>__proto__</span><span>.</span>constructor <span>=</span> newfn

      <span>// 3、让构造函数 newfn 的this改变指向到 obj，并执行</span>
      <span>var</span> result <span>=</span> <span>newfn</span><span>.</span><span>call</span><span>(</span>obj<span>,</span> <span>...</span>args<span>)</span>

      <span>// 4、如果newfn执行后返回的是对象或函数类型，则返回该对象，否则返回 obj</span>
      <span>if</span> <span>(</span>
        result <span>&amp;&amp;</span>
        <span>(</span><span>typeof</span> result <span>===</span> <span>'object'</span> <span>||</span> <span>typeof</span> result <span>===</span> <span>'function'</span><span>)</span>
      <span>)</span> <span>{</span>
        <span>return</span> result
      <span>}</span>
      <span>return</span> obj
    <span>}</span>

    <span>// 构造函数；</span>
    <span>function</span> <span>f1</span><span>(</span><span>name<span>,</span> age</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>name <span>=</span> name
      <span>this</span><span>.</span>age <span>=</span> age
      <span>this</span><span>.</span><span>eat</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>'我叫'</span> <span>+</span> <span>this</span><span>.</span>name <span>+</span> <span>'今年'</span> <span>+</span> <span>this</span><span>.</span>age <span>+</span> <span>'岁'</span>
      <span>}</span>
    <span>}</span>

    <span>// 创建一个对象；</span>
    <span>var</span> obj2 <span>=</span> <span>_new</span><span>(</span>f1<span>,</span> <span>'小明'</span><span>,</span> <span>18</span><span>)</span>
    console<span>.</span><span>log</span><span>(</span>obj2<span>)</span>
    console<span>.</span><span>log</span><span>(</span>obj2<span>.</span>name<span>)</span>  <span>// 小明</span>
    console<span>.</span><span>log</span><span>(</span>obj2<span>.</span><span>eat</span><span>(</span><span>)</span><span>)</span> <span>// 我叫小明今年18岁</span>

  <span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>什么是Promise</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-09/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-09/</guid>
      <source url="https://wangyawei.top/rss.xml">什么是Promise</source>
      <category>javascript</category>
      <pubDate>Sun, 02 May 2021 22:22:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>概念：Promise 代表一个异步操作；</p>
</blockquote>
<ol>
<li>创建<code>Promise</code>对象；</li>
</ol>
<div><pre><code><span>// 创建了一个Promise对象；</span>
<span>new</span> <span>Promise</span><span>(</span><span>)</span>
<span>// 注意：这只是一个【形式上】的异步操作；因为你不知道里面要干什么；是读文件还是发网络请求呢？</span>
优点：
<span>// 1、可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</span>
缺点：
<span>// 1、无法取消 Promise ，一旦新建它就会立即执行，无法中途取消。</span>
<span>// 2、其次，如果不设置回调函数， Promise 内部抛出的错误，不会反应到外部。</span>
<span>// 3、当处于 pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="基本用法"> 基本用法;</h2>
<ol>
<li>ES6 规定， <code>Promise</code> 对象是一个构造函数，用来生成 <code>Promise</code> 实例;</li>
<li><code>Promise</code>构造函数接受一个<strong>函数</strong>作为参数，该函数的两个<strong>参数</strong>分别是<code>resolve</code>和<code>reject</code>。它们是两个
函数，由 JavaScript 引擎提供，不用自己部署。</li>
<li><code>resolve</code>:  在异步操作成功时调用 ;</li>
<li><code>reject</code>:   在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。</li>
<li><code>Promise</code>实例生成以后，可以用<code>then</code>方法分别指定<code>resolved</code>状态和<code>rejected</code>状态的回调函数 。</li>
</ol>
<div><pre><code><span>const</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>/* 异步操作成功 */</span><span>)</span><span>{</span>
    <span>resolve</span><span>(</span>value<span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>reject</span><span>(</span>error<span>)</span><span>;</span>
  <span>}</span>
<span>}</span><span>)</span><span>;</span>

promise<span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>
  <span>// 异步操作成功时的回调</span>
  <span>}</span><span>,</span> <span>function</span><span>(</span><span>error</span><span>)</span> <span>{</span>
  <span>// 异步操作失败时的回调</span>
  <span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code>4.	`then`方法；
</code></pre>
</div><div><pre><code><span>&lt;</span>script<span>></span>
<span>// 将一个异步代码包装到 Promise 中</span>
<span>// 1、定义一个函数</span>
<span>function</span> <span>request</span><span>(</span><span>url</span><span>)</span> <span>{</span>
  <span>// 2、在函数中 return 出一个 Promise 对象</span>
  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>
    <span>// 3、在 Promise 容器中执行异步操作</span>
    <span>// 创建请求对象</span>
    <span>var</span> oReq <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span><span>;</span>

    <span>// 添加请求回调函数</span>
    <span>// 请求成功，就会自动执行该回调函数</span>
    oReq<span>.</span><span>addEventListener</span><span>(</span><span>"load"</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>

      <span>// 当请求成功了，也就是异步执行结束了，callback 被调用了</span>
      <span>resolve</span><span>(</span><span>this</span><span>.</span>responseText<span>)</span>

      <span>// 只有这里才能拿到正确的响应结果 responseText 但是在外面取不到；</span>
      <span>// return this.responseText</span>
    <span>}</span><span>)</span><span>;</span>

    oReq<span>.</span><span>addEventListener</span><span>(</span><span>"error"</span><span>,</span> <span>function</span> <span>(</span><span>err</span><span>)</span> <span>{</span>
      <span>// 失败 reject</span>
      <span>reject</span><span>(</span>err<span>)</span>
    <span>}</span><span>)</span><span>;</span>

    <span>// 设置请求方法和请求路径</span>
    oReq<span>.</span><span>open</span><span>(</span><span>"GET"</span><span>,</span> url<span>)</span><span>;</span>

    <span>// 发出请求</span>
    oReq<span>.</span><span>send</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>)</span>
<span>}</span>

<span>// then 方法之后可以继续 then</span>
<span>// 原因是 then 方法执行完以后会返回一个新的 Promise 对象</span>
<span>request</span><span>(</span><span>'http://jsonplaceholder.typicode.com/posts'</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>data</span> <span>=></span> <span>{</span>
    <span>// 如果是普通数据，那么它会把该数据包装为那个返回的 Promise 的 resolve 结果</span>
    <span>// return new Promise((resolve) => {</span>
    <span>//   resolve('hello')</span>
    <span>// })</span>

    <span>// 因为每个 then 始终返回 promise 对象</span>
    <span>// 所以我才可以在后面继续 .then</span>
    <span>// 每一个后续的 .then 都是在给上一个 then 中返回的 Promise 对象注册：resolve、reject</span>

    <span>// 如果你返回的数据就是一个 Promise 对象，那它就不做任何处理了</span>
    <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>)</span> <span>=></span> <span>{</span>
      <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        <span>resolve</span><span>(</span><span>'hello'</span><span>)</span>
      <span>}</span><span>,</span> <span>2000</span><span>)</span>
    <span>}</span><span>)</span>
  <span>}</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>(</span><span>data</span><span>)</span> <span>=></span> <span>{</span>
    <span>return</span> <span>ptimeout</span><span>(</span><span>1000</span><span>)</span>
  <span>}</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>3</span><span>)</span>
  <span>}</span><span>)</span>

<span>function</span> <span>ptimeout</span><span>(</span><span>time</span><span>)</span> <span>{</span>
  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>)</span> <span>=></span> <span>{</span>
    <span>setTimeout</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>resolve</span><span>(</span><span>)</span>
    <span>}</span><span>,</span> time<span>)</span>
  <span>}</span><span>)</span>
<span>}</span>

<span>// Async 函数，简化了 Promise 的结果获取而已</span>
<span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br></div></div><h2 id="异常处理"> 异常处理；</h2>
<ol>
<li>处理 Promise 中的异常有两种方式：</li>
</ol>
<div><pre><code> -  `then`方法的第2个参数;
 - 或者 .catch 方法 ;
</code></pre>
</div><div><pre><code><span>// 失败 then 方法的第2个参数来接收处理异常</span>
<span>request</span><span>(</span><span>'dbsjabdjsabjdsa'</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>data</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'请求成功'</span><span>,</span> data<span>)</span><span>;</span>
  <span>}</span><span>,</span> <span>err</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'请求失败'</span><span>,</span> err<span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
<span>// 使用 .catch 方法接收处理异常</span>
<span>request</span><span>(</span><span>'dbsjabdjsabjdsa'</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>data</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'请求成功'</span><span>,</span> data<span>)</span><span>;</span>
  <span>}</span><span>)</span>
  <span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'请求失败'</span><span>,</span> err<span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>

<span>request</span><span>(</span><span>'http://jsonplaceholder.typicode.com/posts'</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>data</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'请求成功'</span><span>,</span> data<span>)</span><span>;</span>
  <span>}</span><span>)</span>
  <span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'请求失败'</span><span>,</span> err<span>)</span><span>;</span>
  <span>}</span><span>)</span>
<span>// 无论成功或是失败都会执行</span>
  <span>.</span><span>finally</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'无论成功或是失败都会执行'</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>打包及本地预览</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-10/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-10/</guid>
      <source url="https://wangyawei.top/rss.xml">打包及本地预览</source>
      <category>javascript</category>
      <pubDate>Sun, 02 May 2021 22:22:34 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="构建打包"> 构建打包</h2>
<p>在发布上线之前，我们需要执行构建打包，将 <code>.less</code>、<code>.vue</code>、<code>.js</code> 等相关资源进行编译打包，转换成浏览器可以直接识别运行的普通 <code>css</code>、<code>js</code>、<code>html</code>。</p>
<div><pre><code>// 打包
<span># yarn run build 或者 yarn build</span>
<span>npm</span> run build

每次 <span><span>`</span><span>npm</span> run build<span>`</span></span> 都会先把原来的 dist 删除，然后生成新的结果。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>VueCLI</code>会把打包结果生成存储到项目的 <code>dist</code> 目录中。</p>
<p><img src="./assets/1580038692656.png" alt="1580038692656" /></p>
<h2 id="打包禁用hash值"> 打包禁用hash值；</h2>
<blockquote>
<p>在vue.config.js中   设置<code>filenameHashing</code>选项；</p>
</blockquote>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  <span>// webpack配置: 关闭哈希值</span>
  filenameHashing<span>:</span> <span>false</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="预览打包结果"> 预览打包结果</h2>
<blockquote>
<p><strong>注意</strong>：不能直接双击打开 index.html 运行。</p>
</blockquote>
<p>将 dist 放到一个 Web 服务器中运行测试，常见的 Web 服务器：</p>
<ul>
<li>Ngxin</li>
<li>Apache</li>
<li>tomcat</li>
<li>IIS</li>
<li>Node.js</li>
</ul>
<p>推荐使用<code>Vue</code>官方推荐的一个命令行<code>http</code>服务工具：<a href="https://github.com/zeit/serve" target="_blank" rel="noopener noreferrer">serve</a>。</p>
<p><code>dist</code> 目录需要启动一个 HTTP 服务器来访问，所以 <code>file://</code> 协议直接打开 <code>dist/index.html</code> 是不会工作的。在本地预览生产环境构建最简单的方式就是使用一个 Node.js 静态文件服务器，例如 <a href="https://github.com/zeit/serve" target="_blank" rel="noopener noreferrer">serve</a>：</p>
<p><strong>安装：</strong></p>
<div><pre><code><span># yarn global add serve</span>
<span># 安装全局包，在任何目录执行都可以</span>
<span>npm</span> <span>install</span> -g serve
或
<span>npm</span> <span>install</span> serve
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>然后在你的项目目录下执行：</p>
<div><pre><code><span># dist 是运行 Web 服务根目录</span>
serve -s dist
或 注意 两者有区别
serve dist
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>如果启动成功，你将看到如下提示：</p>
<div><pre><code>   ┌────────────────────────────────────────────────────┐
   │                                                    │
   │   Serving!                                         │
   │                                                    │
   │   - Local:            http://localhost:5000        │
   │   - On Your Network:  http://192.168.156.90:5000   │
   │                                                    │
   │   Copied local address to clipboard!               │
   │                                                    │
   └────────────────────────────────────────────────────┘
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>serve 默认占用 5000 端口并启动一个服务</p>
</blockquote>
<h2 id="部署"> 部署</h2>
<ul>
<li>公司有专门的 devops，就是运维
<ul>
<li>有些公司没有专门的运维人员，那就后端负责</li>
</ul>
</li>
</ul>
<div><pre><code><span># --force 强制推送，简写 -f</span>
<span>git</span> push -u origin master -f
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>javascript内存管理</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-11/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-11/</guid>
      <source url="https://wangyawei.top/rss.xml">javascript内存管理</source>
      <category>javascript</category>
      <pubDate>Sun, 09 May 2021 22:22:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>内存管理可以简单理解为内存空间，内存空间可以分为：栈内存、堆内存</p>
</blockquote>
<h2 id="为什么要关注内存"> 为什么要关注内存</h2>
<blockquote>
<p>作为一位前端开发人员，我们知道程序的运行要分配内存空间，对于一个页面来说，如果我们不在使用的内存没有得到及时释放，我们称这种现象为内存泄漏。虽然一次的内存泄漏不会造成太大影响，但是当泄漏的内存增多的时候，便会造成内存溢出错误。轻则造成页面卡顿，重则造成浏览器崩溃，甚至无响应。所以我们平时在开发的时候要关注内存，并且要合理的释放那些不在使用的内存。</p>
</blockquote>
<ol>
<li>防止页面占用内存过大，引起客户端卡顿，甚至无响应；</li>
<li>nodejs使用V8引擎，内存对于后端服务的性能至关重要，因为后端服务的持久性，后端更容易造成内存溢出；</li>
</ol>
<h2 id="栈内存"> 栈内存；</h2>
<blockquote>
<p>原始数据类型(简单数据类型)都是存在放在栈内存中的，例：字符串(String)、数字(Number)、布尔(Boolean)、Null、Undefined、Symbol(es6)；原始数据类型的值是固定的，由系统自动分配内存，存储在栈内存中；</p>
</blockquote>
<p><img src="./assets/image-20210506223242924.png" alt="image-20210506223242924" /></p>
<blockquote>
<p>如上图所示，我们先后定义了变量a、b、c，三个变量都只能从箭头所指的方向入栈，向栈插入新元素又称“进栈、入栈或压栈”，我定义的三个变量，最先放入的是变量a、随后是变量b、c。而我们的变量c就是我们的栈顶元素。</p>
</blockquote>
<p><strong>定义变量的过程</strong></p>
<ul>
<li>在内存中申请一块空间，并保存 10 这个值；</li>
<li>在内存中创建一个名为 a 的变量，注意此时还没有进行赋值，a 的值为 undefined；</li>
<li>赋值：把创建的变量 a 的指针 指向 10 这个值；</li>
</ul>
<p><img src="./assets/image-20210506225816900.png" alt="image-20210506225816900" /></p>
<blockquote>
<p>从栈顶删除一个元素，又称出栈或者退栈。如上图所示，从箭头所指的方向为出栈，它是把栈顶元素删除掉，使其相邻的栈顶元素称为新的栈顶元素。出栈的顺序是先进后出，也就是说，最先删除的是最后入栈的变量c、然后是b、a；</p>
</blockquote>
<h2 id="堆内存"> 堆内存；</h2>
<blockquote>
<p>我们知道复杂数据类型的大小是不固定的，例如：对象(object)、数组(array)；相对于简单数据类型在栈内存中存储，复杂数据类型(引用数据类型)都是存在放在堆内存中的；js是不允许直接访问堆内存的，因此我们也无法直接操作对象的堆内存空间，我们在操作对象时，实际上是在操作对象的引用，而不是实际的对象，引用类型的值都是按引用访问的，这里的引用我们可以简单的理解为保存在栈内存中的一个地址，该地址与对象的实际值相关联。所以引用数据类型的值是保存在堆内存中的对象。</p>
</blockquote>
<p><img src="./assets/image-20210506233841362.png" alt="image-20210506233841362" /></p>
<blockquote>
<p>由上图所示，当我们需要存储一个对象的时候，首先在堆内存中开辟一块新的空间，然后以键值对的形式存储在堆内存中，这个堆内存会有一个16进制的内存地址，我们假设是 <code>0x8049368</code>,之后我们在栈内存中声明一个变量 <code>obj1</code> 它的值就是我们的堆内存的地址.这样我们就可以通过<code>obj1</code>访问我们的对象了；</p>
</blockquote>
<h2 id="存储函数"> 存储函数；</h2>
<blockquote>
<p>我们知道函数也是引用类型，当我们定义一个函数的时候，它到底是如何工作的呢？</p>
</blockquote>
<p><img src="./assets/image-20210507211040209.png" alt="image-20210507211040209" /></p>
<blockquote>
<p>当我们定义一个函数的时候，首先在堆内存中开辟一块新的空间，然后把我们的函数体以<strong>代码字符串</strong>的形式存在堆内存中，同时这个空间也会有一个内存地址，假设为：<code>0x8049368</code>，同时把这个内存地址赋值给函数名，所以我们也可以把函数理解为变量。</p>
</blockquote>
<h2 id="垃圾回收"> 垃圾回收；</h2>
<blockquote>
<p>在javascript中垃圾回收是指：javascript引擎找出那些不再使用的变量，然后释放其所占用的内存，垃圾回收器会按照固定的时间间隔周期性地执行这一操作；【javascrit会自动的帮我们进行垃圾回收，但是这不代表我们不需要关注内存】</p>
</blockquote>
<p>javascript垃圾回收优缺点；</p>
<ul>
<li>优势：可以大幅简化程序的内存管理代码，降低程序员的负担，减少因长时间运转而带来的内存泄漏问题；</li>
<li>不足：意味这程序员将无法掌控内存。javascript没有暴露任何关于内存的api。我们无法强迫其进行垃圾回收，更无法干预内存管理。</li>
</ul>
<h3 id="引用计数"> 引用计数</h3>
<blockquote>
<p>跟踪记录每个值被引用的次数，如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这些内存释放；</p>
</blockquote>
<p>原理：每次引用加一，被释放时减一，当这个值的引用次数变为0时，就可以将其内存空间回收。</p>
<div><pre><code><span>// 例：</span>
<span>var</span> obj1 <span>=</span> <span>{</span> a<span>:</span> <span>10</span> <span>}</span><span>;</span> <span>// { a: 10 }的引用次数加1</span>
<span>var</span> obj2 <span>=</span> <span>{</span> a<span>:</span> <span>10</span> <span>}</span><span>;</span> <span>// { a: 10 }的引用次数加1</span>
obj1 <span>=</span> <span>{</span><span>}</span><span>;</span> <span>// obj1对{ a: 10 }的引用次数减1</span>
obj1 <span>=</span> <span>null</span><span>;</span> <span>// obj1对{ a: 10 }的引用次数为0</span>
obj2 <span>=</span> <span>null</span><span>;</span> <span>// obj2对{ a: 10 }的引用次数为0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>声明了一个变量并将一个引用类型的值赋值给这个变量，这个引用类型的值的引用次数是1；</li>
<li>同一个值又被赋值给另一个变量，这个引用类型值的引用次数加1；</li>
<li>当包含这个引用类型值的变量又被赋值成另一个值了，那么这个引用类型值的引用次数减1；</li>
<li>当引用次数为0时，说明没办法访问这个值了；</li>
<li>当垃机回收器下一次运行时，它就会释放引用次数是0的值所占用的内存空间；</li>
</ul>
<h4 id="存在的问题"> 存在的问题；</h4>
<div><p>注意</p>
<p>引用计数看起来挺完美的，但是它有一个很严重的bug--循环引用；循环引用就是相互引用，引发的问题就是会造成js的垃圾回收机制无法回收内存，占用内存空间，导致内存泄漏；</p>
</div>
<div><pre><code><span>// 例</span>
<span>function</span> <span>fn</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> obj1 <span>=</span> <span>{</span> a<span>:</span> <span>10</span> <span>}</span><span>;</span>
  <span>var</span> obj2 <span>=</span> <span>{</span> b<span>:</span> <span>10</span> <span>}</span><span>;</span>
  obj1<span>.</span>a <span>=</span> obj2<span>;</span> <span>// obj1的a属性指向obj2</span>
  obj2<span>.</span>b <span>=</span> obj1<span>;</span> <span>// obj2的b属性指向obj1</span>
  obj1 <span>=</span> <span>null</span><span>;</span> <span>// 取消对 { a: 10 }的引用；</span>
  obj2 <span>=</span> <span>null</span><span>;</span> <span>// 取消对 { a: 10 }的引用；</span>
<span>}</span>
<span>fn</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>在这个示例中，当我们调用fn这个函数，首先obj1有一个对{ a: 10 }的引用，则引用次数加1，然后obj2.b有一个对obj1的引用，则引用次数加1，同理{ b: 10 }的引用次数也是2。但是当我们把obj1和obj2都赋值为null的时候，{ b: 10 }和{ a: 10 }的引用次数都减1，但是此时obj1和obj2都已经没有什么用途了，而在函数外也无法访问到。但是这个时候由于obj1.a和obj2.b存在循环引用，导致此时的计数都是1，js垃圾回收机制无法进行回收，如果多次调用则会产生更多内存无法及时释放，导致内存泄漏；</p>
</blockquote>
<h3 id="标记清除"> 标记清除；</h3>
<blockquote>
<p>标记清除指的是变量进入环境时，这个变量标记为“进入环境”；而当变量离开环境时，则将其标记为“离开环境”，最后，垃圾回收器完成内存清除工作，销毁并回收那些被标记为“离开环境”的值所占用的内存空间；</p>
</blockquote>
<ol>
<li>执行环境：	执行环境定义了变量或函数有权访问的其它数据，决定了它们各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的所有变量和函数都保存在这个对象中；</li>
<li>全局执行环境：全局执行环境时最外围的一个执行环境。根据ECMAScript实现所在的宿主环境不同，表示执行环境的变量对象也不一样。例如：在WEB浏览器中，与全局执行环境关联的变量对象是wndows对象，而在Node中，全局执行环境是Global对象；</li>
<li>局部环境：每个函数都有自己的执行环境。当执行流进入一个函数时，函数的环境就会被推入一个环境栈中。而在函数执行之后，栈将其环境弹出，把控制权返回给之前的执行环境。ECMAScript程序中的执行流正是由这个方便的机制控制着；</li>
</ol>
<div><pre><code><span>// 例；</span>
<span>function</span> <span>foo</span> <span>(</span><span>)</span> <span>{</span>
  <span>var</span> a <span>=</span> <span>10</span><span>;</span> <span>// 被标记进入环境</span>
  <span>var</span> b <span>=</span> <span>'hello'</span><span>;</span> <span>// 被标记进入环境</span>
<span>}</span>
<span>foo</span><span>(</span><span>)</span><span>;</span> <span>// 执行完毕，a，和b被标记离开环境，内存被回收；</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="v8内存管理机制"> V8内存管理机制；</h2>
<p>限制内存的原因</p>
<ol>
<li>V8最初为浏览器而设计，不太可能遇到大量内存的使用场景；</li>
<li>防止因为垃圾回收所导致的线程暂停执行的时间过长；</li>
</ol>
<p>V8的回收策略：</p>
<ul>
<li>V8采用了一种分代回收的策略，将内存分为两个生代：新生代和老生代。</li>
<li>V8分别对新生代和老生代使用不同的垃圾回收算法提升垃圾回收效率。</li>
</ul>
<p>新生代垃圾回收：</p>
<blockquote>
<p>如下图所示：当我们分配对象时先在From空间进行分配，在垃圾回收运行时，会检查from中对象，当obj2需要被回收时，将其留到from空间，而obj1移动到to空间，然后进行反转，将from空间和to空间进行互换，进行垃圾回收时，会将to空间的内容进行释放，也就是说，当进行垃圾回收时，会检查from空间的存活对象，将其赋值到to空间中，而非存活对象占用的空间会被释放； 完成赋值后，from空间和to空间的角色完成对换；</p>
</blockquote>
<p><img src="./assets/image-20210507225853547.png" alt="image-20210507225853547" /></p>
<p>新生代对象的晋升：</p>
<ul>
<li>在新生代垃圾回收的过程中，当一个对象经过多次复制后依然存活，他将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用新的算法进行管理；</li>
<li>在From空间和To空间进行反转的过程中，如果To空间中的使用量已经超过了25%，那么就将From中的对象直接晋升到老生代内存中；</li>
</ul>
<p>老生代垃圾回收：</p>
<blockquote>
<p>老生代垃圾回收有两种方式：标记清除和标记合并；</p>
</blockquote>
<ul>
<li>
<p>老生代内存结构是一个连续的结构；</p>
<p><img src="./assets/image-20210507224856589.png" alt="image-20210507224856589" /></p>
</li>
<li>
<p>标记清除：是将需要被回收的对象进行标记，在垃圾回收运行时直接释放相应的地址空间；</p>
<ul>
<li>红色的区域是需要进行垃圾回收的区域；</li>
</ul>
<p><img src="./assets/image-20210507225219160.png" alt="image-20210507225219160" /></p>
<blockquote>
<p>使用标记清除进行垃圾回收会出现内存不连续的情况，为了解决这个问题，会采用标记合并；</p>
</blockquote>
</li>
<li>
<p>标记合并；是将存活的对象移动到一边，将需要被回收的对象移动到另一边，然后对需要被回收的对象区域进行整体的垃圾回收；</p>
<p><img src="./assets/image-20210507225639251.png" alt="image-20210507225639251" /></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>单元测试</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-12/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-12/</guid>
      <source url="https://wangyawei.top/rss.xml">单元测试</source>
      <category>javascript</category>
      <pubDate>Sun, 09 May 2021 22:22:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>测试是一种验证我们的代码是否可以按我们的预期工作的方法；被测试的对象可以是，样式、功能、组件等；</p>
<p>单元测试是指对软件中的最小可测试单元进行检查和验证；</p>
</blockquote>
<p>前端单元测试的意义：</p>
<ul>
<li>检测出潜在的bug;</li>
<li>快速反馈功能输出，验证代码是否达到预期；</li>
<li>保证代码重构的安全性；</li>
<li>方便协作开发；</li>
</ul>
<h2 id="示例"> 示例</h2>
<ol>
<li>
<p>被测试对象；</p>
<div><pre><code><span>// 被测试对象;</span>
<span>let</span> <span>add</span> <span>=</span> <span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>*</span> b<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>测试代码；</p>
<div><pre><code><span>// 测试代码</span>
<span>let</span> <span>expect</span> <span>=</span> <span>(</span><span>res</span><span>)</span> <span>=></span> <span>{</span>
  <span>return</span> <span>{</span>
    <span>toBe</span><span>:</span> <span>(</span><span>actual</span><span>)</span> <span>=></span> <span>{</span>
      <span>if</span><span>(</span>res <span>!==</span> actual<span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'预期值与实际值不符'</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>let</span> <span>test</span> <span>=</span> <span>(</span><span>desc<span>,</span> fn</span><span>)</span> <span>=></span> <span>{</span>
  <span>try</span> <span>{</span>
    <span>fn</span><span>(</span><span>)</span>
  <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span>desc<span>}</span></span><span>没有通过 %o</span><span>`</span></span><span>,</span> e<span>.</span>message<span>)</span>
  <span>}</span>
<span>}</span>

<span>// 开始测试；</span>
<span>test</span><span>(</span><span>'加法测试'</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>expect</span><span>(</span><span>add</span><span>(</span><span>1</span><span>,</span><span>2</span><span>)</span><span>)</span><span>.</span><span>toBe</span><span>(</span><span>3</span><span>)</span><span>;</span>
<span>}</span><span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><blockquote>
<p>在这个示例中：我们的测试对象是加法：1+2 正确应该是 3，则测试通过，但是如果你不小心写成了<code>*</code>法，则捕获错误，输出：加法测试没有通过 预期值与实际值不符；</p>
</blockquote>
</li>
</ol>
<h2 id="jest的基础使用"> jest的基础使用</h2>
<ol>
<li>
<p>安装<code>jest</code>;</p>
<div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ <span>npm</span> i -D jest
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>测试是否安装成功；</p>
<div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ <span>npm</span> <span>ls</span> jest
test@1.0.0 C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>test
`-- jest@26.6.3
<span># 若出现版本号，则安装成功；</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>新建文件<code>math.js和math.test.js</code>；</p>
<div><pre><code><span># 文件结构</span>
<span>test</span>
├── math.js
├── math.test.js
├── package-lock.json
└── package.json
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code><span>// math.js</span>
<span>let</span> <span>add</span> <span>=</span> <span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>+</span> b<span>;</span>
module<span>.</span>exports <span>=</span> <span>{</span> add <span>}</span>


<span>// math.test.js</span>
<span>const</span> <span>{</span> add <span>}</span> <span>=</span> <span>require</span><span>(</span><span>'./math'</span><span>)</span><span>;</span>
<span>test</span><span>(</span><span>'加法测试'</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>expect</span><span>(</span><span>add</span><span>(</span><span>1</span><span>,</span><span>2</span><span>)</span><span>)</span><span>.</span><span>toBe</span><span>(</span><span>3</span><span>)</span><span>;</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
<li>
<p>定义脚本</p>
<div><pre><code>  <span>"scripts"</span><span>:</span> <span>{</span>
    <span>"test"</span><span>:</span> <span>"jest"</span>
  <span>}</span><span>,</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>执行结果：</p>
<div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ <span>npm</span> run <span>test</span>

<span>></span> test@1.0.0 <span>test</span>
<span>></span> jest

 PASS  ./math.test.js
  √ 加法测试 <span>(</span><span>2</span> ms<span>)</span>

Test Suites: <span>1</span> passed, <span>1</span> total
Tests:       <span>1</span> passed, <span>1</span> total
Snapshots:   <span>0</span> total
Time:        <span>3.383</span> s
Ran all <span>test</span> suites.

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>提高代码可靠性</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-13/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-13/</guid>
      <source url="https://wangyawei.top/rss.xml">提高代码可靠性</source>
      <category>javascript</category>
      <pubDate>Sun, 09 May 2021 22:22:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>作为一名程序员，我们需要写出可靠的代码，来保障应用程序的安稳运行，所以提高自己的代码可靠性就变得有为重要；</p>
</blockquote>
<h2 id="函数式编程"> 函数式编程</h2>
<blockquote>
<p>函数式编程：是一种编程范式，是一种构建计算机程序结构和元素的风格，它把计算看作是对数学函数的评估，避免了状态的变化和数据的可变。将我们程序分解为一些更可用、更可靠且更易理解的部分，然后再将他们组合起来，形成一个更易推理的程序整体；</p>
<p>命令式编程： 就是详细的去命令机器怎么去处理一件事情，以达到你想要的结果。</p>
</blockquote>
<p>示例：</p>
<div><pre><code><span>// 初级程序员</span>
<span>let</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>]</span><span>;</span> 
<span>let</span> newArr <span>=</span> <span>[</span><span>]</span><span>;</span>
<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
  newArr<span>.</span><span>push</span><span>(</span>arr<span>[</span>i<span>]</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span>newArr<span>)</span><span>;</span> <span>// [2,3,4,5]</span>


<span>// 函数式编程写法</span>
<span>let</span> <span>newArr</span> <span>=</span> <span>(</span><span>arr<span>,</span> fn</span><span>)</span> <span>=></span> <span>{</span>
  <span>let</span> res <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    res<span>.</span><span>push</span><span>(</span><span>fn</span><span>(</span>arr<span>[</span>i<span>]</span><span>)</span><span>)</span><span>;</span>
  <span>}</span>
  <span>return</span> res<span>;</span>
<span>}</span>
<span>let</span> <span>add</span> <span>=</span> <span>item</span> <span>=></span> item <span>+</span> <span>5</span><span>;</span>
<span>let</span> <span>multi</span> <span>=</span> <span>item</span> <span>=></span> item <span>*</span> <span>5</span><span>;</span>
<span>let</span> sum <span>=</span> <span>newArr</span><span>(</span>arr<span>,</span> add<span>)</span><span>;</span>
<span>let</span> product <span>=</span> <span>newArr</span><span>(</span>arr<span>,</span>multi<span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>sum<span>)</span><span>;</span> <span>// [ 6, 7, 8, 9 ]</span>
console<span>.</span><span>log</span><span>(</span>product<span>)</span><span>;</span> <span>// [ 5, 10, 15, 20 ]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="纯函数"> 纯函数</h2>
<blockquote>
<p>1、相同的输入，则永远返回相同的结果。</p>
<p>2、它不依赖于程序执行期间函数外部任何状态或数据的变化，必须只依赖于其输入参数；</p>
<p>3、没有任何可观察到的副作用；</p>
</blockquote>
<ol>
<li>
<p>非纯函数；</p>
<div><pre><code><span>let</span> discount <span>=</span> <span>0.8</span><span>;</span>
<span>const</span> <span>calculatePrice</span> <span>=</span> <span>(</span><span>price</span><span>)</span> <span>=></span> price <span>*</span> discount<span>;</span>
<span>let</span> price <span>=</span> <span>calculatePrice</span><span>(</span><span>200</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>price<span>)</span><span>;</span>

<span>// 相同的输入不一样的输出；</span>
<span>let</span> discount <span>=</span> <span>0.8</span><span>;</span>
<span>let</span> price <span>=</span> <span>calculatePrice</span><span>(</span><span>200</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>price<span>)</span><span>;</span> <span>// 160</span>

discount <span>=</span> <span>0.9</span><span>;</span>
price <span>=</span> <span>calculatePrice</span><span>(</span><span>200</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>price<span>)</span><span>;</span> <span>// 180</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><blockquote>
<p>为什么说是不纯的函数，因为<code>discount</code>这个变量是从函数外部传入的，我们在调用这个函数的时候如果传入相同的输入，则不能保证相同的输出。我们可以发现由于我在外部改变了<code>discount</code>的值，导致相同的``200`，但是得到了不一样的结果；</p>
</blockquote>
</li>
<li>
<p>纯函数；</p>
<div><pre><code><span>const</span> <span>calculatePrice</span> <span>=</span> <span>(</span><span>price<span>,</span> discount</span><span>)</span> <span>=></span> price <span>*</span> discount<span>;</span>
<span>let</span> price <span>=</span> <span>calculatePrice</span><span>(</span><span>200</span><span>,</span> <span>0.8</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>price<span>)</span><span>;</span> <span>// 160</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ol>
<h2 id="函数副作用"> 函数副作用</h2>
<blockquote>
<ol>
<li>当调用函数时，除了返回函数值之外，还对主调用函数产生附加的影响；</li>
<li>例如修改全局变量(函数外的变量)或修改参数；</li>
</ol>
</blockquote>
<ol>
<li>
<p>函数副作用</p>
<div><pre><code><span>// 例1：</span>
<span>let</span> a <span>=</span> <span>5</span><span>;</span>
<span>let</span> <span>foo</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> a <span>=</span> a <span>*</span> <span>10</span><span>;</span>
<span>foo</span><span>(</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>
<p>我们的函数除了运算以外，还修改了函数外的变量，这就是函数造成的副作用；</p>
</blockquote>
<p>除了我们自己定义的函数会产生副作用以外，一些原生的<code>API</code>也会产生副作用；</p>
<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>]</span><span>;</span>
arr<span>.</span><span>slice</span><span>(</span><span>1</span><span>,</span><span>3</span><span>)</span><span>;</span> <span>// 纯函数，返回[2,3],原数组不改变；</span>
arr<span>.</span><span>splice</span><span>(</span><span>1</span><span>,</span><span>3</span><span>)</span><span>;</span> <span>// 非纯函数，返回[2,3,4]，原数组改变</span>
arr<span>.</span><span>pop</span><span>(</span><span>)</span><span>;</span> <span>// 非纯函数，返回6，原数组改变</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ol>
<hr>
<div><pre><code><span>// 例2 </span>
<span>// 不纯的函数</span>
<span>const</span> <span>foo</span> <span>=</span> <span>(</span><span>something</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> dt <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>.</span><span>toISOString</span><span>(</span><span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span><span><span>`</span><span><span>${</span>dt<span>}</span></span><span>:</span><span><span>${</span>something<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
  <span>return</span> something；
<span>}</span>
<span>foo</span><span>(</span><span>'hello'</span><span>)</span><span>;</span>

<span>// 改进</span>
<span>// 依赖注入</span>
<span>const</span> <span>foo</span> <span>=</span> <span>(</span><span>d<span>,</span> log<span>,</span> something</span><span>)</span> <span>=></span> <span>{</span>
  <span>const</span> dt <span>=</span> d<span>.</span><span>toISOString</span><span>(</span><span>)</span><span>;</span>
  <span>return</span> <span>log</span><span>(</span><span><span>`</span><span><span>${</span>dt<span>}</span></span><span>: </span><span><span>${</span>something<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
<span>}</span>

<span>const</span> something <span>=</span> <span>'你好网易'</span><span>;</span>
<span>const</span> d <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
<span>const</span> log <span>=</span> console<span>.</span><span>log</span><span>.</span><span>bind</span><span>(</span>console<span>)</span><span>;</span>
<span>foo</span><span>(</span>d<span>,</span>log<span>,</span>something<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><ol start="2">
<li>
<p>保护函数无副作用的特性；</p>
<ul>
<li>函数入口使用参数运算，而不修改它；</li>
<li>函数内不修改函数外的变量；</li>
<li>运算结果通过函数返回给外部；</li>
</ul>
</li>
</ol>
<blockquote>
<p>编写没有副作用的函数是不可能的，而且有些副作用是不可避免且至关重要的。所以我们的目标是尽可能的减少函数副作用</p>
</blockquote>
<h2 id="可变性和不可变性"> 可变性和不可变性</h2>
<blockquote>
<p>可变性：是指一个变量创建以后可以任意修改；</p>
<p>不可变性：是指一个变量，一旦被创建，就永远不会发生改变，不可变性是函数式编程的核心概念；</p>
</blockquote>
<ol>
<li>
<p>可变性；</p>
<div><pre><code><span>let</span> data <span>=</span> <span>{</span> count<span>:</span> <span>1</span> <span>}</span><span>;</span>
<span>let</span> <span>foo</span> <span>=</span> <span>(</span><span>data</span><span>)</span> <span>=></span> <span>{</span>
	data<span>.</span>count <span>=</span> <span>3</span><span>;</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span>data<span>.</span>count<span>)</span><span>;</span> <span>// 1</span>
<span>// 调用foo函数；</span>
console<span>.</span><span>log</span><span>(</span>data<span>.</span>count<span>)</span><span>;</span> <span>// 3</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p>data对象里面count的值，在调用foo函数后值发生了改变；</p>
</blockquote>
</li>
<li>
<p>不可变性；</p>
<div><pre><code><span>let</span> data <span>=</span> <span>{</span> count<span>:</span> <span>1</span> <span>}</span><span>;</span>
<span>let</span> <span>foo</span> <span>=</span> <span>(</span><span>data</span><span>)</span> <span>=></span> <span>{</span>
  <span>// 利用深拷贝解决可变性</span>
  <span>let</span> lily <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span>data<span>)</span><span>)</span><span>;</span>
  lily<span>.</span>count <span>=</span> <span>3</span><span>;</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span>data<span>.</span>count<span>)</span><span>;</span> <span>// 1</span>
<span>// 调用foo函数</span>
<span>foo</span><span>(</span>data<span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>data<span>.</span>count<span>)</span><span>;</span> <span>// 1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>compose函数和pipe函数</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-14/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-14/</guid>
      <source url="https://wangyawei.top/rss.xml">compose函数和pipe函数</source>
      <category>javascript</category>
      <pubDate>Wed, 12 May 2021 22:22:34 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="compose函数"> compose函数</h2>
<ol>
<li>什么是compose函数；
<ul>
<li>将需要嵌套执行的函数平铺；</li>
<li>嵌套执行指的是，一个函数的返回值将作为另一个函数的参数；</li>
</ul>
</li>
<li>作用：实现函数式编程中的PointFree，使我们专注于转换而不是数据；</li>
</ol>
<p>示例：</p>
<div><pre><code><span>// 1、下面的这段代码是典型的命令式编程，这样的代码不具备复用性；</span>
<span>let</span> <span>calculate</span> <span>=</span> <span>x</span> <span>=></span> <span>(</span>x <span>+</span> <span>10</span><span>)</span> <span>*</span> <span>10</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>calculate</span><span>(</span><span>10</span><span>)</span><span>)</span><span>;</span> <span>// 200</span>

<span>// 2、代码拆分；不足：简化了，但是不具备函数式编程</span>
<span>let</span> <span>add</span> <span>=</span> <span>x</span> <span>=></span> x <span>+</span> <span>10</span><span>;</span>
<span>let</span> <span>multiply</span> <span>=</span> <span>y</span> <span>=></span> y <span>*</span> <span>10</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>multiply</span><span>(</span><span>add</span><span>(</span><span>10</span><span>)</span><span>)</span><span>)</span><span>;</span> <span>// 200</span>

<span>// 3、复合函数；不足：只能执行两个函数</span>
<span>let</span> <span>compose</span> <span>=</span> <span>(</span><span>f<span>,</span>g</span><span>)</span> <span>=></span> <span>{</span>
  <span>return</span> <span>function</span> <span>(</span><span>x</span><span>)</span> <span>{</span>
    <span>return</span> <span>f</span><span>(</span><span>g</span><span>(</span>x<span>)</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
<span>let</span> calculate <span>=</span> <span>compose</span><span>(</span>multiply<span>,</span> add<span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>calculate</span><span>(</span><span>10</span><span>)</span><span>)</span><span>;</span> <span>// 200</span>

<span>// 4、通用的compose函数 可以传入多个函数；</span>
<span>let</span> <span>compose</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>let</span> args <span>=</span> <span>[</span><span>]</span><span>.</span><span>slice</span><span>.</span><span>call</span><span>(</span>arguments<span>)</span><span>;</span>
  <span>return</span> <span>function</span> <span>(</span><span>x</span><span>)</span> <span>{</span>
    <span>return</span> args<span>.</span><span>reduceRight</span><span>(</span><span>function</span> <span>(</span><span>res<span>,</span> cb</span><span>)</span> <span>{</span>
      <span>return</span> <span>cb</span><span>(</span>res<span>)</span><span>;</span>
    <span>}</span><span>,</span> x<span>)</span>
  <span>}</span>
<span>}</span>
<span>let</span> calculate <span>=</span> <span>compose</span><span>(</span>multiply<span>,</span> add<span>)</span><span>;</span>
consile<span>.</span><span>log</span><span>(</span><span>calculate</span><span>(</span><span>10</span><span>)</span><span>)</span><span>;</span> <span>// 200</span>

<span>// 5、reduce实现compose函数；</span>
<span>function</span> <span>compose</span><span>(</span><span><span>...</span>funcs</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>funcs<span>.</span>length <span>===</span> <span>0</span><span>)</span> <span>{</span>
    <span>return</span> <span>arg</span> <span>=></span> arg<span>;</span>
  <span>}</span>
  <span>return</span> funcs<span>.</span><span>reduce</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> <span>{</span>
    <span>return</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>=></span> <span>a</span><span>(</span><span>b</span><span>(</span><span>...</span>args<span>)</span><span>)</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span>
<span>let</span> <span>add</span> <span>=</span> <span>n</span> <span>=></span> n <span>+</span> <span>3</span><span>;</span>
<span>let</span> <span>multiple</span> <span>=</span> <span>n</span> <span>=></span> n <span>*</span> <span>2</span><span>;</span>
<span>let</span> <span>minus</span> <span>=</span> <span>n</span> <span>=></span> n <span>-</span> <span>1</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>compose</span><span>(</span><span>)</span><span>(</span><span>10</span><span>)</span><span>,</span>
<span>compose</span><span>(</span>add<span>,</span> multiple<span>,</span> minus<span>)</span><span>(</span><span>10</span><span>)</span><span>,</span> <span>'==='</span><span>)</span><span>;</span> <span>// 10 21</span>

<span>// 可以理解为；</span>
<span>const</span> <span>fn1</span> <span>=</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>=></span> <span>add</span><span>(</span><span>multiple</span><span>(</span><span>...</span>args<span>)</span><span>)</span>
<span>const</span> <span>fn2</span> <span>=</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>=></span> <span>fn1</span><span>(</span><span>minus</span><span>(</span><span>...</span>args<span>)</span><span>)</span>

console<span>.</span><span>log</span><span>(</span><span>fn2</span><span>(</span><span>10</span><span>)</span><span>)</span> <span>// 21</span>

<span>//6、es6实现 compose函数；</span>
<span>const</span> <span>compose</span> <span>=</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>=></span> <span>x</span> <span>=></span> args<span>.</span><span>reduceRight</span><span>(</span><span>(</span><span>res<span>,</span> cb</span><span>)</span> <span>=></span> <span>cb</span><span>(</span>res<span>)</span><span>,</span> x<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><blockquote>
<p>复合函数的执行顺序从<strong>右往左</strong>依次执行；比如webpack的loader也是从右往左，这是因为它采用了compose的方式去实现而已；</p>
</blockquote>
<h2 id="pipe函数"> pipe函数；</h2>
<blockquote>
<p>pipe函数可以说是compose函数的复制品，所做的事情和compose也相同，只不过它的执行数据流的方向是从左往右执行而已；</p>
</blockquote>
<p>例一：</p>
<div><pre><code><span>let</span> <span>add</span> <span>=</span> <span>n</span> <span>=></span> n <span>+</span> <span>3</span><span>;</span>
<span>let</span> <span>multiple</span> <span>=</span> <span>n</span> <span>=></span> n <span>*</span> <span>2</span><span>;</span>
<span>let</span> <span>minus</span> <span>=</span> <span>n</span> <span>=></span> n <span>-</span> <span>1</span><span>;</span>

<span>// 法一</span>
<span>function</span> <span>pipe</span><span>(</span><span><span>...</span>funcs</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>funcs<span>.</span>length <span>===</span> <span>0</span><span>)</span> <span>{</span>
    <span>return</span> <span>arg</span> <span>=></span> arg<span>;</span>
  <span>}</span>
  <span>return</span> funcs<span>.</span><span>reduceRight</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> <span>{</span>
    <span>return</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>=></span> <span>a</span><span>(</span><span>b</span><span>(</span><span>...</span>args<span>)</span><span>)</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span>

console<span>.</span><span>log</span><span>(</span><span>pipe</span><span>(</span><span>)</span><span>(</span><span>10</span><span>)</span><span>)</span><span>;</span> <span>// 10</span>
console<span>.</span><span>log</span><span>(</span><span>pipe</span><span>(</span>add<span>)</span><span>(</span><span>10</span><span>)</span><span>)</span> <span>// 13</span>
console<span>.</span><span>log</span><span>(</span><span>pipe</span><span>(</span>add<span>,</span>multiple<span>,</span>minus<span>)</span><span>(</span><span>10</span><span>)</span><span>)</span> <span>// 25</span>

<span>// 法二；</span>
<span>const</span> <span>pipe</span> <span>=</span> <span>(</span><span><span>...</span>args</span><span>)</span> <span>=></span> <span>x</span> <span>=></span> args<span>.</span><span>reduce</span><span>(</span><span>(</span><span>res<span>,</span> cb</span><span>)</span> <span>=></span> <span>cb</span><span>(</span>res<span>)</span><span>,</span> x<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>高阶函数</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-15/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-15/</guid>
      <source url="https://wangyawei.top/rss.xml">高阶函数</source>
      <category>javascript</category>
      <pubDate>Wed, 12 May 2021 22:22:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>1、高阶函数是对其他函数进行操作的函数，可以将它们作为参数或返回它们；</p>
<p>2、简单来说，高阶函数是一个函数，它接收函数作为参数或将函数作为输出返回；</p>
</blockquote>
<h2 id="map方法"> <code>map方法</code></h2>
<p>需求：创建一个新数组，其中的值是原数组的值的两倍</p>
<div><pre><code><span>// 结果；</span>
<span>const</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>]</span><span>;</span>
<span>const</span> arr1 <span>=</span> arr<span>.</span><span>map</span><span>(</span><span>(</span><span>item</span><span>)</span> <span>=></span> item <span>*</span> <span>2</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>arr1<span>)</span><span>// [2,4,6,8]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="reduce方法"> <code>reduce方法</code></h2>
<p>需求：创建一个新数组，并对数组中的值进行求和；</p>
<div><pre><code><span>const</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>]</span><span>;</span>
<span>const</span> sum <span>=</span> arr<span>.</span><span>reduce</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>+</span> b<span>,</span> <span>0</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>sum<span>)</span><span>;</span> <span>// 10</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>需求：创建一个新数组，并对数组中的值进行<strong>去重</strong>；</p>
<div><pre><code><span>const</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>3</span><span>,</span><span>3</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>]</span><span>;</span>
<span>const</span> arr2 <span>=</span> arr<span>.</span><span>reduce</span><span>(</span><span>(</span><span>prev<span>,</span> cur</span><span>)</span> <span>=></span> <span>{</span>
  prev<span>.</span><span>indexOf</span><span>(</span>cur<span>)</span> <span>===</span> <span>-</span><span>1</span> <span>&amp;&amp;</span> prev<span>.</span><span>push</span><span>(</span>cur<span>)</span>
  <span>return</span> prev<span>;</span>
<span>}</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>arr2<span>)</span><span>;</span> <span>[</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span> <span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="filter方法"> <code>filter方法</code></h2>
<p>需求：筛选数组中满足指定条件的数据；</p>
<div><pre><code><span>let</span> persons <span>=</span> <span>[</span>
  <span>{</span> name<span>:</span> <span>'peter'</span><span>,</span> age<span>:</span> <span>21</span> <span>}</span><span>,</span>
  <span>{</span> name<span>:</span> <span>'mark'</span><span>,</span> age<span>:</span> <span>28</span> <span>}</span><span>,</span>
  <span>{</span> name<span>:</span> <span>'josn'</span><span>,</span> age<span>:</span> <span>19</span> <span>}</span><span>,</span>
  <span>{</span> name<span>:</span> <span>'jane'</span><span>,</span> age<span>:</span> <span>31</span> <span>}</span><span>,</span>
  <span>{</span> name<span>:</span> <span>'tony'</span><span>,</span> age<span>:</span> <span>35</span> <span>}</span><span>,</span>
<span>]</span>

<span>let</span> newAge <span>=</span> persons<span>.</span><span>filter</span><span>(</span><span>item</span> <span>=></span> item<span>.</span>age <span>></span> <span>21</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>newAge<span>)</span><span>;</span>
<span>// [</span>
<span>//   { name: 'mark', age: 28 },</span>
<span>//   { name: 'jane', age: 31 },</span>
<span>//   { name: 'tony', age: 35 }</span>
<span>// ]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="flat方法"> <code>flat方法</code></h2>
<blockquote>
<p>可以实现数组扁平化；将多维数组变为一维数组，该方法会返回新数组对原数组没有影响；</p>
</blockquote>
<div><pre><code><span>let</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>[</span><span>5</span><span>,</span> <span>6</span><span>,</span> <span>[</span><span>7</span><span>,</span> <span>8</span><span>,</span> <span>[</span><span>9</span><span>,</span> <span>10</span><span>,</span> <span>[</span><span>11</span><span>,</span> <span>12</span><span>,</span> <span>[</span><span>13</span><span>,</span> <span>14</span><span>]</span><span>]</span><span>]</span><span>]</span><span>]</span><span>]</span><span>;</span>
<span>// 默认只会展平一层</span>
<span>let</span> arr1 <span>=</span> arr<span>.</span><span>flat</span><span>(</span><span>)</span><span>;</span>
<span>// 可以通过参数指定需要展平的层数</span>
<span>let</span> arr2 <span>=</span> arr<span>.</span><span>flat</span><span>(</span><span>2</span><span>)</span><span>;</span>
<span>// 如果不知道有多少层可以传入 Infinity 关键字 展平无限层</span>
<span>let</span> arr3 <span>=</span> arr<span>.</span><span>flat</span><span>(</span><span>Infinity</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>arr1<span>,</span> arr2<span>,</span> arr3<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="高阶函数的意义"> 高阶函数的意义；</h2>
<ol>
<li>
<p>将函数作为参数；</p>
<div><pre><code><span>// 参数为函数的高阶函数</span>
<span>function</span> <span>foo</span> <span>(</span><span>f</span><span>)</span> <span>{</span>
  <span>// 判断实参是否为函数</span>
  <span>if</span> <span>(</span><span>(</span><span>typeof</span> f<span>)</span> <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
      <span>f</span><span>(</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>// 调用</span>
<span>foo</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span><span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
<li>
<p>将函数作为返回值；</p>
<div><pre><code><span>// 返回值为函数的高阶函数；</span>
<span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>function</span> <span>(</span><span>)</span> <span>{</span><span>}</span>
<span>}</span>

<span>// 调用；</span>
<span>let</span> f <span>=</span> <span>foo</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>高阶函数的实际作用；</p>
<div><pre><code><span>const</span> <span>callback</span> <span>=</span> <span>(</span><span>val</span><span>)</span> <span>=></span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>val<span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>const</span> <span>foo</span> <span>=</span> <span>(</span><span>val<span>,</span> fn</span><span>)</span> <span>=></span> <span>{</span>
  <span>if</span> <span>(</span><span>typeof</span> fn <span>===</span> <span>'function'</span><span>)</span> <span>{</span>
      <span>fn</span><span>(</span>val<span>)</span><span>;</span>
  <span>}</span>
<span>}</span><span>;</span>

<span>foo</span><span>(</span><span>'hello'</span><span>,</span> callback<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>常用函数</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-16/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-16/</guid>
      <source url="https://wangyawei.top/rss.xml">常用函数</source>
      <category>javascript</category>
      <pubDate>Thu, 01 Jul 2021 22:22:34 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="缓存函数"> 缓存函数</h2>
<blockquote>
<p>缓存函数是指将上次的计算结果缓存起来，当下次调用时，如果遇到相同的参数，就直接返回缓存中的数据；</p>
</blockquote>
<p>例：</p>
<div><pre><code><span>// 缓存函数</span>
<span>let</span> <span>memoize</span> <span>=</span> <span>function</span> <span>(</span><span>func</span><span>)</span> <span>{</span>
  <span>let</span> cache <span>=</span> <span>{</span><span>}</span><span>;</span>
  <span>return</span> <span>function</span> <span>(</span><span>key</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>cache<span>[</span>key<span>]</span><span>)</span> <span>{</span>
      cache<span>[</span>key<span>]</span> <span>=</span> <span>func</span><span>.</span><span>apply</span><span>(</span><span>null</span><span>,</span> arguments<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> cache<span>[</span>key<span>]</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>let</span> <span>add</span> <span>=</span> <span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a <span>+</span> b<span>;</span>
<span>let</span> calculate <span>=</span> <span>memoize</span><span>(</span>add<span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>calculate</span><span>(</span><span>10</span><span>,</span> <span>20</span><span>)</span><span>)</span> <span>// 30</span>
console<span>.</span><span>log</span><span>(</span><span>calculate</span><span>(</span><span>10</span><span>,</span> <span>20</span><span>)</span><span>)</span> <span>// 相同的参数，第二次调用时，从缓存中取出数据，而非重新计算一次；</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><blockquote>
<p>实现原理：把参数和对应的结果数据存到一个对象中，调用时，判断参数对应的数据是否存在，存在就返回对应的结果数据；</p>
<p>应用场景：需要大量重复的计算，或者大量计算又依赖于之前的结果；</p>
</blockquote>
<h2 id="柯里化函数"> 柯里化函数</h2>
<blockquote>
<p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术；</p>
</blockquote>
<p>例一：</p>
<div><pre><code><span>// 非柯里化函数</span>
<span>function</span> <span>girl</span><span>(</span><span>name<span>,</span> age<span>,</span> single</span><span>)</span> <span>{</span>
  <span>return</span> <span><span>`</span><span>我叫</span><span><span>${</span>name<span>}</span></span><span>,我今年</span><span><span>${</span>age<span>}</span></span><span>岁,我</span><span><span>${</span>single<span>}</span></span><span>单身</span><span>`</span></span><span>;</span>
<span>}</span>

<span>let</span> lincancan <span>=</span> <span>girl</span><span>(</span><span>'林灿灿'</span><span>,</span> <span>18</span><span>,</span> <span>'不是'</span><span>)</span>

console<span>.</span><span>log</span><span>(</span>lincancan<span>)</span> <span>// 我叫林灿灿,我今年18岁,我不是单身</span>

<span>// 柯里化函数</span>
<span>function</span> <span>girl</span><span>(</span><span>name</span><span>)</span> <span>{</span>
  <span>return</span> <span>function</span> <span>(</span><span>age</span><span>)</span> <span>{</span>
    <span>return</span> <span>function</span> <span>(</span><span>single</span><span>)</span> <span>{</span>
      <span>return</span> <span><span>`</span><span>我叫</span><span><span>${</span>name<span>}</span></span><span>,我今年</span><span><span>${</span>age<span>}</span></span><span>岁,我</span><span><span>${</span>single<span>}</span></span><span>单身</span><span>`</span></span>
    <span>}</span>
  <span>}</span>
<span>}</span>
<span>let</span> rst <span>=</span> <span>girl</span><span>(</span><span>'林灿灿'</span><span>)</span><span>(</span><span>18</span><span>)</span><span>(</span><span>'不是'</span><span>)</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>rst<span>)</span> <span>// 我叫林灿灿,我今年18岁,我不是单身</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>例二：</p>
<div><pre><code><span>// 需求：检测字符串中是否包含空格</span>
<span>let</span> <span>matching</span> <span>=</span> <span>(</span><span>reg<span>,</span> str</span><span>)</span> <span>=></span> reg<span>.</span><span>test</span><span>(</span>str<span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>matching</span><span>(</span><span><span>/</span><span>\s+</span><span>/</span><span>g</span></span><span>,</span> <span>'hello world'</span><span>)</span><span>)</span> <span>// true</span>
console<span>.</span><span>log</span><span>(</span><span>matching</span><span>(</span><span><span>/</span><span>\s+</span><span>/</span><span>g</span></span><span>,</span> <span>'abcdefg'</span><span>)</span><span>)</span> <span>// false</span>

<span>// 柯里化函数</span>
<span>let</span> <span>curry</span> <span>=</span> <span>(</span><span>reg</span><span>)</span> <span>=></span> <span>{</span>
  <span>return</span> <span>(</span><span>str</span><span>)</span> <span>=></span> <span>{</span>
    <span>return</span> reg<span>.</span><span>test</span><span>(</span>str<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>let</span> hasSpase <span>=</span> <span>curry</span><span>(</span><span><span>/</span><span>\s+</span><span>/</span><span>g</span></span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>hasSpase</span><span>(</span><span>'hello world'</span><span>)</span><span>)</span> <span>// true</span>
console<span>.</span><span>log</span><span>(</span><span>hasSpase</span><span>(</span><span>'abcdefg'</span><span>)</span><span>)</span> <span>// false</span>
console<span>.</span><span>log</span><span>(</span><span>hasSpase</span><span>(</span><span>'I Love China'</span><span>)</span><span>)</span> <span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>例三：借助loadsh函数库；</p>
<blockquote>
<p>1、lodash是一个一致性、模块化、高性能的javaScript实用工具库；</p>
<p>2、lodash通过降低array、number、objects、string等等的使用难度从而让javaScript变得更简单；</p>
</blockquote>
<div><pre><code><span>// 法一；</span>
<span>const</span> _ <span>=</span> <span>require</span><span>(</span><span>'lodash'</span><span>)</span><span>;</span>
<span>let</span> persons <span>=</span> <span>[</span>
  <span>{</span> name<span>:</span> <span>'Perter'</span><span>,</span> age<span>:</span> <span>21</span> <span>}</span><span>,</span>
  <span>{</span> name<span>:</span> <span>'Mark'</span><span>,</span> age<span>:</span> <span>28</span> <span>}</span><span>,</span>
  <span>{</span> name<span>:</span> <span>'Josn'</span><span>,</span> age<span>:</span> <span>19</span> <span>}</span>
<span>]</span>

<span>let</span> getProp <span>=</span> _<span>.</span><span>curry</span><span>(</span><span>(</span><span>key<span>,</span> obj</span><span>)</span> <span>=></span> <span>{</span>
  <span>return</span> obj<span>[</span>key<span>]</span><span>;</span>
<span>}</span><span>)</span>
<span>let</span> age <span>=</span> persons<span>.</span><span>map</span><span>(</span><span>getProp</span><span>(</span><span>'age'</span><span>)</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>age<span>)</span> <span>// [ 21, 28, 19 ]</span>

<span>// 法二；</span>
<span>let</span> age <span>=</span> persons<span>.</span><span>map</span><span>(</span><span>(</span><span>item</span><span>)</span> <span>=></span> item<span>.</span>age<span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>age<span>)</span> <span>// [ 21, 28, 19 ]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="偏函数"> 偏函数</h2>
<blockquote>
<p>偏函数：是固定一个函数的一个或者多个参数，也就是将一个n元函数转换成一个n-x元函数；</p>
</blockquote>
<ol>
<li>柯里化：<code>f(a, b, c) = f(a)(b)(c)</code>;</li>
<li>偏函数：<code>f(a, b, c) = f(a, b)(c)</code></li>
</ol>
<p>例：</p>
<div><pre><code><span>// 使用bind实现；</span>
<span>let</span> <span>add</span> <span>=</span> <span>(</span><span>x<span>,</span> y</span><span>)</span> <span>=></span> x <span>+</span> y<span>;</span>
<span>let</span> rst <span>=</span> <span>add</span><span>.</span><span>bind</span><span>(</span><span>null</span><span>,</span> <span>1</span><span>)</span><span>;</span>
<span>rst</span><span>(</span><span>2</span><span>)</span><span>;</span> <span>// 3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>排序算法</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-17/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-17/</guid>
      <source url="https://wangyawei.top/rss.xml">排序算法</source>
      <category>javascript</category>
      <pubDate>Sat, 15 May 2021 20:38:45 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="冒泡排序"> 冒泡排序</h2>
<blockquote>
<p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢&quot;浮&quot;到数列的顶端。</p>
</blockquote>
<div><pre><code><span>const</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>5</span><span>,</span><span>6</span><span>,</span><span>7</span><span>,</span><span>8</span><span>,</span><span>9</span><span>,</span><span>12</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>0</span><span>]</span>

<span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> j <span>=</span> <span>0</span><span>;</span> j <span>&lt;</span> arr<span>.</span>length <span>-</span> i<span>;</span> j<span>++</span><span>)</span> <span>{</span>
    <span>let</span> num<span>;</span>
    <span>if</span> <span>(</span>arr<span>[</span>j<span>]</span> <span>></span> arr<span>[</span>j <span>+</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
      num <span>=</span> arr<span>[</span>j <span>+</span> <span>1</span><span>]</span><span>;</span>
      arr<span>[</span>j <span>+</span> <span>1</span><span>]</span> <span>=</span> arr<span>[</span>j<span>]</span><span>;</span>
      arr<span>[</span>j<span>]</span> <span>=</span> num<span>;</span>
      <span>// [ arr[j + 1], arr[j] ] = [ arr[j], arr[j + 1] ]  利用es6数组结构简写</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span>arr<span>)</span> <span>// [0, 1, 2, 3, 4,5, 6, 7, 8, 9,12]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="插入排序"> 插入排序</h2>
<blockquote>
<p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p>
</blockquote>
<div><pre><code><span>var</span> arr <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>,</span> <span>3</span><span>,</span> <span>7</span><span>,</span> <span>5</span><span>,</span> <span>4</span><span>,</span> <span>6</span><span>,</span> <span>0</span><span>,</span> <span>44</span><span>]</span>
<span>var</span> preIndex<span>,</span> current
<span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> arr<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
  preIndex <span>=</span> i <span>-</span> <span>1</span>
  <span>// 保存当前用于比较的值</span>
  current <span>=</span> arr<span>[</span>i<span>]</span>
  <span>while</span> <span>(</span>preIndex <span>>=</span> <span>0</span> <span>&amp;&amp;</span> arr<span>[</span>preIndex<span>]</span> <span>></span> current<span>)</span> <span>{</span>
    <span>// 如果前一个值大于比较的值，则交换位置</span>
    arr<span>[</span>preIndex <span>+</span> <span>1</span><span>]</span> <span>=</span> arr<span>[</span>preIndex<span>]</span>
    <span>// 继续和前面的值比较</span>
    preIndex<span>--</span>
  <span>}</span>
  <span>// 前面的值不满足比较要求时，把比较的值插入到不满足的值的前面；</span>
  arr<span>[</span>preIndex <span>+</span> <span>1</span><span>]</span> <span>=</span> current
<span>}</span>
console<span>.</span><span>log</span><span>(</span>arr<span>)</span> <span>//   [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 44]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><a href="https://www.runoob.com/w3cnote/insertion-sort.html" target="_blank" rel="noopener noreferrer">官方文档</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>链表数据结构</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-18/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-18/</guid>
      <source url="https://wangyawei.top/rss.xml">链表数据结构</source>
      <category>javascript</category>
      <pubDate>Wed, 19 May 2021 22:05:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>链表存储有序的元素集合，但不同于数组，链表中的元素在内存中并不是连续放置的。每个 元素由一个存储元素本身的节点和一个指向下一个元素的引用(也称指针或链接)组成。下图展示了链表的结构:</p>
</blockquote>
<p><img src="./assets/1230971-20190325100955352-619258300.png" alt="img" /></p>
<blockquote>
<p>相对于传统的数组，链表的一个好处在于，<strong>添加或移除元素的时候不需要移动其他元素</strong>。然而，链表需要使用指针，因此实现链表时需要额外注意。 数组的另一个细节是可以直接访问任何位置的任何元素，而要想访问链表中间的一个元素，需要从起点(表头)开始迭代列表直到找到所需的元素</p>
</blockquote>
<h2 id="普通链表"> 普通链表</h2>
<div><pre><code><span>// 链表节点</span>
<span>class</span> <span>Node</span> <span>{</span>
  <span>constructor</span><span>(</span><span>element</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>element <span>=</span> element<span>;</span>
    <span>this</span><span>.</span>next <span>=</span> <span>null</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>// 链表类</span>
<span>class</span> <span>LinkedList</span> <span>{</span>
  <span>constructor</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>head <span>=</span> <span>null</span><span>;</span>
    <span>// 用来表示节点的长度；</span>
    <span>this</span><span>.</span>length <span>=</span> <span>0</span><span>;</span>
  <span>}</span>

  <span>// 追加元素</span>
  <span>append</span><span>(</span><span>element</span><span>)</span> <span>{</span>
    <span>let</span> node <span>=</span> <span>new</span> <span>Node</span><span>(</span>element<span>)</span><span>;</span>

    <span>// 存储下一个数据的引用；</span>
    <span>let</span> current <span>=</span> <span>null</span><span>;</span>
    <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>head<span>)</span> <span>{</span>
      <span>this</span><span>.</span>head <span>=</span> node<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
      current <span>=</span> <span>this</span><span>.</span>head<span>;</span>
      <span>while</span> <span>(</span>current<span>.</span>next<span>)</span> <span>{</span>
        current <span>=</span> current<span>.</span>next<span>;</span>
      <span>}</span>
      <span>// 追加到最后一个链表的next上；</span>
      current<span>.</span>next <span>=</span> node<span>;</span>
    <span>}</span>
    <span>this</span><span>.</span>length<span>++</span><span>;</span>
  <span>}</span>

  <span>// 任意位置插入元素</span>
  <span>insert</span> <span>(</span><span>position<span>,</span> element</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>position <span>>=</span> <span>0</span> <span>&amp;&amp;</span> position <span>&lt;=</span> <span>this</span><span>.</span>length<span>)</span> <span>{</span>
      <span>let</span> node <span>=</span> <span>new</span> <span>Node</span><span>(</span>element<span>)</span><span>;</span>
      <span>let</span> current <span>=</span> <span>this</span><span>.</span>head<span>;</span>
      <span>let</span> previous <span>=</span> <span>null</span><span>;</span>
      <span>let</span> index <span>=</span> <span>0</span><span>;</span>
      <span>if</span> <span>(</span>position <span>===</span> <span>0</span><span>)</span> <span>{</span>
        node<span>.</span>next <span>=</span> current<span>;</span>
        <span>this</span><span>.</span>head <span>=</span> node<span>;</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>while</span> <span>(</span>index<span>++</span> <span>&lt;</span> position<span>)</span> <span>{</span>
          previous <span>=</span> current<span>;</span>
          current <span>=</span> current<span>.</span>next<span>;</span>
        <span>}</span>
        node<span>.</span>next <span>=</span> current<span>;</span>
        previous<span>.</span>next <span>=</span> node<span>;</span>
      <span>}</span>
      <span>this</span><span>.</span>length<span>++</span><span>;</span>
      <span>return</span> <span>true</span>
    <span>}</span>
    <span>return</span> <span>false</span>
  <span>}</span>

  <span>// 移除指定位置元素</span>
  <span>removeAt</span><span>(</span><span>position</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>position <span>></span> <span>-</span><span>1</span> <span>&amp;&amp;</span> position <span>&lt;</span> <span>this</span><span>.</span>length<span>)</span> <span>{</span>
      <span>let</span> current <span>=</span> <span>this</span><span>.</span>head<span>;</span>
      <span>let</span> previous <span>=</span> <span>null</span><span>;</span>
      <span>let</span> index <span>=</span> <span>0</span><span>;</span>
      <span>if</span> <span>(</span>position <span>===</span> <span>0</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>head <span>=</span> current<span>.</span>next<span>;</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>while</span><span>(</span>index<span>++</span> <span>&lt;</span> position<span>)</span> <span>{</span>
          previous <span>=</span> current<span>;</span>
          current <span>=</span> current<span>.</span>next<span>;</span>
        <span>}</span>
        previous<span>.</span>next <span>=</span> current<span>.</span>next<span>;</span>
      <span>}</span>
      <span>this</span><span>.</span>length<span>--</span><span>;</span>
      <span>return</span> current<span>.</span>element<span>;</span>
    <span>}</span>
    <span>return</span> <span>null</span>
  <span>}</span>

  <span>// 寻找元素下标</span>
  <span>findIndex</span><span>(</span><span>element</span><span>)</span> <span>{</span>
    <span>let</span> current <span>=</span> <span>this</span><span>.</span>head<span>;</span>
    <span>let</span> index <span>=</span> <span>0</span><span>;</span>
    <span>while</span> <span>(</span>current<span>)</span> <span>{</span>
      <span>if</span> <span>(</span>element <span>===</span> current<span>.</span>element<span>)</span> <span>{</span>
        <span>return</span> index<span>;</span>
      <span>}</span>
      index<span>++</span><span>;</span>
      current <span>=</span> current<span>.</span>next<span>;</span>
    <span>}</span>
    <span>return</span> <span>-</span><span>1</span><span>;</span>
  <span>}</span>

  <span>// 删除指定文档</span>
  <span>remove</span><span>(</span><span>element</span><span>)</span> <span>{</span>
    <span>let</span> index <span>=</span> <span>this</span><span>.</span><span>findIndex</span><span>(</span>element<span>)</span><span>;</span>
    <span>return</span> <span>this</span><span>.</span><span>removeAt</span><span>(</span>index<span>)</span><span>;</span>
  <span>}</span>

  <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>!</span><span>this</span><span>.</span>length<span>;</span>
  <span>}</span>

  <span>size</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>this</span><span>.</span>length<span>;</span>
  <span>}</span>

  <span>// 返回所有链表的值</span>
  <span>toString</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> current <span>=</span> <span>this</span><span>.</span>head<span>;</span>
    <span>let</span> arr <span>=</span> <span>[</span><span>]</span><span>;</span>
    <span>while</span> <span>(</span>current<span>)</span> <span>{</span>
      arr<span>.</span><span>push</span><span>(</span>current<span>.</span>element<span>)</span><span>;</span>
      current <span>=</span> current<span>.</span>next<span>;</span>
    <span>}</span>
    <span>return</span> arr<span>;</span>
  <span>}</span>
<span>}</span>

<span>const</span> ll <span>=</span> <span>new</span> <span>LinkedList</span><span>(</span><span>)</span><span>;</span>

ll<span>.</span><span>append</span><span>(</span><span>2</span><span>)</span><span>;</span>
ll<span>.</span><span>append</span><span>(</span><span>4</span><span>)</span><span>;</span>
ll<span>.</span><span>append</span><span>(</span><span>6</span><span>)</span><span>;</span>
ll<span>.</span><span>append</span><span>(</span><span>8</span><span>)</span><span>;</span>
ll<span>.</span><span>append</span><span>(</span><span>10</span><span>)</span><span>;</span>
ll<span>.</span><span>removeAt</span><span>(</span><span>0</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>ll<span>.</span><span>remove</span><span>(</span><span>10</span><span>)</span><span>)</span> <span>// 10</span>
console<span>.</span><span>log</span><span>(</span>ll<span>.</span><span>findIndex</span><span>(</span><span>6</span><span>)</span><span>)</span> <span>// 1</span>
console<span>.</span><span>log</span><span>(</span>ll<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// [ 4, 6, 8 ]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br></div></div><p><a href="https://www.cnblogs.com/cc-freiheit/p/10591992.html" target="_blank" rel="noopener noreferrer">阅读原文</a></p>
<p>遍历链表：</p>
<div><pre><code><span>function</span> <span>traversal</span><span>(</span><span>linkedList<span>,</span> callback</span><span>)</span> <span>{</span>
  <span>let</span> current <span>=</span> linkedList<span>.</span>head <span>||</span> <span>{</span><span>}</span><span>;</span>
  <span>callback</span><span>(</span>current<span>.</span>element<span>)</span>
  <span>while</span> <span>(</span>current<span>.</span>next<span>)</span> <span>{</span>
    current <span>=</span> current<span>.</span>next<span>;</span>
    <span>callback</span><span>(</span>current<span>.</span>element<span>)</span>
  <span>}</span>
<span>}</span>
<span>let</span> sum <span>=</span> <span>0</span>
<span>traversal</span><span>(</span>ll<span>,</span> <span>(</span><span>value</span><span>)</span> <span>=></span> sum <span>+=</span> value<span>)</span>
console<span>.</span><span>log</span><span>(</span>sum<span>)</span> <span>// 18</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="环行链表"> 环行链表</h2>
<blockquote>
<p>给定一个链表，判断链表中是否有环。如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 如果链表中存在环，则返回 true 。 否则，返回 false 。</p>
<p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/linked-list-cycle</p>
</blockquote>
<p><img src="./assets/image-20210515231641271.png" alt="image-20210515231641271" /></p>
<div><pre><code><span>const</span> head <span>=</span> <span>{</span>
	value<span>:</span> <span>1</span><span>,</span>
	next<span>:</span> <span>null</span>
<span>}</span>

<span>var</span> <span>hasCycle</span> <span>=</span> <span>function</span><span>(</span><span>head</span><span>)</span> <span>{</span>
  <span>// 快慢指针 </span>
    <span>let</span> fast <span>=</span> head
    <span>let</span> slow <span>=</span> head
    <span>while</span><span>(</span>fast <span>&amp;&amp;</span> fast<span>.</span>next<span>)</span><span>{</span>
        fast <span>=</span> fast<span>.</span>next<span>.</span>next
        slow <span>=</span> slow<span>.</span>next
        <span>if</span><span>(</span>fast <span>===</span> slow<span>)</span><span>{</span>
            <span>return</span> <span>true</span>
        <span>}</span>
    <span>}</span>
    <span>return</span> <span>false</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><blockquote>
<p>解题思路：让xxx.next.next和xxx.next一直比较是否相等，如果相等则存在环；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>js数据类型</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-19/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-19/</guid>
      <source url="https://wangyawei.top/rss.xml">js数据类型</source>
      <category>javascript</category>
      <pubDate>Wed, 19 May 2021 22:05:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>javascript一共有8种数据类型;</p>
<ol>
<li>原始数据类型(简单数据类型)：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol。</li>
<li>引用数据类型(复杂数据类型)：对象(Object)、数组(Array)、函数(Function)。</li>
</ol>
</blockquote>
<div><p>提示</p>
<p><em>注：</em></p>
<ul>
<li>Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。*</li>
<li>NaN：即非数值（Not a Numder) 是一种特殊的number类型值；任何和NaN运算的结果都为NaN;和自己也不相等；</li>
</ul>
</div>
<h2 id="原始数据类型"> 原始数据类型</h2>
<ol>
<li>
<p>原始数据类型的值无法更改；</p>
<div><pre><code><span>"use strict"</span>
<span>var</span> a <span>=</span> <span>'abc'</span><span>;</span>
a<span>[</span><span>1</span><span>]</span> <span>=</span> <span>'a'</span><span>;</span>
<span>alert</span><span>(</span>a<span>)</span> <span>// abc</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p>严格模式则会报语法错误；</p>
</blockquote>
</li>
<li>
<p>原始类型的比较；</p>
<ul>
<li>原始类型的比较是值的比较，只有值相等它们才相等；</li>
</ul>
<div><pre><code><span>var</span> n1 <span>=</span> <span>123</span><span>;</span>
<span>var</span> n2 <span>=</span> <span>Number</span><span>(</span><span>123</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>n1 <span>===</span> n2<span>)</span><span>;</span> <span>// true</span>

<span>var</span> s1 <span>=</span> <span>'abc'</span><span>;</span>
<span>var</span> s2 <span>=</span> <span>String</span><span>(</span><span>'ab c'</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>s1 <span>===</span> s2<span>)</span> <span>// false</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
</ol>
<h2 id="引用数据类型"> 引用数据类型</h2>
<blockquote>
<p>对象类型又叫引用类型，当给一个变量赋值为对象时，该变量保存的是该对象的内存中的地址；</p>
</blockquote>
<ol>
<li>
<p>引用数据类型的值可以更改；</p>
<div><pre><code><span>var</span> o <span>=</span> <span>{</span> x<span>:</span> <span>1</span> <span>}</span><span>;</span>
o<span>.</span>x <span>=</span> <span>2</span><span>;</span>
o<span>.</span>y <span>=</span> <span>3</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>o<span>)</span><span>;</span> <span>// { x: 2, y: 3 };</span>
<span>delete</span> o<span>.</span>x<span>;</span>
console<span>.</span><span>log</span><span>(</span>o<span>)</span><span>;</span> <span>// { y: 3 }</span>

<span>// ===</span>

<span>var</span> a <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>;</span>
a<span>[</span><span>1</span><span>]</span> <span>=</span> <span>4</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span> <span>// [1, 4, 3]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
<li>
<p>引用数据类型的比较；</p>
<ul>
<li>引用数据类型的比较不是值的比较，而是引用地址的比较，只有引用的内存地址是同一个对象时它们才相等；</li>
</ul>
<div><pre><code><span>var</span> o1 <span>=</span> <span>{</span> x<span>:</span> <span>1</span> <span>}</span><span>,</span> o2 <span>=</span> <span>{</span> x<span>:</span> <span>1</span> <span>}</span><span>;</span>
<span>var</span> a1 <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>,</span> a2 <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>]</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>o1 <span>===</span> o2<span>)</span><span>;</span> <span>// false;</span>
console<span>.</span><span>log</span><span>(</span>a1 <span>===</span> a2<span>)</span><span>;</span> <span>// false;</span>

<span>//====</span>

<span>var</span> o1 <span>=</span> <span>{</span> x<span>:</span> <span>1</span> <span>}</span><span>;</span>
<span>var</span> o2 <span>=</span> o1<span>;</span>
o2<span>.</span>y <span>=</span> <span>2</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>o1<span>.</span>y<span>)</span><span>;</span><span>// 2</span>
console<span>.</span><span>log</span><span>(</span>o1 <span>===</span> o2<span>)</span><span>;</span> <span>// true</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>变量的复制</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-20/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-20/</guid>
      <source url="https://wangyawei.top/rss.xml">变量的复制</source>
      <category>javascript</category>
      <pubDate>Wed, 19 May 2021 22:05:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>想复制某个变量的值，只要将它赋值给另外一个变量(或者是某个对象的属性)。复制原始类型和对象类型有所不同；</p>
</blockquote>
<h2 id="复制原始类型的值"> 复制原始类型的值</h2>
<blockquote>
<p>复制原始类型的变量的值时，会将值拷贝一份，和原来的值是互相独立的；</p>
</blockquote>
<ol>
<li>
<p>复制原始类型的值；</p>
<div><pre><code><span>var</span> num1 <span>=</span> <span>5</span><span>;</span>
<span>var</span> num2 <span>=</span> num1<span>;</span>
console<span>.</span><span>log</span><span>(</span>num2<span>)</span><span>;</span><span>// 5</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ol>
<p><img src="./assets/image-20210517235513076.png" alt="image-20210517235513076" /></p>
<h2 id="复制对象类型的值"> 复制对象类型的值</h2>
<blockquote>
<p>复制对象类型的变量的值时，会将储存在变量中的值拷贝一份，也就是它所指向对象在内存中的地址。复制操作结束后，它们俩指向了同一个对象；</p>
</blockquote>
<div><pre><code><span>var</span> o1 <span>=</span> <span>{</span>x<span>:</span> <span>1</span><span>}</span><span>;</span>
<span>var</span> o2 <span>=</span> o1<span>;</span>
console<span>.</span><span>log</span><span>(</span>o1 <span>===</span> o2<span>)</span><span>;</span><span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><img src="./assets/image-20210517235139583.png" alt="image-20210517235139583" /></p>
<blockquote>
<p>如果想复制对象的副本，则必须显示地复制对象的每个属性(如果对象是数组，就复制数组的每个元素)</p>
</blockquote>
<div><pre><code><span>var</span> o <span>=</span> <span>{</span> a<span>:</span> <span>1</span><span>,</span> b<span>:</span><span>2</span> <span>}</span><span>;</span>
<span>var</span> clone <span>=</span> <span>{</span><span>}</span><span>;</span>
<span>for</span> <span>(</span><span>let</span> p <span>in</span> o<span>)</span> <span>{</span>
  clone<span>[</span>p<span>]</span> <span>=</span> o<span>[</span>p<span>]</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span>clone<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><p>提示</p>
<p>实际的情况较为复杂，因为属性的值可能为：数组，对象，正则，函数，需要根据实际情况做处理；</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>类型转换</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-21/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-21/</guid>
      <source url="https://wangyawei.top/rss.xml">类型转换</source>
      <category>javascript</category>
      <pubDate>Wed, 19 May 2021 22:05:34 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="转字符串"> 转字符串</h2>
<blockquote>
<p>转字符串经常出现在 + 运算中，并且其中有一个操作数不是数值类型；</p>
</blockquote>
<div><pre><code><span>let</span> s <span>=</span> <span>4</span> <span>+</span> <span>'px'</span> <span>+</span> <span>5</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>s<span>)</span><span>;</span> <span>// 4px5</span>
s <span>=</span> <span>123e-2</span> <span>+</span> <span>'a'</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>s<span>)</span><span>;</span> <span>// 1.23a</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="转数值"> 转数值</h2>
<blockquote>
<p>经常出现在数学运算中，表示连接字符串的 + 运算符除外；</p>
</blockquote>
<div><pre><code><span>let</span> s <span>=</span> <span>'abc'</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>+</span>s<span>,</span> <span>-</span>s<span>)</span><span>;</span> <span>// NaN NaN</span>
s <span>=</span> <span>' 123 '</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>+</span>s<span>,</span> <span>-</span>s<span>)</span><span>;</span> <span>// 123 -123</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="转布尔"> 转布尔</h2>
<blockquote>
<p>经常出现在if语句、逻辑运算中</p>
</blockquote>
<div><pre><code><span>let</span> s <span>=</span> <span>'abc'</span><span>;</span>
<span>if</span> <span>(</span>s<span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>s<span>)</span><span>;</span> <span>// abc</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>!</span><span>!</span>s<span>)</span><span>;</span> <span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="相等性"> 相等性(==)</h2>
<blockquote>
<p><code>==</code>运算符会有类型转换， <code>===</code>运算符不会进行类型转换;</p>
</blockquote>
<div><pre><code><span>alert</span><span>(</span><span>null</span> <span>==</span> <span>undefined</span><span>)</span><span>;</span> <span>// 相等</span>
<span>alert</span><span>(</span><span>'0'</span> <span>==</span> <span>0</span><span>)</span><span>;</span> <span>// 在比较之前，字符串转换成数值；</span>
<span>alert</span><span>(</span><span>0</span> <span>==</span> <span>false</span><span>)</span><span>;</span> <span>// 在比较之前，布尔转换成数值；</span>
<span>alert</span><span>(</span><span>'0'</span> <span>==</span> <span>false</span><span>)</span><span>;</span> <span>// 在比较之前，字符串和布尔都转换成数值；</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>MDN摘录；</strong></p>
<p><img src="./assets/image-20210518233400047.png" alt="image-20210518233400047" /></p>
<p><strong>js权威指南摘录</strong></p>
<p><img src="./assets/image-20210518233502241.png" alt="image-20210518233502241" /></p>
<p><img src="./assets/image-20210518233544320.png" alt="image-20210518233544320" /></p>
<h2 id="显示类型转换"> 显示类型转换</h2>
<blockquote>
<p>显示类型转换，可以使代码变得清晰易读，推荐在实际编码使用。最简单的方法就是使用Boolean()、Number()、String()、Object()函数；</p>
</blockquote>
<div><pre><code><span>Number</span><span>(</span><span>'123'</span><span>)</span><span>;</span> <span>// 123</span>
<span>String</span><span>(</span><span>123</span><span>)</span><span>;</span> <span>// '123'</span>
<span>Boolean</span><span>(</span><span>[</span><span>]</span><span>)</span><span>;</span> <span>// true</span>
<span>Object</span><span>(</span><span>3</span><span>)</span> <span>// 等价 new Number(3)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="转字符串-2"> 转字符串；</h3>
<blockquote>
<p>还可以使用toString()方法，它的执行结果通常和String()方法一致、Number类型的toStrnig()方法还支持第二个参数指定要转换的进制；</p>
</blockquote>
<div><pre><code><span>(</span><span>null</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span> <span>// Error</span>
<span>(</span><span>undefined</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span> <span>// Error</span>
<span>(</span><span>123</span><span>)</span><span>.</span><span>toStrig</span><span>(</span><span>)</span><span>;</span> <span>// '123'</span>
<span>(</span><span>false</span><span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span> <span>// 'false'</span>

<span>let</span> n <span>=</span> <span>20</span><span>;</span>
<span>alert</span><span>(</span>n<span>.</span><span>toString</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span><span>// 转成二进制 ‘10100’</span>
<span>alert</span><span>(</span>n<span>.</span><span>toString</span><span>(</span><span>8</span><span>)</span><span>)</span><span>;</span> <span>// 转成八进制 ‘24’</span>
<span>alert</span><span>(</span>n<span>.</span><span>toString</span><span>(</span><span>16</span><span>)</span><span>)</span><span>;</span> <span>// 转成十六进制 ‘14’</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><p>提示</p>
<p>Number类型转换为字符串还有3个方法：toFixed()、toExponential()和toPrecision()。</p>
</div>
<h3 id="转数值-2"> 转数值</h3>
<blockquote>
<p>字符串类型转换为数值还有两个全局方法：parseInt()和parseFloat()。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>类型检测</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-22/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-22/</guid>
      <source url="https://wangyawei.top/rss.xml">类型检测</source>
      <category>javascript</category>
      <pubDate>Wed, 19 May 2021 22:05:34 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="typeof操作符"> <code>typeof</code>操作符</h2>
<blockquote>
<p>typeof:操作符可以检测变量的数据类型</p>
</blockquote>
<div><pre><code><span>let</span> a1<span>;</span>
console<span>.</span><span>log</span><span>(</span><span>typeof</span> a1<span>)</span><span>;</span> <span>// undefined</span>
<span>let</span> a2 <span>=</span> <span>true</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>typeof</span> a2<span>)</span><span>;</span> <span>// Boolean</span>
<span>let</span> a3 <span>=</span> <span>123</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>typeof</span> a3<span>)</span><span>;</span> <span>// number</span>
<span>let</span> a4 <span>=</span> <span>'abc'</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>typeof</span> a4<span>)</span><span>;</span> <span>// string</span>
<span>let</span> <span>a5</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span><span>}</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>typeof</span> a5<span>)</span><span>;</span> <span>// function</span>
<span>let</span> a6 <span>=</span> <span>{</span><span>}</span> <span>|</span> <span>[</span><span>]</span> <span>|</span> <span>null</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>typeof</span> a6<span>)</span><span>;</span> <span>// object</span>
<span>let</span> a7 <span>=</span> <span>Symbol</span><span>(</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>typeof</span> a7<span>)</span><span>;</span> <span>// symbol</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="typeof判断对象类型时的局限性"> typeof判断对象类型时的局限性</h3>
<div><pre><code><span>let</span> d <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
<span>let</span> a <span>=</span> <span>[</span><span>]</span><span>;</span>
<span>let</span> n <span>=</span> <span>null</span><span>;</span>
<span>let</span> r <span>=</span> <span><span>/</span><span>\d+</span><span>/</span></span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>typeof</span> d<span>)</span><span>;</span> <span>// object</span>
console<span>.</span><span>log</span><span>(</span><span>typeof</span> a<span>)</span><span>;</span> <span>// object</span>
console<span>.</span><span>log</span><span>(</span><span>typeof</span> n<span>)</span><span>;</span> <span>// object</span>
console<span>.</span><span>log</span><span>(</span><span>typeof</span> r<span>)</span><span>;</span> <span>// object</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="instanceof操作符"> <code>instanceof</code>操作符</h2>
<blockquote>
<p>判断变量是否是给定类的实例。</p>
</blockquote>
<div><pre><code><span>let</span> d <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
<span>let</span> a <span>=</span> <span>[</span><span>]</span><span>;</span>
<span>let</span> n <span>=</span> <span>null</span><span>;</span>
<span>let</span> r <span>=</span> <span><span>/</span><span>\d+</span><span>/</span></span><span>;</span>
console<span>.</span><span>log</span><span>(</span>d <span>instanceof</span> <span>Date</span><span>)</span><span>;</span> <span>// true</span>
console<span>.</span><span>log</span><span>(</span>a <span>instanceof</span> <span>Array</span><span>)</span><span>;</span> <span>// true</span>
console<span>.</span><span>log</span><span>(</span>n <span>instanceof</span> <span>Object</span><span>)</span><span>;</span> <span>// false</span>
console<span>.</span><span>log</span><span>(</span>r <span>instanceof</span> <span>RegExp</span><span>)</span><span>;</span> <span>// true</span>

<span>function</span> <span>Foo</span><span>(</span><span>)</span> <span>{</span><span>}</span><span>;</span>
<span>function</span> <span>Bar</span><span>(</span><span>)</span> <span>{</span><span>}</span><span>;</span>
<span>Bar</span><span>.</span>prototype <span>=</span> <span>new</span> <span>Foo</span><span>(</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>new</span> <span>Bar</span><span>(</span><span>)</span> <span>instanceof</span> <span>Bar</span><span>)</span><span>;</span> <span>// true</span>
console<span>.</span><span>log</span><span>(</span><span>new</span> <span>Bar</span><span>(</span><span>)</span> <span>instanceof</span> <span>Foo</span><span>)</span><span>;</span> <span>// true</span>

<span>let</span> a <span>=</span> <span>[</span><span>]</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>a <span>instanceof</span> <span>Array</span><span>)</span><span>;</span> <span>// true</span>
console<span>.</span><span>log</span><span>(</span>a <span>instanceof</span> <span>Object</span><span>)</span><span>;</span> <span>// true</span>

console<span>.</span><span>log</span><span>(</span><span>'123'</span> <span>instanceof</span> <span>String</span><span>)</span><span>;</span> <span>// false</span>
console<span>.</span><span>log</span><span>(</span><span>123</span> <span>instanceof</span> <span>Number</span><span>)</span><span>;</span> <span>// false</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="constructor"> <code>constructor</code></h2>
<blockquote>
<p>可以检测变量的构造函数</p>
</blockquote>
<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>(</span><span>{</span> x<span>:</span> <span>1</span> <span>}</span><span>)</span><span>.</span>constructor<span>.</span>name<span>)</span><span>;</span> <span>// Object</span>
console<span>.</span><span>log</span><span>(</span><span>(</span><span>[</span><span>]</span><span>)</span><span>.</span>constructor<span>.</span>name<span>)</span><span>;</span> <span>// Array</span>
console<span>.</span><span>log</span><span>(</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>.</span>constructor<span>.</span>name<span>)</span><span>;</span> <span>// Date</span>
console<span>.</span><span>log</span><span>(</span><span>(</span><span>''</span><span>)</span><span>.</span>constructor<span>.</span>name<span>)</span><span>;</span> <span>// String</span>
console<span>.</span><span>log</span><span>(</span><span>(</span><span>true</span><span>)</span><span>.</span>constructor<span>.</span>name<span>)</span><span>;</span> <span>// Boolean</span>
console<span>.</span><span>log</span><span>(</span><span>(</span><span>12</span><span>)</span><span>.</span>constructor<span>.</span>name<span>)</span><span>;</span> <span>// Number</span>
console<span>.</span><span>log</span><span>(</span><span>(</span><span>null</span><span>)</span><span>.</span>constructor<span>.</span>name<span>)</span><span>;</span> <span>// TypeError</span>
console<span>.</span><span>log</span><span>(</span><span>(</span><span>undefined</span><span>)</span><span>.</span>constructor<span>.</span>name<span>)</span><span>;</span> <span>// TypeError</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="失效情况"> 失效情况；</h3>
<ol>
<li>
<p>有原型时失效</p>
<div><pre><code><span>function</span> <span>Foo</span><span>(</span><span>)</span> <span>{</span><span>}</span><span>;</span>
<span>Foo</span><span>.</span>prototype <span>=</span> <span>{</span>
  	<span>methhod1</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span><span>}</span>
<span>}</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>new</span> <span>Foo</span><span>(</span><span>)</span><span>.</span>constructor<span>.</span>name<span>)</span><span>;</span> <span>// Object</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>多重继承时失效</p>
<div><pre><code><span>function</span> <span>a</span><span>(</span><span>)</span> <span>{</span><span>}</span><span>;</span>
<span>function</span> <span>b</span><span>(</span><span>)</span> <span>{</span><span>}</span><span>;</span>
b<span>.</span>prototype <span>=</span> <span>new</span> <span>a</span><span>(</span><span>)</span><span>;</span>
<span>let</span> f <span>=</span> <span>new</span> <span>b</span><span>(</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>f<span>.</span>constructor <span>===</span> b<span>)</span><span>;</span><span>// false</span>
console<span>.</span><span>log</span><span>(</span>f<span>.</span>constructor <span>===</span> a<span>)</span><span>;</span> <span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
</ol>
<h2 id="instanceof和constructor不可跨frame"> <code>instanceof</code>和<code>constructor</code>不可跨frame</h2>
<blockquote>
<p>需要在同个frame中才有效。</p>
</blockquote>
<div><pre><code><span>let</span> iframe <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>'iframe'</span><span>)</span><span>;</span>
document<span>.</span>body<span>.</span><span>apppendChild</span><span>(</span>iframe<span>)</span><span>;</span>
xArray <span>=</span> window<span>.</span>frames<span>[</span>window<span>.</span>frames<span>.</span>length <span>-</span> <span>1</span><span>]</span><span>.</span>Array<span>;</span>
<span>let</span> arr <span>=</span> <span>new</span> <span>xArray</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>arr <span>instanceof</span> <span>Array</span><span>)</span><span>;</span> <span>// false</span>
console<span>.</span><span>log</span><span>(</span>arr<span>.</span>constructor <span>===</span> Array<span>)</span><span>;</span> <span>// false</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="动态类型检测"> 动态类型检测</h2>
<blockquote>
<p>只检测特定的属性，如果存在，则认为是该类型；</p>
</blockquote>
<div><pre><code><span>function</span> <span>isArray</span> <span>(</span><span>object</span><span>)</span> <span>{</span>
  <span>return</span> object <span>!=</span> <span>null</span> <span>&amp;&amp;</span> type object <span>===</span> <span>'object'</span> <span>&amp;&amp;</span> <span>'splice'</span> <span>in</span> object <span>&amp;&amp;</span> <span>'join'</span> <span>in</span> object<span>;</span>
<span>}</span>
<span>function</span> <span>isArray</span> <span>(</span><span>arr</span><span>)</span> <span>{</span>
  <span>return</span> <span>!</span><span>!</span>arr <span>&amp;&amp;</span> arr<span>.</span>constructor <span>==</span> Array<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="object-prototype-tostring-call-obj"> <code>Object.prototype.toString.call(obj)</code></h2>
<blockquote>
<p>可以检测对象的内部属性[[Class]]</p>
</blockquote>
<div><pre><code><span>function</span> <span>getType</span><span>(</span><span>o</span><span>)</span> <span>{</span>
  <span>return</span> <span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span>o<span>)</span><span>;</span>
<span>}</span>
<span>let</span> d <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
<span>let</span> a <span>=</span> <span>[</span><span>]</span><span>;</span>
<span>let</span> r <span>=</span> <span><span>/</span><span>\d+</span><span>/</span></span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>getType</span><span>(</span>d<span>)</span><span>)</span><span>;</span> <span>// [object Date]</span>
console<span>.</span><span>log</span><span>(</span><span>getType</span><span>(</span>a<span>)</span><span>)</span><span>;</span> <span>// [object Array]</span>
console<span>.</span><span>log</span><span>(</span><span>getType</span><span>(</span>c<span>)</span><span>)</span><span>;</span> <span>// [object RegExp]</span>

<span>// 获取 [object Date] 后面的值 Date</span>
<span>function</span> <span>getType</span><span>(</span><span>o</span><span>)</span> <span>{</span>
  <span>return</span> <span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span>o<span>)</span><span>.</span><span>slice</span><span>(</span><span>8</span><span>,</span> <span>-</span><span>1</span><span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>Foo</span><span>(</span><span>)</span> <span>{</span><span>}</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>getType</span><span>(</span><span>new</span> <span>Foo</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span> <span>// Object</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="总结"> 总结</h2>
<p><img src="./assets/image-20210519230914488.png" alt="image-20210519230914488" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>模板字符串</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-23/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-23/</guid>
      <source url="https://wangyawei.top/rss.xml">模板字符串</source>
      <category>javascript</category>
      <pubDate>Tue, 08 Jun 2021 22:05:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>模板字符串是允许嵌入表达式的字符串字面量。可以使用多行字符串和字符串插值功能；</p>
</blockquote>
<ol>
<li>
<p>支持所有的合法表达式，包括函数调用；</p>
<div><pre><code><span>let</span> <span>getName</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>'john'</span><span>;</span>
<span>}</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>my name is </span><span><span>${</span><span>getName</span><span>(</span><span>)</span><span>}</span></span><span>`</span></span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>支持嵌套；</p>
<div><pre><code><span>const</span> classes <span>=</span> <span><span>`</span><span>header </span><span><span>${</span><span>isLargeScreen</span><span>(</span><span>)</span> <span>?</span> <span>''</span> <span>:</span> <span><span>`</span><span>icon-</span><span><span>${</span><span>(</span>isCollapsed <span>?</span> <span>'expander'</span> <span>:</span> <span>'collapser'</span><span>)</span><span>}</span></span><span>`</span></span><span>}</span></span><span>`</span></span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>添加模板tag</p>
<ul>
<li>最前面可以跟一个函数，这个函数叫模板字符串的tag。</li>
<li>literals：模板字面量的数组。subtitutions：插值表达式的值</li>
</ul>
<div><pre><code><span>function</span> <span>tag</span> <span>(</span><span>literals<span>,</span> <span>...</span>subtitutions</span><span>)</span> <span>{</span>
 <span>// return a string 可以返回任意值，不一定是字符串</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>最前面可以跟一个函数，这个函数叫模板字符串的tag，在解析字符串时会调用这个函数。</li>
</ul>
<div><pre><code><span>let</span> person <span>=</span> <span>'Mike'</span><span>;</span>
<span>let</span> age <span>=</span> <span>28</span><span>;</span>
<span>function</span> <span>myTag</span><span>(</span><span>strings<span>,</span> personExp<span>,</span> ageExp</span><span>)</span> <span>{</span>
  <span>let</span> str0 <span>=</span> strings<span>[</span><span>0</span><span>]</span><span>;</span> <span>// 'that'</span>
  <span>let</span> str1 <span>=</span> strings<span>[</span><span>1</span><span>]</span><span>;</span> <span>// ' is a '</span>
  <span>// 最后还有一项，不过它的值是空字符串 ’‘</span>
  <span>// let str2 = string[2];</span>
  <span>let</span> ageStr<span>;</span>
  <span>if</span> <span>(</span>ageExp <span>></span> <span>99</span><span>)</span> <span>{</span>
      ageStr <span>=</span> <span>'centenarian'</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    ageStr <span>=</span> <span>'youngster'</span><span>;</span>
  <span>}</span>
  <span>return</span> str0 <span>+</span> personExp <span>+</span> str1 <span>+</span> ageStr<span>;</span>
<span>}</span>
<span>let</span> output <span>=</span> myTag<span><span>`</span><span>that </span><span><span>${</span>person<span>}</span></span><span> is a </span><span><span>${</span>age<span>}</span></span><span>`</span></span><span>;</span>
console<span>.</span><span>log</span><span>(</span>output<span>)</span><span>;</span> <span>// that Mike is a youngster</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div></li>
<li>
<p>原始字符串值：raw value</p>
<blockquote>
<p>tag函数的第一个参数，还有一个raw属性，它的值是模板字符串被转义之前的值，也可以使用内置的String.raw方法</p>
</blockquote>
<div><pre><code><span>let</span> message1 <span>=</span> <span><span>`</span><span>Multiline\nstring</span><span>`</span></span><span>;</span>
<span>let</span> message2 <span>=</span> String<span>.</span>raw<span><span>`</span><span>Multiline\nstring</span><span>`</span></span><span>;</span>
console<span>.</span><span>log</span><span>(</span>message1<span>)</span><span>;</span> <span>// "Multiline</span>
								<span>// string"</span>
console<span>.</span><span>log</span><span>(</span>message2<span>)</span><span>;</span> <span>// Multiline\\nstring</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>Symbol</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-24/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-24/</guid>
      <source url="https://wangyawei.top/rss.xml">Symbol</source>
      <category>javascript</category>
      <pubDate>Tue, 08 Jun 2021 22:05:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>想给他人创建的对象添加属性，不管该属性取什么名字，理论上都存在冲突的可能性。而使用Symbol作为对象的属性名就没有这个顾虑。因为它的值是唯一的。这也意味着给对象添加私有属性称为了可能。</p>
</blockquote>
<p><strong>例1：</strong></p>
<div><pre><code><span>let</span> name <span>=</span> <span>Symbol</span><span>(</span><span>)</span><span>;</span>
<span>let</span> person <span>=</span> <span>{</span><span>}</span><span>;</span>
person<span>[</span>name<span>]</span> <span>=</span> <span>'john'</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>person<span>[</span>name<span>]</span><span>)</span><span>;</span> <span>// 'john'</span>
console<span>.</span><span>log</span><span>(</span>name<span>)</span><span>;</span> <span>// Symbol()</span>

<span>let</span> name <span>=</span> <span>Symbol</span><span>(</span><span>'my name'</span><span>)</span><span>;</span>
<span>let</span> person <span>=</span> <span>{</span><span>}</span><span>;</span>
person<span>[</span>name<span>]</span> <span>=</span> <span>'john'</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>person<span>[</span>name<span>]</span><span>)</span><span>;</span><span>// 'john';</span>
console<span>.</span><span>log</span><span>(</span>name<span>)</span><span>;</span> <span>// Symbol(my name)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="共享symbol"> 共享Symbol</h2>
<ol>
<li>
<p>有时需要在不同的地方使用同一个symbol，用来当作不同对象的唯一标识符，可以使用Symbol.for()方法完成这个功能；</p>
<div><pre><code><span>let</span> uid <span>=</span> Symbol<span>.</span><span>for</span><span>(</span><span>'uid'</span><span>)</span><span>;</span>
<span>let</span> object <span>=</span> <span>{</span>
  <span>[</span>uid<span>]</span><span>:</span> <span>"12345"</span>
<span>}</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>object<span>[</span>uid<span>]</span><span>)</span><span>;</span><span>// "12345"</span>
console<span>.</span><span>log</span><span>(</span>uid<span>)</span><span>;</span> <span>// Symbol(uid);</span>
<span>let</span> uid2 <span>=</span> Symbol<span>.</span><span>for</span><span>(</span><span>'uid'</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>uid <span>===</span> uid2<span>)</span><span>;</span>  <span>true</span>
console<span>.</span><span>log</span><span>(</span>object<span>[</span>uid2<span>]</span><span>)</span><span>;</span> <span>// "12345"</span>
console<span>.</span><span>log</span><span>(</span>uid2<span>)</span><span>;</span> <span>// Symbol(uid);</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
<li>
<p>可以使用Symbol.keyFor()方法查找和某个Symbol关联的key值；</p>
<div><pre><code><span>let</span> uid <span>=</span> Symbol<span>.</span><span>for</span><span>(</span><span>"uid"</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>Symbol<span>.</span><span>keyFor</span><span>(</span>uid<span>)</span><span>)</span><span>;</span> <span>// "uid"</span>

<span>let</span> uid2 <span>=</span> Symbol<span>.</span><span>for</span><span>(</span><span>"uid"</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>Symbol<span>.</span><span>keyFor</span><span>(</span>uid2<span>)</span><span>)</span><span>;</span> <span>// "uid"</span>

<span>let</span> uid3 <span>=</span> <span>Symbol</span><span>(</span><span>"uid"</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>Symbol<span>.</span><span>keyFor</span><span>(</span>uid3<span>)</span><span>)</span><span>;</span> <span>// undefined</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
<li>
<p>symbol不能转换成字符串或者数值，转换成布尔时是true；</p>
<div><pre><code><span>let</span> uid <span>=</span> Symbol<span>.</span><span>for</span><span>(</span><span>"uid"</span><span>)</span><span>;</span>
<span>// 调用 String(uid),该方法会调用uid.toString()方法</span>
console<span>.</span><span>log</span><span>(</span>uid<span>)</span><span>;</span> <span>// Symbol(uid)</span>
<span>// TypeError: Cannot convert a Symbol value to a string</span>
console<span>.</span><span>log</span><span>(</span>uid <span>+</span> <span>''</span><span>)</span><span>;</span>
<span>// TypeError: Cannot convert a Symbol value to a number</span>
console<span>.</span><span>log</span><span>(</span>uid <span>/</span> <span>1</span><span>)</span><span>;</span>
<span>// 可以转换成布尔；</span>
console<span>.</span><span>log</span><span>(</span><span>!</span><span>!</span>uid<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
</ol>
<h2 id="查找对象的symbol属性"> 查找对象的Symbol属性</h2>
<blockquote>
<p>可以使用Object.getOwnPropertySymbols()方法查找对象的symbol属性；</p>
</blockquote>
<div><pre><code><span>let</span> id <span>=</span> Symbol<span>.</span><span>for</span><span>(</span><span>'id'</span><span>)</span><span>;</span>
<span>let</span> object <span>=</span> <span>{</span>
  <span>[</span>id<span>]</span><span>:</span> <span>"123"</span>
<span>}</span><span>;</span>
<span>let</span> symbols <span>=</span> object<span>.</span><span>getOwnPropertySymbols</span><span>(</span>object<span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>symbols<span>.</span>length<span>)</span><span>;</span> <span>// 1</span>
console<span>.</span><span>log</span><span>(</span>symbols<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span> <span>// Symbol(id)</span>
consloe<span>.</span><span>log</span><span>(</span>object<span>[</span>symbols<span>[</span><span>0</span><span>]</span><span>]</span><span>)</span><span>;</span> <span>// "123"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="es6的内置symbol"> es6的内置symbol</h2>
<blockquote>
<p>es6内置了11个symbol。叫well-known-symbol,它们都是Symbol函数的属性，指向语言内部使用的方法或属性。通过它们可以更改语言的原生行为；</p>
</blockquote>
<p><img src="./assets/image-20210531223702690.png" alt="image-20210531223702690" /></p>
<ol>
<li>
<p>Symbol.hasInstance</p>
<blockquote>
<p>每个函数都有Symbol.hasInstance方法，用来判断给定的对象是否是该函数的实例，它是函数原型上面的方法。</p>
</blockquote>
<div><pre><code><span>// instanceof 不能判段简单数据类型</span>
<span>let</span> a <span>=</span> <span>12</span><span>;</span> 
console<span>.</span><span>log</span><span>(</span>a <span>instanceof</span> <span>Number</span><span>)</span><span>;</span> <span>// false</span>
console<span>.</span><span>log</span><span>(</span>Number<span>[</span>Symbol<span>.</span>hasIntance<span>]</span><span>(</span>a<span>)</span><span>)</span><span>;</span> <span>// false</span>

<span>// 添加一个属性就可以了</span>
Object<span>.</span><span>defineProperty</span><span>(</span>Number<span>,</span> Symbol<span>.</span>hasInstance<span>,</span> <span>{</span>
  <span>value</span><span>:</span> <span>function</span><span>(</span><span>n</span><span>)</span> <span>{</span>
    <span>return</span> <span>typeof</span> n <span>===</span> <span>'number'</span><span>;</span>
  <span>}</span>
<span>}</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>a <span>instanceof</span> <span>Number</span><span>)</span><span>;</span><span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
<li>
<p>Symbol.isConcatSpereadble;</p>
<blockquote>
<p>concat()方法用于合并两个或多个数组，默认数组元素是展开的，他的值是undefined。如果不想展开，则将它的值设置为false。</p>
</blockquote>
<div><pre><code><span>let</span> a <span>=</span> <span>[</span><span>'a'</span><span>,</span> <span>'b'</span><span>]</span><span>;</span>
<span>let</span> n <span>=</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>]</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>a<span>.</span><span>concat</span><span>(</span>n<span>,</span> <span>3</span><span>)</span><span>)</span><span>;</span> <span>// ['a', 'b', 1, 2, 3]</span>
console<span>.</span><span>log</span><span>(</span>a<span>[</span>Symbol<span>.</span>inConcatSpreadble<span>]</span><span>)</span><span>;</span> <span>// undefined</span>
n<span>[</span>Symbol<span>.</span>isConcatSpreadabel<span>]</span> <span>=</span> <span>false</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>a<span>.</span><span>concat</span><span>(</span>n<span>,</span> <span>3</span><span>)</span><span>)</span><span>;</span> <span>// ['a', 'b', [1, 2], 3]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>什么是作用域</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-25/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-25/</guid>
      <source url="https://wangyawei.top/rss.xml">什么是作用域</source>
      <category>javascript</category>
      <pubDate>Tue, 08 Jun 2021 22:05:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>简单来说作用域就是根据名称查找变量的一套规则，它决定了变量的可见范围和生命周期，正确使用作用域可以使代码更清晰、易懂。作用域可以减少命名冲突，而且是垃圾回收的基本单元。</p>
</blockquote>
<h2 id="作用域分类"> 作用域分类</h2>
<ol>
<li>静态作用域**(词法作用域)😗* static scope；
<ul>
<li>如果函数中的变量，没有在该函数中定义，就去定义该函数的地方查找；</li>
<li>**静态作用域，也叫此法作用域，代码写完后，变量的作用域就已确定不变；**是由你写代码时将变量和块作用域写在哪里决定的。</li>
<li>js使用静态作用域；</li>
</ul>
</li>
<li>动态作用域: dynamic scope；
<ul>
<li>如果函数中的变量，没有在该函数中定义，就去调用该函数的地方查找；</li>
<li><strong>动态作用域，代码写完后，变量的作用域还无法确定，它和调用它所在的函数有关；</strong></li>
</ul>
</li>
</ol>
<h2 id="认识作用域"> 认识作用域</h2>
<div><pre><code><span>// 全局作用域</span>
<span>function</span> <span>foo</span><span>(</span><span>a</span><span>)</span> <span>{</span>
  <span>// foo 的作用域</span>
  <span>var</span> b <span>=</span> a <span>*</span> <span>2</span><span>;</span>
  <span>function</span> <span>bar</span><span>(</span><span>c</span><span>)</span> <span>{</span>
    <span>// bar 的作用域</span>
    console<span>.</span><span>log</span><span>(</span>a<span>,</span> b<span>,</span> c<span>)</span><span>;</span>
  <span>}</span>
  <span>// 在 foo的作用中调用</span>
  <span>bar</span><span>(</span>b <span>*</span> <span>3</span><span>)</span><span>;</span>
<span>}</span>
<span>foo</span><span>(</span><span>2</span><span>)</span><span>;</span> <span>// 2, 4, 12</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>以上代码中有三层作用域：</p>
<ol>
<li>全局作用域：即<code>foo</code>所在的作用域;</li>
<li>函数作用域：即<code>foo</code>函数所包含的作用域，也就是<code>bar</code>所在作用域；</li>
<li>函数作用域：即<code>bar</code>函数所包含的作用域，也就是 <code>console.log(a, b, c)</code>代码执行的地方；</li>
</ol>
<h2 id="全局作用域"> 全局作用域</h2>
<blockquote>
<p>在 JavaScript 中有一种特殊的对象称为 全局对象。这个对象在Node.js 对应的是 global对象，在浏览器中对应的是 window 对象。由于全局对象的所有属性在任何地方都是可见的，所以这个对象又称为 <strong>全局作用域</strong>。全局作用域中的变量不论在什么函数中都可以被直接引用，而不必通过全局对象。</p>
</blockquote>
<p>满足以下条件的变量属于全局作用域：</p>
<ul>
<li>在最外层定义的变量；</li>
<li>全局对象的属性；</li>
<li>任何地方隐式定义的变量（未定义直接赋值的变量）  。</li>
</ul>
<div><p>注意</p>
<p>需要格外注意的是第三点，在任何地方隐式定义的变量都会定义在全局作用域中，即不通过 var 声明直接赋值的变量。这一点经常被人遗忘，而模块化编程的一个重要原则就是避免使用全局变量，所以我们在任何地方都不应该隐式定义变量。</p>
</div>
<h2 id="函数作用域"> 函数作用域</h2>
<blockquote>
<p>JavaScript 的作用域是通过函数来定义的，在一个函数中定义的变量只对这个函数内部可见，我们称为函数作用域。</p>
<p>使用==var==声明的变量在声明它的函数体以及该函数体中的嵌套函数体内都是可以访问的，在函数体外不可访问。</p>
</blockquote>
<p><strong>例1：</strong></p>
<div><pre><code><span>var</span> x <span>=</span> <span>5</span><span>;</span>
<span>function</span> <span>f</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> y <span>=</span> <span>10</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>x<span>,</span> y<span>)</span><span>;</span> <span>// 5 10</span>
  <span>function</span> <span>f_1</span><span>(</span><span>)</span> <span>{</span>
    <span>var</span> z <span>=</span> <span>15</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>x<span>,</span> y<span>,</span> z<span>)</span><span>;</span> <span>// 5 10 15</span>
  <span>}</span>
   <span>f_1</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
<span>f</span><span>(</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>x<span>,</span> y<span>,</span> z<span>)</span> <span>// 报错 y is not defined</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>
<p>以上代码说明，JavaScript 的函数定义是可以嵌套的，每一层是一个作用域，变量搜索顺序是从内到外。在函数体外无法访问函数体内的变量，变量只对这个函数内部可见。</p>
</blockquote>
<p><strong>例2:</strong></p>
<div><pre><code><span>if</span> <span>(</span><span>true</span><span>)</span> <span>{</span>
	<span>var</span> somevar <span>=</span> <span>'value'</span><span>;</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span>somevar<span>)</span><span>;</span> <span>// 输出 value</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p>以上代码输出value，这是因为 JavaScript 的作用域完全是由函数来决定的， if、 for 语句中的花括号不是独立的作用域(let、const除外)。</p>
</blockquote>
<p><strong>例3</strong></p>
<div><pre><code><span>var</span> v1 <span>=</span> <span>'v1'</span>
<span>var</span> <span>f1</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>v1<span>)</span> <span>// 输出 v1</span>
<span>}</span>
<span>f1</span><span>(</span><span>)</span>
<span>var</span> <span>f2</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> v1 <span>=</span> <span>'local'</span>
  console<span>.</span><span>log</span><span>(</span>v1<span>)</span> <span>// 输出 local</span>
<span>}</span>
<span>f2</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>在函数中引用一个变量时， JavaScript 会先搜索当前函数作用域，或者称为“局部作用域”，如果没有找到则搜索其上层作用域，一直到全局作用域。</p>
</blockquote>
<p><strong>例4</strong></p>
<div><pre><code><span>var</span> <span>f</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> scope <span>=</span> <span>'f0'</span>
  <span>;</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>var</span> scope <span>=</span> <span>'f1'</span>
    <span>;</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span>scope<span>)</span> <span>// 输出 f1</span>
    <span>}</span><span>)</span><span>(</span><span>)</span>
  <span>}</span><span>)</span><span>(</span><span>)</span>
<span>}</span>
<span>f</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>我们在最内层函数引用了 scope 变量，通过作用域搜索，找到了其父作用域中定义的 scope 变量。</p>
</blockquote>
<p><strong>例5</strong></p>
<div><pre><code><span>var</span> scope <span>=</span> <span>'top'</span>
<span>var</span> <span>f1</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>scope<span>)</span>
<span>}</span>
<span>f1</span><span>(</span><span>)</span> <span>// 输出 top</span>
<span>var</span> <span>f2</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> scope <span>=</span> <span>'f2'</span>
  <span>f1</span><span>(</span><span>)</span>
<span>}</span>
<span>f2</span><span>(</span><span>)</span> <span>// 输出 top</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>通过 f2 调用的 f1 在查找 scope 定义时，找到的是父作用域中定义的 scope 变量，而不是 f2 中定义的 scope 变量。这说明了作用域的嵌套关系不是在调用时确定的，而是在定义时确定的。</p>
</blockquote>
<div><p>注意</p>
<p>函数作用域的嵌套关系是定义时决定的，而不是调用时决定的，也就是说， JavaScript 的作用域是静态作用域，又叫词法作用域，这是因为作用域的嵌套关系可以在语法分析时确定，而不必等到运行时确定。</p>
</div>
<h2 id="作用域嵌套"> 作用域嵌套</h2>
<blockquote>
<p>当一个块或者函数嵌套在另一个块或函数中时，就发生了作用域嵌套。因此，在当前作用域中无法找到某个变量时，引擎就会在外层作用域中继续查找，知道找到该变量或抵达最外层的作用域（也就是全局作用域）为止；</p>
</blockquote>
<p><strong>例：</strong></p>
<div><pre><code><span>function</span> <span>foo</span><span>(</span><span>a</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>a <span>+</span> b<span>)</span><span>;</span> <span>// 4</span>
<span>}</span>
<span>var</span> b <span>=</span> <span>2</span><span>;</span>
<span>foo</span><span>(</span><span>2</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>
<p>遍历嵌套作用域链的规则很简单，引擎首先从当前的执行作用域(foo函数体内)开始查找变量 b，如果找不到，就向上一级继续查找，当抵达最外层的全局作用域(全局作用域)时，发现有变量 b 。查找过程停止。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>声明提升</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-26/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-26/</guid>
      <source url="https://wangyawei.top/rss.xml">声明提升</source>
      <category>javascript</category>
      <pubDate>Tue, 08 Jun 2021 22:05:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>简单来说就是，在var声明的变量之前使用这个变量不会导致报错，而是会打印undefined</p>
</blockquote>
<h2 id="声明提前"> 声明提前；</h2>
<blockquote>
<p>函数内所有使用var声明的变量在函数体内可见。意味着变量在声明之前已经可用，这个特性就叫<strong>声明提前</strong>，即函数中的所有变量及函数声明都会提升至函数体的顶部。</p>
</blockquote>
<h3 id="例-变量声明提前"> 例：变量声明提前；</h3>
<div><pre><code><span>var</span> x <span>=</span> <span>5</span><span>;</span>
<span>function</span> <span>f</span><span>(</span><span>)</span> <span>{</span>
  <span>// undefined 声明提前，但赋值不会</span>
  console<span>.</span><span>log</span><span>(</span>x<span>)</span><span>;</span>
  <span>var</span> x <span>=</span> <span>10</span><span>;</span>
<span>}</span>

<span>// 实际执行情况；</span>
<span>var</span> x <span>=</span> <span>5</span><span>;</span>
<span>function</span> <span>f</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> x<span>;</span>
  console<span>.</span><span>log</span><span>(</span>x<span>)</span><span>;</span>
  x <span>=</span> <span>10</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="例-函数声明提前"> 例：函数声明提前；</h3>
<div><pre><code><span>function</span> <span>f</span><span>(</span><span>)</span> <span>{</span>
  <span>// 可以调用成功</span>
  <span>x</span><span>(</span><span>)</span><span>;</span>
  <span>function</span> <span>x</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
<span>f</span><span>(</span><span>)</span><span>;</span>

<span>// 注意；函数表达式不会提前</span>
<span>function</span> <span>f</span><span>(</span><span>)</span> <span>{</span>
  <span>// 报错</span>
  <span>x</span><span>(</span><span>)</span><span>;</span>
  <span>var</span> <span>x</span> <span>=</span> <span>function</span> <span>x</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
<span>f</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="优先级"> 优先级；</h2>
<blockquote>
<p>函数声明提前高于变量声明提前；</p>
</blockquote>
<div><pre><code><span>var</span> double <span>=</span> <span>22</span><span>;</span>
<span>function</span> <span>double</span><span>(</span><span>num</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>num <span>*</span> <span>2</span><span>)</span><span>;</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>typeof</span> double<span>)</span><span>;</span> <span>// 'number'</span>

<span>// 实际</span>
<span>var</span> double<span>;</span>
<span>function</span> <span>double</span><span>(</span><span>num</span><span>)</span> <span>{</span>
  <span>return</span> <span>(</span>num <span>*</span> <span>2</span><span>)</span><span>;</span>
<span>}</span>
double <span>=</span> <span>22</span>
console<span>.</span><span>log</span><span>(</span><span>typeof</span> double<span>)</span><span>;</span> <span>// 'number'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>变量声明</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-27/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-27/</guid>
      <source url="https://wangyawei.top/rss.xml">变量声明</source>
      <category>javascript</category>
      <pubDate>Tue, 08 Jun 2021 22:05:34 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="const声明"> <code>const</code>声明</h2>
<blockquote>
<p>使用const声明的原始类型是常量，之后不能更改，不然会报类型错误。使用const声明的对象类型的变量，变量本身无法赋值为其他类型，但是它的属性可以修改。</p>
</blockquote>
<div><pre><code><span>const</span> x <span>=</span> <span>1</span><span>;</span>
x <span>=</span> <span>2</span><span>;</span>
<span>// Uncaught TypeError: Assignment to constant variable.</span>

<span>// 对象的属性的值可以正常修改</span>
<span>const</span> x <span>=</span> <span>{</span><span>}</span><span>;</span>
x<span>.</span>age <span>=</span> <span>23</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="let声明"> <code>let</code>声明</h2>
<blockquote>
<p>和const正好相反，使用let声明的变量可以进行修改；</p>
</blockquote>
<div><pre><code><span>let</span> x <span>=</span> <span>1</span><span>;</span>
x <span>=</span> <span>2</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>x<span>)</span><span>;</span> <span>// 2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="禁止重复声明"> 禁止重复声明；</h2>
<blockquote>
<p>如果变量在语句块中已经有定义，则无法再使用let或者const进行声明，会报语法错误；</p>
</blockquote>
<div><pre><code><span>var</span> x <span>=</span> <span>1</span><span>;</span>
<span>let</span> x <span>=</span> <span>2</span><span>;</span>
<span>// Uncaught SyntaxError: Identifier 'x' has already been declared</span>

<span>// 把let放在{}中就可以了</span>
<span>var</span> x <span>=</span> <span>1</span><span>;</span>
<span>if</span> <span>(</span>x<span>)</span> <span>{</span>
   <span>let</span> x <span>=</span> <span>2</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>作用域链</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-28/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-28/</guid>
      <source url="https://wangyawei.top/rss.xml">作用域链</source>
      <category>javascript</category>
      <pubDate>Tue, 08 Jun 2021 22:05:34 GMT</pubDate>
    </item>
    <item>
      <title>作用域链延长</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-29/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-29/</guid>
      <source url="https://wangyawei.top/rss.xml">作用域链延长</source>
      <category>javascript</category>
      <pubDate>Tue, 08 Jun 2021 22:05:34 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="try-catch"> <code>try-catch</code></h2>
<h2 id="with"> <code>with</code></h2>
<blockquote>
<p>with可将某个对象添加到作用域链的顶端，然后执行with语句块中的代码，执行完后会把作用域链回复到之前的状态。</p>
</blockquote>
<div><pre><code><span>function</span> <span>f</span><span>(</span><span>foo<span>,</span> x<span>,</span> y</span><span>)</span> <span>{</span>
  <span>with</span> <span>(</span>foo<span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>x<span>,</span> y<span>)</span><span>;</span><span>// 1, 3</span>
  <span>}</span>
  console<span>.</span><span>log</span><span>(</span>x<span>,</span> y<span>)</span><span>;</span> <span>// 2, 3</span>
<span>}</span>
<span>f</span><span>(</span><span>{</span>x<span>:</span> <span>1</span><span>}</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>原型</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-30/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-30/</guid>
      <source url="https://wangyawei.top/rss.xml">原型</source>
      <category>javascript</category>
      <pubDate>Tue, 08 Jun 2021 22:05:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote></blockquote>
<h2 id="原型和原型链"> 原型和原型链</h2>
<h3 id="原型prototype"> 原型<code>prototype</code></h3>
<h4 id="获取对象的原型属性object-getprototypeof-someobj"> 获取对象的原型属性<code>Object.getPrototypeOf(someObj)</code></h4>
<h4 id="对象的原型属性-proto"> 对象的原型属性<code>__proto__</code></h4>
<h4 id="设置对象的原型属性object-setprototypeof-obj-prototype"> 设置对象的原型属性<code>Object.setPrototypeOf(obj, prototype)</code></h4>
<h4 id="检测是否为某个对象的原型someobj-isprototypeof-anotherobj"> 检测是否为某个对象的原型<code>someObj.isPrototypeOf(anotherObj)</code></h4>
<blockquote>
<p>对象中的super关键字指向该对象的原型</p>
</blockquote>
<h3 id="原型链"> 原型链</h3>
<h2 id="原型对操作对象属性的影响"> 原型对操作对象属性的影响</h2>
<p><img src="./assets/image-20210602221416455.png" alt="image-20210602221416455" /></p>
<h2 id="注意事项"> 注意事项</h2>
<ol>
<li>查询属性会遍历原型链，有一定的性能问题。要注意代码中的原型链的长度，并在必要时将其分解，以避免潜在的性能问题；</li>
<li>原型上的属性被所有实例共享，如果属性值是对象类型，则某个实例更改后会影响其他实例，这往往不是实际所期望的效果；</li>
<li>不要想着去扩展Object.prototype或其他内置原型，影响面太大，出错的可能性非常高；</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>深拷贝与浅拷贝</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-31/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-31/</guid>
      <source url="https://wangyawei.top/rss.xml">深拷贝与浅拷贝</source>
      <category>javascript</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
    </item>
    <item>
      <title>this对象</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-32/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-32/</guid>
      <source url="https://wangyawei.top/rss.xml">this对象</source>
      <category>javascript</category>
      <pubDate>Tue, 08 Jun 2021 22:05:12 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>不管是严格模式还是非严格模式，全局环境中的this指向全局对象；</p>
</blockquote>
<div><pre><code><span>'use strict'</span>
console<span>.</span><span>log</span><span>(</span><span>this</span> <span>===</span> window<span>)</span><span>;</span> <span>// true</span>

<span>this</span><span>.</span>abc <span>=</span> <span>'abc'</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>window<span>.</span>abc<span>)</span> <span>// 'abc'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="函数中的this对象"> 函数中的this对象</h2>
<blockquote>
<p>函数中的this对象，取决于函数是如何被调用的；</p>
</blockquote>
<h3 id="简单调用"> 简单调用；</h3>
<blockquote>
<p>普通函数的中的this是``window<code>；在严格模式下是</code>undefined`;</p>
</blockquote>
<div><pre><code><span>function</span> <span>f</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>this</span><span>)</span><span>;</span> <span>// Window</span>
<span>}</span>
<span>f</span><span>(</span><span>)</span><span>;</span>

<span>// ===</span>

<span>function</span> <span>f</span><span>(</span><span>)</span> <span>{</span>
  <span>'use strict'</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span><span>this</span><span>)</span><span>;</span> <span>// undefined</span>
<span>}</span>
<span>f</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="对象方法调用"> 对象方法调用；</h3>
<div><pre><code><span>let</span> obj <span>=</span> <span>{</span>
  <span>f</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>this</span><span>)</span><span>;</span><span>// obj</span>
  <span>}</span>
<span>}</span><span>;</span>
obj<span>.</span><span>f</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="call和apply调用"> call和apply调用；</h3>
<h3 id="构造函数调用"> 构造函数调用；</h3>
<blockquote>
<p>构造函数中的this指向调用的实例对象；</p>
</blockquote>
<div><pre><code><span>function</span> <span>C</span><span>(</span><span>)</span> <span>{</span>
  <span>this</span><span>.</span>a <span>=</span> <span>'a'</span><span>;</span>
<span>}</span>
<span>let</span> o <span>=</span> <span>new</span> <span>C</span><span>(</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>o<span>.</span>a<span>)</span><span>;</span> <span>// 'a'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>尾调用优化</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-33/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-33/</guid>
      <source url="https://wangyawei.top/rss.xml">尾调用优化</source>
      <category>javascript</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
    </item>
    <item>
      <title>立即执行函数(IIFE)</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-34/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-34/</guid>
      <source url="https://wangyawei.top/rss.xml">立即执行函数(IIFE)</source>
      <category>javascript</category>
      <pubDate>Tue, 08 Jun 2021 22:10:45 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>立即执行函数会创建一个新的作用域，里面的执行的方法和变量不会影响全局作用域；</p>
</blockquote>
<h2 id="语法"> 语法</h2>
<div><pre><code>// 立即执行函数表达式语法
(function () {})()

// 变体；
(function () {}())
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>(</span><span>funcion</span> <span>(</span><span>)</span> <span>{</span>
 	<span>let</span> page <span>=</span> <span>{</span>
 		<span>init</span><span>(</span><span>)</span> <span>{</span>
  		console<span>.</span><span>log</span><span>(</span><span>'hello'</span><span>)</span>
		<span>}</span>
 	<span>}</span>
  page<span>.</span><span>init</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p>不推荐在立即执行函数中，直接引用全局变量；可以采用参数传递的方式；<code>(funtion (win) {})(window)</code></p>
</blockquote>
<div><p>提示</p>
<p>在es6中，由于引用了块级作用域，所以就不需要采用立即执行函数了</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>闭包</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-35/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-35/</guid>
      <source url="https://wangyawei.top/rss.xml">闭包</source>
      <category>javascript</category>
      <pubDate>Thu, 01 Jul 2021 22:22:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>通俗地讲，JavaScript 中每个的函数都是一个闭包，但通常意义上嵌套的函数更能够体现出闭包的特性，</p>
</blockquote>
<h2 id="什么是闭包"> 什么是闭包</h2>
<blockquote>
<p>闭包是指一个函数(作用域)可以访问另外一个函数内部的局部变量。</p>
</blockquote>
<p><strong>特性</strong></p>
<ul>
<li>延伸变量的作用范围。</li>
<li>本质上，闭包就是将函数内部和函数外部连接起来的一座桥梁。</li>
<li>如果函数内部有使用此变量，那么此变量便不会被销毁，否则会被销毁；</li>
<li>闭包阻止变量被垃圾回收</li>
</ul>
<p><strong>用途</strong></p>
<ul>
<li>可以在函数外部读取函数内部成员。</li>
<li>让函数内成员始终存活在内存中。</li>
</ul>
<p><strong>示例1</strong></p>
<div><pre><code><span>// count 就是闭包</span>
<span>var</span> <span>generateClosure</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> count <span>=</span> <span>0</span><span>;</span>
  <span>var</span> <span>get</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>++</span>count<span>;</span>
  <span>}</span>
  <span>return</span> get<span>;</span>
<span>}</span>
<span>var</span> counter <span>=</span> <span>generateClosure</span><span>(</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>counter</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 输出 1</span>
console<span>.</span><span>log</span><span>(</span><span>counter</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 输出 2</span>
console<span>.</span><span>log</span><span>(</span><span>counter</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 输出 3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>
<p>当一个函数返回它内部定义的一个函数时，就产生了一个闭包，闭 包 不 但 包 括 被 返 回 的 函 数 ， 还 包 括 这 个 函 数 的 定 义 环 境 。 上 面 例 子 中 ， 当 函 数generateClosure() 的内部函数 get 被一个外部变量 counter 引用时， counter 和
generateClosure() 的局部变量就是一个闭包。</p>
</blockquote>
<p><strong>例2</strong></p>
<div><pre><code><span>var</span> <span>generateClosure</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> count <span>=</span> <span>0</span>
  <span>var</span> <span>get</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>++</span>count
  <span>}</span>
  <span>return</span> get
<span>}</span>
<span>var</span> counter1 <span>=</span> <span>generateClosure</span><span>(</span><span>)</span>
<span>var</span> counter2 <span>=</span> <span>generateClosure</span><span>(</span><span>)</span>
console<span>.</span><span>log</span><span>(</span><span>counter1</span><span>(</span><span>)</span><span>)</span> <span>// 输出 1</span>
console<span>.</span><span>log</span><span>(</span><span>counter2</span><span>(</span><span>)</span><span>)</span> <span>// 输出 1</span>
console<span>.</span><span>log</span><span>(</span><span>counter1</span><span>(</span><span>)</span><span>)</span> <span>// 输出 2</span>
console<span>.</span><span>log</span><span>(</span><span>counter1</span><span>(</span><span>)</span><span>)</span> <span>// 输出 3</span>
console<span>.</span><span>log</span><span>(</span><span>counter2</span><span>(</span><span>)</span><span>)</span> <span>// 输出 2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><blockquote>
<p>counter1 和 counter2 分别调用了 generateClosure() 函数，生成了两个闭包的实例，它们内部引用的 count 变量分别属于各自的运行环境。</p>
</blockquote>
<div><p>提示</p>
<p>以上例子可以理解为，在 generateClosure() 返回 get 函数时，私下将 get 可能引用到的 generateClosure() 函数的内部变量（也就是 count 变量）也返回了，并在内存中生成了一个副本，之后 generateClosure() 返回的函数的两个实例 counter1和 counter2 就是相互独立的了。</p>
</div>
<h2 id="闭包的用途"> 闭包的用途</h2>
<blockquote>
<p>闭包有两个主要用途，一是实现嵌套的回调函数，二是隐藏对象的细节。</p>
</blockquote>
<h3 id="嵌套的回调函数"> 嵌套的回调函数</h3>
<div><pre><code>exports<span>.</span><span>add_user</span> <span>=</span> <span>function</span><span>(</span><span>user_info<span>,</span> callback</span><span>)</span> <span>{</span>
  <span>var</span> uid <span>=</span> <span>parseInt</span><span>(</span>user_info<span>[</span><span>'uid'</span><span>]</span><span>)</span>
  mongodb<span>.</span><span>open</span><span>(</span><span>function</span><span>(</span><span>err<span>,</span> db</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>err<span>)</span> <span>{</span>
      <span>callback</span><span>(</span>err<span>)</span>
      <span>return</span>
    <span>}</span>
    db<span>.</span><span>collection</span><span>(</span><span>'users'</span><span>,</span> <span>function</span><span>(</span><span>err<span>,</span> collection</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>err<span>)</span> <span>{</span>
        <span>callback</span><span>(</span>err<span>)</span>
        <span>return</span>
      <span>}</span>
      collection<span>.</span><span>ensureIndex</span><span>(</span><span>'uid'</span><span>,</span> <span>function</span><span>(</span><span>err</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>err<span>)</span> <span>{</span>
          <span>callback</span><span>(</span>err<span>)</span>
          <span>return</span>
        <span>}</span>
        collection<span>.</span><span>ensureIndex</span><span>(</span><span>'username'</span><span>,</span> <span>function</span><span>(</span><span>err</span><span>)</span> <span>{</span>
          <span>if</span> <span>(</span>err<span>)</span> <span>{</span>
            <span>callback</span><span>(</span>err<span>)</span>
            <span>return</span>
          <span>}</span>
          collection<span>.</span><span>findOne</span><span>(</span><span>{</span> uid<span>:</span> uid <span>}</span><span>,</span> <span>function</span><span>(</span><span>err</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span>err<span>)</span> <span>{</span>
              <span>callback</span><span>(</span>err<span>)</span>
              <span>return</span>
            <span>}</span>
            <span>if</span> <span>(</span>doc<span>)</span> <span>{</span>
              <span>callback</span><span>(</span><span>'occupied'</span><span>)</span>
            <span>}</span> <span>else</span> <span>{</span>
              <span>var</span> user <span>=</span> <span>{</span>
                uid<span>:</span> uid<span>,</span>
                user<span>:</span> user_info
              <span>}</span>
              collection<span>.</span><span>insert</span><span>(</span>user<span>,</span> <span>function</span><span>(</span><span>err</span><span>)</span> <span>{</span>
                <span>callback</span><span>(</span>err<span>)</span>
              <span>}</span><span>)</span>
            <span>}</span>
          <span>}</span><span>)</span>
        <span>}</span><span>)</span>
      <span>}</span><span>)</span>
    <span>}</span><span>)</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><blockquote>
<p>以上代码是在 Node.js 中使用 MongoDB 实现一个简单的增加用户的功能，可以看到这段代码中用到了闭包的层层嵌套，每一层的嵌套都是一个回调函数。回调函数不会立即执行，而是等待相应请求处理完后由请求的函数回调。我们可以看到，在嵌套的每一层中都有对 callback 的引用，而且最里层还用到了外层定义的 uid 变量。由于闭包机制的存在，即使外层函数已经执行完毕，其作用域内申请的变量也不会释放，因为里层的函数还有可能引用到这些变量，这样就完美地实现了嵌套的异步回调。</p>
</blockquote>
<h3 id="实现私有属性"> 实现私有属性</h3>
<blockquote>
<p>我们知道， JavaScript 的对象没有私有属性，也就是说对象的每一个属性都是曝露给外部的。</p>
</blockquote>
<p><strong>曝露给外部的安全隐患</strong>：对象的使用者直接修改了某个属性，导致对象内部数据的一致性受到破坏</p>
<div><p>提示</p>
<p>JavaScript通过约定在所有私有属性前面加上下划线（例如_myPrivateProp），表示这个属性是私有的，外部对象不应该直接读写它。但这只是个非正式的约定。</p>
</div>
<p><strong>例</strong>：通过闭包实现私有成员</p>
<div><pre><code><span>let</span> obj <span>=</span> <span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>let</span> name <span>=</span> <span>'john'</span><span>;</span>
  <span>return</span> <span>{</span>
    <span>getName</span><span>(</span><span>)</span> <span>{</span>
      <span>return</span> name<span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span><span>)</span><span>(</span><span>)</span><span>;</span>

<span>// 只能通过 getName 方法访问</span>
console<span>.</span><span>log</span><span>(</span>obj<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// john</span>
<span>// 无法直接访问 obj.name</span>
console<span>.</span><span>log</span><span>(</span>obj<span>.</span>name<span>)</span><span>;</span> <span>// undefined</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>递归</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-36/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-36/</guid>
      <source url="https://wangyawei.top/rss.xml">递归</source>
      <category>javascript</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
    </item>
    <item>
      <title>回调</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-37/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-37/</guid>
      <source url="https://wangyawei.top/rss.xml">回调</source>
      <category>javascript</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
    </item>
    <item>
      <title>柯里化</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-38/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-38/</guid>
      <source url="https://wangyawei.top/rss.xml">柯里化</source>
      <category>javascript</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
    </item>
    <item>
      <title>同步与异步</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-39/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-39/</guid>
      <source url="https://wangyawei.top/rss.xml">同步与异步</source>
      <category>javascript</category>
      <pubDate>Mon, 14 Jun 2021 23:34:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>如果你经常使用过js做开发的话，那么你也一定知道，js是一门单线程语言，代码执行有同步与异步之分。</p>
</blockquote>
<h2 id="为什么会有同步和异步"> 为什么会有同步和异步</h2>
<blockquote>
<p>因为JavaScript的单线程，因此同个时间只能处理单个任务，所有任务都需要排队，前一个任务执行完，才能继续执行下一个任务，但是，如果前一个任务的执行时间很长，比如文件的读取操作或ajax操作，后一个任务就不得不等待，拿ajax来说，当用户向后台获取大量的数据时，不得不等到所有数据都获取完毕才能进行下一步操作，用户只能在那里干等着，严重影响用户体验。</p>
<p>所以，为了避免复杂性，从一诞生，JavaScript就是单线程，这已经成了这门语言的核心特征。</p>
<p>所以，为了避免复杂性，JavaScript在设计的时候，就已经考虑到这个问题，主线程可以完全不用等待文件的读取完毕或ajax的加载成功，可以先挂起处于等待中的任务，先运行排在后面的任务，等到文件的读取或ajax有了结果后，再回过头执行挂起的任务，所以JavaScript是单线程，这已经成了这门语言的核心特征。因此任务就可以分为同步任务和异步任务</p>
</blockquote>
<div><p>提示</p>
<p>为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。
其实同步和异步，无论如何，做事情的时候都是只有一条流水线（单线程），同步和异步的差别就在于这条流水线上各个流程的执行顺序不同。</p>
<p><strong>最基础的异步是setTimeout和setInterval函数</strong>;</p>
</div>
<h2 id="同步任务"> 同步任务</h2>
<blockquote>
<p>同步任务是指在主线程上排队执行的任务，只有前一个任务执行完毕，才能继续执行下一个任务。</p>
</blockquote>
<div><pre><code><span>function</span> <span>foo</span> <span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'2'</span><span>)</span>
<span>}</span><span>;</span>

console<span>.</span><span>log</span><span>(</span><span>'1'</span><span>)</span><span>;</span>
<span>foo</span><span>(</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>'3'</span><span>)</span><span>;</span>
<span>// 输出</span>
<span>// 1</span>
<span>// 2</span>
<span>// 3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>以上代码你肯定很熟悉，代码结果会有顺序的输出 1，2，3</p>
<h2 id="异步任务"> 异步任务</h2>
<blockquote>
<p>异步任务是指不进入主线程，而进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，该任务才会进入主线程；</p>
</blockquote>
<div><pre><code><span>function</span> <span>foo</span> <span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'2'</span><span>)</span>
<span>}</span><span>;</span>

console<span>.</span><span>log</span><span>(</span><span>'1'</span><span>)</span><span>;</span>
<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>foo</span><span>(</span><span>)</span><span>;</span>
<span>}</span><span>)</span>
console<span>.</span><span>log</span><span>(</span><span>'3'</span><span>)</span><span>;</span>

<span>// 输出</span>
<span>// 1</span>
<span>// 3</span>
<span>// 2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>以上代码的结果会输出：1, 3, 2。因为foo函数的调用在定时器里面，而定时器是最常见的异步任务；</p>
<h2 id="参考资料"> 参考资料</h2>
<p>https://www.cnblogs.com/Yellow-ice/p/10433423.html</p>
<p>https://segmentfault.com/a/1190000015165424</p>
]]></content:encoded>
    </item>
    <item>
      <title>javascript单线程</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-40/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-40/</guid>
      <source url="https://wangyawei.top/rss.xml">javascript单线程</source>
      <category>javascript</category>
      <pubDate>Tue, 15 Jun 2021 23:34:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>如果你使用过js做开发的话，那么你也一定知道，js是一门单线程语言。</p>
</blockquote>
<p><strong>浏览器是多进程和多线程的，这里简单说下渲染进程</strong></p>
<ol>
<li>GUI线程：主要负责渲染页面。解析css 、js、构建DOM树和渲染树。</li>
<li>js引擎线程：主要负责解析和执行js程序，比较著名的js引擎是v8。v8引擎就是单线程的。
<ul>
<li>与GUI线程互斥。</li>
<li>js加载时间过长会影响GUI的渲染。</li>
</ul>
</li>
<li>定时器触发线程：<code>setTimeout和setInterval</code>，定时任务结束后会通知事件触发线程，往任务队列里面添加事件；</li>
<li>事件触发线程：将满足触发条件的事件放入任务队列；</li>
<li>异步HTTP请求线程：XHR所在线程；</li>
</ol>
<p><img src="./assets/image-20210615212431303.png" alt="image-20210615212431303" /></p>
<h2 id="为什么是单线程"> <strong>为什么是单线程</strong>：</h2>
<blockquote>
<p>其实，JavaScript的单线程，与它的用途是有很大关系，我们都知道，JavaScript作为浏览器的脚本语言，主要用来实现与用户的交互，利用JavaScript，我们可以实现对DOM的各种各样的操作，如果JavaScript是多线程的话，一个线程在一个DOM节点中增加内容，另一个线程要删除这个DOM节点，那么这个DOM节点究竟是要增加内容还是删除呢？这会带来很复杂的同步问题，因此，JavaScript是单线程的；为了利用多核CPU的计算能力，HTML5提出Web Worker标准，允许JavaScript脚本创建多个线程，但是子线程完全受主线程控制，且不得操作DOM。所以，这个新标准并没有改变JavaScript单线程的本质。</p>
</blockquote>
<h2 id="异步场景"> 异步场景；</h2>
<ol>
<li>定时器；</li>
<li>网络请求；</li>
<li>事件绑定；</li>
<li>ES6 promise</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>定时器</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-41/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-41/</guid>
      <source url="https://wangyawei.top/rss.xml">定时器</source>
      <category>javascript</category>
      <pubDate>Wed, 16 Jun 2021 23:34:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="执行过程"> 执行过程</h2>
<p><img src="./assets/image-20210615215518697.png" alt="image-20210615215518697" /></p>
<p><img src="./assets/image-20210615215655579.png" alt="image-20210615215655579" /></p>
<h2 id="存在的问题"> 存在的问题；</h2>
<ol>
<li>
<p>定时任务可能不会按时执行；</p>
<div><pre><code><span>const</span> <span>test</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>let</span> t <span>=</span> <span>+</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>;</span>
  <span>white</span> <span>(</span><span><span>true</span></span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>+</span><span>new</span> <span>Date</span><span>(</span><span>)</span> <span>-</span> t <span>>=</span> <span>5000</span><span>)</span> <span>{</span>
      <span>break</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>2</span><span>)</span><span>;</span>
<span>}</span><span>)</span>
<span>test</span><span>(</span><span>)</span><span>;</span>

<span>// 5秒后才会打印 2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><blockquote>
<p>以上代码可以看出，如果同步任务耗时很久的话，定时器并不会按我们的预期来执行；</p>
</blockquote>
</li>
<li>
<p>定时器嵌套5次之后最小间隔不能低于4ms；</p>
</li>
</ol>
<h2 id="应用场景"> 应用场景；</h2>
<ol>
<li>防抖；</li>
<li>节流；</li>
<li>倒计时；</li>
<li>动画；</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>js实现复制粘贴</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-42/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-42/</guid>
      <source url="https://wangyawei.top/rss.xml">js实现复制粘贴</source>
      <category>javascript</category>
      <pubDate>Tue, 15 Jun 2021 07:34:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>浏览器允许 JavaScript 脚本读写剪贴板，自动复制或粘贴内容。
一般来说，脚本不应该改动用户的剪贴板，以免不符合用户的预期。但是，有些时候这样做确实能够带来方便，比如&quot;一键复制&quot;功能，用户点击一下按钮，指定的内容就自动进入剪贴板。</p>
</blockquote>
<h2 id="execcommand方法"> execCommand方法</h2>
<blockquote>
<p>Document.execCommand()是操作剪贴板的传统方法，各种浏览器都支持。
它支持复制、剪切和粘贴这三个操作。</p>
</blockquote>
<div><pre><code>document<span>.</span><span>execCommand</span><span>(</span><span>'copy'</span><span>)</span>（复制）
document<span>.</span><span>execCommand</span><span>(</span><span>'cut'</span><span>)</span>（剪切）
document<span>.</span><span>execCommand</span><span>(</span><span>'paste'</span><span>)</span>（粘贴）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>这里我只使用复制api;</li>
<li>使用<div><pre><code><span>// 创建一个 textarea 元素</span>
<span>const</span> str <span>=</span> <span>'hello world'</span><span>;</span>
<span>const</span> el <span>=</span> document<span>.</span><span>createElement</span><span>(</span><span>'textarea'</span><span>)</span><span>;</span>
document<span>.</span>body<span>.</span><span>appendChild</span><span>(</span>el<span>)</span><span>;</span>
<span>// 需要复制的内容复制给value;</span>
el<span>.</span>value <span>=</span> str<span>;</span>
<span>// 选中内容</span>
el<span>.</span><span>select</span><span>(</span><span>)</span><span>;</span>
<span>// 复制</span>
document<span>.</span><span>execCommand</span><span>(</span><span>'copy'</span><span>)</span><span>;</span>
document<span>.</span>body<span>.</span><span>removeChild</span><span>(</span>el<span>)</span><span>;</span>
<span>this</span><span>.</span>$toast<span>.</span><span>success</span><span>(</span><span>'已复制到截切版'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
<li>格式化复制的内容<div><pre><code><span>// 复制内容插入空格或换行符</span>
<span>const</span> str <span>=</span> <span>'hello world'</span><span>;</span>
<span>// 复制内容插入换行符</span>
<span>const</span> str <span>=</span> <span>'hello\nworld'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>Document.execCommand()方法虽然方便，但是有一些缺点。
<ul>
<li>它只能将选中的内容复制到剪贴板，无法向剪贴板任意写入内容。</li>
<li>它是同步操作，如果复制/粘贴大量数据，页面会出现卡顿。</li>
<li>有些浏览器还会跳出提示框，要求用户许可，这时在用户做出选择前，页面会失去响应。</li>
</ul>
</li>
</ul>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li>http://www.ruanyifeng.com/blog/2021/01/clipboard-api.html</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Event Loop机制</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-43/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-43/</guid>
      <source url="https://wangyawei.top/rss.xml">Event Loop机制</source>
      <category>javascript</category>
      <pubDate>Tue, 15 Jun 2021 07:34:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>我们知道，javascript从诞生之日起就是一门单线程的非阻塞的脚本语言。这是由其最初的用途来决定的：与浏览器交互。单线程意味着，javascript代码在执行的任何时候，都只有一个主线程来处理所有的任务。而非阻塞则是当代码需要进行一项异步任务（无法立刻返回结果，需要花一定时间才能返回的任务，如I/O事件）的时候，主线程会挂起（pending）这个任务，然后在异步任务返回结果的时候再根据一定规则去执行相应的回调。</p>
</blockquote>
<p><strong>你可能会有所疑问，既然js是一门 单线程的非阻塞的脚本语言那么它是如何实现的异步呢？</strong></p>
<p>答案是：Event Loop即事件循环是实现异步的一种机制;</p>
<h2 id="浏览器的event-loop"> 浏览器的<code>Event Loop</code>;</h2>
<p><strong>1.执行栈与事件队列</strong></p>
<p>当javascript代码执行的时候会将不同的变量存于内存中的不同位置：堆（heap）和栈（stack）中来加以区分。其中，堆里存放着一些对象。而栈中则存放着一些基础类型变量以及对象的指针。 <strong>但是我们这里说的执行栈和上面这个栈的意义却有些不同。</strong></p>
<p>我们知道，当我们调用一个方法的时候，js会生成一个与这个方法对应的执行环境（context），<strong>又叫执行上下文</strong>。这个执行环境中存在着这个方法的私有作用域，上层作用域的指向，方法的参数，这个作用域中定义的变量以及这个作用域的this对象。 而当一系列方法被依次调用的时候，因为js是单线程的，同一时间只能执行一个方法，于是这些方法被排队在一个单独的地方。这个地方被称为执行栈。</p>
<p>当一个脚本第一次执行的时候，js引擎会解析这段代码，并将其中的同步代码按照执行顺序加入执行栈中，然后从头开始执行。如果当前执行的是一个方法，那么js会向执行栈中添加这个方法的执行环境，然后进入这个执行环境继续执行其中的代码。当这个执行环境中的代码 执行完毕并返回结果后，js会退出这个执行环境并把这个执行环境销毁，回到上一个方法的执行环境。。这个过程反复进行，直到执行栈中的代码全部执行完毕。<strong>当然这说的是同步代码的执行；</strong></p>
<div><pre><code><span>function</span> <span>bar</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>3</span><span>)</span><span>;</span>
<span>}</span>
<span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>2</span><span>)</span><span>;</span>
  <span>bar</span><span>(</span><span>3</span><span>)</span><span>;</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span><span>;</span>
<span>foo</span><span>(</span><span>)</span>
console<span>.</span><span>log</span><span>(</span><span>4</span><span>)</span>

<span>// 1</span>
<span>// 2</span>
<span>// 3</span>
<span>// 4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>当js引擎遇到一个异步事件后并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当一个异步事件返回结果后，js会将这个事件加入与当前执行栈不同的另一个队列，我们称之为<strong>事件队列</strong>。被放入事件队列不会立刻执行其回调，而是等待当前执行栈中的所有任务都执行完毕， 主线程处于闲置状态时，主线程会去查找事件队列是否有任务。如果有，那么主线程会从中取出排在第一位的事件，并把这个事件对应的回调放入执行栈中，然后执行其中的同步代码...，如此反复，这样就形成了一个无限的循环。这就是这个过程被称为“事件循环（Event Loop）”的原因。</p>
<p><strong>2、宏任务和微任务；</strong></p>
<p>宏任务：</p>
<ol>
<li>全局script的执行；</li>
<li>定时器(<code>setTimeout setInterval</code>);</li>
<li><code>setImmedidte</code>(nodejs拥有的);</li>
<li>I/O;</li>
<li>UI rendering;</li>
</ol>
<p>微任务：</p>
<ol>
<li>Promise;</li>
<li>Object.observe;</li>
<li>MutationObserver;</li>
<li>postMessage;</li>
</ol>
<blockquote>
<p>在一个事件循环中，异步事件返回结果后会被放到一个任务队列中。然而，根据这个异步事件的类型，这个事件实际上会被放到对应的宏任务队列或者微任务队列中去。<strong>并且在当前执行栈为空的时候，主线程会 查看微任务队列是否有事件存在。如果不存在，那么再去宏任务队列中取出一个事件并把对应的回到加入当前执行栈；如果存在，则会依次执行队列中事件对应的回调，直到微任务队列为空，然后去宏任务队列中取出最前面的一个事件，把对应的回调加入当前执行栈...如此反复，进入循环。</strong></p>
</blockquote>
<div><pre><code><span>setTimeout</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>new</span> <span>Promise</span><span>(</span><span>function</span><span>(</span><span>resolve<span>,</span>reject</span><span>)</span><span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>2</span><span>)</span>
  <span>resolve</span><span>(</span><span>3</span><span>)</span>
<span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>val</span><span>)</span><span>{</span>
  console<span>.</span><span>log</span><span>(</span>val<span>)</span><span>;</span>
<span>}</span><span>)</span>

<span>// 2</span>
<span>// 3</span>
<span>// 1</span>

console<span>.</span><span>log</span><span>(</span><span>'1'</span><span>)</span><span>;</span>
<span>setTimeout</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'2'</span><span>)</span><span>;</span>
<span>}</span><span>)</span>
Promise<span>.</span><span>resolve</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'3'</span><span>)</span><span>;</span>
<span>}</span><span>)</span>
console<span>.</span><span>log</span><span>(</span><span>'4'</span><span>)</span>

<span>// 1</span>
<span>// 4</span>
<span>// 3</span>
<span>// 2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><div><p>提示</p>
<p>当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。同一次事件循环中，微任务永远在宏任务之前执行。</p>
</div>
<p><img src="./assets/image-20210616230321908.png" alt="image-20210616230321908" /></p>
<h2 id="nodejs的event-loop"> nodejs的<code>Event Loop</code></h2>
<blockquote>
<p>Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。</p>
</blockquote>
<p><img src="./assets/image-20210617222404249.png" alt="image-20210617222404249" /></p>
<blockquote>
<p>libuv是一个跨平台的异步I/O库，该库会根据系统自动选择合适的方案，其功能可以用于TCP/DNS等文件的异步操作;</p>
<p>V8是一个js引擎，js代码是跑在v8引擎上面的，首先v8会将js源代码变成本地代码并执行；维护调用栈，保证js的执行顺序；为所有对象分配内存；垃圾回收；实现js的标准库。</p>
<p><strong>v8执行js是单线程，但是本身是多线程；v8自带有eventloop，但是nodejs基于libuv自己做了一个</strong></p>
</blockquote>
<p><strong>Node.js的运行机制</strong></p>
<ol>
<li>V8引擎解析JavaScript脚本。</li>
<li>解析后的代码，调用Node API。</li>
<li><a href="https://github.com/joyent/libuv" target="_blank" rel="noopener noreferrer">libuv库</a>负责Node API的执行。它将不同的任务分配给不同的线程，形成一个Event Loop（事件循环），以异步的方式将任务的执行结果返回给V8引擎。</li>
<li>V8引擎再将结果返回给用户。</li>
<li>见下图：其中每个方框都是 event loop 中的一个阶段。</li>
</ol>
<p><img src="./assets/image-20210617223546089.png" alt="image-20210617223546089" /></p>
<p><strong>event loop运行阶段</strong></p>
<ol>
<li>timers：定时器阶段，执行定时器的回调；</li>
<li>pending callbacks：系统操作的回调；(暂且不关心)</li>
<li>idle,pepare：内部使用；(暂且不关心)</li>
<li>poll：等待新I/O事件；</li>
<li>check：执行setImmediate回调；</li>
<li>close callbacks：内部使用；(暂且不关心)</li>
</ol>
<blockquote>
<p>每一个阶段都有一个callbacks的先进先出的队列需要执行，当event loop运行到一个指定阶段时，该阶段的先进先出队列将会被执行，当队列callbacks执行完或着执行的callbacks数量超过该阶段的上限时，event loop转入下一个阶段。</p>
</blockquote>
<div><p>提示</p>
<p>上面这些操作都有可能添加计时器；另一方面，操作系统会向 poll 队列中添加新的事件，当 poll 队列中的事件被处理时可能会有新的 poll 事件进入 poll 队列。结果，耗时较长的回调函数可以让 event loop 在 poll 阶段停留很久，久到错过了计时器的触发时机。
<a href="https://juejin.cn/post/6844903582538399752" target="_blank" rel="noopener noreferrer">原文链接</a></p>
</div>
<p><strong>poll阶段执行</strong></p>
<p><img src="./assets/image-20210617224454432.png" alt="image-20210617224454432" /></p>
<div><pre><code><span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>
fs<span>.</span><span>readFile</span><span>(</span>__filename<span>,</span> <span>_</span> <span>=></span> <span>{</span>
	<span>setTimeout</span><span>(</span><span>_</span> <span>=></span> <span>{</span>
		console<span>.</span><span>log</span><span>(</span><span>'setTimeout'</span><span>)</span>
	<span>}</span><span>,</span> <span>0</span><span>)</span><span>;</span>
	<span>setImmediate</span><span>(</span><span>_</span> <span>=></span> <span>{</span>
		console<span>.</span><span>log</span><span>(</span><span>'setImmediate'</span><span>)</span>
	<span>}</span><span>)</span>
<span>}</span><span>)</span>

<span>// setImmediate</span>
<span>// setTimeout</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>
<p>setImmediate方法则是在当前&quot;<strong>任务队列</strong>&quot;的尾部添加事件，也就是说，它指定的任务总是在下一次<strong>Event Loop时</strong>执行，</p>
</blockquote>
<h3 id="process-nexttick"> process.nextTick()</h3>
<blockquote>
<p>process.nextTick方法可以在当前&quot;<strong>执行栈</strong>&quot;的尾部也就是下一次<strong>Event Loop（主线程读取&quot;任务队列&quot;）之前</strong>触发回调函数。它指定的任务总是发生在所有异步任务之前。是一个异步的node API 但是不属于event loop的阶段；</p>
</blockquote>
<div><pre><code><span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>
fs<span>.</span><span>readFile</span><span>(</span>__filename<span>,</span> <span>_</span> <span>=></span> <span>{</span>
	<span>setTimeout</span><span>(</span><span>_</span> <span>=></span> <span>{</span>
		console<span>.</span><span>log</span><span>(</span><span>'setTimeout'</span><span>)</span>
	<span>}</span><span>,</span> <span>0</span><span>)</span><span>;</span>
	<span>setImmediate</span><span>(</span><span>_</span> <span>=></span> <span>{</span>
		console<span>.</span><span>log</span><span>(</span><span>'setImmediate'</span><span>)</span><span>;</span>
		process<span>.</span><span>nextTick</span><span>(</span><span>_</span> <span>=></span> <span>{</span>
			console<span>.</span><span>log</span><span>(</span><span>'nextTick2'</span><span>)</span>
		<span>}</span><span>)</span>
	<span>}</span><span>)</span>
	process<span>.</span><span>nextTick</span><span>(</span><span>_</span> <span>=></span> <span>{</span>
		console<span>.</span><span>log</span><span>(</span><span>'nextTick1'</span><span>)</span>
	<span>}</span><span>)</span>
<span>}</span><span>)</span>

<span>// nextTick1</span>
<span>// setImmediate</span>
<span>// nextTick2</span>
<span>// setTimeout</span>

<span>// 例 2</span>
process<span>.</span><span>nextTick</span><span>(</span><span>function</span> <span>A</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span><span>;</span>
  process<span>.</span><span>nextTick</span><span>(</span><span>function</span> <span>B</span><span>(</span><span>)</span><span>{</span>console<span>.</span><span>log</span><span>(</span><span>2</span><span>)</span><span>;</span><span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>setTimeout</span><span>(</span><span>function</span> <span>timeout</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'TIMEOUT FIRED'</span><span>)</span><span>;</span>
<span>}</span><span>,</span> <span>0</span><span>)</span>

<span>// 1 </span>
<span>// 2</span>
<span>// TIMEOUT FIRED</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><blockquote>
<p>例 2 中：由于process.nextTick方法指定的回调函数，总是在当前&quot;执行栈&quot;的尾部触发，所以不仅函数A比setTimeout指定的回调函数timeout先执行，而且函数B也比timeout先执行。这说明，如果有多个process.nextTick语句（不管它们是否嵌套），将全部在当前&quot;执行栈&quot;执行。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>发布订阅</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-44/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-44/</guid>
      <source url="https://wangyawei.top/rss.xml">发布订阅</source>
      <category>javascript</category>
      <pubDate>Sat, 19 Jun 2021 16:39:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>在<a href="https://baike.baidu.com/item/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84" target="_blank" rel="noopener noreferrer">软件架构</a>中，<strong>发布订阅</strong>是一种<a href="https://baike.baidu.com/item/%E6%B6%88%E6%81%AF" target="_blank" rel="noopener noreferrer">消息</a><a href="https://baike.baidu.com/item/%E8%8C%83%E5%BC%8F" target="_blank" rel="noopener noreferrer">范式</a>，消息的发送者（称为发布者）不会将消息直接发送给特定的接收者（称为订阅者）。而是<strong>将发布的消息分为不同的类别</strong>，无需了解哪些订阅者（如果有的话）可能存在。同样的，<strong>订阅者可以表达对一个或多个类别的兴趣，只接收感兴趣的消息</strong>，无需了解哪些发布者（如果有的话）存在。</p>
</blockquote>
<p><img src="./assets/image-20210620002123396.png" alt="image-20210620002123396" /></p>
<p>优点：</p>
<ul>
<li>低耦合；</li>
<li>灵活；</li>
</ul>
<p>缺点：</p>
<ul>
<li>无法确保消息被触发或者触发几次；</li>
</ul>
<h2 id="实现"> 实现</h2>
<blockquote>
<p>首先我们定义一个 发布订阅的 类；</p>
</blockquote>
<div><pre><code><span>class</span> <span>PubSub</span> <span>{</span>
  <span>constructor</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>events <span>=</span> <span>{</span><span>}</span><span>;</span>
  <span>}</span>

  <span>// 订阅者</span>
  <span>$on</span><span>(</span><span>eventNames<span>,</span> callback</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>eventNames <span>instanceof</span> <span>Array</span><span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> eventNames<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>eventNames<span>[</span>i<span>]</span> <span>in</span> <span>this</span><span>.</span>events<span>)</span> <span>{</span>
          <span>this</span><span>.</span>events<span>[</span>eventNames<span>[</span>i<span>]</span><span>]</span><span>.</span><span>push</span><span>(</span>callback<span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
          <span>this</span><span>.</span>events<span>[</span>eventNames<span>[</span>i<span>]</span><span>]</span> <span>=</span> <span>[</span>callback<span>]</span><span>;</span>
        <span>}</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>if</span> <span>(</span>eventNames <span>in</span> <span>this</span><span>.</span>events<span>)</span> <span>{</span>
        <span>this</span><span>.</span>events<span>[</span>eventNames<span>]</span><span>.</span><span>push</span><span>(</span>callback<span>)</span><span>;</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>this</span><span>.</span>events<span>[</span>eventNames<span>]</span> <span>=</span> <span>[</span>callback<span>]</span><span>;</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>

  <span>// 发布者</span>
  <span>$emit</span><span>(</span><span>eventNames<span>,</span> data</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>eventNames <span>instanceof</span> <span>Array</span><span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> eventNames<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>eventNames<span>[</span>i<span>]</span> <span>in</span> <span>this</span><span>.</span>events<span>)</span> <span>{</span>
          <span>this</span><span>.</span>events<span>[</span>eventNames<span>[</span>i<span>]</span><span>]</span><span>.</span><span>forEach</span><span>(</span><span>item</span> <span>=></span> <span>{</span>
            <span>item</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> data<span>)</span>
          <span>}</span><span>)</span>
        <span>}</span> <span>else</span> <span>{</span>
          console<span>.</span><span>log</span><span>(</span><span>'事件未注册：%o'</span><span>,</span> eventNames<span>[</span>i<span>]</span><span>)</span>
        <span>}</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>if</span> <span>(</span>eventNames <span>in</span> <span>this</span><span>.</span>events<span>)</span> <span>{</span>
        <span>this</span><span>.</span>events<span>[</span>eventNames<span>]</span><span>.</span><span>forEach</span><span>(</span><span>item</span> <span>=></span> <span>{</span>
          <span>item</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span>data<span>)</span>
        <span>}</span><span>)</span>
      <span>}</span> <span>else</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'事件未注册：%o'</span><span>,</span> eventNames<span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>

  <span>// 取消订阅</span>
  <span>$unSub</span><span>(</span><span>names<span>,</span> callback</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>names <span>instanceof</span> <span>Array</span><span>)</span> <span>{</span>
      <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> names<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>names<span>[</span>i<span>]</span> <span>in</span> <span>this</span><span>.</span>events<span>)</span> <span>{</span>
          <span>const</span> callbacks <span>=</span> <span>this</span><span>.</span>events<span>[</span>names<span>[</span>i<span>]</span><span>]</span><span>.</span><span>filters</span><span>(</span><span>item</span> <span>=></span> item <span>!==</span> callback<span>)</span><span>;</span>
          <span>if</span> <span>(</span>callbacks<span>.</span>length<span>)</span> <span>{</span>
            <span>this</span><span>.</span>events<span>[</span>names<span>[</span>i<span>]</span><span>]</span> <span>=</span> callbacks<span>;</span>
          <span>}</span> <span>else</span> <span>{</span>
            <span>delete</span> <span>this</span><span>.</span>events<span>[</span>names<span>[</span>i<span>]</span><span>]</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>if</span> <span>(</span>names <span>in</span> <span>this</span><span>.</span>events<span>)</span> <span>{</span>
        <span>const</span> callbacks <span>=</span> <span>this</span><span>.</span>events<span>[</span>names<span>]</span><span>.</span><span>filter</span><span>(</span><span>item</span> <span>=></span> item <span>!==</span> callback<span>)</span><span>;</span>
        <span>if</span> <span>(</span>callbacks<span>.</span>length<span>)</span> <span>{</span>
          <span>this</span><span>.</span>events<span>[</span>names<span>]</span> <span>=</span> callbacks<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
          <span>delete</span> <span>this</span><span>.</span>events<span>[</span>names<span>]</span>
          console<span>.</span><span>log</span><span>(</span><span>'事件已删除：%o'</span><span>,</span> names<span>)</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

module<span>.</span>exports <span>=</span> PubSub<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div><h3 id="订阅单个消息"> <strong>订阅单个消息</strong></h3>
<div><pre><code><span>// 订阅单个消息；</span>
<span>const</span> PubSub <span>=</span> <span>require</span><span>(</span><span>'./PubSub.js'</span><span>)</span><span>;</span>
<span>const</span> pubSub <span>=</span> <span>new</span> <span>PubSub</span><span>(</span><span>)</span><span>;</span>
<span>function</span> <span>event_1</span><span>(</span><span>res</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'我执行了：%o'</span><span>,</span> res<span>)</span>
<span>}</span>

pubSub<span>.</span><span>$on</span><span>(</span><span>'event_1'</span><span>,</span> event_1<span>)</span><span>;</span>

pubSub<span>.</span><span>$emit</span><span>(</span><span>'event_1'</span><span>,</span> <span>'今天是周末'</span><span>)</span><span>;</span>

pubSub<span>.</span><span>$unSub</span><span>(</span><span>'event_1'</span><span>,</span> event_1<span>)</span><span>;</span>

pubSub<span>.</span><span>$emit</span><span>(</span><span>'event_1'</span><span>,</span> <span>'今天周末'</span><span>)</span><span>;</span>

<span>// 我执行了：'今天是周末'</span>
<span>// 事件已删除：'event_1'</span>
<span>// 事件未注册：'event_1'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="订阅多个消息"> <strong>订阅多个消息</strong></h3>
<div><pre><code><span>const</span> PubSub <span>=</span> <span>require</span><span>(</span><span>'./PubSub.js'</span><span>)</span><span>;</span>
<span>const</span> pubSub <span>=</span> <span>new</span> <span>PubSub</span><span>(</span><span>)</span><span>;</span>
<span>function</span> <span>event_1</span><span>(</span><span>res</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'event_1 我执行了：%o'</span><span>,</span> res<span>)</span>
<span>}</span>

<span>function</span> <span>event_2</span><span>(</span><span>res</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'event_2 我执行了：%o'</span><span>,</span> res<span>)</span>
<span>}</span>

pubSub<span>.</span><span>$on</span><span>(</span><span>[</span><span>'event_1'</span><span>,</span> <span>'event_2'</span><span>]</span><span>,</span> event_1<span>)</span><span>;</span>
pubSub<span>.</span><span>$on</span><span>(</span><span>'event_2'</span> <span>,</span> event_2<span>)</span><span>;</span>
pubSub<span>.</span><span>$emit</span><span>(</span><span>[</span><span>'event_1'</span><span>,</span> <span>'event_2'</span><span>]</span><span>,</span> <span>'今天是周一'</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>'----------'</span><span>)</span>
pubSub<span>.</span><span>$unSub</span><span>(</span><span>'event_1'</span><span>,</span> event_1<span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>'----------'</span><span>)</span>
pubSub<span>.</span><span>$emit</span><span>(</span><span>[</span><span>'event_2'</span><span>]</span><span>,</span> <span>'今天是周一'</span><span>)</span><span>;</span>
pubSub<span>.</span><span>$unSub</span><span>(</span><span>'event_2'</span><span>,</span> event_2<span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span><span>'----------'</span><span>)</span>
pubSub<span>.</span><span>$emit</span><span>(</span><span>[</span><span>'event_2'</span><span>]</span><span>,</span> <span>'今天是周一'</span><span>)</span><span>;</span>

<span>// event_1 我执行了：'今天是周一'</span>
<span>// event_1 我执行了：'今天是周一'</span>
<span>// event_2 我执行了：'今天是周一'</span>
<span>// ----------</span>
<span>// 事件已删除：'event_1'</span>
<span>// ----------</span>
<span>// event_1 我执行了：'今天是周一'</span>
<span>// event_2 我执行了：'今天是周一'</span>
<span>// ----------</span>
<span>// event_1 我执行了：'今天是周一'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><div><p>提示</p>
<p>上面的<code>PubSup</code>类中，是多对多的关系；发布者可以同时发布多条消息，同时订阅者，也可以根据自己的&quot;兴趣&quot;订阅多个类别；</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>深入理解Promise</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-45/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-45/</guid>
      <source url="https://wangyawei.top/rss.xml">深入理解Promise</source>
      <category>javascript</category>
      <pubDate>Sun, 20 Jun 2021 11:45:22 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p><strong>Promise</strong> 对象用于表示一个异步操作的最终完成 (或失败)及其结果值</p>
</blockquote>
<h2 id="promise是什么"> promise是什么</h2>
<ul>
<li>主要用于异步操作；</li>
<li>可以将异步操作队列化，按照期望的顺序执行，返回符合预期的结果；</li>
<li>可以在对象之间传递和操作promise，帮助我们处理队列；</li>
<li>Promise代表了未来将要发生的事件，用来传递异步操作的消息。</li>
</ul>
<h2 id="特点"> 特点</h2>
<ol>
<li>对象的状态不受外界影响。Promise 对象代表一个异步操作，</li>
<li>只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。</li>
<li>一旦状态改变，就不会再变，任何时候都可以得到这个结果。</li>
<li>Promise 对象的状态改变，只有两种可能：从 Pending 变为 Resolved 和从 Pending 变为 Rejected。</li>
<li>只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。</li>
<li>一个 <code>Promise</code> 必然处于以下几种状态之一：
<ul>
<li><em>待定（pending）</em>: 初始状态，既没有被兑现，也没有被拒绝。</li>
<li><em>已兑现（fulfilled）</em>: 意味着操作成功完成。</li>
<li><em>已拒绝（rejected）</em>: 意味着操作失败。</li>
</ul>
</li>
</ol>
<p><img src="./assets/image-20210620115104588.png" alt="image-20210620115104588" /></p>
<h2 id="优点"> 优点；</h2>
<ul>
<li>有了 Promise 对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。</li>
<li>Promise 对象提供统一的接口，使得控制异步操作更加容易。</li>
<li><code>Promise.prototype.then</code> 和 <code>Promise.prototype.catch</code> 方法返回的是 promise， 所以它们可以被链式调用。</li>
</ul>
<h2 id="缺点"> 缺点</h2>
<ul>
<li>无法取消 Promise，一旦新建它就会立即执行，无法中途取消。</li>
<li>;如果不设置回调函数，Promise 内部抛出的错误，不会反应到外部。</li>
<li>当处于 Pending 状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ul>
<h2 id="创建promise"> 创建<code>Promise</code></h2>
<blockquote>
<p>创建一个 promise 对象、可以使用 new 调用 Promise 的构造器来进行实例化。</p>
</blockquote>
<div><pre><code><span>const</span> promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>/* 异步操作成功 */</span><span>)</span><span>{</span>
    <span>resolve</span><span>(</span>value<span>)</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>reject</span><span>(</span>error<span>)</span><span>;</span>
  <span>}</span>
<span>}</span><span>)</span><span>;</span>

promise<span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>value</span><span>)</span> <span>{</span>
  <span>// 异步操作成功时的回调</span>
  <span>}</span><span>,</span> <span>function</span><span>(</span><span>error</span><span>)</span> <span>{</span>
  <span>// 异步操作失败时的回调</span>
  <span>}</span><span>)</span><span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p><strong>参数说明；</strong></p>
<ol>
<li><code>Promise</code>构造函数接受一个<strong>函数</strong>作为参数，该函数的两个<strong>参数</strong>分别是<code>resolve</code>和<code>reject</code>。它们是两个函数；
<ul>
<li>resolve：在异步操作成功时调用；</li>
<li>reject：在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去</li>
</ul>
</li>
</ol>
<div><p>提示</p>
<p>new Promise时是同步的执行的，表示你要进行异步操作，then方法和catch方法是异步的；</p>
</div>
<p><strong>then方法</strong></p>
<ul>
<li>promise1.then(onFulfilled, onRejected);</li>
<li>参数；
<ul>
<li>onFulfilled在promise完成后(resolve)被调用，</li>
<li>onRejected在promise被拒绝执行后(reject)调用；</li>
</ul>
</li>
<li>返回值是promise;</li>
</ul>
<p><strong>实例方法</strong></p>
<p><img src="./assets/image-20210620160727935.png" alt="image-20210620160727935" /></p>
<p><strong>静态方法</strong></p>
<p><img src="./assets/image-20210620152408590.png" alt="image-20210620152408590" /></p>
<div><p>注意</p>
<ol>
<li>then、catch返回的promise是最新的promise，不是原来的promise；</li>
<li>Promise对象的错误会冒泡，直到被捕获为止，错误会被下一个catch语句捕获；</li>
<li>不要忘记catch捕获错误；</li>
<li>then方法中使用return;</li>
<li><strong>不要把promise写成嵌套</strong>；因为promise就是解决回调地狱的；</li>
</ol>
</div>
<h2 id="demo"> demo</h2>
<blockquote>
<p>需求：2秒之后亮一次灯，再过2秒亮一次灯，在过1秒亮一次黄灯，用promise实现多次交替亮灯的效果；</p>
</blockquote>
<p>分析</p>
<ul>
<li>多少秒后亮某个颜色的灯；</li>
<li>顺序亮一批灯；</li>
<li>循环顺序亮一批灯；</li>
</ul>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>ie=edge<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>title</span><span>></span></span>Title<span><span><span>&lt;/</span>title</span><span>></span></span>
  <span><span><span>&lt;</span>style</span><span>></span></span><span><span>
    <span>.light</span> <span>{</span>
        <span>width</span><span>:</span> 100px<span>;</span>
        <span>height</span><span>:</span> 100px<span>;</span>
        <span>margin</span><span>:</span> 0 auto<span>;</span>
    <span>}</span>
  </span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>light<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
  <span>const</span> el <span>=</span> document<span>.</span><span>getElementsByClassName</span><span>(</span><span>'light'</span><span>)</span><span>;</span>
  <span>const</span> list <span>=</span> <span>[</span>
    <span>{</span> color<span>:</span> <span>'red'</span><span>,</span> second<span>:</span> <span>3</span> <span>}</span><span>,</span>
    <span>{</span> color<span>:</span> <span>'green'</span><span>,</span> second<span>:</span> <span>2</span> <span>}</span><span>,</span>
    <span>{</span> color<span>:</span> <span>'yellow'</span><span>,</span> second<span>:</span> <span>1</span> <span>}</span><span>,</span>
  <span>]</span><span>;</span>
  <span>function</span> <span>light</span><span>(</span><span>color<span>,</span> second</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>
      <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span>color<span>)</span>
        el<span>[</span><span>0</span><span>]</span><span>.</span>style<span>.</span>background <span>=</span> color<span>;</span>
        <span>resolve</span><span>(</span><span>)</span><span>;</span>
      <span>}</span><span>,</span> second <span>*</span> <span>1000</span><span>)</span>
    <span>}</span><span>)</span><span>)</span>
  <span>}</span>

  <span>function</span> <span>orderLights</span><span>(</span><span>list</span><span>)</span> <span>{</span>
    <span>// 关键位置；</span>
    <span>let</span> promise <span>=</span> Promise<span>.</span><span>resolve</span><span>(</span><span>)</span><span>;</span>
    list<span>.</span><span>forEach</span><span>(</span><span>(</span><span>item</span><span>)</span> <span>=></span> <span>{</span>
      promise <span>=</span> promise<span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        <span>return</span> <span>light</span><span>(</span>item<span>.</span>color<span>,</span> item<span>.</span>second<span>)</span><span>;</span>
      <span>}</span><span>)</span>
    <span>}</span><span>)</span>
    promise<span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>orderLights</span><span>(</span>list<span>)</span><span>;</span>
    <span>}</span><span>)</span>
  <span>}</span>
  <span>orderLights</span><span>(</span>list<span>)</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Generator函数及其异步应用</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-46/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-46/</guid>
      <source url="https://wangyawei.top/rss.xml">Generator函数及其异步应用</source>
      <category>javascript</category>
      <pubDate>Sun, 20 Jun 2021 22:18:22 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Generator函数是ES6提供的一种异步编程解决方案，是回调地狱的一种解决方案，它跟<code>promise</code>类似，但是却可以以同步的方式来书写代码，而避免了promise的链式调用。语法行为与传统函数完全不同，对于generator函数有多种不同的理解角度，从语法上，首先我们可以把它理解成一个状态机，封装了多个内部状态。由于执行generator函数会返回一个遍历器对象，说明它还是一个遍历器对象生成函数。</p>
</blockquote>
<p><strong>特征</strong></p>
<ol>
<li>function命令与函数名之间有一个星号(<code>*</code>)；</li>
<li>函数语句使用<code>yield</code>语句定义不同的内部状态；</li>
</ol>
<h2 id="迭代器iterator"> 迭代器<code>iterator</code></h2>
<blockquote>
<p>它是一种接口，为各种不同的数据结构提供统一的访问机制；</p>
</blockquote>
<p>作用：</p>
<ol>
<li>为各种数据结构提供一个统一的、简便的访问接口；</li>
<li>使得数据结构的成员能够按某种次序排列；</li>
<li>ES6创造了一种新的遍历器命令：for...of 循环，iterator接口主要供for...of 消费；</li>
</ol>
<p>特点：</p>
<ul>
<li>有next方法，执行后返回结果对象；</li>
</ul>
<div><pre><code><span>// 创建一个iterator函数</span>
<span>function</span> <span>makeIterator</span><span>(</span><span>array</span><span>)</span> <span>{</span>
  <span>let</span> nextIndex <span>=</span> <span>0</span><span>;</span>
  <span>return</span> <span>{</span>
    <span>next</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
      <span>return</span> nextIndex <span>&lt;</span> array<span>.</span>length <span>?</span>
      <span>{</span> value<span>:</span> array<span>[</span>nextIndex<span>++</span><span>]</span><span>,</span> done<span>:</span> <span>false</span> <span>}</span> <span>:</span>
      <span>{</span> value<span>:</span> <span>undefined</span><span>,</span> done<span>:</span> <span>true</span> <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>const</span> it <span>=</span> <span>makeIterator</span><span>(</span><span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>]</span><span>)</span>

console<span>.</span><span>log</span><span>(</span>it<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// { value: 1, done: false }</span>
console<span>.</span><span>log</span><span>(</span>it<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// { value: 2, done: false }</span>
console<span>.</span><span>log</span><span>(</span>it<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// { value: 3, done: false }</span>
console<span>.</span><span>log</span><span>(</span>it<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// { value: undefined, done: true }</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="生成器generator"> 生成器<code>Generator</code></h2>
<blockquote>
<p>生成器是一种使用强大的新ES6语法定义的迭代器，同时又是ES6的异步编程解决方案。</p>
</blockquote>
<p>特点</p>
<ul>
<li>声明语法与常规的js函数类似，但使用的关键字是function*而非function。</li>
<li>调用生成器函数并不会实际执行函数体，而是返回一个生成器对象。</li>
<li>这个生成器是一个迭代器。</li>
<li>在执行时能暂停，又能从暂停处继续执行。</li>
<li>ES6异步编程解决方案。</li>
<li>独有的<code>yield</code>语句。
<ul>
<li>调用它的<code>generator</code>函数的next方法会导致生成器函数的函数体从头开始执行，直至遇到<code>yield</code>语句。</li>
<li>只能出现在<code>Generator</code>函数；</li>
<li>用来暂停和恢复生成器函数；</li>
<li>类似于return语句。</li>
<li><code>yield</code>语句的值会成为调用迭代器的next()方法的返回值。</li>
<li>next执行。
<ul>
<li>遇<code>yield</code>暂停，将紧跟<code>yield</code>表达式的值作为返回的对象的value。</li>
<li>没有<code>yield</code>，一直执行到return，将return 的值作为返回的对象的value。</li>
<li>没有return，将undefined作为返回的对象的value。</li>
</ul>
</li>
<li>Next参数
<ul>
<li>next方法可以带一个参数，该参数会被当作上一个<code>yield</code>表达式的返回值。</li>
</ul>
</li>
</ul>
</li>
</ul>
<div><pre><code>
<span>function</span><span>*</span> <span>makeIterator</span><span>(</span><span>array</span><span>)</span> <span>{</span>
  <span>let</span> first <span>=</span> <span>yield</span> <span>1</span><span>;</span>
  <span>let</span> second <span>=</span> <span>yield</span> first <span>+</span> <span>2</span><span>;</span>
  <span>yield</span> second <span>+</span> <span>3</span><span>;</span>
<span>}</span>

<span>const</span> it <span>=</span> <span>makeIterator</span><span>(</span><span>)</span>

console<span>.</span><span>log</span><span>(</span>it<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// { value: 1, done: false }</span>
console<span>.</span><span>log</span><span>(</span>it<span>.</span><span>next</span><span>(</span><span>4</span><span>)</span><span>)</span> <span>// { value: 6, done: false }</span>
console<span>.</span><span>log</span><span>(</span>it<span>.</span><span>next</span><span>(</span><span>5</span><span>)</span><span>)</span> <span>// { value: 8, done: false }</span>
console<span>.</span><span>log</span><span>(</span>it<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// { value: undefined, done: true }</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><blockquote>
<p>执行过程：</p>
<ol>
<li>执行next()：遇到yield暂停，并返回生成器对象<code>{ value: 1, done: false }</code>;</li>
<li>执行next(4)：携带的参数修改了第一次next方法的返回值(1)，此时first 为 4，然后加 2 。<code>{ value: 6, done: false }</code></li>
<li>执行next(5)：携带的参数修改了第二次next(4)方法的返回值(6)，此时second为 8；<code>{ value: 8, done: false }</code></li>
<li>执行next()：没有return，将undefined作为返回的对象的value。<code>{ value: undefined, done: true }</code></li>
</ol>
</blockquote>
<h3 id="yield-生成器函数-可迭代对象"> <code>yield*</code>生成器函数/可迭代对象</h3>
<ul>
<li>委托给其他可迭代对象；</li>
<li>作用：服用生成器；</li>
<li>可以用来迭代任何可迭代对象；</li>
</ul>
<div><pre><code><span>function</span><span>*</span> <span>generator1</span><span>(</span><span>)</span> <span>{</span>
  <span>yield</span> <span>1</span><span>;</span>
  <span>yield</span> <span>2</span><span>;</span>
<span>}</span>

<span>function</span><span>*</span> <span>generator2</span><span>(</span><span>)</span> <span>{</span>
  <span>yield</span> <span>100</span><span>;</span>
  <span>yield</span><span>*</span> <span>generator1</span><span>(</span><span>)</span><span>;</span>
  <span>yield</span> <span>200</span><span>;</span>
<span>}</span>

<span>let</span> g2 <span>=</span> <span>generator2</span><span>(</span><span>)</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>g2<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// { value: 100, done: false }</span>
console<span>.</span><span>log</span><span>(</span>g2<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// { value: 1, done: false }</span>
console<span>.</span><span>log</span><span>(</span>g2<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// { value: 2, done: false }</span>
console<span>.</span><span>log</span><span>(</span>g2<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// { value: 200, done: false }</span>
console<span>.</span><span>log</span><span>(</span>g2<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// { value: undefined, done: true }</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><blockquote>
<p>以上例子中 <code>yield*</code>调用了 <code>generator2</code>生成器，并返回了每一次可迭代对象；</p>
</blockquote>
<h3 id="return-param"> return(param)</h3>
<ul>
<li>给定Param值终结遍历器，param可缺省。</li>
</ul>
<div><pre><code><span>function</span><span>*</span> <span>createIterator</span><span>(</span><span>)</span> <span>{</span>
  <span>yield</span> <span>1</span><span>;</span>
  <span>yield</span> <span>2</span><span>;</span>
  <span>yield</span> <span>3</span><span>;</span>
<span>}</span>

<span>let</span> iterator <span>=</span> <span>createIterator</span><span>(</span><span>)</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// { value: 1, done: false }</span>
console<span>.</span><span>log</span><span>(</span>iterator<span>.</span><span>return</span><span>(</span><span>)</span><span>)</span> <span>// { value: undefined, done: false }</span>
console<span>.</span><span>log</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// { value: undefined, done: false }</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="throw-param"> throw(param)</h3>
<ul>
<li>让生成器对象内部抛出错误。</li>
</ul>
<div><pre><code><span>function</span><span>*</span> <span>createIterator</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> first <span>=</span> <span>yield</span> <span>1</span><span>;</span>
  <span>let</span> second<span>;</span>
  <span>try</span> <span>{</span>
    second <span>=</span> <span>yield</span> first <span>+</span> <span>2</span><span>;</span>
  <span>}</span> <span>catch</span> <span>{</span>
    second <span>=</span> <span>6</span><span>;</span>
  <span>}</span>
  <span>yield</span> second <span>+</span> <span>3</span><span>;</span>
<span>}</span>

<span>let</span> iterator <span>=</span> <span>createIterator</span><span>(</span><span>)</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span> <span>// { value: 1, done: false }</span>
console<span>.</span><span>log</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>10</span><span>)</span><span>)</span> <span>// { value: 12, done: false }</span>
console<span>.</span><span>log</span><span>(</span>iterator<span>.</span><span>throw</span><span>(</span><span>new</span> <span>Error</span><span>(</span><span>'error'</span><span>)</span><span>)</span><span>)</span> <span>// { value: 9, done: false }</span>
console<span>.</span><span>log</span><span>(</span>iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span>  <span>// { value: undefined, done: true }</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><blockquote>
<p>以上示例中错误被try...catch处理了，如果没有被处理，则会抛出错误；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>Generator函数的实现原理</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-47/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-47/</guid>
      <source url="https://wangyawei.top/rss.xml">Generator函数的实现原理</source>
      <category>javascript</category>
      <pubDate>Tue, 22 Jun 2021 23:30:22 GMT</pubDate>
      <content:encoded><![CDATA[<p>协程</p>
<ul>
<li>一个线程存在多个协程，但同时只能执行一个。</li>
<li>Generator函数是协程在ES6的实现。</li>
<li>Yield挂起x协程(交给其他协程)，Next唤醒x协程；</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>co模块源码分析</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-48/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-48/</guid>
      <source url="https://wangyawei.top/rss.xml">co模块源码分析</source>
      <category>javascript</category>
      <pubDate>Wed, 04 Aug 2021 22:36:22 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>co模块是generator函数的自动执行函数，它基于 ES6 的 generator 和 yield ，让我们能用同步的形式编写异步代码。</p>
</blockquote>
<h2 id="示例"> 示例</h2>
<blockquote>
<p>我们知道调用生成器函数并不会实际执行函数体，而是返回一个生成器(迭代器)对象，然而co模块改变了这一现状；</p>
</blockquote>
<div><pre><code><span>function</span><span>*</span> <span>generator1</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> a <span>=</span> <span>yield</span> Promise<span>.</span><span>resolve</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>const</span> b <span>=</span> <span>yield</span> Promise<span>.</span><span>resolve</span><span>(</span><span>2</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>a<span>,</span> <span>'---'</span><span>,</span> b<span>)</span><span>;</span>
<span>}</span>

<span>const</span> it <span>=</span> <span>generator1</span><span>(</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>it<span>)</span><span>;</span>
it<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span>value<span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>res<span>)</span><span>;</span>
<span>}</span><span>)</span>
it<span>.</span><span>next</span><span>(</span><span>)</span><span>.</span>value<span>.</span><span>then</span><span>(</span><span>res</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>res<span>)</span><span>;</span>
<span>}</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>it<span>.</span><span>next</span><span>(</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><blockquote>
<p>上面函数的调用，你会发现第8行打印出来的是<code>Generator</code>对象，然而要想拿到两个promise的值，就必须执行<code>it.next()</code>方法并.then。而且函数中的console要想打印，就必须执行第15行的next()方法，可见利用<code>Generator</code>函数虽然可以让我们已同步的方式编写异步代码，但是我们却做了许多操作；</p>
</blockquote>
<div><p>提示</p>
<p><code>it.next()</code>如果不传值那么<code>yield</code>的值为<code>undefined</code>；</p>
</div>
<p>优化：使用<a href="https://github.com/tj/co#readme" target="_blank" rel="noopener noreferrer">co模块</a>，下载<code>index.js</code>文件并引入；</p>
<div><pre><code><span>co</span><span>(</span><span>function</span><span>*</span> <span>(</span><span>)</span> <span>{</span>
    <span>const</span> a <span>=</span> <span>yield</span> Promise<span>.</span><span>resolve</span><span>(</span><span>1</span><span>)</span><span>;</span>
    <span>const</span> b <span>=</span> <span>yield</span> Promise<span>.</span><span>resolve</span><span>(</span><span>2</span><span>)</span><span>;</span>
    console<span>.</span><span>log</span><span>(</span>a<span>,</span> <span>'---'</span><span>,</span> b<span>)</span><span>;</span> <span>// 1 --- 2</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>
<p>使用了co模块后你不需要在next便可以直接拿到值，这一步骤co帮我们做了；有没有感觉方便多了！</p>
</blockquote>
<div><p>提示</p>
<p><code>async/await</code>其实是<code>Generator</code>函数的语法糖；</p>
</div>
<h2 id="原理"> 原理</h2>
<blockquote>
<p>为什么 co 可以自动执行 Generator函数？我们知道Generator 就是一个异步操作的容器，它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。</p>
</blockquote>
<p>两种方法可以做到这一点：</p>
<ul>
<li>回调函数：将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。</li>
<li>Promise：将异步操作包装成 Promise 对象，用<code>then</code>方法交回执行权。</li>
</ul>
<p>co模块其实就是将<strong>两种自动执行器（Thunk 函数和 Promise 对象）</strong>，包装成了一个模块。使用 co 的前提条件是，Generator函数的<code>yield</code>命令后面，只能是 Thunk 函数或 Promise 对象。如果数组或对象的成员，全部都是 Promise 对象，也可以使用 co。</p>
<h3 id="源码下载"> 源码下载</h3>
<p><code>github</code>下载co模块源码；<a href="https://github.com/tj/co#readme" target="_blank" rel="noopener noreferrer">传送门</a>。或者找到<code>index.js</code>把里面的代码拷贝下来；</p>
<h3 id="源码分析"> 源码分析</h3>
<p>在源码中我们先找到co模块的入口：</p>
<div><pre><code><span>function</span> <span>co</span><span>(</span><span>gen</span><span>)</span> <span>{</span>
  <span>var</span> ctx <span>=</span> <span>this</span><span>;</span>
  <span>var</span> args <span>=</span> <span>slice</span><span>.</span><span>call</span><span>(</span>arguments<span>,</span> <span>1</span><span>)</span><span>;</span>

  <span>// co 模块返回 Promise</span>
  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>
    <span>// 这两句是判断gen是否为 Generator 函数，如果是就执行 onFulfilled ，如果不是就 resolve(gen)；</span>
    <span>if</span> <span>(</span><span>typeof</span> gen <span>===</span> <span>'function'</span><span>)</span> gen <span>=</span> <span>gen</span><span>.</span><span>apply</span><span>(</span>ctx<span>,</span> args<span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>!</span>gen <span>||</span> <span>typeof</span> gen<span>.</span>next <span>!==</span> <span>'function'</span><span>)</span> <span>return</span> <span>resolve</span><span>(</span>gen<span>)</span><span>;</span>

    <span>// 是 Generator函数调用 onFulfilled();</span>
    <span>onFulfilled</span><span>(</span><span>)</span><span>;</span>

    <span>function</span> <span>onFulfilled</span><span>(</span><span>res</span><span>)</span> <span>{</span>
      <span>var</span> ret<span>;</span>
      <span>try</span> <span>{</span>
        <span>// 因为在 gen.apply()时已经执行gen并返回了生成器对象，所以这里直接执行gen.next()方法；</span>
        ret <span>=</span> gen<span>.</span><span>next</span><span>(</span>res<span>)</span><span>;</span>
      <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
        <span>return</span> <span>reject</span><span>(</span>e<span>)</span><span>;</span>
      <span>}</span>
      <span>// 实现自动执行的关键代码就是这个，它执行了上一次返回的生成器对象；</span>
      <span>next</span><span>(</span>ret<span>)</span><span>;</span>
      <span>return</span> <span>null</span><span>;</span>
    <span>}</span>

    <span>function</span> <span>onRejected</span><span>(</span><span>err</span><span>)</span> <span>{</span>
      <span>var</span> ret<span>;</span>
      <span>try</span> <span>{</span>
        ret <span>=</span> gen<span>.</span><span>throw</span><span>(</span>err<span>)</span><span>;</span>
      <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
        <span>return</span> <span>reject</span><span>(</span>e<span>)</span><span>;</span>
      <span>}</span>
      <span>next</span><span>(</span>ret<span>)</span><span>;</span>
    <span>}</span>

    <span>function</span> <span>next</span><span>(</span><span>ret</span><span>)</span> <span>{</span>
      <span>// 判断 done 是否为true，如果为true则说明 generator函数执行完毕(没有需要执行的 yield语句了)</span>
      <span>// 返回最后执行的结果 resolve(ret.value);</span>
      <span>if</span> <span>(</span>ret<span>.</span>done<span>)</span> <span>return</span> <span>resolve</span><span>(</span>ret<span>.</span>value<span>)</span><span>;</span>
      <span>var</span> value <span>=</span> <span>toPromise</span><span>.</span><span>call</span><span>(</span>ctx<span>,</span> ret<span>.</span>value<span>)</span><span>;</span>
      <span>// 判断 value 是否为 promise，如果是就执行 then()方法，然后会调用 onFulfilled ！！！</span>
      <span>// 重点 在这里就形成了一个递归调用 会一直执行下去直到yield语句执行完毕；</span>
      <span>if</span> <span>(</span>value <span>&amp;&amp;</span> <span>isPromise</span><span>(</span>value<span>)</span><span>)</span> <span>return</span> value<span>.</span><span>then</span><span>(</span>onFulfilled<span>,</span> onRejected<span>)</span><span>;</span>
      <span>return</span> <span>onRejected</span><span>(</span><span>new</span> <span>TypeError</span><span>(</span><span>'You may only yield a function, promise, generator, array, or object, '</span>
        <span>+</span> <span>'but the following object was passed: "'</span> <span>+</span> <span>String</span><span>(</span>ret<span>.</span>value<span>)</span> <span>+</span> <span>'"'</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><div><p>提示</p>
<p>上面的代码中的核心部分就是<code>onFulfilled</code>和<code>next</code>这两个函数，产生了递归调用，从而实现了<code>Generator</code>函数的自动执行；</p>
</div>
<h3 id="co中其他方法介绍"> co中其他方法介绍</h3>
<ol>
<li>
<p>把非Promise的值转换为Promise:</p>
<div><pre><code><span>// 这里只转化 Object、Generator、Array、Function，其他类型直接返回不做处理；</span>
<span>// 所以next函数中会有这样的判断 if (value &amp;&amp; isPromise(value)) </span>
<span>function</span> <span>toPromise</span><span>(</span><span>obj</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span>obj<span>)</span> <span>return</span> obj<span>;</span>
  <span>if</span> <span>(</span><span>isPromise</span><span>(</span>obj<span>)</span><span>)</span> <span>return</span> obj<span>;</span>
  <span>if</span> <span>(</span><span>isGeneratorFunction</span><span>(</span>obj<span>)</span> <span>||</span> <span>isGenerator</span><span>(</span>obj<span>)</span><span>)</span> <span>return</span> <span>co</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> obj<span>)</span><span>;</span>
  <span>if</span> <span>(</span><span>'function'</span> <span>==</span> <span>typeof</span> obj<span>)</span> <span>return</span> <span>thunkToPromise</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> obj<span>)</span><span>;</span>
  <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>obj<span>)</span><span>)</span> <span>return</span> <span>arrayToPromise</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> obj<span>)</span><span>;</span>
  <span>if</span> <span>(</span><span>isObject</span><span>(</span>obj<span>)</span><span>)</span> <span>return</span> <span>objectToPromise</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> obj<span>)</span><span>;</span>
  <span>return</span> obj<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>
<li>
<p>Promise判断：</p>
<div><pre><code><span>// 此方法主要用于判断 一个变量是否是 Promise，</span>
<span>function</span> <span>isPromise</span><span>(</span><span>obj</span><span>)</span> <span>{</span>
  <span>// 只有 Promise 有 then方法；</span>
  <span>return</span> <span>'function'</span> <span>==</span> <span>typeof</span> obj<span>.</span>then<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>isGeneratorFunction判断：</p>
<div><pre><code><span>// 这一步主要是判断 obj 是否为 Generator 函数；</span>
<span>function</span> <span>isGeneratorFunction</span><span>(</span><span>obj</span><span>)</span> <span>{</span>
  <span>var</span> constructor <span>=</span> obj<span>.</span>constructor<span>;</span>
  <span>if</span> <span>(</span><span>!</span>constructor<span>)</span> <span>return</span> <span>false</span><span>;</span>
  <span>if</span> <span>(</span><span>'GeneratorFunction'</span> <span>===</span> constructor<span>.</span>name <span>||</span> <span>'GeneratorFunction'</span> <span>===</span> constructor<span>.</span>displayName<span>)</span> <span>return</span> <span>true</span><span>;</span>
  <span>return</span> <span>isGenerator</span><span>(</span>constructor<span>.</span>prototype<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>isGenerator判断：</p>
<div><pre><code><span>// 这一个和isGeneratorFunction是有区别的，这个判断的是 Generator 函数执行后返回的生成器对象；</span>
<span>function</span> <span>isGenerator</span><span>(</span><span>obj</span><span>)</span> <span>{</span>
  <span>return</span> <span>'function'</span> <span>==</span> <span>typeof</span> obj<span>.</span>next <span>&amp;&amp;</span> <span>'function'</span> <span>==</span> <span>typeof</span> obj<span>.</span>throw<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>isObject判断：</p>
<div><pre><code><span>function</span> <span>isObject</span><span>(</span><span>val</span><span>)</span> <span>{</span>
  <span>return</span> Object <span>==</span> val<span>.</span>constructor<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>arrayToPromise：数组转promise：</p>
<div><pre><code><span>function</span> <span>arrayToPromise</span><span>(</span><span>obj</span><span>)</span> <span>{</span>
  <span>return</span> Promise<span>.</span><span>all</span><span>(</span>obj<span>.</span><span>map</span><span>(</span>toPromise<span>,</span> <span>this</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>thunkToPromise判断</p>
<div><pre><code><span>function</span> <span>thunkToPromise</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
  <span>var</span> ctx <span>=</span> <span>this</span><span>;</span>
  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>function</span> <span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>{</span>
    <span>fn</span><span>.</span><span>call</span><span>(</span>ctx<span>,</span> <span>function</span> <span>(</span><span>err<span>,</span> res</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>err<span>)</span> <span>return</span> <span>reject</span><span>(</span>err<span>)</span><span>;</span>
      <span>if</span> <span>(</span>arguments<span>.</span>length <span>></span> <span>2</span><span>)</span> res <span>=</span> <span>slice</span><span>.</span><span>call</span><span>(</span>arguments<span>,</span> <span>1</span><span>)</span><span>;</span>
      <span>resolve</span><span>(</span>res<span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
<li>
<p>objectToPromise判断</p>
<div><pre><code><span>function</span> <span>objectToPromise</span><span>(</span><span>obj</span><span>)</span><span>{</span>
  <span>var</span> results <span>=</span> <span>new</span> <span>obj<span>.</span>constructor</span><span>(</span><span>)</span><span>;</span>
  <span>var</span> keys <span>=</span> Object<span>.</span><span>keys</span><span>(</span>obj<span>)</span><span>;</span>
  <span>var</span> promises <span>=</span> <span>[</span><span>]</span><span>;</span>
  <span>for</span> <span>(</span><span>var</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> keys<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>var</span> key <span>=</span> keys<span>[</span>i<span>]</span><span>;</span>
    <span>var</span> promise <span>=</span> <span>toPromise</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> obj<span>[</span>key<span>]</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>promise <span>&amp;&amp;</span> <span>isPromise</span><span>(</span>promise<span>)</span><span>)</span> <span>defer</span><span>(</span>promise<span>,</span> key<span>)</span><span>;</span>
    <span>else</span> results<span>[</span>key<span>]</span> <span>=</span> obj<span>[</span>key<span>]</span><span>;</span>
  <span>}</span>
  <span>return</span> Promise<span>.</span><span>all</span><span>(</span>promises<span>)</span><span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> results<span>;</span>
  <span>}</span><span>)</span><span>;</span>

  <span>function</span> <span>defer</span><span>(</span><span>promise<span>,</span> key</span><span>)</span> <span>{</span>
    <span>// predefine the key in the result</span>
    results<span>[</span>key<span>]</span> <span>=</span> <span>undefined</span><span>;</span>
    promises<span>.</span><span>push</span><span>(</span>promise<span>.</span><span>then</span><span>(</span><span>function</span> <span>(</span><span>res</span><span>)</span> <span>{</span>
      results<span>[</span>key<span>]</span> <span>=</span> res<span>;</span>
    <span>}</span><span>)</span><span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div></li>
</ul>
</li>
</ol>
<blockquote>
<p>实现自动执行器的原理简单的说就是 next方法结合Promise</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>深入理解async/await</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-49/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-49/</guid>
      <source url="https://wangyawei.top/rss.xml">深入理解async/await</source>
      <category>javascript</category>
      <pubDate>Thu, 24 Jun 2021 21:05:22 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>相对于回调函数来说，Promise是一种相对优雅的选择，那么有没有更好的方案呢？答案就是async/await。ES2017新增了两个关键字：async和await，代表异步javascript编程范式的迁移。允许我们编写像网络请求或其他异步事件而阻塞的同步代码一样编写异步代码。async函数是一个语法糖，它使异步操作更简单；</p>
</blockquote>
<p><strong>async/await优点：</strong></p>
<ul>
<li>从上到下，顺序执行，就像写同步代码一样，这更符合人编写代码的习惯。</li>
<li>async/await是基于协程的机制，是真正的“保存上下文，控制权切换 ... ... 控制权恢复，取回上下文”这种机制，是对异步过程更精确的一种描述。</li>
<li>async/await是对Promise的优化：</li>
</ul>
<h2 id="await表达式"> <code>await</code>表达式</h2>
<blockquote>
<p>await 表达式会暂停当前 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener noreferrer"><code>async function</code></a> 的执行，等待 Promise 处理完成。若 Promise 正常处理(fulfilled)，其回调的resolve函数参数作为 await 表达式的值，继续执行 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener noreferrer"><code>async function</code></a>。若 Promise 处理异常(rejected)，await 表达式会把 Promise 的异常原因抛出。另外，如果 await 操作符后的表达式的值不是一个 Promise，则返回该值本身。</p>
</blockquote>
<p>语法</p>
<div><pre><code><span>[</span>返回值<span>]</span> <span>=</span> <span>await</span> 表达式<span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>说明</p>
<ul>
<li>表达式： 一个 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener noreferrer"><code>Promise</code></a> 对象或者任何要等待的值。</li>
<li>返回值：返回 Promise 对象的处理结果。如果等待的不是 Promise 对象，则返回该值本身。</li>
</ul>
<div><p>提示</p>
<p><code>await</code> 操作符用于等待一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener noreferrer"><code>Promise</code></a> 对象。它只能在异步函数 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener noreferrer"><code>async function</code></a> 中使用。</p>
</div>
<p><strong>例：如果一个 Promise 被传递给一个 await 操作符，await 将等待 Promise 正常处理完成并返回其处理结果。</strong></p>
<div><pre><code><span>function</span> <span>resolveAfter2Seconds</span><span>(</span><span>x</span><span>)</span> <span>{</span>
  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>resolve</span> <span>=></span> <span>{</span>
    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>resolve</span><span>(</span>x<span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>2000</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span>

<span>async</span> <span>function</span> <span>f1</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span><span>;</span>
  <span>var</span> x <span>=</span> <span>await</span> <span>resolveAfter2Seconds</span><span>(</span><span>10</span><span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>x<span>)</span><span>;</span> <span>// 10</span>
<span>}</span>
<span>f1</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module.js 
<span>1</span>
<span>10</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><hr>
<p><strong>例：如果该值不是一个 Promise，await 会把该值转换为已正常处理的Promise，然后等待其处理结果。</strong></p>
<div><pre><code><span>async</span> <span>function</span> <span>f2</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> y <span>=</span> <span>await</span> <span>20</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>y<span>)</span><span>;</span> <span>// 20</span>
<span>}</span>
<span>f2</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module.js 
<span>20</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><hr>
<p><strong>例：如果 Promise 处理异常，则异常值被抛出。</strong></p>
<div><pre><code><span>async</span> <span>function</span> <span>f3</span><span>(</span><span>)</span> <span>{</span>
  <span>try</span> <span>{</span>
    <span>var</span> z <span>=</span> <span>await</span> Promise<span>.</span><span>reject</span><span>(</span><span>30</span><span>)</span><span>;</span>
  <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>e<span>)</span><span>;</span> <span>// 30</span>
  <span>}</span>
<span>}</span>
<span>f3</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module.js 
<span>30</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="async函数"> <code>async</code>函数</h2>
<blockquote>
<p>async函数是使用<code>async</code>关键字声明的函数。 async函数是<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/AsyncFunction" target="_blank" rel="noopener noreferrer"><code>AsyncFunction</code></a>构造函数的实例， 并且其中允许使用<code>await</code>关键字。<code>async</code>和<code>await</code>关键字让我们可以用一种更简洁的方式写出基于<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener noreferrer"><code>Promise</code></a>的异步行为，而无需刻意地链式调用<code>promise</code>。</p>
</blockquote>
<p>语法</p>
<div><pre><code><span>async</span> <span>function</span> <span>name</span><span>(</span><span><span>[</span>param<span>[</span><span>,</span> param<span>[</span><span>,</span> <span>...</span> param<span>]</span><span>]</span><span>]</span></span><span>)</span> <span>{</span>
    statements 
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>参数</p>
<ul>
<li>name：函数名称</li>
<li>param：要传递给函数的参数的名称。</li>
<li>statements：包含函数主体的表达式。可以使用<code>await</code>机制。</li>
</ul>
<p>返回值</p>
<ul>
<li>一个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener noreferrer"><code>Promise</code></a>，这个promise要么会通过一个由async函数返回的值被解决，要么会通过一个从async函数中抛出的（或其中没有被捕获到的）异常被拒绝。</li>
<li>return的值是promise resolved时候的value；</li>
<li>throw的值是promise rejected时候的reason；</li>
</ul>
<p><strong>例：return一个 1</strong></p>
<div><pre><code><span>async</span> <span>function</span> <span>f3</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>1</span><span>;</span>
<span>}</span>
<span>const</span> p <span>=</span> <span>f3</span><span>(</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>p<span>)</span><span>;</span>
p<span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>data</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>data<span>)</span><span>;</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code> ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module.js 
Promise <span>{</span> <span>1</span> <span>}</span>
<span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><hr>
<p><strong>例：return一个错误</strong></p>
<div><pre><code><span>async</span> <span>function</span> <span>f3</span><span>(</span><span>)</span> <span>{</span>
  <span>throw</span> <span>new</span> <span>Error</span><span>(</span><span>'error'</span><span>)</span><span>;</span>
<span>}</span>
<span>const</span> p <span>=</span> <span>f3</span><span>(</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>p<span>)</span><span>;</span>
p<span>.</span><span>catch</span><span>(</span><span>function</span><span>(</span><span>data</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>data<span>)</span><span>;</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module.js 
Promise <span>{</span>
  <span>&lt;</span>rejected<span>></span> Error: error
      at f3 <span>(</span>C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>test<span>\</span>module.js:2:9<span>)</span>
      at Object.<span>&lt;</span>anonymous<span>></span> <span>(</span>C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>test<span>\</span>module.js:4:11<span>)</span>
      at Module._compile <span>(</span>internal/modules/cjs/loader.js:999:30<span>)</span>
      at Object.Module._extensions<span>..</span>js <span>(</span>internal/modules/cjs/loader.js:1027:10<span>)</span>
      at Module.load <span>(</span>internal/modules/cjs/loader.js:863:32<span>)</span>
      at Function.Module._load <span>(</span>internal/modules/cjs/loader.js:708:14<span>)</span>
      at Function.executeUserEntryPoint <span>[</span>as runMain<span>]</span> <span>(</span>internal/modules/run_main.js:60:12<span>)</span>
      at internal/main/run_main_module.js:17:47
<span>}</span>
Error: error
    at f3 <span>(</span>C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>test<span>\</span>module.js:2:9<span>)</span>
    at Object.<span>&lt;</span>anonymous<span>></span> <span>(</span>C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>test<span>\</span>module.js:4:11<span>)</span>
    at Module._compile <span>(</span>internal/modules/cjs/loader.js:999:30<span>)</span>
    at Object.Module._extensions<span>..</span>js <span>(</span>internal/modules/cjs/loader.js:1027:10<span>)</span>
    at Module.load <span>(</span>internal/modules/cjs/loader.js:863:32<span>)</span>
    at Function.Module._load <span>(</span>internal/modules/cjs/loader.js:708:14<span>)</span>
    at Function.executeUserEntryPoint <span>[</span>as runMain<span>]</span> <span>(</span>internal/modules/run_main.js:60:12<span>)</span>
    at internal/main/run_main_module.js:17:47
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><blockquote>
<p>async函数可能包含0个或者多个<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener noreferrer"><code>await</code></a>表达式。await表达式会暂停整个async函数的执行进程并出让其控制权，只有当其等待的基于promise的异步操作被兑现或被拒绝之后才会恢复进程。promise的解决值会被当作该await表达式的返回值。使用<code>async</code> / <code>await</code>关键字就可以在异步代码中使用普通的<code>try</code> / <code>catch</code>代码块。</p>
</blockquote>
<div><p>提示</p>
<ul>
<li>
<p><code>await</code>关键字只在async函数内有效。如果你在async函数体之外使用它，就会抛出语法错误 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/SyntaxError" target="_blank" rel="noopener noreferrer"><code>SyntaxError</code></a> 。</p>
</li>
<li>
<p><code>async</code>/<code>await</code>的目的为了简化使用基于promise的API时所需的语法。<code>async</code>/<code>await</code>的行为就好像搭配使用了生成器和promise。</p>
</li>
<li>
<p>async函数一定会返回一个promise对象。如果一个async函数的返回值看起来不是promise，那么它将会被隐式地包装在一个promise中。</p>
<div><pre><code><span>async</span> <span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>
   <span>return</span> <span>1</span>
<span>}</span>
<span>// 等价于</span>
<span>function</span> <span>foo</span><span>(</span><span>)</span> <span>{</span>
   <span>return</span> Promise<span>.</span><span>resolve</span><span>(</span><span>1</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
</ul>
</div>
<div><p>注意</p>
<p>async函数的函数体可以被看作是由0个或者多个await表达式分割开来的。从第一行代码直到（并包括）第一个await表达式（如果有的话）都是同步运行的。这样的话，一个不含await表达式的async函数是会同步运行的。然而，如果函数体内有一个await表达式，async函数就一定会异步执行。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>async函数实现原理</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-50/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-50/</guid>
      <source url="https://wangyawei.top/rss.xml">async函数实现原理</source>
      <category>javascript</category>
      <pubDate>Thu, 24 Jun 2021 22:57:22 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Generator+自动执行器</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>promise A+规范</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-51/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-51/</guid>
      <source url="https://wangyawei.top/rss.xml">promise A+规范</source>
      <category>javascript</category>
      <pubDate>Tue, 29 Jun 2021 21:34:22 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>什么是<code>Promise A+</code>规范</strong></p>
<p>答：它一个开放、健全且通用的 JavaScript Promise 标准，由开发者制定，供开发者参考。<code>Promise A+</code>规范实际上是把之前 <a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="noopener noreferrer">Promise/A 规范</a> 中的建议，明确成为了行为标准：我们一方面扩展了原有规范约定俗成的行为，一方面删减了原规范的一些特例情况和有问题的部分。 <strong>Promises/A+ 规范不设计如何创建、解决和拒绝 promise，而是专注于提供一个通用的 <code>then</code> 方法</strong>；</p>
<div><p>提示</p>
<p>如果你想写出一个规范的 <code>Promise</code>，我们就需要遵循这个标准——<code>Promise A+</code>规范。</p>
</div>
<h2 id="术语"> 术语</h2>
<ul>
<li>promise：是一个拥有 <code>then</code> 方法的对象或函数，其行为符合本规范。</li>
<li>thenable：是一个定义了 <code>then</code> 方法的对象或函数。</li>
<li>值（value）：指任何 JavaScript 的合法值（包括 <code>undefined</code> , thenable 和 promise）；</li>
<li>异常（exception）：是使用 <code>throw</code> 语句抛出的一个值。</li>
<li>据因（reason）：表示一个 promise 的拒绝原因。</li>
</ul>
<h2 id="要求"> 要求</h2>
<ol>
<li>
<p><strong>Promise 的状态</strong>：一个 Promise 的当前状态必须为以下三种状态中的一种：<strong>等待态（Pending）</strong>、<strong>执行态（Fulfilled）<strong>和</strong>拒绝态（Rejected）</strong>。</p>
<ul>
<li><strong>Pending</strong>： 处于等待态时，promise 需满足以下条件。
<ul>
<li>可以迁移至执行态或拒绝态。</li>
</ul>
</li>
<li><strong>Fulfilled</strong>：处于执行态时，promise 需满足以下条件。
<ul>
<li>不能迁移至其他任何状态。</li>
<li>必须拥有一个<strong>不可变</strong>的终值。</li>
</ul>
</li>
<li><strong>Rejected</strong>：处于拒绝态时，promise 需满足以下条件。
<ul>
<li>不能迁移至其他任何状态。</li>
<li>必须拥有一个<strong>不可变</strong>的据因。
<ul>
<li>这里的不可变指的是恒等（===），而不是意味着更深层次的不可变（盖指当 value 或 reason 不是基本值时，只要求其引用地址相等，但属性值可被更改）。</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>Then 方法</strong>：一个 promise 必须提供一个 <code>then</code> 方法以访问其当前值、终值和据因。</p>
<div><pre><code><span>// 一个 promise 的then方法接受两个参数：</span>
promise<span>.</span><span>then</span><span>(</span>onFulfilled<span>,</span> onRejected<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>
<p><code>onFulfilled</code> 和 <code>onRejected</code> 都是可选参数。</p>
<ul>
<li>如果 <code>onFulfilled</code> 不是函数，其必须被忽略。</li>
<li>如果 <code>onRejected</code> 不是函数，其必须被忽。</li>
</ul>
</li>
<li>
<p><strong>onFulfilled</strong>：如果<code>onFulfilled</code>是一个函数。</p>
<ul>
<li>当 <code>promise</code> 执行结束后其必须被调用，并将<code>promise</code>的值作为它的第一个参数。</li>
<li>在<code>promise</code>完成之前不能调用它。</li>
<li>它不能被多次调用，其调用次数不可超过一次。</li>
</ul>
</li>
<li>
<p><strong>onRejected</strong>：如果<code>onRejected</code>是函数。</p>
<ul>
<li>当 <code>promise</code> 被拒绝执行后其必须被调用，其第一个参数为 <code>promise</code> 的据因(``reason`)。</li>
<li>在<code>promise</code>被拒绝之前不能调用它。</li>
<li>它不能被多次调用，其调用次数不可超过一次。</li>
</ul>
</li>
<li>
<p><code>onFulfilled</code> 和 <code>onRejected</code> 在<a href="https://es5.github.io/#x10.3" target="_blank" rel="noopener noreferrer">执行上下文</a>堆栈仅包含平台代码之前不得调用. [ <a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener noreferrer">3.1</a> ]。</p>
</li>
<li>
<p><code>onFulfilled</code> 和 <code>onRejected</code> 必须被当做函数调用 (即函数体内的 <code>this</code> 为<code>undefined</code>). [ <a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener noreferrer">3.2</a> ]</p>
</li>
<li>
<p>对于一个<code>promise</code>，它的then方法可以调用多次。</p>
<ul>
<li>当<code>promise</code> fulfilled后，所有<code>onFulfilled</code>都必须按照其注册顺序执行。</li>
<li>当<code>promise</code> rejected后，所有<code>OnRejected</code>都必须按照其注册顺序执行。</li>
</ul>
</li>
<li>
<p><code>then</code> 必须返回一个promise  [ <a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener noreferrer">3.3</a> ].</p>
<div><pre><code>promise2 <span>=</span> promise1<span>.</span><span>then</span><span>(</span>onFulfilled<span>,</span> onRejected<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>如果<code>onFulfilled</code> 或 <code>onRejected</code> 返回了值<code>x</code>, 则执行Promise 解析流程<code>[[Resolve]](promise2, x)</code>。</li>
<li>如果任一<code>onFulfilled</code> 或 <code>onRejected</code>抛出了异常<code>e</code>, 则<code>promise2</code>应当以<code>e</code>为<code>reason</code>被拒绝。</li>
<li>如果<code>onFulfilled</code>不是函数并且<code>promise1</code>已经fulfilled，则<code>promise2</code>必须以<code>promise1</code>的值fulfilled。</li>
<li>如果 <code>onReject</code> 不是一个函数且<code>promise1</code>已经rejected, 则<code>promise2</code>必须以相同的reason被拒绝.</li>
</ul>
</li>
</ul>
</li>
</ol>
<h2 id="promise解析过程"> Promise解析过程</h2>
<blockquote>
<p><strong>Promise解析过程</strong> 是以一个promise和一个值做为参数的抽象过程，可表示为<code>[[Resolve]](promise, x)</code></p>
</blockquote>
<ol>
<li>如果<code>promise</code> 和 <code>x</code> 指向相同的值, 使用 <code>TypeError</code>做为原因将<code>promise</code>拒绝。</li>
<li>如果 <code>x</code> 是一个<code>promise</code>, 采用其状态 [ <a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener noreferrer">3.4</a> ];
<ul>
<li>如果<code>x</code>是pending状态，<code>promise</code>必须保持pending状态，直到<code>x</code> fulfilled或rejected。</li>
<li>如果<code>x</code>是fulfilled状态，将<code>x</code>的值用于fulfill <code>promise</code>。</li>
<li>如果<code>x</code>是rejected状态, 将<code>x</code>的原因用于reject <code>promise</code>。</li>
</ul>
</li>
<li>如果<code>x</code>是一个对象或一个函数：
<ul>
<li>将 <code>then</code> 赋为 <code>x.then</code>.[ <a href="https://promisesaplus.com/#notes" target="_blank" rel="noopener noreferrer">3.5</a> ]</li>
<li>如果在取<code>x.then</code>值时抛出了异常，则以这个异常做为原因将<code>promise</code>拒绝。</li>
<li>如果 <code>then</code> 是一个函数， 以<code>x</code>为<code>this</code>调用<code>then</code>函数， 且第一个参数是<code>resolvePromise</code>，第二个参数是<code>rejectPromise</code>，且：
<ul>
<li>当 <code>resolvePromise</code> 被以 <code>y</code>为参数调用, 执行 <code>[[Resolve]](promise, y)</code>。</li>
<li>当 <code>rejectPromise</code> 被以 <code>r</code> 为参数调用, 则以<code>r</code>为原因将<code>promise</code>拒绝。</li>
<li>如果 <code>resolvePromise</code> 和 <code>rejectPromise</code> 都被调用了，或者被调用了多次，则只第一次有效，后面的忽略。</li>
<li>如果在调用<code>then</code>时抛出了异常，则：
<ul>
<li>如果 <code>resolvePromise</code> 或 <code>rejectPromise</code> 已经被调用了，则忽略它。</li>
<li>否则, 以<code>e</code>为reason将 <code>promise</code> 拒绝。</li>
</ul>
</li>
</ul>
</li>
<li>如果 <code>then</code>不是一个函数，则 以<code>x</code>为值fulfill <code>promise</code>。</li>
</ul>
</li>
<li>如果 <code>x</code> 不是对象也不是函数，则以<code>x</code>为值 fulfill <code>promise</code>。</li>
</ol>
<h2 id="参考资料"> 参考资料</h2>
<p>官方文档：https://promisesaplus.com/</p>
<p>详解Promise/Promise/A+ 规范：https://www.jianshu.com/p/2207b01e1174</p>
<p>Promise/A+规范：https://segmentfault.com/a/1190000002452115</p>
]]></content:encoded>
    </item>
    <item>
      <title>手写promise</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-52/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-52/</guid>
      <source url="https://wangyawei.top/rss.xml">手写promise</source>
      <category>javascript</category>
      <pubDate>Tue, 29 Jun 2021 21:42:22 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>在开始手写promise之前我们需要了解一个东西：<code>promise A+规范</code>，<a href="./javascript-note-51.html">传送门</a></p>
</blockquote>
<div><p>注意</p>
<p>要求：根据Promise/A+规范实现promise，使用promise-aplus-tests插件验证；</p>
</div>
<h3 id="代码"> 代码</h3>
<div><pre><code><span>// promise的状态</span>
<span>const</span> state <span>=</span> <span>{</span>
  <span>PENDING</span><span>:</span> <span>'pending'</span><span>,</span>
  <span>RESOLVE</span><span>:</span> <span>'resolve'</span><span>,</span>
  <span>REJECTED</span><span>:</span> <span>'rejected'</span><span>,</span>
<span>}</span>

<span>// 将promise设置为fulfilled状态</span>
<span>function</span> <span>fulfilledPromise</span><span>(</span><span>promise<span>,</span> value</span><span>)</span> <span>{</span>
  <span>// 只能从pending状态转换为其他状态；</span>
  <span>if</span> <span>(</span>promise<span>.</span>state <span>!==</span> stateMap<span>.</span><span>PENDING</span><span>)</span> <span>{</span>
    <span>return</span><span>;</span>
  <span>}</span>
  promise<span>.</span>state <span>=</span> stateMap<span>.</span><span>FULFILLED</span><span>;</span>
  promise<span>.</span>value <span>=</span> value<span>;</span>
  <span>runCbs</span><span>(</span>promise<span>.</span>fulfilledCbs<span>,</span> value<span>)</span><span>;</span>
<span>}</span>

<span>// 将promise设置为rejected状态</span>
<span>function</span> <span>rejectedPromise</span><span>(</span><span>promise<span>,</span> reason</span><span>)</span> <span>{</span>
  <span>// 只能从pending状态转换为其他状态；</span>
  <span>if</span> <span>(</span>promise<span>.</span>state <span>!==</span> stateMap<span>.</span><span>PENDING</span><span>)</span> <span>{</span>
    <span>return</span><span>;</span>
  <span>}</span>
  promise<span>.</span>state <span>=</span> stateMap<span>.</span><span>REJECTED</span><span>;</span>
  promise<span>.</span>reason <span>=</span> reason<span>;</span>
  <span>runCbs</span><span>(</span>promise<span>.</span>rejectedCbs<span>,</span> reason<span>)</span><span>;</span>
<span>}</span>

<span>function</span> <span>isFunction</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
  <span>return</span> <span>Object</span><span>.</span>prototype<span>.</span><span>toString</span><span>.</span><span>call</span><span>(</span>fn<span>)</span><span>.</span><span>toLocaleLowerCase</span><span>(</span><span>)</span> <span>===</span> <span>'[object function]'</span>
<span>}</span>

<span>function</span> <span>isObject</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
  <span>return</span> <span>Object</span><span>.</span>prototype<span>.</span>call<span>.</span><span>toString</span><span>(</span>fn<span>)</span><span>.</span><span>toLocaleLowerCase</span><span>(</span><span>)</span> <span>===</span> <span>'[object function]'</span>
<span>}</span>

<span>function</span> <span>isPromise</span><span>(</span><span><span>P</span></span><span>)</span> <span>{</span>
  <span>return</span> p <span>instanceof</span> <span>Promise</span><span>;</span>
<span>}</span>

<span>// promise解析</span>
<span>function</span> <span>resolvePromise</span><span>(</span><span>promise<span>,</span> x</span><span>)</span> <span>{</span>
  <span>// x 与 promise相同</span>
  <span>if</span> <span>(</span>promsie <span>===</span> x<span>)</span> <span>{</span>
    <span>rejectedPromise</span><span>(</span>promise<span>,</span> <span>new</span> <span>TypeError</span><span>(</span><span>'cant be the same'</span><span>)</span><span>)</span><span>;</span>
    <span>return</span><span>;</span>
  <span>}</span>

  <span>// x 是 promise</span>
  <span>if</span><span>(</span><span>isPromise</span><span>(</span>x<span>)</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>x<span>.</span>status <span>===</span> statusMap<span>.</span><span>FULFILLED</span><span>)</span> <span>{</span>
      <span>fulfilledPromise</span><span>(</span>promise<span>,</span> x<span>.</span>value<span>)</span><span>;</span>
      <span>return</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>x<span>.</span>status <span>===</span> statusMap<span>.</span><span>REJECTED</span><span>)</span> <span>{</span>
      <span>rejectedPromise</span><span>(</span>promise<span>,</span> x<span>.</span>reason<span>)</span><span>;</span>
      <span>return</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span>x<span>.</span>status <span>===</span> statusMap<span>.</span><span>PENDING</span><span>)</span> <span>{</span>
      x<span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        <span>fulfilledPromise</span><span>(</span>promise<span>,</span> x<span>.</span>value<span>)</span><span>;</span>
      <span>}</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
        <span>rejectedPromise</span><span>(</span>promise<span>,</span> x<span>.</span>reason<span>)</span><span>;</span>
      <span>}</span><span>)</span>
      <span>return</span><span>;</span>
    <span>}</span>
    <span>return</span><span>;</span>
  <span>}</span>

  <span>// x 是对象或者函数</span>
  <span>if</span> <span>(</span><span>isObject</span><span>(</span>x<span>)</span> <span>||</span> <span>isFunction</span><span>(</span>x<span>)</span><span>)</span> <span>{</span>
    <span>let</span> then<span>;</span>
    <span>try</span> <span>{</span>
      then <span>=</span> x<span>.</span>then<span>;</span>
    <span>}</span> <span>catch</span><span>(</span>error<span>)</span> <span>{</span>
      <span>rejectedPromise</span><span>(</span>promise<span>,</span> error<span>)</span><span>;</span>
      <span>return</span><span>;</span>
    <span>}</span>
    <span>if</span> <span>(</span><span>isFunction</span><span>(</span>then<span>)</span><span>)</span> <span>{</span>
      <span>try</span> <span>{</span>
        <span>then</span><span>.</span><span>call</span><span>(</span>x<span>,</span> <span>(</span><span>y</span><span>)</span> <span>=></span> <span>{</span>
          <span>if</span> <span>(</span>called<span>)</span> <span>{</span>
            <span>return</span><span>;</span>
          <span>}</span>
          called <span>=</span> <span>true</span><span>;</span>
          <span>resolvePromise</span><span>(</span>promise<span>,</span> y<span>)</span><span>;</span>
        <span>}</span><span>)</span>
      <span>}</span> <span>catch</span> <span>(</span>error<span>)</span> <span>{</span>
        <span>rejectedPromise</span><span>(</span>promise<span>,</span> r<span>)</span><span>;</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>fulfilledPromise</span><span>(</span>promise<span>,</span> x<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span><span>;</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// x 不是对象或者函数</span>
    <span>fulfilledPromise</span><span>(</span>promise<span>,</span> x<span>)</span><span>;</span>
    <span>return</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>runCbs</span><span>(</span><span>cbs<span>,</span> value</span><span>)</span> <span>{</span>
  cbs<span>.</span><span>forEach</span><span>(</span><span>cb</span> <span>=></span> <span>cb</span><span>(</span>value<span>)</span><span>)</span><span>;</span>
<span>}</span>
<span>class</span> <span>MyPromise</span> <span>{</span>
  <span>constructor</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
    <span>// 状态</span>
    <span>this</span><span>.</span>state <span>=</span> stateMap<span>.</span><span>PENDING</span><span>;</span>
    <span>// 结果值</span>
    <span>this</span><span>.</span>value <span>=</span> <span>undefined</span><span>;</span>
    <span>// 拒因</span>
    <span>this</span><span>.</span>reason <span>=</span> <span>undefined</span><span>;</span>
    <span>// 用于存放 then 中 fulfilled 的callback</span>
    <span>this</span><span>.</span>fulfilledCbs <span>=</span> <span>[</span><span>]</span><span>;</span>
    <span>// 用于存放 then 中 rejected 的callback</span>
    <span>this</span><span>.</span>rejectedCba <span>=</span> <span>[</span><span>]</span><span>;</span>
    <span>fn</span><span>(</span><span>(</span><span>value</span><span>)</span> <span>=></span> <span>{</span>
      <span>resolvePromise</span><span>(</span><span>this</span><span>,</span> value<span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>(</span><span>reason</span><span>)</span> <span>=></span> <span>{</span>
      <span>rejectedPromise</span><span>(</span><span>this</span><span>,</span> reason<span>)</span><span>;</span>
    <span>}</span><span>)</span>
  <span>}</span>

  <span>then</span><span>(</span><span>onFulfilled<span>,</span> onRejected</span><span>)</span> <span>{</span>
    <span>const</span> promise1 <span>=</span> <span>this</span><span>;</span>
    <span>const</span> promise2 <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>promise<span>.</span>state <span>===</span> state<span>.</span><span>FULFILLED</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>!</span><span>isFunction</span><span>(</span>onFulfilled<span>)</span><span>)</span> <span>{</span>
        <span>return</span> promse1
      <span>}</span>
      <span>// 因为then的执行是异步的所以这里要模拟异步的执行</span>
      <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        <span>try</span> <span>{</span>
          <span>// 调用then方法的参数(用户传进来的)</span>
          <span>const</span> x <span>=</span> <span>onFulfilled</span><span>(</span>promise1<span>.</span>value<span>)</span><span>;</span>
          <span>// 开始解析promise</span>
          <span>resolvePromise</span><span>(</span>promise2<span>,</span> x<span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span>error<span>)</span> <span>{</span>
          <span>rejectedPromise</span><span>(</span>promise2<span>,</span> error<span>)</span><span>;</span>
        <span>}</span>
      <span>}</span><span>,</span> <span>0</span><span>)</span>
    <span>}</span>

    <span>if</span> <span>(</span>promise<span>.</span>state <span>===</span> state<span>.</span><span>REJECTED</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>!</span><span>isFunction</span><span>(</span>onRejected<span>)</span><span>)</span> <span>{</span>
        <span>return</span> promse1
      <span>}</span>
      <span>// 因为then的执行是异步的所以这里要模拟异步的执行</span>
      <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        <span>try</span> <span>{</span>
          <span>// 调用then方法的参数(用户传进来的)</span>
          <span>const</span> x <span>=</span> <span>onRejected</span><span>(</span>promise1<span>.</span>value<span>)</span><span>;</span>
          <span>// 开始解析promise</span>
          <span>resolvePromise</span><span>(</span>promise2<span>,</span> x<span>)</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span>error<span>)</span> <span>{</span>
          <span>rejectedPromise</span><span>(</span>promise2<span>,</span> error<span>)</span><span>;</span>
        <span>}</span>
      <span>}</span><span>,</span> <span>0</span><span>)</span>
    <span>}</span>

    <span>if</span> <span>(</span>promise<span>.</span>state <span>===</span> state<span>.</span><span>PENDING</span><span>)</span> <span>{</span>
      promise1<span>.</span>fulfilledCbs<span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
          <span>try</span> <span>{</span>
            <span>const</span> x <span>=</span> <span>onFulfilled</span><span>(</span>promise1<span>.</span>value<span>)</span><span>;</span>
            <span>resolvePromise</span><span>(</span>promise2<span>,</span> x<span>)</span><span>;</span>
          <span>}</span> <span>catch</span> <span>(</span>error<span>)</span> <span>{</span>
            <span>rejectedPromise</span><span>(</span>promise2<span>,</span> error<span>)</span><span>;</span>
          <span>}</span>
        <span>}</span><span>,</span> <span>0</span><span>)</span>
      <span>}</span><span>)</span>
      promise1<span>.</span>rejectCbs<span>.</span><span>push</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
          <span>try</span> <span>{</span>
            <span>const</span> x <span>=</span> <span>onRejected</span><span>(</span>promise1<span>.</span>reason<span>)</span><span>;</span>
            <span>resolvePromise</span><span>(</span>promise2<span>,</span> x<span>)</span><span>;</span>
          <span>}</span> <span>catch</span> <span>(</span>error<span>)</span> <span>{</span>
            <span>rejectedPromise</span><span>(</span>promise<span>,</span> error<span>)</span><span>;</span>
          <span>}</span>
        <span>}</span><span>,</span> <span>0</span><span>)</span>
      <span>}</span><span>)</span>
    <span>}</span>
    <span>return</span> promise2<span>;</span>
  <span>}</span>
<span>}</span>

MyPromise<span>.</span><span>deferred</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>const</span> deferred <span>=</span> <span>{</span><span>}</span><span>;</span>
  deferred<span>.</span>promise <span>=</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>
    deferred<span>.</span>resolve <span>=</span> resolve<span>;</span>
    deferred<span>.</span>reject <span>=</span> reject<span>;</span>
  <span>}</span><span>)</span><span>;</span>
  <span>return</span> deferred<span>;</span>
<span>}</span>
module<span>.</span>exports <span>=</span> MyPromise<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br></div></div><h3 id="测试"> 测试</h3>
<ul>
<li>
<p>安装测试包；</p>
<div><pre><code><span>npm</span> <span>install</span> promises-aplus-tests -g
</code></pre>
<div><span>1</span><br></div></div><p><strong>注意这里要全局安装，本人在使用时非全局安装出现了问题</strong></p>
</li>
<li>
<p>开始测试</p>
<div><pre><code>promises-aplus-tests ./myPromise.js
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>测试结果</p>
<div><pre><code>    The value is <span><span>`</span><span>true</span><span>`</span></span> with <span><span>`</span>Boolean.prototype<span>`</span></span> modified to have a <span><span>`</span><span>then</span><span>`</span></span> method
      √ already-fulfilled
      √ immediately-fulfilled
      √ eventually-fulfilled
      √ already-rejected
      √ immediately-rejected
      √ eventually-rejected
    The value is <span><span>`</span><span>1</span><span>`</span></span> with <span><span>`</span>Number.prototype<span>`</span></span> modified to have a <span><span>`</span><span>then</span><span>`</span></span> method
      √ already-fulfilled
      √ immediately-fulfilled
      √ eventually-fulfilled
      √ already-rejected
      √ immediately-rejected
      √ eventually-rejected


  <span>872</span> passing <span>(</span>20s<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>创建和访问对象</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-53/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-53/</guid>
      <source url="https://wangyawei.top/rss.xml">创建和访问对象</source>
      <category>javascript</category>
      <pubDate>Thu, 01 Jul 2021 08:25:22 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>js是一个弱类型的语言，同时也是一个面向对象的编程的语言。</p>
</blockquote>
<h2 id="javascript的特点"> <code>javascript</code>的特点</h2>
<ul>
<li>一种解释性执行的脚本语言。
<ul>
<li>javascript不需要预先编译，而是在程序运行过程中被逐行地解释。</li>
</ul>
</li>
<li>一种基于对象的脚本语言。
<ul>
<li>开发者可以创建对象，这意味着JavaScript能运用其已经创建的对象进行开发。</li>
</ul>
</li>
<li>一种弱类型脚本语言。
<ul>
<li>它与强类型定义语言相反, 一个变量可以赋不同数据类型的值。</li>
</ul>
</li>
<li>一种相对安全脚本语言。
<ul>
<li>JavaScript作为一种安全性语言，不被允许访问本地的硬盘，且不能将数据存入服务器，不允许对网络文档进行修改和删除，只能通过浏览器实现信息浏览或动态交互。</li>
</ul>
</li>
<li>一种事件驱动脚本语言。
<ul>
<li>JavaScript对用户的响应，是以事件驱动的方式进行的。比如：点击鼠标，选择菜单等，这背后都注册的有一定的事件在里面。</li>
</ul>
</li>
<li>一种跨平台性脚本语言。
<ul>
<li>JavaScript依赖于浏览器本身，与操作环境无关，只要计算机能运行浏览器，并支持JavaScript的浏览器，就可正确执行，从而实现了“编写一次，走遍天下”的梦想。</li>
</ul>
</li>
</ul>
<h2 id="javascript的优缺点"> <code>javascript</code>的优缺点</h2>
<p><strong>优点</strong></p>
<ul>
<li>减少网络传输。
<ul>
<li>不需要把表单工作发送到服务器效验后再返回给浏览器，简单的验证可以直接再客户端进行，有效的减少了数据的传输。</li>
</ul>
</li>
<li>方便操纵HTML对象。
<ul>
<li>可以方便地操纵各种页面中的元素，使用JavaScript来控制页面中各个元素的外观、状态甚至运行方式，可以根据用户的需要“定制”浏览器，从而使网页更加友好。</li>
</ul>
</li>
<li>支持分布式运算。
<ul>
<li>JavaScript可以使多种任务仅在用户端就可以完成，而不需要网络和服务器的参与，从而支持分布式的运算和处理。</li>
</ul>
</li>
</ul>
<p><strong>缺点</strong></p>
<ul>
<li>各浏览器厂商对JavaScript支持程度不同。</li>
<li>“Web安全性”对JavaScript一些功能牺牲。
<ul>
<li>不能打开、读写和保存用户计算机上的文件。其有权访问的唯一信息就是该JavaScript所嵌入的那个Web主页中的信息</li>
</ul>
</li>
</ul>
<h2 id="创建和访问对象"> 创建和访问对象</h2>
<blockquote>
<p>JavaScript 中的对象实际上就是一个由属性组成的关联数组，属性由名称和值组成，值的类型可以是任何数据类型，或者函数和其他对象。</p>
</blockquote>
<p><strong>字面量方式创建对象</strong></p>
<div><pre><code><span>// 语法</span>
<span>var</span> obj <span>=</span> <span>{</span><span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>// 创建一个 foo 的对象；</span>
<span>const</span> foo <span>=</span> <span>{</span><span>}</span>
<span>// . 语法添加对象成员</span>
foo<span>.</span>prop_1 <span>=</span> <span>'bar'</span>
<span>// 关联数组的方式添加对象成员</span>
foo<span>[</span><span>'prop_2'</span><span>]</span> <span>=</span> <span>false</span>
foo<span>.</span><span>prop_3</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>'hello world'</span>
<span>}</span>
<span>// 关联数组的方式访问对象成员</span>
console<span>.</span><span>log</span><span>(</span>foo<span>[</span><span>'prop_2'</span><span>]</span><span>)</span> <span>// false</span>
<span>// . 语法访问对象</span>
console<span>.</span><span>log</span><span>(</span>foo<span>.</span><span>prop_3</span><span>(</span><span>)</span><span>)</span> <span>// 'hello world'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><strong>构造函数的方式创建对象</strong></p>
<div><pre><code><span>// 语法</span>
<span>var</span> obj <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>// 创建一个 foo 的对象；</span>
<span>const</span> foo <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
foo<span>.</span>prop_1 <span>=</span> <span>'bar'</span>
<span>// 关联数组的方式访问对象成员</span>
console<span>.</span><span>log</span><span>(</span>foo<span>.</span>prop_1<span>)</span> <span>// 'bar'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>方法创建对象</strong></p>
<div><pre><code><span>// 语法</span>
<span>var</span> obj <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>// 创建一个 foo 的对象；</span>
<span>const</span> foo <span>=</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span><span>;</span>
foo<span>.</span>prop_1 <span>=</span> <span>'bar'</span>
<span>// 关联数组的方式访问对象成员</span>
console<span>.</span><span>log</span><span>(</span>foo<span>.</span>prop_1<span>)</span> <span>// 'bar'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>创建对象时初始化对象成员</strong></p>
<div><pre><code><span>const</span> foo <span>=</span> <span>{</span>
  name<span>:</span> <span>'小明'</span>
<span>}</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>foo<span>.</span>name<span>)</span> <span>// 小明</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="参考资料"> 参考资料</h2>
<p>JavaScript弱类型语言的优缺点有哪些：http://www.elecfans.com/emb/593478.html</p>
]]></content:encoded>
    </item>
    <item>
      <title>编译原理</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-54/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-54/</guid>
      <source url="https://wangyawei.top/rss.xml">编译原理</source>
      <category>javascript</category>
      <pubDate>Sun, 20 Jun 2021 22:18:22 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>尽管开发者将 JavaScript 归类为“动态”或“解释执行”语言，但事实上它是一门编译语言。
在传统编译语言的流程中，程序中的一段源代码在执行之前会经历三个步骤，统称为“编译”。</p>
</blockquote>
<h2 id="分词-词法分析"> 分词/词法分析</h2>
<blockquote>
<p>这个过程会将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，这些代码块被称为词法单元。例如，考虑程序 var a = 2;。这段程序通常会被分解成为下面这些词法单元： var、 a、 =、 2 、 ;空格是否会被当作词法单元，取决于空格在这门语言中是否具有意义。</p>
</blockquote>
<div><p>提示</p>
<p>分词（tokenizing）和词法分析（Lexing）之间的区别是非常微妙、晦涩的，主要差异在于词法单元的识别是通过有状态还是无状态的方式进行的。简单来说，如果词法单元生成器在判断 a 是一个独立的词法单元还是其他词法
单元的一部分时，调用的是有状态的解析规则，那么这个过程就被称为词法分析。</p>
</div>
<h2 id="解析-语法分析"> 解析/语法分析</h2>
<blockquote>
<p>这个过程是将词法单元流（数组）转换成一个由元素逐级嵌套所组成的代表了程序语法结构的树。这个树被称为“抽象语法树”（Abstract Syntax Tree， AST）。var a = 2; 的抽象语法树中可能会有一个叫作 VariableDeclaration 的顶级节点，接下来是一个叫作 Identifier（它的值是 a）的子节点，以及一个叫作 AssignmentExpression的子节点。 AssignmentExpression 节点有一个叫作 NumericLiteral（它的值是 2）的子节点。</p>
</blockquote>
<h2 id="代码生成"> 代码生成</h2>
<blockquote>
<p>将 AST 转换为可执行代码的过程被称为代码生成。</p>
</blockquote>
<p>简单来说就是有某种方法可以将 var a = 2; 的 AST 转化为一组机器指
令，用来创建一个叫作 a 的变量（包括分配内存等），并将一个值储存在 a 中。</p>
<div><p>提示</p>
<p>比起那些编译过程只有三个步骤的语言的编译器， JavaScript 引擎要复杂得多。例如，在语法分析和代码生成阶段有特定的步骤来对运行性能进行优化，包括对冗余元素进行优化等，JavaScript 引擎不会有大量的（像其他语言编译器那么多的）时间用来进行优化，因为与其他语言不同， JavaScript 的编译过程不是发生在构建之前的。对于 JavaScript 来说，大部分情况下编译发生在代码执行前的几微秒（甚至更短！）的时间内。因此，JavaScript 编译器首先会对 var a = 2; 这段程序进行编译，然后做好执行它的准备，并且通常马上就会执行它。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>chunk函数及其应用</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-55/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-55/</guid>
      <source url="https://wangyawei.top/rss.xml">chunk函数及其应用</source>
      <category>javascript</category>
      <pubDate>Sun, 20 Jun 2021 22:18:22 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="特点"> 特点</h2>
<ul>
<li>求值策略：传值调用，传名调用sum(x+1,x+2);</li>
<li>thunk函数是传名调用的实现方式之一；</li>
<li>可以实现自动执行Generator函数；</li>
</ul>
<h2 id="应用"> 应用</h2>
<blockquote>
<p>需求：顺序的打印下列文件</p>
</blockquote>
<h3 id="普通方法嵌套"> <strong>普通方法嵌套</strong></h3>
<div><pre><code><span>function</span> <span>readFilesByCallback</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>"fs"</span><span>)</span><span>;</span>
    <span>const</span> files <span>=</span> <span>[</span>
        <span>"./1.text"</span><span>,</span>
        <span>"./2.text"</span><span>,</span>
        <span>"./3.text"</span>
    <span>]</span><span>;</span>
    fs<span>.</span><span>readFile</span><span>(</span>files<span>[</span><span>0</span><span>]</span><span>,</span> <span>function</span><span>(</span><span>err<span>,</span> data</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span>data<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
        fs<span>.</span><span>readFile</span><span>(</span>files<span>[</span><span>1</span><span>]</span><span>,</span> <span>function</span><span>(</span><span>err<span>,</span> data</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span>data<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
            fs<span>.</span><span>readFile</span><span>(</span>files<span>[</span><span>2</span><span>]</span><span>,</span> <span>function</span><span>(</span><span>err<span>,</span> data</span><span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span>data<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span>
<span>// 调用</span>
<span>readFilesByCallback</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><div><pre><code><span>ASUS</span>@yaweidediannao <span>MINGW64</span> <span>~</span><span>/</span>Desktop<span>/</span>test
$ node module<span>.</span>js 
text1
text2
text3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>
<p>形成了回调地狱；</p>
</blockquote>
<h3 id="使用generator函数"> <strong>使用<code>Generator</code>函数；</strong></h3>
<div><pre><code><span>function</span><span>*</span> <span>readFilesByGenerator</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>"fs"</span><span>)</span><span>;</span>
    <span>const</span> files <span>=</span> <span>[</span>
        <span>"./1.text"</span><span>,</span>
        <span>"./2.text"</span><span>,</span>
        <span>"./3.text"</span>
    <span>]</span><span>;</span>
    <span>function</span> <span>readFile</span><span>(</span><span>filename</span><span>)</span> <span>{</span>
        fs<span>.</span><span>readFile</span><span>(</span>filename<span>,</span> <span>function</span><span>(</span><span>err<span>,</span> data</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span>data<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
            f<span>.</span><span>next</span><span>(</span>data<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>
    <span>yield</span> <span>readFile</span><span>(</span>files<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
    <span>yield</span> <span>readFile</span><span>(</span>files<span>[</span><span>1</span><span>]</span><span>)</span><span>;</span>
    <span>yield</span> <span>readFile</span><span>(</span>files<span>[</span><span>2</span><span>]</span><span>)</span><span>;</span>
<span>}</span>
<span>// 调用</span>
<span>const</span> f <span>=</span> <span>readFilesByGenerator</span><span>(</span><span>)</span><span>;</span>

f<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module.js 
text1
text2
text3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>
<p>虽然解决了层层的嵌套，但是<code>f.next()</code>的调用耦合在文件读取的回调函数里面了，不好；</p>
</blockquote>
<h3 id="使用chunk函数"> <strong>使用chunk函数</strong></h3>
<div><pre><code><span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>"fs"</span><span>)</span><span>;</span>
<span>const</span> <span>Thunk</span> <span>=</span> <span>function</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
  <span>return</span> <span>function</span><span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>
    <span>return</span> <span>function</span><span>(</span><span>callback</span><span>)</span> <span>{</span>
      <span>return</span> <span>fn</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> <span>...</span>args<span>,</span> callback<span>)</span><span>;</span>
    <span>}</span><span>;</span>
  <span>}</span><span>;</span>
<span>}</span><span>;</span>
<span>const</span> readFileThunk <span>=</span> <span>Thunk</span><span>(</span>fs<span>.</span>readFile<span>)</span><span>;</span>

<span>function</span> <span>run</span><span>(</span><span>fn</span><span>)</span> <span>{</span>
  <span>var</span> gen <span>=</span> <span>fn</span><span>(</span><span>)</span><span>;</span>
  <span>function</span> <span>next</span><span>(</span><span>err<span>,</span> data</span><span>)</span> <span>{</span>
    <span>var</span> result <span>=</span> gen<span>.</span><span>next</span><span>(</span>data<span>)</span><span>;</span>
    <span>if</span> <span>(</span>result<span>.</span>done<span>)</span> <span>return</span><span>;</span>
    result<span>.</span><span>value</span><span>(</span>next<span>)</span><span>;</span>
  <span>}</span>
  <span>next</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>const</span> <span>g</span> <span>=</span> <span>function</span><span>*</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> s1 <span>=</span> <span>yield</span> <span>readFileThunk</span><span>(</span><span>"./1.text"</span><span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>s1<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
  <span>const</span> s2 <span>=</span> <span>yield</span> <span>readFileThunk</span><span>(</span><span>"./2.text"</span><span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>s2<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
  <span>const</span> s3 <span>=</span> <span>yield</span> <span>readFileThunk</span><span>(</span><span>"./3.text"</span><span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>s3<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span><span>;</span>

<span>run</span><span>(</span>g<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/test
$ node module.js 
text1
text2
text3
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Rxjs</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-56/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-56/</guid>
      <source url="https://wangyawei.top/rss.xml">Rxjs</source>
      <category>javascript</category>
      <pubDate>Wed, 04 Aug 2021 23:18:22 GMT</pubDate>
    </item>
    <item>
      <title>Web Workers</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/javascript-note-57/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/javascript-note-57/</guid>
      <source url="https://wangyawei.top/rss.xml">Web Workers</source>
      <category>javascript</category>
      <pubDate>Sun, 08 Aug 2021 15:07:22 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>web worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。当在 HTML 页面中执行脚本时，页面的状态是不可响应的，直到脚本已完成。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。</p>
</blockquote>
<h2 id="web-worker是什么"> web worker是什么</h2>
<blockquote>
<p>web worker 是运行在后台的 JavaScript。</p>
</blockquote>
<ul>
<li>一个Web API 提供了一个js可以运行的环境。</li>
<li>web应用程序可以在独立于主线程的后台线程中，运行一个脚本操作。</li>
</ul>
<h2 id="解决的痛点是什么"> 解决的痛点是什么</h2>
<p>js执行复杂运算时候阻塞了页面渲染；</p>
<h2 id="web-worker限制"> web worker限制</h2>
<ul>
<li>与主线程脚本同源；</li>
<li>与主线程的上下文不同；
<ul>
<li>无法操作DOM；</li>
<li>不能执行alert；</li>
</ul>
</li>
<li>不能读取本地文件；</li>
</ul>
<h2 id="执行过程"> 执行过程</h2>
<p><img src="./assets/image-20210808145629319.png" alt="image-20210808145629319" /></p>
<blockquote>
<p>如上图所示：主线程有一个<code>postMessage</code>方法用于发送消息，worker线程有<code>onMessage</code>方法用于监听消息，同时worker线程有一个<code>postMessage</code>方法，用于向主线程说明消息已经收到，然后主线程接收到结果就可以做自己的逻辑了。</p>
</blockquote>
<h2 id="外部引用web-worker文件"> 外部引用web worker文件</h2>
<p><strong>创建 web worker 文件:</strong></p>
<div><pre><code><span>// worker.js`:</span>
<span>// 检测浏览器是否支持Worker：</span>
<span>if</span> <span>(</span><span>typeof</span><span>(</span>Worker<span>)</span> <span>!==</span> <span>'undefined'</span><span>)</span> <span>{</span>
    <span>function</span> <span>fibonacci</span><span>(</span><span>n</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>n <span>===</span> <span>1</span> <span>||</span> n <span>===</span> <span>2</span><span>)</span> <span>{</span>
            <span>return</span> <span>1</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>fibonacci</span><span>(</span>n<span>-</span><span>2</span><span>)</span> <span>+</span> <span>fibonacci</span><span>(</span>n<span>-</span><span>1</span><span>)</span><span>;</span>
    <span>}</span>
    <span>// 发送消息</span>
    <span>postMessage</span><span>(</span><span>fibonacci</span><span>(</span><span>40</span><span>)</span><span>)</span><span>;</span>
    
    <span>// 监听worker线程传过来的消息</span>
    <span>onmessage</span> <span>=</span> <span>function</span><span>(</span><span>e</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span>e<span>,</span> <span>'worker'</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>创建 Web Worker 对象:</strong> 检测是否存在 worker，如果不存在，创建一个新的 web worker 对象，然后运行<code>worker.js</code> 中的代码</p>
<div><pre><code><span>let</span> worker<span>;</span>
<span>if</span> <span>(</span><span>typeof</span><span>(</span>worker<span>)</span> <span>===</span> <span>'undefined'</span><span>)</span> <span>{</span>
    <span>// 创建worker</span>
    worker <span>=</span> <span>new</span> <span>Worker</span><span>(</span><span>'./worker.js'</span><span>)</span><span>;</span>

    <span>// // 监听主线程传过来的消息</span>
    worker<span>.</span><span>onmessage</span> <span>=</span> <span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'worker通知的message'</span><span>,</span> e<span>)</span><span>;</span>
        worker<span>.</span><span>postMessage</span><span>(</span><span>'message收到了'</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>运行：</strong></p>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>ie=edge<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span><span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>./webworker.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>
<p>fibonacci(40)运行的结果在 <strong>onmessage</strong>事件对象的 data 中；</p>
</blockquote>
<div><p>注意</p>
<p>由于 web worker 位于外部文件中，它们无法访问下列 JavaScript 对象：</p>
<ul>
<li>window 对象</li>
<li>document 对象</li>
<li>parent 对象</li>
</ul>
</div>
<h2 id="嵌入式worker"> 嵌入式worker</h2>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>

<span><span><span>&lt;</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width, initial-scale=1.0<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>ie=edge<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>

<span><span><span>&lt;</span>script</span> <span>id</span><span><span>=</span><span>"</span>worker<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>javascript/worker<span>"</span></span><span>></span></span><span><span>
  <span>function</span> <span>fibonacci</span><span>(</span><span>n</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>n <span>===</span> <span>1</span> <span>||</span> n <span>===</span> <span>2</span><span>)</span> <span>{</span>
          <span>return</span> <span>1</span><span>;</span>
      <span>}</span>
      <span>return</span> <span>fibonacci</span><span>(</span>n<span>-</span><span>2</span><span>)</span> <span>+</span> <span>fibonacci</span><span>(</span>n<span>-</span><span>1</span><span>)</span><span>;</span>
  <span>}</span>
  <span>postMessage</span><span>(</span><span>fibonacci</span><span>(</span><span>40</span><span>)</span><span>)</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
  <span>// 读取script标签中的代码字符串；</span>
  <span>const</span> workerScript <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>'#worker'</span><span>)</span><span>.</span>textContent<span>;</span>
  <span>// 转化为blob</span>
  <span>const</span> blob <span>=</span> <span>new</span> <span>Blob</span><span>(</span><span>[</span>workerScript<span>]</span><span>,</span> <span>{</span> type<span>:</span> <span>"text/javascript"</span> <span>}</span><span>)</span><span>;</span>
  <span>// 创建worker对象；</span>
  <span>const</span> worker <span>=</span> <span>new</span> <span>Worker</span><span>(</span>window<span>.</span><span>URL</span><span>.</span><span>createObjectURL</span><span>(</span>blob<span>)</span><span>)</span><span>;</span>
  <span>// 监听消息通知</span>
  worker<span>.</span><span>onmessage</span> <span>=</span> <span>function</span><span>(</span><span>e</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'worker通知message'</span><span>,</span> e<span>)</span><span>;</span>
  <span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><blockquote>
<p>script标签的type应该是：<code>javascript/worker</code></p>
</blockquote>
<h2 id="使用场景"> 使用场景</h2>
<ul>
<li>复杂运算；</li>
<li>渲染优化；</li>
<li>流媒体数据处理；</li>
<li>性能考虑，web workers主要用于更耗费 CPU 资源的任务。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/frontEnd/jquery/</link>
      <guid>https://wangyawei.top/views/frontEnd/jquery/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>JQUERY</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些和jquery相关的知识点；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>jquery 基础</title>
      <link>https://wangyawei.top/views/frontEnd/jquery/jquery-note-00/</link>
      <guid>https://wangyawei.top/views/frontEnd/jquery/jquery-note-00/</guid>
      <source url="https://wangyawei.top/rss.xml">jquery 基础</source>
      <category>JQUERY</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="jquery简介"> jQuery简介；</h2>
<h3 id="使用javascript的不便之处"> 使用JavaScript的不便之处：</h3>
<div><pre><code><span>-</span>查找元素的方法太少，麻烦。
<span>-</span>遍历伪数组很麻烦，通常要嵌套一大堆的<span>for</span>循环。
<span>-</span>有兼容性问题。
<span>-</span>想要实现简单的动画效果，也很麻烦
<span>-</span>代码冗余。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="jquery的优点好处"> jQuery的优点好处</h3>
<div><pre><code>具有独特的链式语法和短小清晰的多功能接口；具有高效灵活的css选择器，并且可对CSS选择器进行扩展；拥有便捷的插件扩展机制和丰富的插件。jQuery兼容各种主流浏览器。
</code></pre>
<div><span>1</span><br></div></div><h3 id="jquery的基本使用"> jQuery的基本使用；</h3>
<ul>
<li>jQuery官网下载地址（https://jquery.com/）；</li>
<li>jQuery版本介绍及下载地址（<a href="https://code.jquery.com/" target="_blank" rel="noopener noreferrer">https://code.jquery.com/</a>）；</li>
</ul>
<p>优点总结：</p>
<div><pre><code><span>-</span>查找元素的方法多种多样，非常灵活
<span>-</span>拥有隐式迭代特性，因此不再需要手写<span>for</span>循环了。
<span>-</span>完全没有兼容性问题。
<span>-</span>实现动画非常简单，而且功能更加的强大。
<span>-</span>代码简单、粗暴。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>
<div><pre><code><span>$</span><span>(</span>document<span>)</span><span>.</span><span>ready</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>$</span><span>(</span><span>'#btn1'</span><span>)</span><span>.</span><span>click</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
      	<span>// 隐式迭代：偷偷的遍历，在jQuery中，不需要手动写for循环了，会自动进行遍历。</span>
        <span>$</span><span>(</span><span>'div'</span><span>)</span><span>.</span><span>show</span><span>(</span><span>200</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>

    <span>$</span><span>(</span><span>'#btn2'</span><span>)</span><span>.</span><span>click</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>$</span><span>(</span><span>'div'</span><span>)</span><span>.</span><span>text</span><span>(</span><span>'我是内容'</span><span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
</ul>
<h3 id="jquery代码的书写顺序"> JQuery代码的书写顺序：</h3>
<div><pre><code><span>1.</span> 在<span>THML</span>结构后使用
     <span>$</span><span>(</span>选择器<span>)</span><span>.</span><span>方法</span><span>(</span><span>)</span>
     例如：
     <span>$</span><span>(</span><span>'div'</span><span>)</span><span>.</span><span>hide</span><span>(</span><span>)</span>

<span>2.</span> 在<span>HTML</span>结构之前使用

    <span>$</span><span>(</span><span>function</span><span>(</span><span>)</span><span>{</span>
       <span>//入口函数：当页面中的DOM元素都加载完成后就执行该处代码</span>
       <span>//jQuery代码</span>
    <span>}</span><span>)</span>

    或者
    <span>$</span><span>(</span>document<span>)</span><span>.</span><span>ready</span><span>(</span><span>function</span><span>(</span><span>)</span><span>{</span>
       <span>//入口函数：当页面中的DOM元素都加载完成后就执行该处代码</span>
       <span>//jQuery代码</span>
    <span>}</span><span>)</span>

<span>3.</span> jQuery中的入口函数与js中的load事件是有差异的：
 ☞ js中的load事件是整个页面的静态资源文件都加载完毕后才执行；
 ☞ jQuery中的入口函数是整个文档加载完成后就立即执行代码；
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id="jquery中顶级对象"> jQuery中顶级对象</h3>
<p>jQuery中的顶级对象是$或jQuery</p>
<ul>
<li>$是jQuery的一个别名；</li>
</ul>
<div><pre><code><span>例如：$</span><span>(</span><span>'div'</span><span>)</span><span>.</span><span>hide</span><span>(</span><span>)</span>  <span>===</span>》 <span>jQuery</span><span>(</span><span>'div'</span><span>)</span><span>.</span><span>hied</span><span>(</span><span>)</span>；

通过 <span>$</span><span>(</span><span>'div'</span><span>)</span> 将dom对象包装成一个jQuery对象。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>注意：jQuery中的$和JQuery关键字本身为同一对象；</strong></p>
<h3 id="jquery中页面加载事件"> jQuery中页面加载事件</h3>
<p>使用jQuery的三个步骤：</p>
<div><pre><code>引入jQuery文件
入口函数
功能实现
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>关于jQuery的入口函数：</p>
<div><pre><code><span>// 第一种写法</span>
<span>$</span><span>(</span>document<span>)</span><span>.</span><span>ready</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
	
<span>}</span><span>)</span><span>;</span>
<span>// 第二种写法</span>
<span>$</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
	
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="jquery对象和dom对象"> jQuery对象和DOM对象</h2>
<h4 id="dom对象"> DOM对象</h4>
<div><pre><code>	用原生JavaScript获取的<span>DOM</span>对象
	通过document<span>.</span><span>getElementById</span><span>(</span><span>)</span>  <span>反馈的是元素</span><span>(</span><span>DOM</span>对象<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="jquery对象"> jQuery对象</h4>
<div><pre><code>jQuery对象用$()的方式获取的对象
jQuery对象又可以叫做包装集(包装的DOM对象的集合)
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h4 id="区别"> 区别;</h4>
<ul>
<li><strong>jQuery对象不能使用DOM对象的成员，DOM对象不能使用jQuery对象的成员</strong></li>
</ul>
<div><pre><code><span>// DOM对象</span>
<span>var</span> box <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'box'</span><span>)</span><span>;</span>
<span>// 错误</span>
box<span>.</span><span>text</span><span>(</span><span>'hello'</span><span>)</span><span>;</span>
<span>// 正确</span>
box<span>.</span>innerText <span>=</span> <span>'hello'</span><span>;</span>

<span>// jQuery对象，jQuery对象加前缀$，用以区分DOM对象</span>
<span>var</span> $box <span>=</span> <span>$</span><span>(</span><span>'#box'</span><span>)</span><span>;</span>
<span>// 错误</span>
$box<span>.</span>innerText <span>=</span> <span>'hello'</span><span>;</span>
<span>// 正确</span>
$box<span>.</span><span>text</span><span>(</span><span>'hello'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="jquery对象和dom对象的相互转换"> jQuery对象和DOM对象的相互转换;</h3>
<div><pre><code>将jQuery对象转化为Dom对象的原因：
<span>1.</span> jQuery并没有将js中所有的方法和属性封装，所以js原生中的一些方法和属性jQuery是不支持的
   
jQuery获取到的对象是以伪数组形式存储的【也就是jQuery中是以数组形式存储的每一个<span>DOM</span>对象】

jQuery对象转<span>DOM</span>对象的方式：
	<span>$</span><span>(</span><span>'div'</span><span>)</span><span>[</span>索引<span>]</span>
	<span>$</span><span>(</span><span>'div'</span><span>)</span><span>.</span><span>get</span><span>(</span>索引<span>)</span>

<span>DOM</span>对象转换成jQuery对象：   
	<span>$</span><span>(</span><span>DOM</span>对象<span>)</span> 只有这一种方法<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="案例"> 案例</h3>
<ul>
<li>开关灯 [01-开关灯.html]</li>
</ul>
<div><pre><code><span>// 仅仅演示对象之间的转换，代码不推荐这么写</span>
<span>jQuery</span><span>(</span>document<span>)</span><span>.</span><span>ready</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
  <span>// 获取元素；</span>
  <span>var</span> inpArr <span>=</span> document<span>.</span><span>getElementsByTagName</span><span>(</span><span>'input'</span><span>)</span><span>;</span>
  <span>// 获取第一个按钮，然后绑定事件；</span>
  <span>$</span><span>(</span>inpArr<span>[</span><span>0</span><span>]</span><span>)</span><span>.</span><span>click</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>// 设置body的背景色</span>
    <span>$</span><span>(</span><span>'body'</span><span>)</span><span>[</span><span>0</span><span>]</span><span>.</span>style<span>.</span>background <span>=</span> <span>'#fff'</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
  <span>// 获取第二个按钮，然后绑定事件；</span>
  <span>$</span><span>(</span>inpArr<span>[</span><span>1</span><span>]</span><span>)</span><span>.</span><span>click</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
    <span>// 设置body的背景色</span>
    <span>$</span><span>(</span><span>'body'</span><span>)</span><span>.</span><span>get</span><span>(</span><span>0</span><span>)</span><span>.</span>style<span>.</span>background <span>=</span> <span>'#000'</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="选择器"> 选择器</h2>
<ul>
<li>
<p>jQuery选择器是jQuery为我们提供的一组方法，让我们更加方便的获取到页面中的元素。</p>
</li>
<li>
<p>注意：jQuery选择器返回的是jQuery对象。</p>
</li>
<li>
<p>jQuery选择器虽然很多，但是选择器之间可以相互替代，就是说获取一个元素，你会有很多种方法获取到。</p>
</li>
</ul>
<h3 id="jquery基本选择器"> jQuery基本选择器</h3>
<div><pre><code>  语法：   <span>$</span><span>(</span><span>'css选择器'</span><span>)</span> 
</code></pre>
<div><span>1</span><br></div></div><table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>ID选择器</td>
<td>$('#id');</td>
<td style="text-align:left">获取指定ID的元素</td>
</tr>
<tr>
<td>类选择器</td>
<td>$('.class');</td>
<td style="text-align:left">获取同一类class的元素</td>
</tr>
<tr>
<td>标签选择器</td>
<td>$('div');</td>
<td style="text-align:left">获取同一类标签的所有元素</td>
</tr>
<tr>
<td>并集选择器</td>
<td>$('div,p,li');</td>
<td style="text-align:left">使用逗号分隔，只要符合条件之一就可。</td>
</tr>
<tr>
<td>交集选择器</td>
<td>$('div.redClass');</td>
<td style="text-align:left">获取class为redClass的div元素</td>
</tr>
<tr>
<td>通配符选择器</td>
<td>$('*')</td>
<td style="text-align:left">获取页面中所有的元素;</td>
</tr>
</tbody>
</table>
<ul>
<li>总结：跟css的选择器用法一模一样。</li>
</ul>
<h3 id="jquery层级选择器"> jQuery层级选择器</h3>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>子代选择器</td>
<td>$('ul &gt; li');</td>
<td style="text-align:left">获取父元素中的直接子元素</td>
</tr>
<tr>
<td>后代选择器</td>
<td>$('ul li');</td>
<td style="text-align:left">获取父元素中的所有后代元素；包括孙子等</td>
</tr>
</tbody>
</table>
<ul>
<li>跟CSS的选择器一模一样。</li>
</ul>
<h3 id="jquery过滤选择器-结构选择器"> jQuery过滤选择器（结构选择器）</h3>
<ul>
<li>这类选择器都带冒号:</li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>:eq（index）</td>
<td>$('li:eq(2)').css('color', 'red');</td>
<td style="text-align:left">获取到的li元素中，选择索引号为2的元素，索引号index从0开始。</td>
</tr>
<tr>
<td>:odd</td>
<td>$('li:odd').css('color', 'red');</td>
<td style="text-align:left">获取到的li元素中，选择索引号为奇数的元素</td>
</tr>
<tr>
<td>:even</td>
<td>$('li:even').css('color', 'red');</td>
<td style="text-align:left">获取到的li元素中，选择索引号为偶数的元素</td>
</tr>
<tr>
<td>:first</td>
<td>$('li:first')</td>
<td style="text-align:left">获取第一个元素</td>
</tr>
<tr>
<td>:last</td>
<td>$('li:last')</td>
<td style="text-align:left">获取最后一个元素</td>
</tr>
</tbody>
</table>
<h3 id="jquery筛选选择器-方法"> jQuery筛选选择器(方法)</h3>
<ul>
<li>筛选选择器的功能与过滤选择器有点类似，但是用法不一样，<strong>筛选选择器主要是方法。</strong></li>
</ul>
<table>
<thead>
<tr>
<th>名称</th>
<th>用法</th>
<th style="text-align:left">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>children(selector)</td>
<td>$('ul').children('li')</td>
<td style="text-align:left">相当于$('ul-li')，子类选择器</td>
</tr>
<tr>
<td>find(selector)</td>
<td>$('ul').find('li');</td>
<td style="text-align:left">相当于$('ul li'),后代选择器</td>
</tr>
<tr>
<td>siblings(selector)</td>
<td>$('#first').siblings('li');</td>
<td style="text-align:left">查找兄弟节点，不包括自己本身。</td>
</tr>
<tr>
<td>parent()    |   parents([选择器])</td>
<td>$('#first').parent();</td>
<td style="text-align:left">获取当前元素的直接父级元素</td>
</tr>
<tr>
<td>eq(index)</td>
<td>$('li').eq(2);</td>
<td style="text-align:left">相当于$('li:eq(2)'),index从0开始</td>
</tr>
<tr>
<td>next()</td>
<td>$('li').next()</td>
<td style="text-align:left">找下一个兄弟</td>
</tr>
<tr>
<td>nextAll()</td>
<td>$('.one').nextAll()</td>
<td style="text-align:left">获取当前元素之后的所有同级元素</td>
</tr>
<tr>
<td>prev()</td>
<td>$('li').prev()</td>
<td style="text-align:left">找上一次兄弟</td>
</tr>
<tr>
<td>prevtAll()</td>
<td>$('.one').prevtAll()</td>
<td style="text-align:left">获取当前元素之前的所有同级元素</td>
</tr>
<tr>
<td>hasClass(class)</td>
<td>$('div').hasClass('nav')</td>
<td style="text-align:left">判断当前元素是否有某个类名，存在返回true</td>
</tr>
</tbody>
</table>
<h2 id="jquery方法"> jQuery方法：</h2>
<h3 id="index"> index();</h3>
<ul>
<li>
<p>获取当前元素的索引位置   Jquery对象.index()；</p>
<div><pre><code> <span>//获取索引；</span>
<span>var</span> suoyin <span>=</span> <span>$</span><span>(</span><span>this</span><span>)</span><span>.</span><span>index</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
<h3 id="tofixed-x"> toFixed(x);</h3>
<ul>
<li>
<p>可以返回指定位数的小数，如果要保留2位小数参数 x 就写2;</p>
<div><pre><code><span>var</span> sum <span>=</span> xiaoji <span>*</span> text<span>;</span>
<span>$</span><span>(</span><span>this</span><span>)</span><span>.</span><span>parent</span><span>(</span><span>)</span><span>.</span><span>next</span><span>(</span><span>)</span><span>.</span><span>text</span><span>(</span>sum<span>.</span><span>toFixed</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
<h3 id="each"> each();</h3>
<ul>
<li>jq中默认的隐式迭代只能给元素设置相同的样式，如果需要设置不同样式需要通过遍历的方式实现；</li>
<li>jQuery的隐式迭代会对所有的DOM对象设置相同的值，但是如果我们需要给每一个对象设置不同的值的时候，就需要自己进行迭代了。</li>
</ul>
<div><pre><code><span>//语法1：</span>
	jQ对象<span>.</span><span>each</span><span>(</span><span>function</span><span>(</span><span>index<span>,</span> domElement</span><span>)</span><span>{</span> <span>}</span><span>)</span><span>;</span>
备注：
   	<span>1.</span> 第一个参数代表每一个元素的索引值
    <span>2.</span> 第二个参数代表的是一个dom对象，不是jq对象
    <span>3.</span> 如果要使用jq中的方法，必须要将对象转化为jq对象
    
<span>//语法2：</span>
	$<span>.</span><span>each</span><span>(</span>object<span>,</span> <span>function</span><span>(</span><span>index<span>,</span> element</span><span>)</span><span>{</span><span>}</span><span>)</span>
备注：
   	<span>1.</span> object表示要遍历哪个对象，一般在程序是一个数据【数组，对象】
    <span>2.</span> index，表示数据的索引值
    <span>3.</span> element 表示数据中的值
例如：
	 <span>//遍历程序中的数据</span>
	 <span>var</span> ary <span>=</span> <span>[</span><span>'a'</span><span>,</span><span>'b'</span><span>,</span> <span>'c'</span><span>]</span><span>;</span>
	 $<span>.</span><span>each</span><span>(</span>ary<span>,</span> <span>function</span><span>(</span><span>i<span>,</span>element</span><span>)</span> <span>{</span>
         console<span>.</span><span>log</span><span>(</span>i<span>,</span> element<span>)</span><span>;</span>
     <span>}</span><span>)</span>
     <span>//可以遍历程序中的jq对象</span>
     $<span>.</span><span>each</span><span>(</span><span>$</span><span>(</span><span>'li'</span><span>)</span><span>,</span> <span>function</span><span>(</span><span>i<span>,</span> element</span><span>)</span><span>{</span>
         console<span>.</span><span>log</span><span>(</span>i<span>,</span> element<span>)</span><span>;</span>
     <span>}</span><span>)</span>   
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id="change事件"> change事件;</h3>
<ul>
<li>
<p>表单控件中的值发生修改，触发 change事件;</p>
</li>
<li>
<p>当用于 text field  或 text area 时，该事件会在元素失去焦点时发生。</p>
</li>
<li>
<p>该事件仅适用于文本域（text field），以及 textarea 和 select 元素。</p>
</li>
</ul>
<p>当用于 select 元素时，change 事件会在选择某个选项时发生。</p>
<div><pre><code> <span>//当用户手动填写文本域时，价格也应发生变化；！</span>
        <span>$</span><span>(</span><span>'.box .num input'</span><span>)</span><span>.</span><span>change</span><span>(</span><span>function</span> <span>(</span><span>)</span> <span>{</span>
            <span>//获取数量；</span>
            <span>var</span> text <span>=</span> <span>$</span><span>(</span><span>this</span><span>)</span><span>.</span><span>val</span><span>(</span><span>)</span><span>;</span>
            <span>//获取单价；</span>
            <span>var</span> price <span>=</span> <span>$</span><span>(</span><span>this</span><span>)</span><span>.</span><span>parent</span><span>(</span><span>)</span><span>.</span><span>prev</span><span>(</span><span>)</span><span>.</span><span>text</span><span>(</span><span>)</span><span>;</span>
            <span>//计算总价；</span>
            <span>var</span> sum <span>=</span> text <span>*</span> price<span>;</span>
            <span>//修改属性值；</span>
            <span>$</span><span>(</span><span>this</span><span>)</span><span>.</span><span>parent</span><span>(</span><span>)</span><span>.</span><span>next</span><span>(</span><span>)</span><span>.</span><span>text</span><span>(</span>sum<span>.</span><span>toFixed</span><span>(</span><span>2</span><span>)</span><span>)</span><span>;</span>
            <span>f_sum</span><span>(</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="jquery操作样式"> jQuery操作样式</h2>
<h3 id="css操作"> CSS操作</h3>
<ul>
<li>
<p>功能：设置或者修改样式，操作的是style属性。</p>
</li>
<li>
<p>操作单个样式</p>
</li>
</ul>
<div><pre><code><span>// name：需要设置的样式名称</span>
<span>// value：对应的样式值</span>
$obj<span>.</span><span>css</span><span>(</span>name<span>,</span> value<span>)</span><span>;</span>
<span>// 使用案例</span>
<span>$</span><span>(</span><span>'#one'</span><span>)</span><span>.</span><span>css</span><span>(</span><span>'background'</span><span>,</span><span>'gray'</span><span>)</span><span>;</span><span>// 将背景色修改为灰色</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>设置多个样式</li>
</ul>
<div><pre><code><span>// 参数是一个对象，对象中包含了需要设置的样式名和样式值</span>
$obj<span>.</span><span>css</span><span>(</span>obj<span>)</span><span>;</span>
<span>// 使用案例</span>
<span>$</span><span>(</span><span>'#one'</span><span>)</span><span>.</span><span>css</span><span>(</span><span>{</span>
    background<span>:</span><span>'gray'</span><span>,</span>
    width<span>:</span><span>'400px'</span><span>,</span>
    height<span>:</span><span>'200px'</span>
<span>}</span><span>)</span><span>;</span>
<span>// 值如果是数字，可以不用设置引号；</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ul>
<li>获取样式</li>
</ul>
<div><pre><code><span>// name:需要获取的样式名称</span>
$obj<span>.</span><span>css</span><span>(</span>name<span>)</span><span>;</span>
<span>// 案例</span>
<span>$</span><span>(</span><span>'div'</span><span>)</span><span>.</span><span>css</span><span>(</span><span>'background-color'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>注意：获取样式操作只会返回第一个元素对应的样式值。</p>
<h3 id="隐式迭代"> 隐式迭代：</h3>
<ol>
<li>遍历内部 DOM 元素（伪数组形式存储）的过程就叫做隐式迭代。</li>
<li>设置操作的时候，如果是多个元素，那么给所有的元素设置相同的值；</li>
<li>获取操作的时候，如果是多个元素，那么只会返回第一个元素的值。</li>
</ol>
<h3 id="class操作"> class操作</h3>
<ol>
<li>注意：
<ol>
<li>原来DOM中 className 可以覆盖原来的类；</li>
<li>Jq中addClass不会覆盖原来的类；</li>
</ol>
</li>
</ol>
<ul>
<li>添加样式类</li>
</ul>
<div><pre><code><span>// name：需要添加的样式类名，注意参数不要带点.</span>
$obj<span>.</span><span>addClass</span><span>(</span>name<span>)</span><span>;</span>
<span>// 例子,给所有的div添加one的样式。</span>
<span>$</span><span>(</span><span>'div'</span><span>)</span><span>.</span><span>addClass</span><span>(</span><span>'one'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>移除样式类</li>
</ul>
<div><pre><code><span>// name:需要移除的样式类名</span>
$obj<span>.</span><span>removeClass</span><span>(</span><span>'name'</span><span>)</span><span>;</span>
<span>// 例子，移除div中one的样式类名</span>
<span>$</span><span>(</span><span>'div'</span><span>)</span><span>.</span><span>removeClass</span><span>(</span><span>'one'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>判断是否有某个样式类</li>
</ul>
<div><pre><code><span>// name:用于判断的样式类名，返回值为true false</span>
$obj<span>.</span><span>hasClass</span><span>(</span>name<span>)</span>
<span>// 例子，判断第一个div是否有one的样式类</span>
<span>$</span><span>(</span><span>'div'</span><span>)</span><span>.</span><span>hasClass</span><span>(</span><span>'one'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li>切换样式类</li>
</ul>
<div><pre><code><span>// name:需要切换的样式类名，如果有，移除该样式，如果没有，添加该样式。</span>
$obj<span>.</span><span>toggleClass</span><span>(</span>name<span>)</span><span>;</span>
<span>// 例子</span>
<span>$</span><span>(</span><span>'div'</span><span>)</span><span>.</span><span>toggleClass</span><span>(</span><span>'one'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="链式编程"> 链式编程：</h2>
<ul>
<li>通常情况下，只有<strong>设置操作</strong>才能把链式编程延续下去。因为获取操作的时候，会返回获取到的相应的值，无法返回 jQuery对象。</li>
<li>实现链式编程的核心：是对象中的每一个方法都会返回当前<strong>对象</strong>。</li>
</ul>
<h2 id="jquery动画"> jQuery动画</h2>
<ul>
<li>jQuery提供了三组基本动画，这些动画都是标准的、有规律的效果；</li>
<li>jQuery还提供了自定义动画的功能。</li>
</ul>
<h3 id="三组基本动画"> 三组基本动画</h3>
<ul>
<li>显示(show)与隐藏(hide)是一组动画：</li>
<li>滑入(slideUp)与滑出(slideDown)与切换(slideToggle)，效果与卷帘门类似；</li>
<li>淡入(fadeIn)与淡出(fadeOut)与切换(fadeToggle)；</li>
<li>透明度；</li>
</ul>
<div><pre><code><span>//显示隐藏;</span>
<span>//语法：</span>
<span>//显示；</span>
<span>☞show</span><span>(</span><span>[</span>speed<span>,</span> <span>[</span>easing<span>]</span><span>,</span> <span>[</span>fn<span>]</span><span>]</span><span>)</span>   <span>--</span><span>-</span><span>></span>参数可以省略
        <span>1.</span> speed <span>:</span> 设置动画速度（slow<span>,</span>normal<span>,</span>fast<span>,</span>自定义时间）
        <span>2.</span> easing<span>:</span> 设置切换效果（默认是swing）<span>,</span>linear
        <span>3.</span> fn ： 回调函数，在动画执行完以后执行的函数
 <span>//隐藏；  </span>
<span>☞hide</span><span>(</span><span>[</span>speed<span>,</span> <span>[</span>easing<span>]</span><span>,</span> <span>[</span>fn<span>]</span><span>]</span><span>)</span>   <span>--</span><span>-</span><span>></span>参数可以省略
        <span>1.</span> speed <span>:</span> 设置动画速度（slow<span>,</span>normal<span>,</span>fast<span>,</span>自定义时间）
        <span>2.</span> easing<span>:</span> 设置切换效果（默认是swing）<span>,</span>linear
        <span>3.</span> fn ： 回调函数，在动画执行时候执行的函数；
<span>//切换；</span>
<span>☞toggle</span><span>(</span><span>[</span>speed<span>,</span> <span>[</span>easing<span>]</span><span>,</span> <span>[</span>fn<span>]</span><span>]</span><span>)</span>   <span>--</span><span>-</span><span>></span>参数可以省略
        <span>1.</span> speed <span>:</span> 设置动画速度（slow<span>,</span>normal<span>,</span>fast<span>,</span>自定义时间）
        <span>2.</span> easing<span>:</span> 设置切换效果（默认是swing）<span>,</span>linear；
        <span>3.</span> fn ： 回调函数，在动画执行时候执行的函数；
        
<span>//滑动效果；效果与卷帘门类似；</span>
<span>//滑出；</span>
☞ <span>slideDown</span><span>(</span><span>[</span>speed<span>,</span> easing<span>,</span> fn<span>]</span><span>)</span>
    	<span>1.</span> speed <span>:</span> 设置动画速度（slow<span>,</span>normal<span>,</span>fast<span>,</span>自定义时间）
        <span>2.</span> easing<span>:</span> 设置切换效果（默认是swing）<span>,</span>linear
        <span>3.</span> fn ： 回调函数，在动画执行时候执行的函数
<span>//滑入；  </span>
☞ <span>slideUp</span><span>(</span><span>[</span>speed<span>,</span> easing<span>,</span> fn<span>]</span><span>)</span>
    	<span>1.</span> speed <span>:</span> 设置动画速度（slow<span>,</span>normal<span>,</span>fast<span>,</span>自定义时间）
        <span>2.</span> easing<span>:</span> 设置切换效果（默认是swing）<span>,</span>linear
        <span>3.</span> fn ： 回调函数，在动画执行时候执行的函数
<span>//切换；  </span>
☞ <span>slideToggle</span><span>(</span><span>[</span>speed<span>,</span> easing<span>,</span> fn<span>]</span><span>)</span>
    	<span>1.</span> speed <span>:</span> 设置动画速度（slow<span>,</span>normal<span>,</span>fast<span>,</span>自定义时间）
        <span>2.</span> easing<span>:</span> 设置切换效果（默认是swing）<span>,</span>linear
        <span>3.</span> fn ： 回调函数，在动画执行时候执行的函数        

<span>//淡入和淡出；完全隐藏，不占有原有位置；</span>
<span>//淡入；        </span>
☞ <span>fadeIn</span><span>(</span><span>[</span>speed<span>,</span> easing<span>,</span> fn<span>]</span><span>)</span>
    	<span>1.</span> speed <span>:</span> 设置动画速度（slow<span>,</span>normal<span>,</span>fast<span>,</span>自定义时间）
        <span>2.</span> easing<span>:</span> 设置切换效果（默认是swing）<span>,</span>linear
        <span>3.</span> fn ： 回调函数，在动画执行时候执行的函数
<span>//淡出；  </span>
☞ <span>fadeOut</span><span>(</span><span>[</span>speed<span>,</span> easing<span>,</span> fn<span>]</span><span>)</span>
    	<span>1.</span> speed <span>:</span> 设置动画速度（slow<span>,</span>normal<span>,</span>fast<span>,</span>自定义时间）
        <span>2.</span> easing<span>:</span> 设置切换效果（默认是swing）<span>,</span>linear
        <span>3.</span> fn ： 回调函数，在动画执行时候执行的函数
<span>//切换；淡入与淡出之间的切换；  </span>
☞ <span>fadeToggle</span><span>(</span><span>[</span>speed<span>,</span> easing<span>,</span> fn<span>]</span><span>)</span>
    	<span>1.</span> speed <span>:</span> 设置动画速度（slow<span>,</span>normal<span>,</span>fast<span>,</span>自定义时间）
        <span>2.</span> easing<span>:</span> 设置切换效果（默认是swing）<span>,</span>linear
        <span>3.</span> fn ： 回调函数，在动画执行时候执行的函数
<span>//透明度；  </span>
☞ <span>fadeTo</span><span>(</span><span>[</span>speed<span>,</span> opacity<span>,</span> easing<span>,</span> fn<span>]</span><span>)</span>
    	<span>1.</span> speed <span>:</span> 设置动画速度（slow<span>,</span>normal<span>,</span>fast<span>,</span>自定义时间） 【必须写】
    	<span>2.</span> opacity<span>:</span> 设置透明度<span>0</span><span>-</span><span>1</span>之间  【必须写】
        <span>3.</span> easing<span>:</span> 设置切换效果（默认是swing）<span>,</span>linear
        <span>4.</span> fn ： 回调函数，在动画执行时候执行的函数 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><h3 id="事件切换"> 事件切换：</h3>
<div><pre><code>☞ <span>事件切换：hover</span><span>(</span><span>fn</span><span>(</span><span>)</span><span>,</span> <span>fu</span><span>(</span><span>)</span><span>)</span>
      	<span>1.</span> 第一个回调函数代表鼠标进入时候触发的事件（相当于mouseenter）
      	<span>2.</span> 第二个回调函数代表鼠标离开时候触发的事件（相当于mouseleave）
	注意：
		✔ 如果只写一个fn，那么代表同时触发鼠标进入和离开
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="自定义动画"> 自定义动画</h3>
<ul>
<li>animate: 自定义动画</li>
</ul>
<div><pre><code><span>$</span><span>(</span>selector<span>)</span><span>.</span><span>animate</span><span>(</span>params<span>,</span><span>[</span>speed<span>]</span><span>,</span><span>[</span>easing<span>]</span><span>,</span><span>[</span>fn<span>]</span><span>)</span><span>;</span>
  <span>1.</span> params：要设置动画的<span>CSS</span>属性	【要以对象的形式设置<span>CSS</span>样式】
   <span>$</span><span>(</span><span>this</span><span>)</span><span>.</span><span>animate</span><span>(</span><span>{</span>width<span>:</span> <span>300</span><span>,</span>height<span>:</span> <span>300</span><span>,</span>opacity<span>:</span> <span>0.1</span><span>}</span><span>)</span>；
  <span>2.</span> speed： <span>动画速度</span><span>(</span><span>"slow"</span><span>,</span><span>"normal"</span><span>,</span> or <span>"fast"</span><span>)</span><span>或表示动画时长的毫秒数值</span><span>(</span>如：<span>1000</span><span>)</span>； 
  <span>3.</span> easing<span>:</span> 动画切换效果<span>"linear"</span> 和 <span>"swing"</span><span>.</span>
  <span>4.</span> fn<span>:</span> 动画完成后执行的一个回调函数；

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="动画队列与停止动画"> 动画队列与停止动画</h3>
<ul>
<li>在同一个元素上执行多个动画，那么对于这个动画来说，后面的动画会被放到动画队列中，等前面的动画执行完成了才会执行。</li>
</ul>
<div><pre><code><span>// stop方法：停止动画效果</span>
<span>stop</span><span>(</span>clearQueue<span>,</span> jumpToEnd<span>)</span><span>;</span>
<span>// 第一个参数：是否清除队列</span>
<span>// 第二个参数：是否跳转到最终效果;</span>
<span>//停止排队（stop()）: 必须写到动画前面!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="jquery节点操作"> jQuery节点操作</h2>
<h3 id="创建节点"> 创建节点</h3>
<div><pre><code><span>// $(htmlStr)</span>
<span>// htmlStr：html格式的字符串</span>
语法：
 	<span>$</span><span>(</span><span>'&lt;li>&lt;/li>'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="添加节点"> 添加节点</h3>
<div><pre><code>append<span>:</span>将创建的元素添加到父元素的末尾
<span>$</span><span>(</span><span>'父元素'</span><span>)</span><span>.</span><span>append</span><span>(</span>创建的元素<span>)</span>

prepend<span>:</span>将创建的元素添加到父元素的开始
 <span>$</span><span>(</span><span>'父元素'</span><span>)</span><span>.</span><span>prepend</span><span>(</span>创建的元素<span>)</span>

before<span>:</span>将创建的元素添加到目标元素的后面
 <span>$</span><span>(</span><span>'元素'</span><span>)</span><span>.</span><span>before</span><span>(</span>创建的元素<span>)</span>

after<span>:</span>将创建的元素添加到目标元素的前面
<span>$</span><span>(</span><span>'元素'</span><span>)</span><span>.</span><span>after</span><span>(</span>创建的元素<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="清空节点与删除节点"> 清空节点与删除节点</h3>
<ul>
<li>empty：清空指定节点的所有元素，自身保留(清理门户)</li>
</ul>
<div><pre><code><span>$</span><span>(</span><span>'div'</span><span>)</span><span>.</span><span>empty</span><span>(</span><span>)</span><span>;</span> <span>// 清空div的所有内容（推荐使用，会清除子元素上绑定的内容，源码）</span>
<span>$</span><span>(</span><span>'div'</span><span>)</span><span>.</span><span>html</span><span>(</span><span>''</span><span>)</span><span>;</span><span>// 使用html方法来清空元素，不推荐使用，会造成内存泄漏，绑定的事件不会被清除。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>remove：将元素自己删除掉（自杀）;</li>
</ul>
<div><pre><code><span>$</span><span>(</span><span>'div'</span><span>)</span><span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span><span>//将div自己删除；</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="克隆节点"> 克隆节点</h3>
<ul>
<li>作用：复制匹配的元素</li>
</ul>
<div><pre><code><span>// 复制$(selector)所匹配到的元素（深度复制）</span>
<span>// cloneNode(true)</span>
<span>// 返回值为复制的新元素，和原来的元素没有任何关系了。即修改新元素，不会影响到原来的元素。</span>
<span>$</span><span>(</span>selector<span>)</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="jquery操作属性"> jQuery操作属性</h2>
<h3 id="attr操作"> attr操作</h3>
<ul>
<li>设置单个属性</li>
</ul>
<div><pre><code><span>// 第一个参数：需要设置的属性名</span>
<span>// 第二个参数：对应的属性值</span>
$obj<span>.</span><span>attr</span><span>(</span>name<span>,</span> value<span>)</span><span>;</span>
<span>// 用法举例</span>
<span>$</span><span>(</span><span>'img'</span><span>)</span><span>.</span><span>attr</span><span>(</span><span>'title'</span><span>,</span><span>'哎哟，不错哦'</span><span>)</span><span>;</span>
<span>$</span><span>(</span><span>'img'</span><span>)</span><span>.</span><span>attr</span><span>(</span><span>'alt'</span><span>,</span><span>'哎哟，不错哦'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>设置多个属性</li>
</ul>
<div><pre><code><span>// 参数是一个对象，包含了需要设置的属性名和属性值</span>
$obj<span>.</span><span>attr</span><span>(</span>obj<span>)</span>
<span>// 用法举例</span>
<span>$</span><span>(</span><span>'img'</span><span>)</span><span>.</span><span>attr</span><span>(</span><span>{</span>
    title<span>:</span><span>'哎哟，不错哦'</span><span>,</span>
    alt<span>:</span><span>'哎哟，不错哦'</span><span>,</span>
    style<span>:</span><span>'opacity:.5'</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li>获取属性</li>
</ul>
<div><pre><code><span>// 传需要获取的属性名称，返回对应的属性值</span>
$obj<span>.</span><span>attr</span><span>(</span>name<span>)</span>
<span>// 用法举例</span>
<span>var</span> oTitle <span>=</span> <span>$</span><span>(</span><span>'img'</span><span>)</span><span>.</span><span>attr</span><span>(</span><span>'title'</span><span>)</span><span>;</span>
<span>alert</span><span>(</span>oTitle<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>移除属性</li>
</ul>
<div><pre><code><span>// 参数：需要移除的属性名，</span>
$obj<span>.</span><span>removeAttr</span><span>(</span>name<span>)</span><span>;</span>
<span>// 用法举例</span>
<span>$</span><span>(</span><span>'img'</span><span>)</span><span>.</span><span>removeAttr</span><span>(</span><span>'title'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="prop操作"> prop操作</h3>
<ul>
<li>
<p>获取元素的固有属性;</p>
</li>
<li>
<p>对于checked、selected、disabled这类boolean类型的属性来说，不能用attr方法，只能用prop方法。</p>
</li>
</ul>
<div><pre><code><span>// 设置属性</span>
<span>$</span><span>(</span><span>':checked'</span><span>)</span><span>.</span><span>prop</span><span>(</span><span>'checked'</span><span>,</span><span>true</span><span>)</span><span>;</span>
<span>// 获取属性</span>
<span>$</span><span>(</span><span>':checked'</span><span>)</span><span>.</span><span>prop</span><span>(</span><span>'checked'</span><span>)</span><span>;</span><span>// 返回true或者false</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="操作内容文本"> 操作内容文本：</h2>
<ul>
<li>val()/text/()html()；</li>
</ul>
<div><pre><code>$obj<span>.</span><span>val</span><span>(</span><span>)</span>		相当于原生js中的   value    用于获取表单控件的value属性值；
$obj<span>.</span><span>html</span><span>(</span><span>)</span> 	相当于原生js中的  innerHtml
$obj<span>.</span><span>text</span><span>(</span><span>)</span>		对应innerText<span>/</span>textContent，处理了浏览器的兼容性  常用；
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="jquery尺寸和位置操作"> jQuery尺寸和位置操作</h2>
<h3 id="width方法与height方法"> width方法与height方法</h3>
<ul>
<li>设置或者获取高度，不包括内边距、边框和外边距；</li>
<li>获取的是内容区域的大小；</li>
</ul>
<div><pre><code><span>// 带参数表示设置高度  </span>
<span>$</span><span>(</span><span>'img'</span><span>)</span><span>.</span><span>height</span><span>(</span><span>200</span><span>)</span><span>;</span>
<span>// 不带参数表示获取高度</span>
<span>$</span><span>(</span><span>'img'</span><span>)</span><span>.</span><span>height</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>获取网页的可视区宽高</p>
<div><pre><code><span>// 获取可视区宽度  //内容区域的大小</span>
<span>$</span><span>(</span>window<span>)</span><span>.</span><span>width</span><span>(</span><span>)</span><span>;</span>
<span>// 获取可视区高度</span>
<span>$</span><span>(</span>window<span>)</span><span>.</span><span>height</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="innerwidth-innerheight-outerwidth-outerheight"> innerWidth/innerHeight/outerWidth/outerHeight</h3>
<div><pre><code><span>innerWidth</span><span>(</span><span>)</span><span>/</span><span>innerHeight</span><span>(</span><span>)</span>	方法返回元素的宽度<span>/</span>高度（包括内边距）。
<span>outerWidth</span><span>(</span><span>)</span><span>/</span><span>outerHeight</span><span>(</span><span>)</span>  方法返回元素的宽度<span>/</span>高度（包括内边距和边框）。
<span>outerWidth</span><span>(</span><span>true</span><span>)</span><span>/</span><span>outerHeight</span><span>(</span><span>true</span><span>)</span>  方法返回元素的宽度<span>/</span>高度（包括内边距、边框和外边距）。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="scrolltop与scrollleft"> scrollTop与scrollLeft</h3>
<ul>
<li>设置或者获取垂直滚动条的位置</li>
</ul>
<div><pre><code><span>// 获取页面被卷曲的高度</span>
<span>$</span><span>(</span>window<span>)</span><span>.</span><span>scrollTop</span><span>(</span><span>)</span><span>;</span>
<span>// 获取页面被卷曲的宽度</span>
<span>$</span><span>(</span>window<span>)</span><span>.</span><span>scrollLeft</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="offset方法与position方法"> offset方法与position方法</h3>
<ul>
<li>offset方法获取元素距离document的位置，position方法获取的是元素距离有定位的父元素(offsetParent)的位置。</li>
</ul>
<div><pre><code><span>// 获取元素距离document的位置,返回值为对象：{left:100, top:100}</span>
<span>$</span><span>(</span>selector<span>)</span><span>.</span><span>offset</span><span>(</span><span>)</span><span>;</span>
<span>// 获取相对于其最近的有定位的父元素的位置。</span>
<span>$</span><span>(</span>selector<span>)</span><span>.</span><span>position</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="jquery事件机制"> jQuery事件机制</h2>
<ul>
<li>JavaScript中已经学习过了事件，jQuery对JavaScript事件进行了封装，增加并扩展了事件处理机制。jQuery不仅提供了更加优雅的事件处理语法，而且极大的增强了事件的处理能力。</li>
</ul>
<h3 id="jquery事件发展历程-了解"> jQuery事件发展历程(了解)</h3>
<p>简单事件绑定--bind事件绑定--delegate事件绑定--on事件绑定(推荐)</p>
<ul>
<li>简单事件注册</li>
</ul>
<div><pre><code><span>click</span><span>(</span>handler<span>)</span>			单击事件
<span>mouseenter</span><span>(</span>handler<span>)</span>		鼠标进入事件
<span>mouseleave</span><span>(</span>handler<span>)</span>		鼠标离开事件
语法：
	<span>$</span><span>(</span><span>'元素'</span><span>)</span><span>.</span><span>事件名称</span><span>(</span><span>function</span><span>(</span><span>)</span><span>{</span><span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>缺点：不能同时注册多个事件</p>
<ul>
<li>bind方式注册事件</li>
</ul>
<div><pre><code><span>// 第一个参数：事件类型</span>
<span>// 第二个参数：事件处理程序</span>
<span>$</span><span>(</span><span>'p'</span><span>)</span><span>.</span><span>bind</span><span>(</span><span>'click mouseenter'</span><span>,</span> <span>function</span><span>(</span><span>)</span><span>{</span>
    <span>// 事件响应方法</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>缺点：不支持动态事件绑定</p>
<ul>
<li>delegate注册委托事件</li>
</ul>
<div><pre><code><span>// 第一个参数：selector，要绑定事件的元素</span>
<span>// 第二个参数：事件类型</span>
<span>// 第三个参数：事件处理函数</span>
<span>$</span><span>(</span><span>'.parentBox'</span><span>)</span><span>.</span><span>delegate</span><span>(</span><span>'p'</span><span>,</span> <span>'click'</span><span>,</span> <span>function</span><span>(</span><span>)</span><span>{</span>
    <span>// 为 .parentBox下面的所有的p标签绑定事件</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>缺点：只能注册委托事件，因此注册时间需要记得方法太多了</p>
<h3 id="on注册事件-重点"> on注册事件(重点)</h3>
<ul>
<li>jQuery1.7之后，jQuery用on统一了所有事件的处理方法。</li>
<li>最现代的方式，兼容zepto(移动端类似jQuery的一个库)，强烈建议使用。</li>
</ul>
<p>on注册简单事件</p>
<div><pre><code><span>// 一次注册一个事件，并且由自己触发，不支持动态绑定。</span>
<span>$</span><span>(</span><span>'元素'</span><span>)</span><span>.</span><span>on</span><span>(</span> <span>'click'</span><span>,</span> <span>function</span><span>(</span><span>)</span> <span>{</span><span>}</span><span>)</span><span>;</span>

<span>$</span><span>(</span><span>'元素'</span><span>)</span><span>.</span><span>on</span><span>(</span><span>{</span>
          <span>事件名称</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span><span>}</span><span>,</span>
          <span>事件名称</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span><span>}</span><span>,</span>
          <span>事件名称</span><span>:</span> <span>function</span><span>(</span><span>)</span> <span>{</span><span>}</span>
    <span>}</span><span>)</span>
   <span>//一次注册多个元素事件</span>

<span>//注意：</span>
	如果注册的事件处理程序相同，那么可以合写：
    <span>$</span><span>(</span><span>'元素'</span><span>)</span><span>.</span><span>on</span><span>(</span><span>'click  mouseenter mouseleave'</span><span>,</span> <span>function</span><span>(</span><span>)</span><span>{</span>
      <span>// 代表当前元素在执行 click， mouseenter ， mouseleave 事件时候，执行的代码是一样的</span>
    <span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>on注册事件委托</p>
<div><pre><code><span>//语法：</span>
	<span>$</span><span>(</span><span>'元素'</span><span>)</span><span>.</span><span>on</span><span>(</span><span>'事件名称'</span><span>,</span> <span>'真正执行事件的子元素'</span><span>,</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>}</span><span>)</span>
<span>//给ul注册点击事件，但是在执行的时候，是点击每一个li执行的点击事件，委托思想;</span>
<span>//当必须是它的内部元素li才能触发这个事件，支持动态绑定；</span>
<span>$</span><span>(</span><span>'ul'</span><span>)</span><span>.</span><span>on</span><span>(</span><span>'click'</span><span>,</span> <span>'li'</span><span>,</span> <span>function</span><span>(</span><span>)</span><span>{</span> console<span>.</span><span>log</span><span>(</span><span>123</span><span>)</span> <span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>事件委托原理</p>
<div><pre><code><span>// 事件委托的原理</span>
<span>var</span> ul <span>=</span> document<span>.</span><span>querySelector</span><span>(</span><span>'#ul'</span><span>)</span><span>;</span>
ul<span>.</span><span>onclick</span> <span>=</span> <span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
  <span>// console.log(e.target.tagName);</span>
  <span>if</span> <span>(</span>e<span>.</span>target<span>.</span>tagName<span>.</span><span>toLowerCase</span><span>(</span><span>)</span> <span>===</span> <span>'li'</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>e<span>.</span>target<span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>on注册事件的注意点：</p>
<div><pre><code>  	<span>1.</span> 可以通过on的方式给元素注册一个事件
    <span>2.</span> 通过on的方式给元素注册多个事件
    <span>3.</span> 通过on的方式注册事件可以实现委托的效果
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>通过源码查看 bind click delegate on 注册事件的区别</li>
</ul>
<h3 id="事件解绑"> 事件解绑</h3>
<ul>
<li>unbind方式（不用）</li>
</ul>
<div><pre><code><span>$</span><span>(</span>selector<span>)</span><span>.</span><span>unbind</span><span>(</span><span>)</span><span>;</span> <span>// 解绑所有的事件</span>
<span>$</span><span>(</span>selector<span>)</span><span>.</span><span>unbind</span><span>(</span><span>'click'</span><span>)</span><span>;</span> <span>// 解绑指定的事件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>undelegate方式（不用）</li>
</ul>
<div><pre><code><span>$</span><span>(</span> selector <span>)</span><span>.</span><span>undelegate</span><span>(</span><span>)</span><span>;</span> <span>// 解绑所有的delegate事件</span>
<span>$</span><span>(</span> selector<span>)</span><span>.</span><span>undelegate</span><span>(</span> <span>'click'</span> <span>)</span><span>;</span> <span>// 解绑所有的click事件</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>off方式（推荐）</li>
</ul>
<div><pre><code>语法：
	<span>$</span><span>(</span><span>'元素'</span><span>)</span><span>.</span><span>off</span><span>(</span><span>[</span>事件名称<span>]</span><span>,</span><span>[</span>执行事件委托元素<span>]</span><span>)</span>

注意：
   	<span>1.</span> <span>如果off</span><span>(</span><span>)</span>中没有设置任何参数，代表将该元素身上的所有事件都解除掉
    <span>2.</span> <span>如果要解除对应的事件，可以设置off</span><span>(</span><span>'事件名称'</span><span>)</span>
   	<span>3.</span> <span>如果要解除委托事件，可以通过off</span><span>(</span><span>'事件名称'</span><span>,</span> <span>'执行事件的元素'</span><span>)</span>
	   例如：
       <span>$</span><span>(</span><span>'ul'</span><span>)</span><span>.</span><span>on</span><span>(</span><span>'click'</span><span>,</span> <span>'li'</span><span>,</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>}</span><span>)</span> <span>--</span><span>-</span><span>></span> 通过委托给li注册的点击事件
  	   <span>$</span><span>(</span><span>'ul'</span><span>)</span><span>.</span><span>off</span><span>(</span><span>'click'</span><span>,</span> <span>'li'</span><span>)</span>  <span>--</span><span>-</span><span>></span> 解除li委托的点击事件

   	<span>4.</span> 如果一个元素只执行一次事件可以通过 <span>one</span><span>(</span><span>'事件名称'</span><span>,</span> <span>function</span><span>(</span><span>)</span><span>{</span><span>}</span><span>)</span>实现
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="触发事件"> 触发事件；</h3>
<ul>
<li>自动触发一次事件；</li>
</ul>
<div><pre><code><span>$</span><span>(</span><span>'元素'</span><span>)</span><span>.</span><span>事件名称</span><span>(</span><span>)</span><span>;</span>
<span>$</span><span>(</span><span>'元素'</span><span>)</span><span>.</span><span>trigger</span><span>(</span><span>'事件类型'</span><span>)</span><span>;</span>
例如：
	<span>$</span><span>(</span><span>'div'</span><span>)</span><span>.</span><span>mouseenter</span><span>(</span><span>function</span><span>(</span><span>)</span><span>{</span>
       <span>$</span><span>(</span><span>this</span><span>)</span><span>.</span><span>css</span><span>(</span><span>'background'</span><span>,</span><span>'pink'</span><span>)</span><span>;</span>
    <span>}</span><span>)</span>

    <span>$</span><span>(</span><span>'div'</span><span>)</span><span>.</span><span>mouseenter</span><span>(</span><span>)</span><span>;</span>
    <span>$</span><span>(</span><span>'div'</span><span>)</span><span>.</span><span>trigger</span><span>(</span><span>'mouseenter'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="jquery事件对象"> jQuery事件对象</h3>
<p>jQuery事件对象其实就是js事件对象的一个封装，处理了兼容性。</p>
<div><pre><code><span>// screenX和screenY	对应屏幕最左上角的值</span>
<span>// clientX和clientY	距离页面左上角的位置（忽视滚动条）</span>
<span>// pageX和pageY	距离页面最顶部的左上角的位置（会计算滚动条的距离）</span>

<span>// event.keyCode	按下的键盘代码</span>
<span>// event.data	存储绑定事件时传递的附加数据</span>

<span>// event.stopPropagation()	阻止事件冒泡行为</span>
<span>// event.preventDefault()	阻止浏览器默认行为</span>
<span>// return false:既能阻止事件冒泡，又能阻止浏览器默认行为。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="jquery补充知识点"> jQuery补充知识点</h2>
<h3 id="多库共存"> 多库共存</h3>
<ul>
<li>jQuery使用<code>$</code>作为标示符，但是如果与其他框架中的<code>$</code>冲突时，jQuery可以释放$符的控制权.</li>
</ul>
<div><pre><code><span>var</span> c <span>=</span> $<span>.</span><span>noConflict</span><span>(</span><span>)</span><span>;</span><span>// 释放$的控制权,并且把$的能力给了c</span>

为了避免其他js文件中和jQuery文件中的 <span>'$'</span>符号冲突

方式一：
	使用 jQuery 替代 <span>'$'</span>

方式二：
 用户完全自定义
<span>var</span>  test <span>=</span> jQuery<span>.</span><span>noConflict</span><span>(</span><span>)</span><span>;</span>
		 test<span>.</span><span>each</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="拷贝对象"> 拷贝对象；</h3>
<div><pre><code>希望将一个对象拷贝给另外一个对象使用
语法：
	$<span>.</span><span>extend</span><span>(</span><span>[</span>deep<span>]</span><span>,</span> target<span>,</span> object1<span>,</span> <span>[</span>objectn<span>]</span><span>)</span>
注意<span>;</span>
   	<span>1.</span> deep，默认值是<span>false</span>，浅拷贝。<span>true</span>代表深拷贝
	   浅拷贝，如果遇到复杂数据类型，是将复杂数据类型的地址拷贝给目标对象的
       深拷贝，拷贝的就是对象，没有拷贝地址
    <span>2.</span> target，要将对象拷贝给哪个对象
    <span>3.</span> object1<span>,</span>当前要被拷贝的对象
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="插件"> 插件</h2>
<h3 id="常用插件"> 常用插件</h3>
<ul>
<li>弹出层插件 layer
<ul>
<li><a href="https://github.com/sentsin/layer" target="_blank" rel="noopener noreferrer">layer插件</a></li>
</ul>
</li>
<li>放大镜插件
<ul>
<li><a href="http://www.jacklmoore.com/zoom/" target="_blank" rel="noopener noreferrer">jQuery.zoom</a></li>
</ul>
</li>
<li>轮播图插件
<ul>
<li><a href="http://sorgalla.com/jcarousel/" target="_blank" rel="noopener noreferrer">http://sorgalla.com/jcarousel/</a></li>
<li><a href="https://github.com/OwlCarousel2/OwlCarousel2" target="_blank" rel="noopener noreferrer">https://github.com/OwlCarousel2/OwlCarousel2</a></li>
</ul>
</li>
<li>图片懒加载插件
<ul>
<li><a href="https://github.com/tuupola/jquery_lazyload" target="_blank" rel="noopener noreferrer">jQuery.lazyload</a></li>
</ul>
</li>
<li>jQueryUI
<ul>
<li>常用的2-3个功能演示</li>
</ul>
</li>
<li>查看jQuery插件的源码</li>
</ul>
<h3 id="自己探索插件"> 自己探索插件</h3>
<ul>
<li><a href="https://github.com/aui/artDialog" target="_blank" rel="noopener noreferrer">artDialog</a></li>
<li><a href="https://github.com/fat/zoom.js" target="_blank" rel="noopener noreferrer">图片放大</a></li>
<li><a href="http://www.github.com" target="_blank" rel="noopener noreferrer">github上搜索</a></li>
</ul>
<h2 id="jquery插件开发"> jQuery插件开发</h2>
<ul>
<li>给jQuery增加方法的两种方式</li>
</ul>
<div><pre><code>$<span>.</span>method <span>=</span> fn		静态方法
$<span>.</span>fn<span>.</span>method <span>=</span> fn	实例方法
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><ul>
<li>增加一个静态方法，实现两个数的和，插件</li>
</ul>
<div><pre><code><span>(</span><span>function</span> <span>(</span><span>$</span><span>)</span> <span>{</span>
  $<span>.</span><span>add</span> <span>=</span> <span>function</span> <span>(</span><span>a<span>,</span> b</span><span>)</span> <span>{</span>
    <span>return</span> a <span>+</span> b<span>;</span>
  <span>}</span>
<span>}</span><span>(</span>jQuery<span>)</span><span>)</span>

$<span>.</span><span>add</span><span>(</span><span>5</span><span>,</span> <span>6</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><ul>
<li>tab栏插件 [21-tab栏插件.html]</li>
</ul>
<div><pre><code><span>(</span><span>function</span> <span>(</span><span>$</span><span>)</span> <span>{</span>
  <span>// {tabMenu: '#aa'}</span>
  $<span>.</span><span>tab</span> <span>=</span> <span>function</span> <span>(</span><span>options</span><span>)</span> <span>{</span>
    <span>// 默认参数</span>
    <span>var</span> defaults <span>=</span> <span>{</span>
      tabMenu<span>:</span> <span>'#tab'</span><span>,</span>
      activeClass<span>:</span> <span>'active'</span><span>,</span>
      tabMain<span>:</span> <span>'#tab-main'</span><span>,</span>
      tabMainSub<span>:</span> <span>'.main'</span><span>,</span>
      selectedClass<span>:</span> <span>'selected'</span>
    <span>}</span>
    <span>// 把options中的属性，把对应属性的值赋给defaults对应的属性</span>
    <span>// defaults.tabMenu = options.tabMenu || defaults.tabMenu;</span>
    <span>// for(var key in options) {</span>
    <span>//   defaults[key] = options[key];</span>
    <span>// }</span>
    $<span>.</span><span>extend</span><span>(</span>defaults<span>,</span> options<span>)</span><span>;</span>

    <span>$</span><span>(</span>defaults<span>.</span>tabMenu<span>)</span><span>.</span><span>on</span><span>(</span><span>'click'</span><span>,</span> <span>'li'</span><span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>$</span><span>(</span><span>this</span><span>)</span>
        <span>.</span><span>addClass</span><span>(</span>defaults<span>.</span>activeClass<span>)</span>
        <span>.</span><span>siblings</span><span>(</span><span>)</span>
        <span>.</span><span>removeClass</span><span>(</span>defaults<span>.</span>activeClass<span>)</span><span>;</span>

      <span>//</span>
      <span>var</span> index <span>=</span> <span>$</span><span>(</span><span>this</span><span>)</span><span>.</span><span>index</span><span>(</span><span>)</span><span>;</span>
      <span>//</span>
      <span>$</span><span>(</span>defaults<span>.</span>tabMain <span>+</span> <span>' '</span> <span>+</span> defaults<span>.</span>tabMainSub<span>)</span>
        <span>.</span><span>eq</span><span>(</span>index<span>)</span>
        <span>.</span><span>addClass</span><span>(</span>defaults<span>.</span>selectedClass<span>)</span>
        <span>.</span><span>siblings</span><span>(</span><span>)</span>
        <span>.</span><span>removeClass</span><span>(</span>defaults<span>.</span>selectedClass<span>)</span><span>;</span>
    <span>}</span><span>)</span>
  <span>}</span>
<span>}</span><span>(</span>window<span>.</span>jQuery<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><ul>
<li>表格插件  [22-表格插件.html]</li>
</ul>
<div><pre><code><span>(</span><span>function</span><span>(</span><span>$</span><span>)</span> <span>{</span>
  <span>// 内部的变量，外部无法访问，防止变量名冲突</span>
  <span>var</span> a <span>=</span> <span>0</span><span>;</span>
  <span>// 给$增加了一个实例方法</span>
  $<span>.</span>fn<span>.</span><span>table</span> <span>=</span> <span>function</span> <span>(</span><span>header<span>,</span> data</span><span>)</span> <span>{</span>
    <span>var</span> array <span>=</span> <span>[</span><span>]</span><span>;</span>
    array<span>.</span><span>push</span><span>(</span><span>'&lt;table>'</span><span>)</span><span>;</span>
    array<span>.</span><span>push</span><span>(</span><span>'&lt;tr>'</span><span>)</span><span>;</span>

    <span>// 生成表头</span>
    $<span>.</span><span>each</span><span>(</span>header<span>,</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      array<span>.</span><span>push</span><span>(</span><span>'&lt;th>'</span> <span>+</span> <span>this</span> <span>+</span> <span>'&lt;/th>'</span><span>)</span><span>;</span>
    <span>}</span><span>)</span>
    array<span>.</span><span>push</span><span>(</span><span>'&lt;/tr>'</span><span>)</span><span>;</span>


    <span>// 生成数据行</span>
    $<span>.</span><span>each</span><span>(</span>data<span>,</span> <span>function</span> <span>(</span><span>index</span><span>)</span> <span>{</span>
      <span>// this是当前遍历到的数组中的每一个对象</span>
      <span>// 拼数据行</span>
      array<span>.</span><span>push</span><span>(</span><span>'&lt;tr>'</span><span>)</span><span>;</span>
      array<span>.</span><span>push</span><span>(</span><span>'&lt;td>'</span> <span>+</span> <span>(</span>index <span>+</span> <span>1</span><span>)</span> <span>+</span> <span>'&lt;/td>'</span><span>)</span><span>;</span>

      <span>// 遍历对象，拼表格</span>
      <span>for</span> <span>(</span><span>var</span> key <span>in</span> <span>this</span><span>)</span> <span>{</span>
        array<span>.</span><span>push</span><span>(</span><span>'&lt;td>'</span> <span>+</span> <span>this</span><span>[</span>key<span>]</span> <span>+</span> <span>'&lt;/td>'</span><span>)</span><span>;</span>
      <span>}</span>

      array<span>.</span><span>push</span><span>(</span><span>'&lt;/tr>'</span><span>)</span><span>;</span>
    <span>}</span><span>)</span>
    array<span>.</span><span>push</span><span>(</span><span>'&lt;/table>'</span><span>)</span><span>;</span>

    <span>this</span><span>.</span><span>append</span><span>(</span>array<span>.</span><span>join</span><span>(</span><span>''</span><span>)</span><span>)</span><span>;</span>
  <span>}</span>

<span>}</span><span>(</span>window<span>.</span>jQuery<span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><ul>
<li>插件开发的原理</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/frontEnd/npm/</link>
      <guid>https://wangyawei.top/views/frontEnd/npm/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>NPM</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些自己平时积累的<strong>npm</strong>相关的知识；</p>
</blockquote>
<h2 id="目录"> 目录</h2>
<ul>
<li><a href="./npm-note-00.html">安装npm</a></li>
<li><a href="./npm-note-01.html">npm设置下载源</a></li>
<li><a href="./npm-note-02.html">全局安装和本地安装</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>安装npm</title>
      <link>https://wangyawei.top/views/frontEnd/npm/npm-note-00/</link>
      <guid>https://wangyawei.top/views/frontEnd/npm/npm-note-00/</guid>
      <source url="https://wangyawei.top/rss.xml">安装npm</source>
      <category>NPM</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>npm是Nodejs的官方包管理工具，可以安装、更新、卸载npm包。新版本的nodejs内置了Npm所以不需要我们在另外安装。这里主要说一下，单独安装npm的情况。</p>
</blockquote>
<div><p>提示</p>
<p>注意Npm的使用需要nodejs支持，所以请确定你已经安装了nodejs。</p>
</div>
<h2 id="演示1"> 演示1</h2>
<blockquote>
<p>这里需要注意一下，因为Nodejs和npm的版本有对应关系，如果版本不对应或差异太大，则会安装不成功；</p>
</blockquote>
<ol>
<li>
<p>Nodejs版本：<code>nodejs@0.12.18</code></p>
</li>
<li>
<p>git克隆的npm版本为：<code>npm@2.1.2</code></p>
</li>
<li>
<p>进入cli目录，执行以下命令；</p>
<div><pre><code>C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span><span>34</span><span>\</span>cli<span>></span>node -v
v0.12.18

C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span><span>34</span><span>\</span>cli<span>></span>node cli.js <span>install</span> npm@2.1.2 -g
C:<span>\</span>Program Files <span>(</span>x86<span>)</span><span>\</span>nodejs<span>\</span>npm -<span>></span> C:<span>\</span>Program Files <span>(</span>x86<span>)</span><span>\</span>nodejs<span>\</span>node_modules<span>\</span>npm<span>\</span>bin<span>\</span>npm-cli.js
npm@2.1.2 C:<span>\</span>Program Files <span>(</span>x86<span>)</span><span>\</span>nodejs<span>\</span>node_modules<span>\</span>npm

C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span><span>34</span><span>\</span>cli<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p>此时你已经安装成功，你可以在<code>C:\Program Files (x86)\nodejs</code>文件中查看；当然你也可以不全局安装。</p>
</blockquote>
</li>
</ol>
<p><img src="./assets/image-20210711200928890.png" alt="image-20210711200928890" /></p>
<div><pre><code><span># 此时你便可以全局使用</span>
PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>></span> node -v
v0.12.18
PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>></span> <span>npm</span> -v
<span>2.1</span>.2
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><p>提示</p>
<p>注意：nodejs@0.12.18版本本身内置Npm，所以你不需要下载，以上演示是在删除了<code>C:\Program Files (x86)\nodejs\node_modules</code>下的<strong>npm</strong>和<code>C:\Program Files (x86)\nodejs</code>文件中的<strong>npm.xx</strong>后，做的操作。</p>
</div>
<h2 id="演示2"> 演示2</h2>
<blockquote>
<p>这里下载的Nodejs是14.17.3版本，实际上是附带Npm的，但是在安装过程中时可以选择是个否安装Npm，这里我为了演示就取消了npm的安装。</p>
</blockquote>
<ol>
<li>
<p>Nodejs版本：<code>nodejs@v14.17.3</code></p>
<p><img src="./assets/image-20210711205003776.png" alt="image-20210711205003776" /></p>
<div><pre><code><span># 查看node和npm版本</span>
PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span><span>34</span><span>\</span>cli<span>></span> node -v
v14.17.3
PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span><span>34</span><span>\</span>cli<span>></span> <span>npm</span> -v
<span>npm</span> <span>:</span> 无法将“npm”项识别为 cmdlet、函数、脚本文件或可运行程序的名称。请检查名称的拼写，如果包括路径，请确保路径正确，然后再试一次。
所在位置 行:1 字符: <span>1</span>
+ <span>npm</span> -v
+ ~~~
    + CategoryInfo          <span>:</span> ObjectNotFound: <span>(</span>npm:String<span>)</span> <span>[</span><span>]</span>, CommandNotFoundException
    + FullyQualifiedErrorId <span>:</span> CommandNotFoundException
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
<li>
<p>git克隆的npm版本为：<code>npm@7.19.1</code></p>
</li>
<li>
<p>进入cli目录，执行以下命令；</p>
<div><pre><code><span># node .\lib\npm.js install npm -g 和 node .\cli install npm -g 等价</span>
PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span><span>34</span><span>\</span>cli<span>></span> node .<span>\</span>lib<span>\</span>npm.js <span>install</span> <span>npm</span> -g
C:<span>\</span>Program Files<span>\</span>nodejs<span>\</span>npx -<span>></span> C:<span>\</span>Program Files<span>\</span>nodejs<span>\</span>node_modules<span>\</span>npm<span>\</span>bin<span>\</span>npx-cli.js
C:<span>\</span>Program Files<span>\</span>nodejs<span>\</span>npm -<span>></span> C:<span>\</span>Program Files<span>\</span>nodejs<span>\</span>node_modules<span>\</span>npm<span>\</span>bin<span>\</span>npm-cli.js
+ npm@7.19.1
added <span>256</span> packages from <span>146</span> contributors <span>in</span> <span>11</span>.689s
PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>\</span><span>34</span><span>\</span>cli<span>></span> <span>npm</span> -v
<span>7.19</span>.1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
</ol>
<p><img src="./assets/image-20210711205852547.png" alt="image-20210711205852547" /></p>
<h2 id="注意"> 注意</h2>
<ol>
<li>在演示1中：cli根目录中有cli.js，但是在演示2中没有这个文件。我们可以通过查看<code>package.json</code>文件中的<code>main</code>字段来确定我们需要执行的文件<code>&quot;main&quot;: &quot;./lib/npm.js&quot;,</code>;</li>
<li>通过这种方式安装的nodejs，全局安装的npm包会存在两个地方：
<ul>
<li>在nodejs的安装目录中的<code>node_modules</code>文件夹中。</li>
<li>不在nodejs的安装目录中，nodejs的安装目录中只有全局安装的npm包，不含有其他包。其他包在<code>C:\Users\wangy\AppData\Roaming\npm</code>中。同时npm缓存文件也在../Roaming/文件下。</li>
</ul>
</li>
</ol>
<h2 id="nodejs与npm的版本对应关系"> Nodejs与npm的版本对应关系</h2>
<p>https://nodejs.org/zh-cn/download/releases/</p>
]]></content:encoded>
    </item>
    <item>
      <title>npm设置下载源</title>
      <link>https://wangyawei.top/views/frontEnd/npm/npm-note-01/</link>
      <guid>https://wangyawei.top/views/frontEnd/npm/npm-note-01/</guid>
      <source url="https://wangyawei.top/rss.xml">npm设置下载源</source>
      <category>NPM</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="npm设置下载源"> npm设置下载源</h2>
<blockquote>
<p>在项目中下载依赖是在正常不过的事情了，但是我们知道npm的官方下载源是国外的服务器，在国内使用下载速度比较慢，那么我们为了提高下载的速度，往往会选择国内的下载源，这个时候就需要设置Npm的下载源了</p>
</blockquote>
<p>常用下载源；</p>
<div><pre><code><span># npm </span>
https://registry.npmjs.org/

<span># cnpm</span>
http://r.cnpmjs.org/

<span># taobao</span>
https://registry.npm.taobao.org/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>设置下载源：</p>
<div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/vue.3.0/viteee/myVite_three
$ <span>npm</span> config get registry
http://r.cnpmjs.org/

ASUS@yaweidediannao MINGW64 ~/Desktop/vue.3.0/viteee/myVite_three
$ <span>npm</span> config <span>set</span> registry https://registry.npmjs.org/

ASUS@yaweidediannao MINGW64 ~/Desktop/vue.3.0/viteee/myVite_three
$ <span>npm</span> config get registry
https://registry.npmjs.org/
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>全局安装和本地安装</title>
      <link>https://wangyawei.top/views/frontEnd/npm/npm-note-02/</link>
      <guid>https://wangyawei.top/views/frontEnd/npm/npm-note-02/</guid>
      <source url="https://wangyawei.top/rss.xml">全局安装和本地安装</source>
      <category>NPM</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>开发web项目你一定会使用npm包管理器安装各种包，那么你知道Npm包的安装方式：全局安装和本地安装的区别吗？<strong>注意：以下示例是<code>window系统</code></strong></p>
</blockquote>
<h2 id="全局安装"> 全局安装</h2>
<blockquote>
<p>全局安装会将安装包放在 <code>C:\Users\[username]\AppData\Roaming\npm\node_modules</code>目录中，可以直接在命令行里使用。</p>
</blockquote>
<div><pre><code><span>npm</span> <span>install</span> -g packageName
</code></pre>
<div><span>1</span><br></div></div><div><pre><code>PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>></span> <span>npm</span> <span>install</span> -g serve
<span>npm</span> WARN registry Unexpected warning <span>for</span> https://registry.npmjs.org/: Miscellaneous Warning ECONNRESET: request to https://registry.npmjs.org/ajv failed, reason: <span>read</span> ECONNRESET
<span>npm</span> WARN registry Using stale data from https://registry.npmjs.org/ due to a request error during revalidation.
C:<span>\</span>Users<span>\</span>wangy<span>\</span>AppData<span>\</span>Roaming<span>\</span>npm<span>\</span>serve -<span>></span> C:<span>\</span>Users<span>\</span>wangy<span>\</span>AppData<span>\</span>Roaming<span>\</span>npm<span>\</span>node_modules<span>\</span>serve<span>\</span>bin<span>\</span>serve.js
+ serve@12.0.0
added <span>88</span> packages from <span>42</span> contributors <span>in</span> <span>125</span>.131s
PS C:<span>\</span>Users<span>\</span>wangy<span>\</span>Desktop<span>></span> serve -v
<span>12.0</span>.0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="本地安装"> 本地安装</h2>
<blockquote>
<p>将安装包放在 ./node_modules 下，可以通过 require() 来引入本地安装的包。</p>
</blockquote>
<div><pre><code><span>npm</span> <span>install</span> packageName
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>const</span> express <span>=</span> <span>require</span><span>(</span><span>'express'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/frontEnd/react/</link>
      <guid>https://wangyawei.top/views/frontEnd/react/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>REACT</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些自己平时积累的<strong>react</strong>相关的知识；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>react 基础语法</title>
      <link>https://wangyawei.top/views/frontEnd/react/react-note-00/</link>
      <guid>https://wangyawei.top/views/frontEnd/react/react-note-00/</guid>
      <source url="https://wangyawei.top/rss.xml">react 基础语法</source>
      <category>REACT</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="react的特点"> <code>React</code>的特点；</h2>
<h3 id="_1、声明式"> 1、声明式；</h3>
<ul>
<li>可以声明式的在<code>js</code>中写<code>html</code>结构；</li>
</ul>
<blockquote>
<p>注意: <code>react</code>是用很像 <code>js</code> 的语言写标签;</p>
</blockquote>
<div><pre><code><span>const</span> jsx <span>=</span> <span><span><span>&lt;</span>div</span> <span>className</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span><span><span><span>&lt;</span>h1</span><span>></span></span><span>Hello React! 动态变化数据：</span><span>{</span>count<span>}</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span> </span><span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="_2、基于组件"> 2、基于组件；</h3>
<ul>
<li>组件是<code>React</code>最重要的部分；</li>
<li>组合、复用多个组件，可以实现完整的页面功能;</li>
</ul>
<h3 id="_3、学习一次-随处可用"> 3、学习一次，随处可用；</h3>
<ul>
<li>使用<code>React</code>可以开发 Web 应用、移动端原生应用（react-native）、 VR（虚拟现实）应用（react 360）</li>
</ul>
<h2 id="react的基本使用"> <code>React</code>的基本使用；</h2>
<h3 id="_1、安装"> 1、安装；</h3>
<div><pre><code>1、安装命令： $ npm i react react-dom
2、react 包是核心，提供创建元素、组件等功能 ；
3、react-dom 包提供 DOM 相关功能等；
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_2、使用"> 2、使用；</h3>
<ol>
<li>引入<code>react</code>和<code>react-dom</code>两个 js 文件;</li>
</ol>
<div><pre><code> <span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>./node_modules/react/umd/react.development.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span> 
  <span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>./node_modules/react-dom/umd/react-dom.development.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code> 2.	创建`React`元素；
    	 3.	渲染React元素到页面中;
</code></pre>
</div><div><pre><code><span>// 指定要渲染的范围；</span>
<span>&lt;</span>div id<span>=</span><span>"root"</span><span>></span><span>&lt;</span><span>/</span>div<span>></span>

<span>&lt;</span>script<span>></span> 
    <span>// React.createElement()方法用于创建react元素；</span>
    <span>// - 返回值：React元素</span>
    <span>// - 第一个参数：要创建的React元素名称</span>
    <span>// - 第二个参数：该React元素的属性</span>
    <span>// - 第三个及其以后的参数：该React元素的子节点，节点也可以是标签</span>
    
    <span>const</span> h1 <span>=</span> React<span>.</span><span>createElement</span><span>(</span><span>'h1'</span><span>,</span> <span>null</span><span>,</span> <span>'晚上好哈哈哈哈'</span><span>)</span>
    <span>const</span> span <span>=</span> React<span>.</span><span>createElement</span><span>(</span><span>'span'</span><span>,</span> <span>null</span><span>,</span> <span>'李逵'</span><span>)</span>
    <span>const</span> p <span>=</span> React<span>.</span><span>createElement</span><span>(</span><span>'p'</span><span>,</span> <span>{</span> className<span>:</span> <span>'so'</span> <span>}</span><span>,</span> <span>'李白'</span><span>,</span> span<span>)</span>
    <span>const</span> div <span>=</span> React<span>.</span><span>createElement</span><span>(</span><span>'div'</span><span>,</span> <span>null</span><span>,</span> <span>'我是div'</span><span>,</span> p<span>,</span> h1<span>)</span>

    <span>// ReactDOM.render() 说明</span>
    <span>// - 返回值:React元素</span>
    <span>// - 第一个参数：要渲染的React元素</span>
    <span>// - 第二个参数：DOM对象，用于指定渲染到页面中的位置</span>
    ReactDOM<span>.</span><span>render</span><span>(</span>div<span>,</span>document<span>.</span><span>getElementById</span><span>(</span><span>'root'</span><span>)</span><span>)</span>
<span>&lt;</span><span>/</span>script<span>></span> 

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="react脚手架"> <code>React</code>脚手架;</h2>
<h3 id="_1、脚手架的意义"> 1、脚手架的意义；</h3>
<ol>
<li>脚手架是开发现代Web 应用的必备。</li>
<li>充分利用<code>Webpack</code>、<code>Babel</code>、<code>ESLint</code>等工具辅助项目开发。</li>
<li>零配置，无需手动配置繁琐的工具即可使用。</li>
<li>关注业务，而不是工具配置。</li>
</ol>
<h3 id="_2、项目初始化"> 2、项目初始化；</h3>
<ol>
<li>初始化项目：<code>npx create-react-app my-app</code>;</li>
<li>启动项目：<code>npm start</code>，需切换到项目根目录；</li>
</ol>
<p><img src="./assets/1577501389161.png" alt="1577501389161" /></p>
<blockquote>
<p><code>npx</code>命令介绍</p>
<ul>
<li><code>npm v5.2.0</code> 引入的一条命令 。</li>
<li>目的：提升包内提供的命令行工具的使用体验 。</li>
<li>原来：先安装脚手架包，再使用这个包中提供的命令 。</li>
<li>现在：无需安装脚手架包，就可以直接使用这个包提供的命令 。</li>
</ul>
</blockquote>
<h3 id="_3、使用react"> 3、使用<code>React</code>；</h3>
<ol>
<li>
<p>导入<code>react</code>和<code>react-dom</code>两个包。</p>
<div><pre><code><span>import</span> React <span>from</span> <span>'react'</span> 
<span>import</span> ReactDOM <span>from</span> <span>'react-dom'</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>调用<code>React.createElement()</code>方法创建 react 元素。</p>
<ol>
<li><strong>不建议使用代码繁琐</strong>；</li>
<li>不直观，无法一眼看出所描述的结构。</li>
<li>不优雅，用户体验不爽。</li>
<li>使用<code>JSX</code>替代。</li>
</ol>
</li>
<li>
<p>调用<code>ReactDOM.render()</code>方法渲染 react 元素到页面中。</p>
</li>
</ol>
<h2 id="jsx介绍"> <code>JSX</code>介绍；</h2>
<ul>
<li><code>JSX</code>是<code>JavaScript XML</code>的简写，表示在 JavaScript 代码中写 XML（HTML） 格式的代码。</li>
<li>优势：声明式语法更加直观、与HTML结构相同，降低了学习成本、提升开发效率</li>
<li><code>JSX</code>是 React 的核心内容。</li>
</ul>
<blockquote>
<ol>
<li><code>JSX</code>不是标准的<code>ECMAScript</code>语法，它是<code>ECMAScript</code>的语法扩展。</li>
<li>需要使用<code>babel</code>编译处理后，才能在浏览器环境中使用。</li>
<li><code>create-react-app</code>脚手架中已经默认有该配置，无需手动配置。</li>
<li><code>JSX</code>是<code>React.createElement</code>方法的语法糖。</li>
</ol>
</blockquote>
<h3 id="_1、使用步骤"> 1、使用步骤；</h3>
<ol>
<li>
<p>使用<code>JSX</code>法创建 react 元素。</p>
<div><pre><code><span>// 使用 JSX 语法，创建 react 元素： </span>
<span>const</span> title <span>=</span> <span><span><span>&lt;</span>h1</span><span>></span></span><span>Hello JSX</span><span><span><span>&lt;/</span>h1</span><span>></span></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>使用<code>ReactDOM.render()</code>方法渲染 react 元素到页面中。</p>
<div><pre><code><span>// 渲染创建好的React元素 </span>
ReactDOM<span>.</span><span>render</span><span>(</span>title<span>,</span> document<span>.</span><span>getElementById</span><span>(</span><span>'root'</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ol>
<h3 id="_2、注意事项"> 2、注意事项；</h3>
<ol>
<li>
<p><code>React</code>元素的属性名使用小驼峰命名法。</p>
</li>
<li>
<p>特殊属性名：class -&gt; className、for -&gt; htmlFor、tabindex -&gt; tabIndex 。</p>
</li>
<li>
<p>没有子节点的React元素可以用 /&gt; 结束 。</p>
</li>
<li>
<p>推荐：使用<strong>小括号包裹 JSX</strong> ，从而避免<code>JS</code>中的自动插入分号陷阱。</p>
<div><pre><code><span>// 使用小括号包裹 JSX </span>
<span>const</span> dv <span>=</span> <span>(</span> 
  <span><span><span>&lt;</span>div</span><span>></span></span><span>Helo JSX</span><span><span><span>&lt;/</span>div</span><span>></span></span> 
<span>)</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ol>
<h3 id="_3、jsx中使用js表达式"> 3、<code>JSX</code>中使用<code>JS</code>表达式；</h3>
<ol>
<li>
<p>嵌入<code>JS</code>表达式；</p>
<ul>
<li>
<p>语法：{ JavaScript表达式 }</p>
</li>
<li>
<p><strong>注意</strong>：语法中是单大括号，不是双大括号！</p>
<div><pre><code><span>// 例：</span>
<span>const</span> name <span>=</span> <span>'小红'</span>
<span>const</span> <span>fn</span> <span>=</span> <span>function</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span><span><span>&lt;</span>h3</span><span>></span></span><span>h3</span><span><span><span>&lt;/</span>h3</span><span>></span></span>
<span>}</span>
  <span>const</span> app <span>=</span> <span>(</span>
       <span><span><span>&lt;</span>div</span><span>></span></span><span>
         </span><span><span><span>&lt;</span>div</span><span>></span></span><span>{</span><span>'猪八戒'</span><span>}</span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
         </span><span><span><span>&lt;</span>div</span><span>></span></span><span>{</span>name<span>}</span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
         </span><span><span><span>&lt;</span>div</span><span>></span></span><span>{</span><span>fn</span><span>(</span><span>)</span><span>}</span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
         </span><span><span><span>&lt;</span>div</span><span>></span></span><span>{</span><span>100</span><span>}</span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
      	</span><span><span><span>&lt;</span>div</span><span>></span></span><span>{</span><span>true</span> <span>?</span> <span>'输出正确'</span> <span>:</span> <span>'输出错误'</span><span>}</span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
	  </span><span><span><span>&lt;/</span>div</span><span>></span></span>
        <span>)</span>
  
  ReactDOM<span>.</span><span>render</span><span>(</span>app<span>,</span> document<span>.</span><span>getElementById</span><span>(</span><span>'root'</span><span>)</span><span>)</span><span>;</span>

 注意：
 <span>1.</span> 单大括号中可以使用任意的 JavaScript 表达式 （值，变量，函数调用，三元运算符，数组）。
 <span>2.</span> <span><span>`</span><span>JSX </span><span>`</span></span>自身也是<span><span>`</span><span>JS </span><span>`</span></span>表达式 。
 <span>3.</span> <span>**</span>注意<span>**</span>：不能在 <span>{</span><span>}</span> 中出现语句和对象（比如：<span>if</span><span>/</span><span>for</span>，<span>{</span>a<span>:</span><span>100</span><span>}</span> 等） 。

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div></li>
</ul>
</li>
<li>
<p><code>JSX</code>条件渲染；</p>
<ul>
<li>
<p>如果要渲染一组数据，应该使用数组的 map() 方法 ；</p>
<div><pre><code><span>// jsx的列表渲染；</span>
<span>const</span> songs <span>=</span> <span>[</span>
  <span>{</span> id<span>:</span> <span>1</span><span>,</span> name<span>:</span> <span>'野狼dicso'</span> <span>}</span><span>,</span>
  <span>{</span> id<span>:</span> <span>2</span><span>,</span> name<span>:</span> <span>'像我这样的人'</span> <span>}</span><span>,</span>
  <span>{</span> id<span>:</span> <span>3</span><span>,</span> name<span>:</span> <span>'桥边姑娘'</span> <span>}</span>
<span>]</span><span>;</span>

<span>const</span> app <span>=</span> <span>(</span>
  <span><span><span>&lt;</span>div</span><span>></span></span><span>
    </span><span>{</span>
     songs<span>.</span><span>map</span><span>(</span><span>item</span> <span>=></span> <span><span><span>&lt;</span>h1</span> <span>key</span><span><span>=</span><span>{</span> item<span>.</span>id <span>}</span></span><span>></span></span><span>{</span> item<span>.</span>name <span>}</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>)</span>
    <span>}</span><span>
  </span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span>)</span>
ReactDOM<span>.</span><span>render</span><span>(</span>app<span>,</span> document<span>.</span><span>getElementById</span><span>(</span><span>'root'</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></li>
</ul>
<blockquote>
<p>注意：渲染列表时应该添加 key 属性，key 属性的值要保证唯一。</p>
<p>注意：尽量避免使用索引号作为 key !</p>
</blockquote>
</li>
</ol>
<h3 id="_4、jsx样式处理"> 4、<code>JSX</code>样式处理；</h3>
<ol>
<li>
<p>行内样式；</p>
<ul>
<li>注意：是双大花括号；</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>h1</span> <span>style</span><span><span>=</span><span>{</span><span>{</span> color<span>:</span> <span>'red'</span><span>,</span> backgroundColor<span>:</span> <span>'#eee'</span> <span>}</span><span>}</span></span><span>></span></span><span> 
  JSX的样式处理 
</span><span><span><span>&lt;/</span>h1</span><span>></span></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>类样式；</p>
<ul>
<li>
<p>推荐使用<code>className</code>的方式给<code>JSX</code>添加样式。</p>
</li>
<li>
<p>注意：使用小驼峰命名；</p>
</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>h1</span> <span>className</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span><span> 
 JSX的样式处理 
</span><span><span><span>&lt;/</span>h1</span><span>></span></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ol>
<h2 id="react组件"> <code>React</code>组件；</h2>
<h3 id="_1、组件的特点"> 1、组件的特点；</h3>
<ul>
<li>可复用、独立、可组合；</li>
<li>多个组件实现完整的页面功能 ；</li>
</ul>
<h3 id="_2、组件的创建"> 2、组件的创建；</h3>
<h4 id="_2-1-使用函数创建组件"> 2.1 使用函数创建组件；</h4>
<ul>
<li>
<p>函数组件：使用<code>JS</code>的函数（或箭头函数）创建的组件;</p>
<ul>
<li>函数体内要返回<code>JSX</code>元素。</li>
</ul>
</li>
<li>
<p>渲染函数组件：<strong>用函数名作为组件标签名</strong> 。</p>
<div><pre><code><span>// 例：</span>
<span>function</span> <span>Hello</span><span>(</span><span>)</span> <span>{</span> 
  <span>return</span> <span>(</span> 
    <span><span><span>&lt;</span>div</span><span>></span></span><span>这是我的第一个函数组件！</span><span><span><span>&lt;/</span>div</span><span>></span></span> 
  <span>)</span> 
<span>}</span> 
ReactDOM<span>.</span><span>render</span><span>(</span><span><span><span>&lt;</span><span>Hello</span></span> <span>/></span></span><span>,</span> document<span>.</span><span>getElementById</span><span>(</span><span>'root'</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>
<p>注意：</p>
<p>​	1、函数名称必须以<strong>大写字母</strong>开头，使用<strong>大驼峰</strong>命名法；</p>
<p>​	2、函数组件必须有<strong>返回值</strong>，表示该组件的结构；</p>
<p>​	3、<strong>组件标签可以单闭合</strong>；</p>
</blockquote>
</li>
</ul>
<h4 id="_2-2-使用class创建组件"> 2.2 使用<code>class</code>创建组件；</h4>
<ul>
<li>
<p>类组件：使用<code>ES6</code>的<code>class</code>关键字 创建的组件 。</p>
</li>
<li>
<p>类组件应该继承<code>React.Component</code>父类，从而可以使用父类中提供的方法和属性。</p>
<div><pre><code><span>class</span> <span>Hello</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span> 
  <span>render</span><span>(</span><span>)</span> <span>{</span> 
    <span>return</span> <span><span><span>&lt;</span>div</span><span>></span></span><span>Hello Class Component!</span><span><span><span>&lt;/</span>div</span><span>></span></span> 
  <span>}</span> 
<span>}</span> 
ReactDOM<span>.</span><span>render</span><span>(</span><span><span><span>&lt;</span><span>Hello</span></span> <span>/></span></span><span>,</span> root<span>)</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>
<p>注意：</p>
<p>​	1、<strong>类名称也必须以大写字母开头</strong>，<strong>使用大驼峰命名法</strong>  。</p>
<p>​	2、类组件必须提供<code>render()</code>方法 。</p>
<p>​	3、 <code>render()</code>方法必须有返回值，表示该组件的结构。</p>
</blockquote>
</li>
</ul>
<h4 id="_2-3-组件分离"> 2.3 组件分离；</h4>
<ol>
<li>首先引入<code>React</code>核心包</li>
<li>创建组件</li>
<li>导出组件</li>
</ol>
<h3 id="_3、组件封装"> 3、组件封装；</h3>
<h4 id="_3-1、组件复用"> 3.1、组件复用；</h4>
<ol>
<li>
<p>复用什么？1.  state  2.  操作state的方法 （组件状态逻辑 ）</p>
</li>
<li>
<p>两种方式：1.  <strong>render props模式</strong>  2.  <strong>高阶组件（HOC）</strong></p>
</li>
<li>
<p><strong>render props模式</strong>；</p>
<blockquote>
<p>复用的是组件的状态和功能，传入的是<code>UI</code>要呈现的效果。</p>
</blockquote>
<p><img src="./assets/1577801731784.png" alt="1577801731784" /></p>
</li>
<li>
<p><strong>高阶组件；</strong></p>
<blockquote>
<p>高阶组件本质上就是<strong>高阶函数</strong>。</p>
<p>高阶组件（HOC，Higher-Order Component）<strong>是一个函数</strong>，接收要包装的组件，返回增强后的组件</p>
<p>高阶组件：<strong>参数为组件</strong>，返回值为<strong>新组件的函数。</strong></p>
</blockquote>
<ol>
<li>创建一个函数，名称约定以 with 开头 。</li>
<li>指定函数参数，参数应该以大写字母开头（作为要渲染的组件）。</li>
<li>在函数内部创建一个类组件，提供复用的状态逻辑代码，并返回 。</li>
<li>在该组件中，渲染参数组件，同时将状态通过prop传递给参数组件。</li>
<li>调用该高阶组件，传入要增强的组件，通过返回值拿到增强后的组件,并将其渲染到页面中 。</li>
</ol>
<div><pre><code><span>// 创建一个函参数为 ：组件</span>
<span>function</span> <span>withMouse</span><span>(</span><span>WrappedComponent</span><span>)</span> <span>{</span> 
  <span>// 创建类组件并返回</span>
  <span>return</span> <span>class</span> <span>MouseHoc</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
    state <span>=</span> <span>{</span>
      x<span>:</span><span>0</span><span>,</span>
      y<span>:</span><span>0</span>
    <span>}</span>
    
    <span>render</span><span>(</span><span>)</span> <span>{</span>
      <span>// 使用参数组件的并传入 状态参数；</span>
      <span>return</span> <span><span><span>&lt;</span><span>WrappedComponent</span></span> <span><span>{</span><span>...</span><span>this</span><span>.</span>state<span>}</span></span> <span>/></span></span> 
    <span>}</span>
  <span>}</span> 
<span>}</span> 

<span>// 创建组件 Position为要传入的另一个函数组件；</span>
<span>const</span> MousePosition <span>=</span> <span>withMouse</span><span>(</span>Position<span>)</span> 
 
<span>// 渲染组件 </span>
<span><span><span>&lt;</span><span>MousePosition</span></span> <span>/></span></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></li>
</ol>
<h2 id="react事件处理"> <code>React</code>事件处理；</h2>
<h3 id="_1、事件绑定"> 1、事件绑定；</h3>
<ol>
<li>语法：on + 事件名称 = { 事件处理程序 }，比如：<code>onClick={() =&gt; {}}</code></li>
<li>注意：React 事件采用小驼峰命名法，比如：<code>onMouseEnter</code>、<code>onFocus</code></li>
</ol>
<div><pre><code><span>// 类组件事件绑定；</span>
<span>import</span> React <span>from</span> <span>'react'</span>

<span>class</span> <span>Index</span> <span>extends</span> <span>React<span>.</span>Component</span><span>{</span>
  <span>OnLick</span> <span>(</span><span>event</span><span>)</span> <span>{</span>
    <span>// 阻止默认行为</span>
    event<span>.</span><span>preventDefault</span><span>(</span><span>)</span>
    <span>// 阻止事件冒泡</span>
    event<span>.</span><span>stopPropagation</span><span>(</span><span>)</span>
    <span>alert</span><span>(</span><span>1</span><span>)</span>
  <span>}</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span>div</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span> <span>this</span><span>.</span>OnLick <span>}</span></span><span>></span></span><span>按钮</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span> <span>(</span><span>)</span> <span>=></span> <span>{</span> <span>alert</span><span>(</span><span>3</span><span>)</span> <span>}</span> <span>}</span></span><span>></span></span><span>按钮</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
        </span><span><span><span>&lt;</span><span>Fn</span></span><span>></span></span><span><span><span>&lt;/</span><span>Fn</span></span><span>></span></span><span>
      </span><span><span><span>&lt;/</span>div</span><span>></span></span>
    <span>)</span>
  <span>}</span>
<span>}</span>

<span>// 函数组件事件绑定；</span>
<span>function</span> <span>Fn</span><span>(</span><span>)</span> <span>{</span>
  <span>var</span> <span>OnLick</span> <span>=</span> <span>function</span> <span>(</span><span>e</span><span>)</span> <span>{</span>
      
    <span>alert</span><span>(</span><span>8</span><span>)</span>
    console<span>.</span><span>log</span><span>(</span>e<span>)</span> <span>// 事件对象</span>
  <span>}</span>
  <span>return</span> <span>(</span>
    <span><span><span>&lt;</span>div</span><span>></span></span><span>
      </span><span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span> OnLick <span>}</span></span><span>></span></span><span>函数组件</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span>
  <span>)</span>
<span>}</span>

<span>export</span> <span>default</span> Index
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><h3 id="_2、事件对象"> 2、事件对象；</h3>
<ol>
<li>
<p>可以通过事件处理程序的默认参数获取到事件对象。</p>
</li>
<li>
<p>React 中的事件对象叫做：合成事件（对象）。</p>
</li>
<li>
<p>合成事件：兼容所有浏览器，无需担心跨浏览器兼容性问题。</p>
<div><pre><code><span>function</span> <span>handleClick</span><span>(</span><span>e</span><span>)</span> <span>{</span> 
  e<span>.</span><span>preventDefault</span><span>(</span><span>)</span> 
  console<span>.</span><span>log</span><span>(</span><span>'事件对象'</span><span>,</span> e<span>)</span> 
<span>}</span> 
<span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>http://www.baidu.com<span>"</span></span> <span>onClick</span><span><span>=</span><span>{</span>handleClick<span>}</span></span><span>></span></span><span>点我，不会跳转页面</span><span><span><span>&lt;/</span>a</span><span>></span></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
</ol>
<h3 id="_3、this指向问题"> 3、<code>this</code>指向问题；</h3>
<ol>
<li>
<p>利用<code>bind</code>修改<code>this</code>指向组件实例。</p>
<div><pre><code><span>// 类组件事件绑定；</span>
<span>import</span> React <span>from</span> <span>'react'</span>

<span>class</span> <span>Index</span> <span>extends</span> <span>React<span>.</span>Component</span><span>{</span>
    
  <span>constructor</span><span>(</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span><span>)</span><span>;</span>
    <span>// 使用bind方法绑定this</span>
    <span>this</span><span>.</span>OnLick <span>=</span> <span>this</span><span>.</span><span>OnLick</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>;</span>
  <span>}</span>
  <span>// 不改变this指向，不能以 this.num 的方式拿到 num 的值；</span>
  num <span>=</span> <span>10</span><span>;</span>

  <span>OnLick</span> <span>(</span><span>event</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>num<span>)</span>
  <span>}</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span>div</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span> <span>this</span><span>.</span>OnLick <span>}</span></span><span>></span></span><span>按钮</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
      </span><span><span><span>&lt;/</span>div</span><span>></span></span>
    <span>)</span>
  <span>}</span>
<span>}</span>
<span>export</span> <span>default</span> Index
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></li>
<li>
<p>利用箭头函数方法**(推荐)**;</p>
<blockquote>
<p>注意：该语法是实验性语法，但是，由于babel的存在可以直接使用</p>
</blockquote>
<div><pre><code><span>class</span> <span>Index</span> <span>extends</span> <span>React<span>.</span>Component</span><span>{</span>
  <span>// 使用es6 箭头函数绑定this</span>
  <span>OnLick</span> <span>=</span> <span>(</span><span>event</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>num<span>)</span>
  <span>}</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span>div</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span> <span>this</span><span>.</span>OnLick <span>}</span></span><span>></span></span><span>按钮</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
      </span><span><span><span>&lt;/</span>div</span><span>></span></span>
    <span>)</span>
  <span>}</span>
<span>}</span>
<span>export</span> <span>default</span> Index
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></li>
</ol>
<h3 id="_4、状态组件"> 4、状态组件；</h3>
<h4 id="_4-1-有状态组件"> 4.1 有状态组件；</h4>
<blockquote>
<p>类组件class-&gt;有状态<code>（state）</code>组件;</p>
</blockquote>
<div><pre><code><span>/**
 * 定义类组件状态
 * 语法：state
 * 1. constructor()中
 * 2. 类属性形式定义
 */</span>
<span>class</span> <span>Index</span> <span>extends</span> <span>Component</span> <span>{</span>
    
  <span>//constructor() {</span>
  <span>//  super();</span>
  <span>//  初始化 state </span>
  <span>//  this.state = {</span>
  <span>//    num: 123</span>
  <span>//  }</span>
  <span>//}</span>
    
  <span>// 初始化 state</span>
  state <span>=</span> <span>{</span>
    name<span>:</span> <span>'李晨'</span><span>,</span>
  <span>}</span>
    
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span>div</span><span>></span></span><span>
     // &lt;p>{this.state.num}&lt;/p>
        </span><span><span><span>&lt;</span>p</span><span>></span></span><span>{</span><span>this</span><span>.</span>state<span>.</span>name<span>}</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
      </span><span><span><span>&lt;/</span>div</span><span>></span></span>
    <span>)</span>
  <span>}</span>
<span>}</span>

<span>export</span> <span>default</span> Index<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h4 id="_4-2-无状态组件"> 4.2 无状态组件；</h4>
<ul>
<li>函数组件-&gt;无状态组件</li>
</ul>
<h4 id="_4-1-两者的区别"> 4.1 两者的区别；</h4>
<ul>
<li>函数组件又叫做无状态组件，类组件又叫做有状态组件</li>
<li>状态（state）即数据，某个时刻的值</li>
<li>类组件有自己的状态，负责更新 UI，让页面“动” 起来</li>
<li>函数组件没有自己的状态，只负责数据展示（静）</li>
<li>比如计数器案例中，点击按钮让数值加 1 。0 和 1 就是不同时刻的状态，而由 0 变为 1 就表示状态发生了变 化。状态变化后，UI 也要相应的更新。React 中想要实现该功能，就要使用有状态组件来完成。</li>
</ul>
<h2 id="state和setstate"> <code>state</code>和<code>setState()</code> ;</h2>
<h3 id="_1、state"> 1、<code>state</code>;</h3>
<ol>
<li>状态（state）即数据，是组件内部的私有数据，<strong>只能</strong>在组件内部使用 。</li>
<li>state 的值是对象，表示一个组件中可以有多个数据 。</li>
</ol>
<h3 id="_2、setstate"> 2、<code>setState()</code>；</h3>
<ul>
<li>
<p>状态是可变的</p>
<ul>
<li>语法：<code>this.setState({ key:val, key2:val2 })</code> 。</li>
</ul>
</li>
<li>
<p><code>setState()</code>作用：</p>
<ul>
<li>修改 state</li>
<li>更新<code>UI</code></li>
</ul>
<blockquote>
<p>注意：不能直接修改 state 中的值，this.state.num=2  这样写错误!</p>
</blockquote>
</li>
</ul>
<div><pre><code><span>import</span> React<span>,</span> <span>{</span> Component <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>class</span> <span>Index</span> <span>extends</span> <span>Component</span> <span>{</span>
  <span>// num加一</span>
  <span>handlerNum</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>// 不能直接给状态数据赋值</span>
    <span>// this.state.num = this.state.num + 1</span>
    <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span>
      <span>// key:val</span>
      num<span>:</span> <span>this</span><span>.</span>state<span>.</span>num <span>+</span> <span>1</span>
    <span>}</span><span>)</span>
  <span>}</span>

  state <span>=</span> <span>{</span>
    num<span>:</span> <span>0</span>
  <span>}</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span>div</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h1</span> <span>onClick</span><span><span>=</span><span>{</span><span>this</span><span>.</span>handlerNum<span>}</span></span><span>></span></span><span>有状态组件</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>p</span><span>></span></span><span>{</span><span>this</span><span>.</span>state<span>.</span>num<span>}</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
      </span><span><span><span>&lt;/</span>div</span><span>></span></span>
    <span>)</span>
  <span>}</span>
<span>}</span>

<span>export</span> <span>default</span> Index<span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><h2 id="表单处理"> 表单处理；</h2>
<h3 id="_1、受控组件"> 1、受控组件；</h3>
<blockquote>
<p>概述：其值受到 <code>state</code>状态控制的组件；</p>
</blockquote>
<div><pre><code><span>-</span> <span>HTML</span> 中的表单元素是可输入的，也就是有自己的可变状态 。
<span>-</span> 而React 中可变状态通常保存在 state 中，并且只能通过 <span>setState</span><span>(</span><span>)</span> 方法来修改 。
<span>-</span> React将 state 与表单元素值value绑定到一起，由 state 的值来控制表单元素的值 。
<span>-</span> 受控组件：其值受到 React 控制的表单元素 。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>import</span> React <span>from</span> <span>'react'</span>

<span>class</span> <span>Index</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>// 数据初始化</span>
  state <span>=</span> <span>{</span>
    val<span>:</span> <span>'345'</span>
  <span>}</span>
  <span>setInputVal</span> <span>=</span> <span>(</span><span>event</span><span>)</span> <span>=></span> <span>{</span>
    <span>// 通过 setState 修改 状态数据的值；</span>
    <span>// 注意：只能通过这种方式修改；</span>
    <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span>
      val<span>:</span> event<span>.</span>target<span>.</span>value
    <span>}</span><span>)</span>
  <span>}</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span>div</span><span>></span></span><span>
        // 将 value 值绑定到 状态值上面；
        </span><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>value</span><span><span>=</span><span>{</span> <span>this</span><span>.</span>state<span>.</span>val <span>}</span></span> <span>onChange</span><span><span>=</span><span>{</span> <span>this</span><span>.</span>setInputVal <span>}</span></span><span>/></span></span><span>
      </span><span><span><span>&lt;/</span>div</span><span>></span></span>
    <span>)</span>
  <span>}</span>
<span>}</span>
<span>export</span> <span>default</span> Index

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id="_2、非受控组件"> 2、非受控组件；</h3>
<ul>
<li>
<p>说明：借助于 ref，使用原生 DOM 方式来获取表单元素值 。</p>
</li>
<li>
<p>ref 的作用：获取 DOM 或组件实例 。</p>
<div><pre><code><span>import</span> React <span>from</span> <span>'react'</span>

<span>class</span> <span>Index</span> <span>extends</span> <span>React<span>.</span>Component</span><span>{</span>
  <span>// 创建React 对象；如果要获取多个Dom元素则要创建多个对象；</span>
  texRef <span>=</span> React<span>.</span><span>createRef</span><span>(</span><span>)</span>
  txRef <span>=</span> React<span>.</span><span>createRef</span><span>(</span><span>)</span>
  <span>setInputVal</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>// 获取文本数据；</span>
    console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>texRef<span>)</span>
    console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>txRef<span>.</span>current<span>.</span>value<span>)</span>
  <span>}</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span>div</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>input</span> <span>ref</span><span><span>=</span><span>{</span> <span>this</span><span>.</span>texRef <span>}</span></span> <span>value</span><span><span>=</span><span>"</span>134<span>"</span></span> <span>onChange</span><span><span>=</span><span>{</span> <span>this</span><span>.</span>setInputVal <span>}</span></span><span>/></span></span><span>
        </span><span><span><span>&lt;</span>textarea</span> <span>ref</span><span><span>=</span><span>{</span> <span>this</span><span>.</span>txRef <span>}</span></span> <span>onChange</span><span><span>=</span><span>{</span> <span>this</span><span>.</span>setInputVal <span>}</span></span><span>/></span></span><span>
         </span><span>{</span><span>/* // 函数组件不能绑定ref对象
        &lt;Fnc ref={this.fnRef} /> */</span><span>}</span><span>
      </span><span><span><span>&lt;/</span>div</span><span>></span></span>
    <span>)</span>
  <span>}</span>
<span>}</span>
<span>export</span> <span>default</span> Index

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><blockquote>
<p>注意：不能在函数<strong>组件上</strong>使用 ref，因为它没有实例。不要过度使用Refs。</p>
</blockquote>
</li>
</ul>
<h2 id="组件通讯"> 组件通讯；</h2>
<div><pre><code>概述：
组件是独立且封闭的单元，默认情况下，只能使用组件自己的数据。在组件化过程中，我们将一个完整的功能 拆分成多个组件，以更好的完成整个应用的功能。而在这个过程中，多个组件之间不可避免的要共享某些数据 。为了实现这些功能，就需要打破组件的独立封闭性，让其与外界沟通。这个过程就是组件通讯。
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_1、props的介绍"> 1、<code>props</code>的介绍;</h3>
<ul>
<li>组件是封闭的，要接收外部数据应该通过 props 来实现。</li>
<li>props的作用：接收传递给组件的数据 。</li>
<li>传递数据的方式：给组件标签添加属性  。</li>
<li>接收数据：函数组件通过参数<code>props</code>接收数据，类组件通过<code>this.props</code>接收数据 。</li>
</ul>
<p><img src="./assets/1577609747566.png" alt="1577609747566" /></p>
<h3 id="_2、props特点"> 2、<code>props</code>特点；</h3>
<ol>
<li>
<p>可以给组件传递<strong>任意</strong>类型的数据 。</p>
</li>
<li>
<p>props 是<strong>只读</strong>的对象，只能读取属性的值，<strong>无法修改</strong>对象 。</p>
</li>
<li>
<p><code>children</code>属性：当组件标签有子节点时，props 就会有该属性；</p>
<ul>
<li>
<p>值可以是任意值（文本、React元素、组件，甚至是函数）。</p>
<div><pre><code> <span><span><span>&lt;</span><span>Son</span></span> <span>name</span><span><span>=</span><span>{</span><span>this</span><span>.</span>state<span>.</span>lastname<span>}</span></span><span>></span></span><span>传递数据给子组件</span><span><span><span>&lt;/</span><span>Son</span></span><span>></span></span>
 
 <span>class</span> <span>Son</span> <span>extends</span> <span>React<span>.</span>Component</span><span>{</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>props<span>)</span> <span>// {name: "我是父组件", children: "传递数据给子组件"}</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span>div</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h2</span><span>></span></span><span>类组件接收到数据了：</span><span>{</span> <span>this</span><span>.</span>props<span>.</span>name <span>}</span><span><span><span>&lt;/</span>h2</span><span>></span></span><span>
      </span><span><span><span>&lt;/</span>div</span><span>></span></span>
    <span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
</ul>
<blockquote>
<p>注意：使用类组件时，如果写了构造函数，应该将 props 传递给 super()，否则，无法在构造函数中获取到 props！</p>
</blockquote>
</li>
</ol>
<p><img src="./assets/1577609982259.png" alt="1577609982259" /></p>
<h3 id="_3、props效验"> 3、<code>props</code>效验；</h3>
<blockquote>
<p><strong>说明</strong>：对于子组件来说，props 是接收外来数据的，无法确定父组件在使用子组件时传入什么格式的数据如果传入的数据格式不对，可能会导致组件内部报错 ；</p>
<p><strong>关键问题</strong>：组件的使用者（子）不知道明确的错误原因 ；</p>
</blockquote>
<ol>
<li>props 校验：允许在创建组件的时候，就指定 props 的类型、格式等 。</li>
<li>作用：用于捕获，在使用组件时因为props的类型而导致的错误，用于给出明确的错误提示。</li>
</ol>
<h4 id="_3-1、步骤"> 3.1、步骤；</h4>
<ol>
<li>
<p>安装包 prop-types （yarn add prop-types / npm i props-types）</p>
</li>
<li>
<p>导入 prop-types 包 。</p>
</li>
<li>
<p>使用组件名.propTypes = {} 来给组件的props添加校验类型。</p>
</li>
<li>
<p>校验类型通过 PropTypes 对象来指定 。</p>
<div><pre><code><span>import</span> React<span>,</span> <span>{</span> Component <span>}</span> <span>from</span> <span>'react'</span><span>;</span>
<span>import</span> PropTypes <span>from</span> <span>'prop-types'</span><span>;</span>

<span>//子组件</span>
<span>class</span> <span>Child</span> <span>extends</span> <span>Component</span> <span>{</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> <span>{</span> name <span>}</span> <span>=</span> <span>this</span><span>.</span>props<span>;</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span>div</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h2</span><span>></span></span><span>子组件</span><span><span><span>&lt;/</span>h2</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>p</span><span>></span></span><span>{</span>name<span>}</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
      </span><span><span><span>&lt;/</span>div</span><span>></span></span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>// 校验</span>
Child<span>.</span>propTypes <span>=</span> <span>{</span>
  name<span>:</span> PropTypes<span>.</span>string<span>,</span>
  obj<span>:</span> PropTypes<span>.</span><span>shape</span><span>(</span>
    <span>{</span>
      a<span>:</span> PropTypes<span>.</span>number<span>,</span>
      b<span>:</span> PropTypes<span>.</span>bool
    <span>}</span>
  <span>)</span>
<span>}</span>

<span>// 设置默认值</span>
Child<span>.</span>defaultProps <span>=</span> <span>{</span>
  name<span>:</span> <span>'李晨'</span>
<span>}</span>

<span>// 父组件 </span>
<span>class</span> <span>Index</span> <span>extends</span> <span>Component</span> <span>{</span>

  state <span>=</span> <span>{</span>
    obj<span>:</span> <span>{</span> a<span>:</span> <span>1</span><span>,</span> b<span>:</span> <span>true</span> <span>}</span>
  <span>}</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span>div</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h1</span><span>></span></span><span>Props深入</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>hr</span> <span>/></span></span><span>
        </span><span><span><span>&lt;</span><span>Child</span></span> <span>name</span><span><span>=</span><span>{</span><span>'范冰冰'</span><span>}</span></span> <span>obj</span><span><span>=</span><span>{</span><span>this</span><span>.</span>state<span>.</span>obj<span>}</span></span> <span>/></span></span><span>
      </span><span><span><span>&lt;/</span>div</span><span>></span></span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>export</span> <span>default</span> Index<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div></li>
<li>
<p>注意：</p>
<ol>
<li>
<p>常见类型：array、bool、func、number、object、string</p>
</li>
<li>
<p>React元素类型：element</p>
</li>
<li>
<p>必填项：isRequired</p>
</li>
<li>
<p>特定结构的对象：shape({  })</p>
<div><pre><code>Child.propTypes = { 
  obj: PropTypes.shape(
    {
      a: PropTypes.number,
      b: PropTypes.bool
    }
  )
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
</ol>
</li>
</ol>
<h3 id="_4、父传子"> 4、父传子；</h3>
<ol>
<li>父组件提供要传递的state数据 。</li>
<li>给子组件标签添加属性，值为 state 中的数据 。</li>
<li>子组件中通过 props 接收父组件中传递的数据 。</li>
<li><code>props</code>接收的数据是只读的，不能修改。</li>
</ol>
<div><pre><code><span>import</span> React <span>from</span> <span>'react'</span>

<span>/**
 * 父组件
 */</span>
<span>class</span> <span>Father</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  state <span>=</span> <span>{</span>
    lastname<span>:</span> <span>'我是父组件'</span>
  <span>}</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span>div</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h1</span><span>></span></span><span>我是h1</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
        </span><span>{</span><span>/* 给子组件标签添加属性，值为 state 中的数据  */</span><span>}</span><span>
        </span><span><span><span>&lt;</span><span>Son</span></span> <span>name</span><span><span>=</span><span>{</span><span>this</span><span>.</span>state<span>.</span>lastname<span>}</span></span><span>></span></span><span>传递数据给子组件</span><span><span><span>&lt;/</span><span>Son</span></span><span>></span></span><span>
      </span><span><span><span>&lt;/</span>div</span><span>></span></span>
    <span>)</span>
  <span>}</span>
<span>}</span>

<span>/**
 * 子组件：函数组件；
 * 默认形参接收父组件传过来的参数
 */</span>
<span>// function Son(props) {</span>
<span>//   console.log(props)</span>
<span>//   return (</span>
<span>//     &lt;div></span>
<span>//       &lt;h2>子组件接收到数据了：{ props.name }&lt;/h2></span>
<span>//     &lt;/div></span>
<span>//   )</span>
<span>// }</span>

<span>/**
 * 子组件：类组件
 * 类组件通过 this.props接收
 */</span>
<span>class</span> <span>Son</span> <span>extends</span> <span>React<span>.</span>Component</span><span>{</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> <span>{</span> name <span>}</span> <span>=</span> <span>this</span><span>.</span>props
    console<span>.</span><span>log</span><span>(</span><span>this</span><span>)</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span>div</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h2</span><span>></span></span><span>类组件接收到数据了：</span><span>{</span> name <span>}</span><span><span><span>&lt;/</span>h2</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h2</span><span>></span></span><span>类组件接收到数据了：</span><span>{</span> <span>this</span><span>.</span>props<span>.</span>name <span>}</span><span><span><span>&lt;/</span>h2</span><span>></span></span><span>
      </span><span><span><span>&lt;/</span>div</span><span>></span></span>
    <span>)</span>
  <span>}</span>
<span>}</span>
<span>export</span> <span>default</span> Father

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><h3 id="_4、子传父"> 4、子传父；</h3>
<ol>
<li>父组件提供一个回调函数（用于接收数据）。</li>
<li>将该函数作为属性的值，传递给子组件 。</li>
<li>子组件通过 props 调用回调函数 。</li>
<li>将子组件的数据作为参数传递给回调函数 。</li>
</ol>
<div><pre><code><span>import</span> React<span>,</span> <span>{</span> Component <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>/**
 * 子组件
 * 一般情况下，函数组件只用来接收数据使用，
 * 里面的数据都是静态的，不可修改
 */</span>
<span>const</span> <span>Fnc</span> <span>=</span> <span>(</span><span>props</span><span>)</span> <span>=></span> <span>{</span>
  <span>// 接收父组件传过来的值；</span>
  <span>const</span> <span>{</span> fn <span>}</span> <span>=</span> props<span>;</span>
  <span>let</span> abc <span>=</span> <span>100</span><span>;</span>

  <span>// 改变abc</span>
  <span>function</span> <span>setAbc</span><span>(</span><span>)</span> <span>{</span>
    <span>// 值修改了。但是视图没有更新；</span>
      abc <span>=</span> <span>1000000</span><span>;</span>
      console<span>.</span><span>log</span><span>(</span>abc<span>)</span><span>;</span> <span>// 1000000</span>
    <span>}</span>
  <span>return</span> <span>(</span>
    <span><span><span>&lt;</span>div</span><span>></span></span><span>
      </span><span><span><span>&lt;</span>h2</span><span>></span></span><span>子组件</span><span><span><span>&lt;/</span>h2</span><span>></span></span><span>
      </span><span><span><span>&lt;</span>p</span><span>></span></span><span>{</span>abc<span>}</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
      </span><span>{</span><span>/* 调用函数，并传递参数 */</span><span>}</span><span>
      </span><span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span><span>(</span><span>)</span> <span>=></span> <span>fn</span><span>(</span>abc<span>)</span><span>}</span></span><span>></span></span><span>子传父</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
      </span><span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span> setAbc <span>}</span></span><span>></span></span><span>改变abc的值</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span>
  <span>)</span>
<span>}</span>

<span>// 父组件：</span>
<span>class</span> <span>Parent</span> <span>extends</span> <span>Component</span> <span>{</span>
  state <span>=</span> <span>{</span>
    a<span>:</span> <span>1</span>
  <span>}</span>

  <span>// 静态属性；</span>
  a <span>=</span> <span>17770</span><span>;</span>

  <span>getChildData</span> <span>=</span> <span>(</span><span>data</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'接收子组件传递的数据：'</span><span>,</span> data<span>)</span><span>;</span>
    <span>// 静态属性的值修改了。但是视图没有更新；</span>
    <span>this</span><span>.</span>a <span>=</span> <span>56</span>
    console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>a<span>)</span> <span>// 56</span>
  <span>}</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span>div</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h1</span><span>></span></span><span>子传父</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>hr</span> <span>/></span></span><span>
        </span><span><span><span>&lt;</span>h5</span><span>></span></span><span>{</span> <span>this</span><span>.</span>a <span>}</span><span><span><span>&lt;/</span>h5</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h5</span><span>></span></span><span>{</span> <span>this</span><span>.</span>state<span>.</span>a <span>}</span><span><span><span>&lt;/</span>h5</span><span>></span></span><span>
        </span><span>{</span><span>/* 传递给子组件 */</span><span>}</span><span>
        </span><span><span><span>&lt;</span><span>Fnc</span></span> <span>fn</span><span><span>=</span><span>{</span><span>this</span><span>.</span>getChildData<span>}</span></span> <span>/></span></span><span>
      </span><span><span><span>&lt;/</span>div</span><span>></span></span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>export</span> <span>default</span> Parent<span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><h3 id="_5、兄弟传值"> 5、兄弟传值；</h3>
<blockquote>
<p>思想：<strong>状态提升</strong>  :  把 A 和 B 共同的<code>state</code>放到父组件中维护。</p>
</blockquote>
<ol>
<li>将共享状态提升到最近的公共父组件中，由公共父组件管理这个状态 。</li>
<li>公共父组件职责：1. 提供共享状态 2. 提供操作共享状态的方法 。</li>
<li>要通讯的子组件只需通过 props 接收状态或操作状态的方法 。</li>
</ol>
<div><pre><code><span>import</span> React<span>,</span> <span>{</span>Component<span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>/**
 * 兄弟组件通信思想：
 * 共享-状态-提升
 */</span>
<span>// 两个兄弟组件</span>
<span>class</span> <span>BroA</span> <span>extends</span> <span>Component</span> <span>{</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> <span>{</span>fn<span>}</span> <span>=</span> <span>this</span><span>.</span>props<span>;</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span>div</span> <span>style</span><span><span>=</span><span>{</span><span>{</span>marginRight<span>:</span> <span>'20px'</span><span>}</span><span>}</span></span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h2</span><span>></span></span><span>BroA</span><span><span><span>&lt;/</span>h2</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>button</span> <span>onClick</span><span><span>=</span><span>{</span>fn<span>}</span></span><span>></span></span><span>改变共享数据</span><span><span><span>&lt;/</span>button</span><span>></span></span><span>
      </span><span><span><span>&lt;/</span>div</span><span>></span></span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>class</span> <span>BroB</span> <span>extends</span> <span>Component</span> <span>{</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> <span>{</span>own<span>}</span> <span>=</span> <span>this</span><span>.</span>props<span>;</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span>div</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h2</span><span>></span></span><span>BroB</span><span><span><span>&lt;/</span>h2</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>p</span><span>></span></span><span>兄弟组件B：</span><span>{</span>own<span>}</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
      </span><span><span><span>&lt;/</span>div</span><span>></span></span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span>


<span>// 最近的共同父组件</span>
<span>class</span> <span>Index</span> <span>extends</span> <span>Component</span> <span>{</span>
  <span>// 状态提升的共享数据</span>
  state <span>=</span> <span>{</span>
    own<span>:</span> <span>10</span>
  <span>}</span>
  <span>// 修改状态提升数据的方法</span>
  <span>changeOwn</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span>
      own<span>:</span> <span>this</span><span>.</span>state<span>.</span>own <span>+</span> <span>10</span>
    <span>}</span><span>)</span>
  <span>}</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span>div</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h1</span><span>></span></span><span>父组件</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>p</span><span>></span></span><span>父组件own:</span><span>{</span><span>this</span><span>.</span>state<span>.</span>own<span>}</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>hr</span><span>/></span></span><span>
        </span><span><span><span>&lt;</span>div</span> <span>style</span><span><span>=</span><span>{</span><span>{</span>display<span>:</span> <span>'flex'</span><span>}</span><span>}</span></span><span>></span></span><span>
          </span><span><span><span>&lt;</span><span>BroA</span></span> <span>fn</span><span><span>=</span><span>{</span><span>this</span><span>.</span>changeOwn<span>}</span></span><span>/></span></span><span>
          </span><span><span><span>&lt;</span><span>BroB</span></span> <span>own</span><span><span>=</span><span>{</span><span>this</span><span>.</span>state<span>.</span>own<span>}</span></span><span>/></span></span><span>
        </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
      </span><span><span><span>&lt;/</span>div</span><span>></span></span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>export</span> <span>default</span> Index<span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div><h2 id="context"> <code>Context</code></h2>
<blockquote>
<p>作用：Context 提供了一个无需为每层组件手动添加 <code>props</code>，就能在组件树间进行数据传递的方法。 【跨组件通讯】</p>
<p>使用场景：如果两个组件嵌套多层可以使用<code>Context</code>实现组件通讯 。</p>
</blockquote>
<p><img src="./assets/1577707671143.png" alt="1577707671143" /></p>
<h3 id="_1、使用步骤-2"> 1、使用步骤；</h3>
<ol>
<li>
<p>调用<code>React. createContext()</code>方法，创建对象，该对象中包含<code>Provider</code>（提供数据） 和<code>Consumer</code>（消费数据） 两个组件。</p>
<div><pre><code> <span>const</span> <span>{</span> Provider<span>,</span> Consumer <span>}</span> <span>=</span> React<span>.</span><span>createContext</span><span>(</span><span>)</span> 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>使用<code>Provider</code>组件包裹根节点；</p>
<div><pre><code> <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span><span>Provider</span></span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h1</span><span>></span></span><span>根组件</span><span><span><span>&lt;/</span>h1</span><span>></span></span><span>
        </span><span><span><span>&lt;</span><span>Child1</span></span> <span>/></span></span><span>
      </span><span><span><span>&lt;/</span><span>Provider</span></span><span>></span></span>
    <span>)</span><span>;</span>
  <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
<li>
<p>在<code>Provider</code>设置<code>value</code>属性，表示要传递的数据；</p>
<div><pre><code>      <span><span><span>&lt;</span><span>Provider</span></span> <span>value</span><span><span>=</span><span>{</span><span>this</span><span>.</span>state<span>.</span>name<span>}</span></span><span>></span></span><span>
</span></code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>在需要接收数据的地方放置<code>Consumer</code>来接收数据；</p>
<div><pre><code> <span>// 接收根组件传递的数据并显示</span>
  <span>// msg 为传递过来的数据</span>
  <span>getAppData</span> <span>=</span> <span>(</span><span>msg</span><span>)</span> <span>=></span> <span>{</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span>h3</span><span>></span></span><span>{</span>msg<span>}</span><span><span><span>&lt;/</span>h3</span><span>></span></span>
    <span>)</span>
  <span>}</span>

  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span>div</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>h2</span><span>></span></span><span>Child3</span><span><span><span>&lt;/</span>h2</span><span>></span></span><span>
        </span><span><span><span>&lt;</span>div</span><span>></span></span><span>
          </span><span><span><span>&lt;</span><span>Consumer</span></span><span>></span></span><span>{</span><span>this</span><span>.</span>getAppData<span>}</span><span><span><span>&lt;/</span><span>Consumer</span></span><span>></span></span><span>
        </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
      </span><span><span><span>&lt;/</span>div</span><span>></span></span>
    <span>)</span><span>;</span>
  <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></li>
</ol>
<h2 id="组件的生命周期"> 组件的生命周期；</h2>
<h3 id="_1、概述"> 1、概述；</h3>
<ol>
<li>生命周期：组件从被创建到挂载到页面中运行，再到组件不用时卸载的过程</li>
<li>生命周期的每个阶段总是伴随着一些方法调用，这些方法就是生命周期的钩子函数。</li>
<li>钩子函数的作用：为开发人员在不同阶段操作组件提供了时机。</li>
<li>只有 <strong>类组件</strong> 才有生命周期。</li>
</ol>
<h3 id="_2、三个阶段"> 2、三个阶段；</h3>
<p><img src="./assets/1577714121517.png" alt="1577714121517" /></p>
<h4 id="_2-1、创建时-挂载阶段"> 2.1、创建时(挂载阶段)</h4>
<ol>
<li>执行时机:组件创建时(页面加载时)。</li>
</ol>
<ul>
<li>执行顺序。</li>
</ul>
<p><img src="./assets/1577714241030.png" alt="1577714241030" /></p>
<h4 id="_2-2、更新时-更新阶段"> 2.2、更新时(更新阶段)</h4>
<ul>
<li>执行时机：<strong>1. setState()  2. forceUpdate()  3. 组件接收到新的props</strong></li>
<li>说明：以上三者任意一种变化，组件就会重新渲染</li>
<li>执行顺序：</li>
</ul>
<p><img src="./assets/1577714379334.png" alt="1577714379334" /></p>
<h4 id="_2-3、卸载时"> 2.3、卸载时；</h4>
<ul>
<li>执行时机：组件从页面中消失 。(组件切换)  可以清除定时器，解绑事件</li>
</ul>
<p><img src="./assets/1577714501410.png" alt="1577714501410" /></p>
<h2 id="react路由"> <code>React</code>路由;</h2>
<blockquote>
<p>使用<code>React</code>路由简单来说，就是配置路径和组件（配对）</p>
<p>安装：<code>$ npm i react-router-dom</code></p>
</blockquote>
<h3 id="_1、路由的三种基本组件"> 1、路由的三种基本组件：</h3>
<ol>
<li>路由组件（router components）</li>
<li>路由匹配组件（route matching components）</li>
<li>导航组件（navigation components）</li>
</ol>
<h4 id="_1、路由组件"> 1、路由组件；</h4>
<blockquote>
<p><code>react-router-dom</code> 提供了<code>&lt;BrowserRouter&gt;</code>(<strong>推荐</strong>)和<code>&lt;HashRouter&gt;</code>两种路由组件。</p>
</blockquote>
<div><pre><code><span>import</span> <span>{</span> BrowserRouter <span>}</span> <span>from</span> <span>"react-router-dom"</span><span>;</span>
ReactDOM<span>.</span><span>render</span><span>(</span>
  <span>// 作为根组件将其包裹起来；</span>
  <span><span><span>&lt;</span><span>BrowserRouter</span></span><span>></span></span><span>
    </span><span><span><span>&lt;</span><span>App</span></span> <span>/></span></span><span>
  </span><span><span><span>&lt;/</span><span>BrowserRouter</span></span><span>></span></span><span>,</span>
	document<span>.</span><span>getElementById</span><span>(</span><span>'root'</span><span>)</span>
<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id="_2、路由匹配组件"> 2、路由匹配组件；</h4>
<blockquote>
<p>有两个路由匹配组件： <code>&lt;Route&gt;</code> 和 <code>&lt;Switch&gt;</code>。</p>
</blockquote>
<ol>
<li>
<p>通过<code>&lt;Route&gt;</code>组件的<code>path</code>属性匹配当前地址，当匹配成功时就渲染<code>component</code>属性指定的组件。</p>
<div><pre><code><span>import</span> <span>{</span> Route<span>,</span> Switch <span>}</span> <span>from</span> <span>"react-router-dom"</span><span>;</span>
<span>...</span>
<span>// 当前路径是'/about'</span>
<span><span><span>&lt;</span><span>Route</span></span> <span>path</span><span><span>=</span><span>'</span>/about<span>'</span></span> <span>component</span><span><span>=</span><span>{</span>About<span>}</span></span><span>/></span></span> <span>// 匹配成功时渲染</span>
<span><span><span>&lt;</span><span>Route</span></span> <span>path</span><span><span>=</span><span>'</span>/contact<span>'</span></span> <span>component</span><span><span>=</span><span>{</span>Contact<span>}</span></span><span>/></span></span> <span>// 不渲染</span>
<span><span><span>&lt;</span><span>Route</span></span> <span>component</span><span><span>=</span><span>{</span>Always<span>}</span></span><span>/></span></span> <span>// 始终渲染</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>可选组件<code>&lt;Switch&gt;</code>会遍历其所有的子 <code>&lt;Route&gt;</code> 元素，并仅渲染与当前地址匹配的<strong>第一个</strong>元素，例如可以实现没有匹配到路由显示一个404的组件。</p>
<div><pre><code><span>import</span> <span>{</span> Route<span>,</span> Switch <span>}</span> <span>from</span> <span>"react-router-dom"</span><span>;</span>

<span>// 当前路径是'/about'</span>
<span><span><span>&lt;</span><span>Switch</span></span><span>></span></span><span>
    </span><span>{</span><span>/* 由于react路由的匹配模式为模糊匹配，所以当没有 exact 时 Home 组件会始终渲染 */</span><span>}</span><span>
  </span><span><span><span>&lt;</span><span>Route</span></span> <span>exact</span> <span>path</span><span><span>=</span><span>"</span>/<span>"</span></span> <span>component</span><span><span>=</span><span>{</span>Home<span>}</span></span> <span>/></span></span><span>
  </span><span><span><span>&lt;</span><span>Route</span></span> <span>path</span><span><span>=</span><span>"</span>/about<span>"</span></span> <span>component</span><span><span>=</span><span>{</span>About<span>}</span></span> <span>/></span></span><span>
  </span><span><span><span>&lt;</span><span>Route</span></span> <span>path</span><span><span>=</span><span>"</span>/contact<span>"</span></span> <span>component</span><span><span>=</span><span>{</span>Contact<span>}</span></span> <span>/></span></span><span>
  </span><span>{</span><span>/* 当什么都没匹配到时，&lt;NoMatch> 组件将会渲染 */</span><span>}</span><span>
  </span><span><span><span>&lt;</span><span>Route</span></span> <span>component</span><span><span>=</span><span>{</span>NoMatch<span>}</span></span> <span>/></span></span><span>
</span><span><span><span>&lt;/</span><span>Switch</span></span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
</ol>
<h4 id="_3、导航组件"> 3、导航组件；</h4>
<blockquote>
<p>两个主要的导航组件：<code>&lt;Link&gt;</code> 和<code>&lt;NavLink&gt;</code> 。</p>
</blockquote>
<ol>
<li>
<p><code>React Router</code>提供了一个 <code>&lt;Link&gt;</code> 组件来在你的应用程序中创建链接，渲染后为<code>html</code>的<code>&lt;a&gt;</code>标签。</p>
<div><pre><code><span><span><span>&lt;</span><span>Link</span></span> <span>to</span><span><span>=</span><span>"</span>/<span>"</span></span><span>></span></span><span>Home</span><span><span><span>&lt;/</span><span>Link</span></span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>其中<code>&lt;NavLink&gt;</code> 是一种特殊类型的<code>&lt;Link&gt;</code>， 当它的 <code>to</code> 属性与当前地址匹配时，可以自动为其添加<code>active</code>的状态。</p>
<div><pre><code><span>// 当路径是 '/react '时</span>
<span><span><span>&lt;</span><span>NavLink</span></span> <span>to</span><span><span>=</span><span>"</span>/react<span>"</span></span> <span>activeClassName</span><span><span>=</span><span>"</span>active<span>"</span></span><span>></span></span><span>
  React
</span><span><span><span>&lt;/</span><span>NavLink</span></span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ol>
<div><pre><code><span>import</span> React<span>,</span> <span>{</span> Component <span>}</span> <span>from</span> <span>'react'</span><span>;</span>

<span>import</span> <span>{</span> BrowserRouter <span>as</span> Router<span>,</span> Route<span>,</span> Link<span>,</span> Switch <span>}</span> <span>from</span> <span>'react-router-dom'</span><span>;</span>
<span>// 1. 安装：npm i react-router-dom</span>
<span>// 2. 导入路由的三个核心组件：Router / Route / Link</span>
<span>// 3. 使用 Router 组件包裹整个应用（重要）</span>
<span>// 4. 使用 Link 组件作为导航菜单（路由入口）</span>
<span>// 5. 使用 Route 组件配置路由规则和要展示的组件（路由出口）</span>

<span>// 其它视图的组件</span>
<span>const</span> <span>About</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>(</span>
  <span><span><span>&lt;</span>div</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>h2</span><span>></span></span><span>关于我们</span><span><span><span>&lt;/</span>h2</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span>)</span>

<span>const</span> <span>Contact</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>(</span>
  <span><span><span>&lt;</span>div</span><span>></span></span><span>
    </span><span><span><span>&lt;</span>h3</span><span>></span></span><span>联系我</span><span><span><span>&lt;/</span>h3</span><span>></span></span><span>
  </span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span>)</span>

<span>// 根组件</span>
<span>class</span> <span>App</span> <span>extends</span> <span>Component</span> <span>{</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span><span>Router</span></span><span>></span></span><span>
          </span><span>{</span><span>/* 路由导航 */</span><span>}</span><span>
          </span><span><span><span>&lt;</span><span>Link</span></span> <span>to</span><span><span>=</span><span>"</span>/about<span>"</span></span><span>></span></span><span>关于我们</span><span><span><span>&lt;/</span><span>Link</span></span><span>></span></span><span>
          </span><span><span><span>&lt;</span><span>Link</span></span> <span>to</span><span><span>=</span><span>"</span>/contact<span>"</span></span><span>></span></span><span>联系我</span><span><span><span>&lt;/</span><span>Link</span></span><span>></span></span><span>
        </span><span>{</span><span>/* 配置路由 */</span><span>}</span><span>
          </span><span><span><span>&lt;</span><span>Route</span></span> <span>path</span><span><span>=</span><span>"</span>/about<span>"</span></span> <span>component</span><span><span>=</span><span>{</span>About<span>}</span></span> <span>/></span></span><span>
          </span><span><span><span>&lt;</span><span>Route</span></span> <span>path</span><span><span>=</span><span>"</span>/contact<span>"</span></span> <span>component</span><span><span>=</span><span>{</span>Contact<span>}</span></span> <span>/></span></span><span>
      </span><span><span><span>&lt;/</span><span>Router</span></span><span>></span></span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span>

<span>export</span> <span>default</span> App<span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><blockquote>
<p>注意事项：</p>
<ul>
<li><code>Router</code>组件：包裹整个应用，一个 React 应用只需要<strong>使用一次</strong> 。</li>
</ul>
<ul>
<li>Route、Link组件：<strong>必须</strong>在Router 组件<strong>内部</strong>。</li>
</ul>
</blockquote>
<h3 id="_2、动态路由和404页面"> 2、动态路由和404页面；</h3>
<ol>
<li>
<p>动态路由配置；</p>
<div><pre><code><span>{</span><span>/* 动态组件配置 */</span><span>}</span>
<span><span><span>&lt;</span><span>Route</span></span> <span>path</span><span><span>=</span><span>"</span>/about/:id<span>"</span></span> <span>component</span><span><span>=</span><span>{</span>About<span>}</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>404页面配置；</p>
<ol>
<li>结合<code>Switch</code>组件；</li>
</ol>
<div><pre><code><span><span><span>&lt;</span><span>Router</span></span><span>></span></span><span>
        </span><span><span><span>&lt;</span>nav</span> <span>className</span><span><span>=</span><span>"</span>menu<span>"</span></span><span>></span></span><span>
          </span><span><span><span>&lt;</span><span>Link</span></span> <span>to</span><span><span>=</span><span>"</span>/about<span>"</span></span><span>></span></span><span>关于我们</span><span><span><span>&lt;/</span><span>Link</span></span><span>></span></span><span>
          </span><span><span><span>&lt;</span><span>Link</span></span> <span>to</span><span><span>=</span><span>"</span>/contact<span>"</span></span><span>></span></span><span>联系我</span><span><span><span>&lt;/</span><span>Link</span></span><span>></span></span><span>
        </span><span><span><span>&lt;/</span>nav</span><span>></span></span><span>
        </span><span>{</span><span>/* 配置路由 */</span><span>}</span><span>
        </span><span><span><span>&lt;</span>div</span> <span>className</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span><span>
          </span><span><span><span>&lt;</span><span>Switch</span></span><span>></span></span><span>
            </span><span><span><span>&lt;</span><span>Route</span></span> <span>path</span><span><span>=</span><span>"</span>/about<span>"</span></span> <span>component</span><span><span>=</span><span>{</span>About<span>}</span></span> <span>/></span></span><span>
            </span><span><span><span>&lt;</span><span>Route</span></span> <span>path</span><span><span>=</span><span>"</span>/contact<span>"</span></span> <span>component</span><span><span>=</span><span>{</span>Contact<span>}</span></span> <span>/></span></span><span>
            </span><span>{</span><span>/* 当什么都没有匹配到时 显示 FourComponent 组件 */</span><span>}</span><span>
            </span><span><span><span>&lt;</span><span>Route</span></span> <span>component</span><span><span>=</span><span>{</span>FourComponent<span>}</span></span> <span>/></span></span><span>
          </span><span><span><span>&lt;/</span><span>Switch</span></span><span>></span></span><span>
        </span><span><span><span>&lt;/</span>div</span><span>></span></span><span>
      </span><span><span><span>&lt;/</span><span>Router</span></span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></li>
</ol>
<h3 id="_3、默认路由"> 3、默认路由；</h3>
<blockquote>
<p>默认路由：表示进入页面时就会匹配的路由 ;</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span><span>Route</span></span> <span>path</span><span><span>=</span><span>"</span>/<span>"</span></span> <span>exact</span> <span>component</span><span><span>=</span><span>{</span>Home<span>}</span></span> <span>/></span></span> 
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>注意：需配合<code>exact</code>属性开启路由的精确匹配模式;</p>
</blockquote>
<h3 id="_4、编程式导航"> 4、编程式导航；</h3>
<blockquote>
<p>编程式导航：通过<code>JS</code>代码来实现页面跳转。</p>
</blockquote>
<ol>
<li>
<p>通过组件的<code>props</code>的<code>history</code>属性获取：</p>
<ul>
<li>
<p>只有通过<code>Route</code>组件配置后才有<code>history</code>属性；</p>
</li>
<li>
<p>push(path)：跳转到某个页面，参数 path 表示要跳转的路径 。</p>
</li>
<li>
<p>go(n)： 前进或后退到某个页面，参数 n 表示前进或后退页面数量（比如：-1 表示后退到上一页，为 0 或不传则为当前页） 。</p>
<div><pre><code><span>class</span> <span>Login</span> <span>extends</span> <span>Component</span> <span>{</span> 
  <span>handleLogin</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span> 
    <span>// ... </span>
    <span>this</span><span>.</span>props<span>.</span>history<span>.</span><span>push</span><span>(</span><span>'/home'</span><span>)</span> <span>// 要跳转的组件；</span>
  <span>}</span> 
  <span>render</span><span>(</span><span>)</span> <span>{</span><span>...</span>省略其他代码<span>}</span> 
<span>}</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
</ul>
</li>
<li>
<p>动态路由的参数获取：</p>
<ul>
<li>
<p>通过组件的<code>props</code>的<code>match</code>属性获取：</p>
<ul>
<li>
<p><code>match.params</code>：获取动态路由的参数值。</p>
<div><pre><code><span>this</span><span>.</span>props<span>.</span>match<span>.</span>params <span>// 包含着动态路由的参数值的集合；</span>
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="_5、匹配模式"> 5、匹配模式；</h3>
<blockquote>
<p>默认情况下，<code>React</code>路由是模糊匹配模式 。</p>
<p>给 Route 组件添加 exact 属性，让其变为精确匹配模式 。</p>
</blockquote>
<div><pre><code><span>// 此时，该组件只能匹配 “/” 这一种情况 </span>
<span><span><span>&lt;</span><span>Route</span></span> <span>exact</span> <span>path</span><span><span>=</span><span>"</span>/<span>"</span></span> <span>component</span><span><span>=</span>...</span> <span>/></span></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_6、二级路由的配置"> 6、二级路由的配置；</h3>
<ul>
<li>
<p>在匹配到的一级路由组件中继续使用<code>Link</code>和<code>Route</code>。</p>
<div><pre><code><span>// 联系我</span>
<span>//二级路由组件</span>
<span>const</span> <span>FnTwo</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>(</span><span><span><span>&lt;</span>p</span><span>></span></span><span>我是二级路由</span><span><span><span>&lt;/</span>p</span><span>></span></span><span>)</span><span>;</span>
<span>const</span> <span>Contact</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>return</span> <span>(</span>
    <span><span><span>&lt;</span>div</span><span>></span></span><span>
      </span><span><span><span>&lt;</span>h3</span><span>></span></span><span>联系我</span><span><span><span>&lt;/</span>h3</span><span>></span></span><span>
      </span><span>{</span><span>/* 配置联系我的二级路由 */</span><span>}</span><span>
      </span><span><span><span>&lt;</span><span>Link</span></span> <span>to</span><span><span>=</span><span>'</span>/contact/two<span>'</span></span><span>></span></span><span>联系我的下级</span><span><span><span>&lt;/</span><span>Link</span></span><span>></span></span><span>
      </span><span><span><span>&lt;</span><span>Route</span></span> <span>path</span><span><span>=</span><span>'</span>/contact/two<span>'</span></span> <span>component</span><span><span>=</span><span>{</span>FnTwo<span>}</span></span> <span>/></span></span><span>
    </span><span><span><span>&lt;/</span>div</span><span>></span></span>
  <span>)</span>
<span>}</span>

<span>// 根组件</span>
<span>class</span> <span>App</span> <span>extends</span> <span>Component</span> <span>{</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span><span><span>&lt;</span><span>Router</span></span><span>></span></span><span>
          </span><span>{</span><span>/* 一级路由导航和组件 */</span><span>}</span><span>
          </span><span><span><span>&lt;</span>link</span> <span>to</span><span><span>=</span><span>"</span>/contact<span>"</span></span><span>></span></span><span> 跟组件 </span><span><span><span>&lt;/</span>link</span><span>></span></span><span>    
          </span><span><span><span>&lt;</span><span>Route</span></span> <span>path</span><span><span>=</span><span>"</span>/contact<span>"</span></span> <span>component</span><span><span>=</span><span>{</span>Contact<span>}</span></span> <span>/></span></span><span>
      </span><span><span><span>&lt;/</span><span>Router</span></span><span>></span></span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div></li>
</ul>
<h3 id="_7、路由重定向"> 7、路由重定向；</h3>
<blockquote>
<p>使用场景：页面一打开或手动修改路径都会默认跳转到同一个页面；</p>
</blockquote>
<div><pre><code><span>// 引入组件；</span>
<span>import</span> <span>{</span> Redirect <span>}</span> <span>from</span> <span>'react-router-dom'</span><span>;</span>
<span>// 使用组件；并配合 exact 进行精确定位；</span>
<span>&lt;</span>Redirect exact from<span>=</span><span>"/"</span> to<span>=</span><span>"/home"</span> <span>/</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="_8、自定义route"> 8、自定义<code>route</code>;</h3>
<ul>
<li>
<p>系统鉴权应用场景；</p>
<div><pre><code><span>const</span> <span>Auth</span> <span>=</span> <span>(</span><span><span>{</span> path<span>,</span> component<span>:</span> Component<span>,</span> history <span>}</span></span><span>)</span> <span>=></span> <span>{</span>
  <span>let</span> token <span>=</span> sessionStorage<span>.</span><span>getItem</span><span>(</span><span>'auth'</span><span>)</span>
  <span>return</span> <span>(</span>
    <span>&lt;</span>Route path<span>=</span><span>{</span>path<span>}</span> render<span>=</span><span>{</span><span>(</span><span>props</span><span>)</span> <span>=></span> <span>{</span>
      <span>if</span> <span>(</span>token<span>)</span> <span>{</span>
        <span>return</span> <span><span><span>&lt;</span><span>Component</span></span> <span><span>{</span><span>...</span>props<span>}</span></span> <span>/></span></span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>alert</span><span>(</span><span>'请登录！'</span><span>)</span>
        <span>return</span> <span><span><span>&lt;</span><span>Redirect</span></span> <span>to</span><span><span>=</span><span>"</span>/login<span>"</span></span> <span>/></span></span>
      <span>}</span>
    <span>}</span><span>}</span> <span>/</span><span>></span>
  <span>)</span>
<span>}</span>

<span>// 路由配置；</span>
<span>{</span><span>/* &lt;Route path="/" exact component={Home} /> */</span><span>}</span>
<span>{</span><span>/* 需要鉴权访问 */</span><span>}</span>
<span><span><span>&lt;</span><span>Redirect</span></span> <span>exact</span> <span>from</span><span><span>=</span><span>"</span>/<span>"</span></span> <span>to</span><span><span>=</span><span>"</span>/home<span>"</span></span> <span>/></span></span>
<span><span><span>&lt;</span><span>Auth</span></span> <span>path</span><span><span>=</span><span>'</span>/home<span>'</span></span> <span>component</span><span><span>=</span><span>{</span>Home<span>}</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div></li>
</ul>
<h3 id="_9、withrouter高阶组件"> 9、<code>withRouter</code>高阶组件;</h3>
<blockquote>
<p>让一个组件的<code>props</code>增加了一些路由属性和方法：history、match、location。</p>
</blockquote>
<div><pre><code><span>import</span> <span>{</span> withRouter <span>}</span> <span>from</span> <span>'react-router-dom'</span>
<span>const</span> 新组件 <span>=</span> <span>withRouter</span><span>(</span>旧组件<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="setstate-的说明"> <code>setState()</code>的说明；</h2>
<h3 id="_1、第一个参数"> 1、第一个参数；</h3>
<blockquote>
<p>1、<strong>对象语法</strong>：<code>setState(stateChange[, callback])</code>；</p>
</blockquote>
<ol>
<li>
<p><code>setState()</code>是<strong>异步</strong>更新数据的。</p>
</li>
<li>
<p>使用该语法时，后面的<code>setState()</code>不要依赖于前面的<code>setState()</code> ；<strong>可以在第二个参数的回调函数中获取更新后的状态。</strong></p>
</li>
<li>
<p>可以多次调用<code>setState()</code>，但是<code>react</code>会做批处理和覆盖，且只会触发一次重新渲染。</p>
<div><pre><code><span>...</span>
state <span>=</span> <span>{</span> count<span>:</span> <span>0</span> <span>}</span> 

<span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span> 
  count<span>:</span> <span>this</span><span>.</span>state<span>.</span>count <span>+</span> <span>1</span> 
<span>}</span><span>)</span> 
<span>// 第二次加一</span>
<span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span> 
  count<span>:</span> <span>this</span><span>.</span>state<span>.</span>count <span>+</span> <span>2</span> 
<span>}</span><span>)</span> 
console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>state<span>.</span>count<span>)</span> <span>// 0 </span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
</ol>
<blockquote>
<p>2、<strong>函数语法</strong>：<code>setState(updater[, callback])</code>；</p>
</blockquote>
<ol>
<li>
<p><strong>推荐</strong>：使用<code>setState((state, props) =&gt; {})</code>语法，支持异步批量更新 ；</p>
</li>
<li>
<p>参数state：表示最新的state 。</p>
</li>
<li>
<p>参数props：表示最新的props 。</p>
<div><pre><code><span>this</span><span>.</span><span>setState</span><span>(</span><span>(</span><span>state<span>,</span> props</span><span>)</span> <span>=></span> <span>{</span> 
  <span>return</span> <span>{</span> 
    count<span>:</span> state<span>.</span>count <span>+</span> <span>1</span> 
  <span>}</span> 
<span>}</span><span>)</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
</ol>
<h3 id="_2、第二个参数"> 2、第二个参数；</h3>
<ol>
<li>
<p>场景：在状态更新（页面完成重新渲染）后立即执行某个操作 。</p>
</li>
<li>
<p>语法： <code>setState(updater[, callback])</code>  。</p>
<div><pre><code><span>this</span><span>.</span><span>setState</span><span>(</span> 
  <span>(</span><span>state<span>,</span> props</span><span>)</span> <span>=></span> <span>{</span><span>}</span><span>,</span> 
  <span>(</span><span>)</span> <span>=></span> <span>{</span>console<span>.</span><span>log</span><span>(</span><span>'这个回调函数会在状态更新后立即执行'</span><span>)</span><span>}</span> 
<span>)</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ol>
<h2 id="组件性能优化"> 组件性能优化；</h2>
<h3 id="_1、轻量化state"> 1、轻量化<code>state</code>;</h3>
<ol>
<li>
<p>轻量 state：只存储跟组件渲染相关的数据（比如：count / 列表数据 / loading 等） 。</p>
</li>
<li>
<p>注意：不用做渲染的数据不要放在 state 中，比如定时器 id等 。</p>
</li>
<li>
<p>对于这种需要在多个方法中用到的数据，应该放在 this 中 。</p>
<div><pre><code><span>class</span> <span>Hello</span> <span>extends</span> <span>Component</span> <span>{</span>   
  <span>componentDidMount</span><span>(</span><span>)</span> <span>{</span>     
    <span>// timerId存储到this中，而不是state中     </span>
    <span>this</span><span>.</span>timerId <span>=</span> <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span><span>}</span><span>,</span> <span>2000</span><span>)</span>   
  <span>}</span>  
  <span>componentWillUnmount</span><span>(</span><span>)</span> <span>{</span> 
    <span>clearInterval</span><span>(</span><span>this</span><span>.</span>timerId<span>)</span> 
  <span>}</span>   
  <span>render</span><span>(</span><span>)</span> <span>{</span> … <span>}</span> 
<span>}</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
</ol>
<h3 id="_2、减少不必要的重新渲染"> 2、减少不必要的重新渲染；</h3>
<ol>
<li>
<p>组件更新机制：父组件更新会引起子组件也被更新。</p>
</li>
<li>
<p>问题：子组件没有任何变化时也会重新渲染 。</p>
</li>
<li>
<p>如何避免不必要的重新渲染呢？</p>
</li>
<li>
<p>解决方式：使用钩子函数 <strong>shouldComponentUpdate(nextProps, nextState)</strong></p>
</li>
<li>
<p>作用：通过返回值决定该组件是否重新渲染，返回 true 表示重新渲染，false 表示不重新渲染</p>
</li>
<li>
<p>触发时机：更新阶段的钩子函数，组件重新渲染前执行 （shouldComponentUpdate -&gt; render）</p>
<div><pre><code><span>class</span> <span>Hello</span> <span>extends</span> <span>Component</span> <span>{</span> 
  <span>// 根据条件，决定是否重新渲染组件</span>
  <span>shouldComponentUpdate</span><span>(</span><span>nextProps<span>,</span> nextState</span><span>)</span> <span>{</span>       
 		<span>return</span> <span>true</span>
    <span>...</span>
    <span>return</span> <span>false</span>
  <span>}</span> 
  <span>render</span><span>(</span><span>)</span> <span>{</span>…<span>}</span> 
<span>}</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></li>
</ol>
<h3 id="_3、纯组件"> 3、纯组件；</h3>
<ol>
<li>
<p>纯组件：PureComponent  与 React.Component 功能相似</p>
</li>
<li>
<p>区别：PureComponent 内部自动实现了 shouldComponentUpdate 钩子，不需要手动比较 。</p>
</li>
<li>
<p>原理：纯组件内部通过分别 对比 前后两次 props 和 state 的值，来决定是否重新渲染组件 。</p>
<div><pre><code><span>class</span> <span>Hello</span> <span>extends</span> <span>React<span>.</span>PureComponent</span> <span>{</span>   
  <span>render</span><span>(</span><span>)</span> <span>{</span> 
    <span>return</span> <span>(</span> 
      <span><span><span>&lt;</span>div</span><span>></span></span><span>纯组件</span><span><span><span>&lt;/</span>div</span><span>></span></span>     
    <span>)</span>   
  <span>}</span> 
<span>}</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
</ol>
<blockquote>
<p>注意：</p>
<ol>
<li>对于值类型来说：比较两个值是否相同直接赋值即可。</li>
<li>对于引用类型来说：<strong>只比较对象的引用（地址）是否相同</strong>。
<ul>
<li>解决：应该创建新数据，不要直接修改原数据！</li>
</ul>
</li>
</ol>
</blockquote>
<div><pre><code><span>// 正确！创建新数据 </span>
<span>const</span> newObj <span>=</span> <span>{</span><span>...</span>state<span>.</span>obj<span>,</span> number<span>:</span> <span>2</span><span>}</span> 
<span>setState</span><span>(</span><span>{</span> obj<span>:</span> newObj <span>}</span><span>)</span> 
 
<span>// 正确！创建新数据 </span>
<span>// 不要用数组的push / unshift 等直接修改当前数组的的方法 </span>
<span>// 而应该用 concat 或 slice 等这些返回新数组的方法 </span>
<span>this</span><span>.</span><span>setState</span><span>(</span><span>{</span> 
  list<span>:</span> <span>[</span><span>...</span><span>this</span><span>.</span>state<span>.</span>list<span>,</span> <span>{</span>新数据<span>}</span><span>]</span> 
<span>}</span><span>)</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="虚拟dom"> 虚拟DOM；</h2>
<blockquote>
<p>React 更新视图的思想是：<strong>只要 state 变化就重新渲染视图</strong> 。</p>
<p>问题：组件中只有一个 DOM 元素需要更新时，整个组件的内容也会重新渲染到页面中</p>
<p>理想状态：部分更新 =&gt; 只更新变化的地方。</p>
</blockquote>
<ol>
<li>虚拟 DOM：本质上就是一个<code>JS</code>对象。</li>
<li>在数据和真实 DOM 之间<strong>建立了一层缓冲区</strong>。</li>
</ol>
<h3 id="_1、执行过程"> 1、执行过程；</h3>
<ol>
<li>初次渲染时，React 会根据初始<code>state</code>结合<code>jsx</code>元素结构，创建一个虚拟DOM对象（树）。</li>
<li>根据虚拟 DOM 生成真正的 DOM，渲染到页面中。</li>
<li>当数据<strong>变化后</strong>（setState()），重新根据新的数据，<strong>创建新的虚拟DOM对象</strong>（树）。</li>
<li>与上一次得到的虚拟 DOM 对象，使用 <strong>Diff 算法</strong> 对比，得到需要更新的内容。</li>
<li>最终，React 只将变化的内容更新到 DOM 中，重新渲染页面。</li>
</ol>
<h3 id="_2、diff算法说明"> 2、<code>Diff</code>算法说明;</h3>
<blockquote>
<p><strong>一、元素类型</strong>：如果两棵树的根元素类型不同，React 会销毁旧树，创建新树.</p>
</blockquote>
<div><pre><code><span>// 旧树</span>
<span><span><span>&lt;</span>div</span><span>></span></span><span>
  </span><span><span><span>&lt;</span><span>Counter</span></span> <span>/></span></span><span>
</span><span><span><span>&lt;/</span>div</span><span>></span></span>

<span>// 新树</span>
<span><span><span>&lt;</span>span</span><span>></span></span><span>
  </span><span><span><span>&lt;</span><span>Counter</span></span> <span>/></span></span><span>
</span><span><span><span>&lt;/</span>span</span><span>></span></span>

执行过程：destory all <span>-</span><span>></span> insert <span>new</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>
<p><strong>二、元素属性</strong>：</p>
<ul>
<li>对于类型相同的 React DOM 元素，React 会对比两者的属性是否相同，只更新不同的属性</li>
<li>当处理完这个 DOM 节点，React 就会递归处理子节点。</li>
</ul>
</blockquote>
<div><pre><code><span>// 旧</span>
<span><span><span>&lt;</span>div</span> <span>className</span><span><span>=</span><span>"</span>before<span>"</span></span> <span>title</span><span><span>=</span><span>"</span>stuff<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span>// 新</span>
<span><span><span>&lt;</span>div</span> <span>className</span><span><span>=</span><span>"</span>after<span>"</span></span> <span>title</span><span><span>=</span><span>"</span>stuff<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
只更新：className 属性

<span>// 旧</span>
<span><span><span>&lt;</span>div</span> <span>style</span><span><span>=</span><span>{</span><span>{</span>color<span>:</span> <span>'red'</span><span>,</span> fontWeight<span>:</span> <span>'bold'</span><span>}</span><span>}</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span>// 新</span>
<span><span><span>&lt;</span>div</span> <span>style</span><span><span>=</span><span>{</span><span>{</span>color<span>:</span> <span>'green'</span><span>,</span> fontWeight<span>:</span> <span>'bold'</span><span>}</span><span>}</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
只更新：color属性
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>
<p><strong>三、修改元素</strong>：</p>
<ol>
<li>当在子节点的后面添加一个节点，这时候两棵树的转化工作执行的很好。</li>
<li>但是如果你在开始位置插入一个元素，那么问题就来了；</li>
</ol>
</blockquote>
<div><pre><code><span>// 旧</span>
<span><span><span>&lt;</span>ul</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span><span>></span></span><span>1</span><span><span><span>&lt;/</span>li</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span><span>></span></span><span>2</span><span><span><span>&lt;/</span>li</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>ul</span><span>></span></span>

<span>// 新</span>
<span><span><span>&lt;</span>ul</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span><span>></span></span><span>3</span><span><span><span>&lt;/</span>li</span><span>></span></span><span> // 一次  1->3
  </span><span><span><span>&lt;</span>li</span><span>></span></span><span>1</span><span><span><span>&lt;/</span>li</span><span>></span></span><span> // 一次  2->1
  </span><span><span><span>&lt;</span>li</span><span>></span></span><span>2</span><span><span><span>&lt;/</span>li</span><span>></span></span><span> // 新增一次
</span><span><span><span>&lt;/</span>ul</span><span>></span></span>

执行过程：
React将改变每一个子节点，而非保持 <span><span><span>&lt;</span>li</span><span>></span></span><span>1</span><span><span><span>&lt;/</span>li</span><span>></span></span> 和 <span><span><span>&lt;</span>li</span><span>></span></span><span>2</span><span><span><span>&lt;/</span>li</span><span>></span></span> 不变
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>解决；</strong></p>
<blockquote>
<p>React 提供了一个 key 属性。当子节点带有 key 属性，React 会通过 key 来匹配原始树和后来的树。</p>
</blockquote>
<div><pre><code><span>// 旧</span>
<span><span><span>&lt;</span>ul</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>2015<span>"</span></span><span>></span></span><span>1</span><span><span><span>&lt;/</span>li</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>2016<span>"</span></span><span>></span></span><span>2</span><span><span><span>&lt;/</span>li</span><span>></span></span><span>
</span><span><span><span>&lt;/</span>ul</span><span>></span></span>

<span>// 新</span>
<span><span><span>&lt;</span>ul</span><span>></span></span><span>
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>2014<span>"</span></span><span>></span></span><span>3</span><span><span><span>&lt;/</span>li</span><span>></span></span><span>  // 添加
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>2015<span>"</span></span><span>></span></span><span>1</span><span><span><span>&lt;/</span>li</span><span>></span></span><span>  
  </span><span><span><span>&lt;</span>li</span> <span>key</span><span><span>=</span><span>"</span>2016<span>"</span></span><span>></span></span><span>2</span><span><span><span>&lt;/</span>li</span><span>></span></span><span>  
</span><span><span><span>&lt;/</span>ul</span><span>></span></span>

执行过程：
现在 React 知道带有key <span>'2014'</span> 的元素是新的，对于 <span>'2015'</span> 和 <span>'2016'</span> 仅仅移动位置即可
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><blockquote>
<ul>
<li>说明：key 属性在 React 内部使用，但不会传递给你的组件。</li>
<li>推荐：在遍历数据时，推荐在组件中使用 key 属性：<code>&lt;li key={item.id}&gt;{item.name}&lt;/li&gt;</code></li>
<li>注意：<strong>key 只需要保持与他的兄弟节点唯一即可，不需要全局唯一。</strong></li>
<li>注意：<strong>尽可能的减少数组 index 作为 key，数组中插入元素的等操作时，会使得效率底下</strong>。</li>
</ul>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>redux使用</title>
      <link>https://wangyawei.top/views/frontEnd/react/react-note-01/</link>
      <guid>https://wangyawei.top/views/frontEnd/react/react-note-01/</guid>
      <source url="https://wangyawei.top/rss.xml">redux使用</source>
      <category>REACT</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="redux概述"> <code>Redux概述</code></h2>
<blockquote>
<p>Redux 是 JavaScript 状态容器，提供可预测化的状态统一管理。</p>
<p><strong>注意</strong>：它不是react独有的，任何地方都可以用：原生<code>js</code>、<code>jQery</code>、<code>vue</code>等。</p>
</blockquote>
<ol>
<li>三大原则：
<ol>
<li>单一数据源。</li>
<li>State 是只读的。</li>
<li>使用纯函数来执行修改。</li>
</ol>
</li>
</ol>
<h2 id="基本使用"> 基本使用；</h2>
<h3 id="_1、安装"> 1、安装；</h3>
<ul>
<li>
<p>通过标签引入；</p>
<div><pre><code><span>&lt;</span>script src<span>=</span><span>"../node_modules/redux/dist/redux.js"</span><span>></span><span>&lt;</span><span>/</span>script<span>></span>

<span>const</span> <span>{</span> Redux <span>}</span> <span>=</span> window  <span>// 要结构出来使用；</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>通过<code>npm</code>包管理。</p>
<div><pre><code><span>// 安装；</span>
npm install <span>--</span>save redux

<span>// 引入；</span>
<span>import</span> <span>{</span> createStore <span>}</span> <span>from</span> <span>'redux'</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
</ul>
<h2 id="action"> <code>Action</code>;</h2>
<blockquote>
<p>1、 <strong>Action</strong> 是把数据从应用传到 store 的有效载荷。它是 store 数据的<strong>唯一</strong>来源。</p>
<p>2、本质：本质上<code>javaScript</code>的普通对象。</p>
<p>3、注意： action 内必须使用一个字符串类型的 <code>type</code> 字段来表示将要执行的动作 。</p>
<p>4、 多数情况下，<code>type</code> 会被定义成字符串常量。<strong>建议使用单独的模块或文件来存放 action。</strong></p>
<div><pre><code><span>// 单独的模块统一管理存放 action；</span>
<span>import</span> <span>{</span> <span>ADD_TODO</span><span>,</span> <span>REMOVE_TODO</span> <span>}</span> <span>from</span> <span>'../actionTypes'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></blockquote>
<div><pre><code><span>// 添加新 todo 任务的 action ：</span>
<span>const</span> <span>ADD_TODO</span> <span>=</span> <span>'ADD_TODO'</span>

<span>const</span> action1 <span>=</span> <span>{</span>
  type<span>:</span> <span>ADD_TODO</span><span>,</span>
  text<span>:</span> <span>'Build my first Redux app'</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="action创建函数"> <code>Action</code>创建函数;</h2>
<blockquote>
<p>概述： <strong>Action 创建函数</strong> 就是生成 <code>action</code>的方法 。</p>
</blockquote>
<div><pre><code><span>// action 创建函数只是简单的返回一个 action:</span>

<span>function</span> <span>addTodo</span><span>(</span><span>text</span><span>)</span> <span>{</span>
  <span>return</span> <span>{</span>
    type<span>:</span> <span>ADD_TODO</span><span>,</span>
    text
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="reducer"> <code>Reducer</code>;</h2>
<blockquote>
<p>概述： <strong>Reducers</strong> 指定了应用状态的变化如何响应 <a href="https://www.redux.org.cn/docs/basics/Actions.html" target="_blank" rel="noopener noreferrer">actions</a> 并发送到 store 的，注意 actions 只是说明了<em>有事情发生了</em>这一事实，并没有说明应用如何更新 state。</p>
</blockquote>
<h3 id="_1、设计state结构"> 1、设计<code>state</code>结构；</h3>
<ul>
<li>所有的 state 都被保存在一个单一对象中 。</li>
</ul>
<h3 id="_2、action处理"> 2、<code>Action</code>处理;</h3>
<blockquote>
<p>确定了 state 对象的结构，就可以开发 reducer。reducer 就是一个<strong>纯函数</strong>，接收旧的 state 和 action，返回新的 state。</p>
</blockquote>
<div><pre><code> <span>// 旧数据</span>
  <span>const</span> state <span>=</span> <span>{</span>
    num<span>:</span> <span>20</span>
  <span>}</span>
  <span>const</span> <span>reducerState</span> <span>=</span> <span>function</span> <span>(</span><span>state<span>,</span> action</span><span>)</span> <span>{</span>
    <span>// 新数据</span>
    <span>// const newState = { ...state }</span>
    <span>// 处理不同 action </span>
    <span>switch</span> <span>(</span>action<span>.</span>type<span>)</span> <span>{</span>
      <span>case</span> <span>'add'</span><span>:</span>
        <span>const</span> newState1 <span>=</span> <span>{</span>
          <span>...</span>state
        <span>}</span>
        newState1<span>.</span>num<span>++</span>
        <span>return</span> newState1
      <span>case</span> <span>'sub'</span><span>:</span>
        <span>const</span> newState2 <span>=</span> <span>{</span>
          <span>...</span>state
        <span>}</span>
        newState2<span>.</span>num<span>++</span>
        <span>return</span> newState2
      <span>default</span><span>:</span> 
     	<span>return</span> state <span>// 默认返回原数据</span>
    <span>}</span>
    <span>return</span> newState
  <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><blockquote>
<p>注意：</p>
<p>1、 <strong>不要</strong>在<code>reduce</code>里修改传入的参数。</p>
<p>2、  <strong>不要</strong>执行有副作用的操作，如 API 请求和路由跳转；</p>
<p>3、<strong>不要</strong> 调用非纯函数，如 <code>Date.now()</code> 或 <code>Math.random()</code>。</p>
</blockquote>
<h2 id="score"> <code>Score</code></h2>
<blockquote>
<p>概述：</p>
<p><strong>Store</strong> 就是把它们联系到一起的对象。Store 有以下职责：</p>
<ul>
<li>维持应用的 state；</li>
<li>提供 <a href="https://www.redux.org.cn/docs/api/Store.html#getState" target="_blank" rel="noopener noreferrer"><code>getState()</code></a> 方法获取 state；</li>
<li>提供 <a href="https://www.redux.org.cn/docs/api/Store.html#dispatch" target="_blank" rel="noopener noreferrer"><code>dispatch(action)</code></a> 方法更新 state；</li>
<li>通过 <a href="https://www.redux.org.cn/docs/api/Store.html#subscribe" target="_blank" rel="noopener noreferrer"><code>subscribe(listener)</code></a> 注册监听器;</li>
<li>通过 <a href="https://www.redux.org.cn/docs/api/Store.html#subscribe" target="_blank" rel="noopener noreferrer"><code>subscribe(listener)</code></a> 返回的函数注销监听器。</li>
</ul>
</blockquote>
<h3 id="_1、-创建-store"> 1、 创建 store ；</h3>
<div><pre><code><span>// src导入方式；</span>
<span>const</span> <span>{</span> Redux<span>:</span> <span>{</span>createStore<span>}</span> <span>}</span> <span>=</span> window

<span>// 包引入方式；</span>
<span>import</span> <span>{</span> createStore <span>}</span> <span>from</span> <span>'redux'</span>
<span>import</span> todoApp <span>from</span> <span>'./reducers'</span>
<span>// 创建仓库；</span>
<span>let</span> store <span>=</span> <span>createStore</span><span>(</span>todoApp<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/frontEnd/vue/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>vue</category>
      <pubDate>Sat, 01 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些自己平时学习vue的一些相关的知识；</p>
</blockquote>
<h2 id="目录"> 目录</h2>
<ul>
<li>
<p><a href="./vue-note-01.html">vue指令</a></p>
</li>
<li>
<p><a href="./vue-note-02.html">计算属性</a></p>
</li>
<li>
<p><a href="./vue-note-03.html">侦听器</a></p>
</li>
<li>
<p><a href="./vue-note-04.html">列表的更新</a></p>
</li>
<li>
<p><a href="./vue-note-05.html">template</a></p>
</li>
<li>
<p><a href="./vue-note-06.html">component</a></p>
</li>
<li>
<p><a href="./vue-note-07.html">vue-router</a></p>
</li>
<li>
<p><a href="./vue-note-08.html">vue-cli使用</a></p>
</li>
<li>
<p><a href="./vue-note-09.html">wepy-cli的使用</a></p>
</li>
<li>
<p><a href="./vue-note-10.html">组件通信</a></p>
</li>
<li>
<p><a href="./vue-note-11.html">插槽</a></p>
</li>
<li>
<p><a href="./ssr介绍-17.html">ssr介绍</a></p>
</li>
<li>
<p><a href="./vue-note-18.html">基本用法</a></p>
</li>
<li>
<p>组件</p>
<ul>
<li><a href="./vue-example-01.html">toast组件</a></li>
</ul>
</li>
<li>
<p>进阶</p>
<ul>
<li><a href="./vue-note-12.html">vue-router源码实现1</a></li>
<li><a href="./vue-note-13.html">vue-router源码实现2</a></li>
<li><a href="./vue-note-14.html">vuex源码实现</a></li>
<li><a href="./vue-note-02-01.html">响应式原理(对象)</a></li>
<li><a href="./vue-note-02-02.html">响应式原理(数组)</a></li>
<li><a href="./手写vue-16.html">手写vue</a></li>
<li><a href="./vue-note-95.html">el和$mount的区别</a></li>
<li><a href="./vue-note-100.html">vue在实例化之前初始化了什么？</a></li>
</ul>
</li>
<li>
<p>VUE SSR实战</p>
<ul>
<li><a href="./vue-note-20.html">项目初始化</a></li>
<li><a href="./vue-note-25.html">处理favicon.icon</a></li>
<li><a href="./vue-note-30.html">处理路由</a></li>
<li><a href="./vue-note-35.html">构建流程</a></li>
<li><a href="./vue-note-40.html">创建VUE实例</a></li>
<li><a href="./vue-note-45.html">服务端入口</a></li>
<li><a href="./vue-note-50.html">客户端入口</a></li>
<li><a href="./vue-note-55.html">配置webpack</a></li>
<li><a href="./vue-note-60.html">脚本配置</a></li>
<li><a href="./vue-note-65.html">宿主文件</a></li>
<li><a href="./vue-note-70.html">托管静态资源</a></li>
<li><a href="./vue-note-75.html">配置清单</a></li>
<li><a href="./vue-note-80.html">整合VUEX</a></li>
<li><a href="./vue-note-85.html">数据预取</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>toast组件</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-example-01/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-example-01/</guid>
      <source url="https://wangyawei.top/rss.xml">toast组件</source>
      <category>vue</category>
      <pubDate>Sat, 21 Aug 2021 12:04:30 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>吐司组件在前端中算是最常用的组件了，这里简单实现一下；</p>
</blockquote>
<h2 id="封装toast组件"> 封装toast组件</h2>
<blockquote>
<p>ui部分，主要是显示内容；</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>w-toast<span>"</span></span> <span>v-show</span><span><span>=</span><span>"</span>visible<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>span</span> <span>class</span><span><span>=</span><span>"</span>w-toast-title<span>"</span></span><span>></span></span>{{ title }}<span><span><span>&lt;/</span>span</span><span>></span></span>
        <span><span><span>&lt;</span>slot</span><span>></span></span>
            <span><span><span>&lt;</span>p</span> <span>class</span><span><span>=</span><span>"</span>w-toast-content<span>"</span></span><span>></span></span>{{ content }}<span><span><span>&lt;/</span>p</span><span>></span></span>
        <span><span><span>&lt;/</span>slot</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
    name<span>:</span> <span>'WToast'</span><span>,</span>
    props<span>:</span> <span>{</span>
        title<span>:</span> String<span>,</span>
        content<span>:</span> String<span>,</span>
        duration<span>:</span> <span>{</span>
            <span>default</span><span>:</span> <span>3000</span>
        <span>}</span>
    <span>}</span><span>,</span>
    <span>data</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>{</span>
            visible<span>:</span> <span>false</span><span>,</span>
        <span>}</span>
    <span>}</span><span>,</span>
    methods<span>:</span> <span>{</span>
        <span>open</span><span>(</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span>visible <span>=</span> <span>true</span><span>;</span>
            <span>setTimeout</span><span>(</span><span>this</span><span>.</span>close<span>,</span> <span>this</span><span>.</span>duration<span>)</span><span>;</span>
        <span>}</span><span>,</span>
        <span>close</span><span>(</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span>visible <span>=</span> <span>false</span><span>;</span>
            <span>this</span><span>.</span><span>remove</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;</span>style</span> <span>scoped</span><span>></span></span><span><span>
<span>.w-toast</span> <span>{</span>
    <span>position</span><span>:</span> fixed<span>;</span>
    <span>left</span><span>:</span> 50%<span>;</span>
    <span>top</span><span>:</span> 20%<span>;</span>
    <span>max-width</span><span>:</span> 300px<span>;</span>
    <span>height</span><span>:</span> 40px<span>;</span>
    <span>line-height</span><span>:</span> 40px<span>;</span>
    <span>padding</span><span>:</span> 0 20px<span>;</span>
    <span>transform</span><span>:</span> <span>translateX</span><span>(</span>-50%<span>)</span><span>;</span>
    <span>background</span><span>:</span> #ccc<span>;</span>
<span>}</span>
<span>.w-toast-content</span> <span>{</span>
    <span>margin</span><span>:</span> 0<span>;</span>
    <span>display</span><span>:</span> inline-block<span>;</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><h2 id="创建create函数"> 创建create函数</h2>
<blockquote>
<p>方法用于随时创建使用 toast 提示；</p>
</blockquote>
<div><pre><code><span>import</span> Vue <span>from</span> <span>'vue'</span><span>;</span>

<span>// 方式一</span>
<span>function</span> <span>create</span><span>(</span><span>component<span>,</span> props</span><span>)</span> <span>{</span>
    <span>// 完成vue的初始化但是没有要挂载的节点；</span>
    <span>const</span> _vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
        <span>render</span><span>(</span><span>h</span><span>)</span> <span>{</span>
            <span>return</span> <span>h</span><span>(</span>component<span>,</span> <span>{</span> props <span>}</span><span>)</span>
        <span>}</span>
    <span>}</span><span>)</span><span>.</span><span>$mount</span><span>(</span><span>)</span><span>;</span>

    <span>// 挂载到 body 节点上</span>
    document<span>.</span>body<span>.</span><span>appendChild</span><span>(</span>_vm<span>.</span>$el<span>)</span><span>;</span>

    <span>// 给组件示例添加销毁方法；</span>
    <span>const</span> comp <span>=</span> _vm<span>.</span>$children<span>[</span><span>0</span><span>]</span><span>;</span>
    comp<span>.</span><span>remove</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
        document<span>.</span>body<span>.</span><span>removeChild</span><span>(</span>_vm<span>.</span>$el<span>)</span><span>;</span>
        _vm<span>.</span><span>$destroy</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> comp<span>;</span>
<span>}</span>

<span>// 方式二；</span>
<span>function</span> <span>create</span><span>(</span><span>component<span>,</span> props</span><span>)</span> <span>{</span>
    <span>const</span> Ctor <span>=</span> Vue<span>.</span><span>extend</span><span>(</span>component<span>)</span>
    <span>const</span> comp <span>=</span> <span>new</span> <span>Ctor</span><span>(</span><span>{</span> propsData<span>:</span> props <span>}</span><span>)</span><span>;</span>
    comp<span>.</span><span>$mount</span><span>(</span><span>)</span><span>;</span>
    document<span>.</span>body<span>.</span><span>appendChild</span><span>(</span>comp<span>.</span>$el<span>)</span><span>;</span>

    <span>// 给组件示例添加销毁方法；</span>
    comp<span>.</span><span>remove</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
        document<span>.</span>body<span>.</span><span>removeChild</span><span>(</span>comp<span>.</span>$el<span>)</span><span>;</span>
        comp<span>.</span><span>$destroy</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> comp<span>;</span>
<span>}</span>

<span>export</span> <span>default</span> create<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h2 id="使用"> 使用</h2>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>"</span>open<span>"</span></span><span>></span></span>弹窗<span><span><span>&lt;/</span>button</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>import</span> toast <span>from</span> <span>'./toast.vue'</span><span>;</span>
<span>import</span> create <span>from</span> <span>'../utils/toast'</span><span>;</span>
<span>export</span> <span>default</span> <span>{</span>
  methods<span>:</span> <span>{</span>
    <span>open</span><span>(</span><span>)</span> <span>{</span>
      <span>create</span><span>(</span>toast<span>,</span> <span>{</span>
        title<span>:</span> <span>'成功'</span><span>,</span>
        content<span>:</span> <span>'恭喜你创建成功'</span><span>,</span>
        duration<span>:</span> <span>1000</span><span>,</span>
      <span>}</span><span>)</span><span>.</span><span>open</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p><img src="./assets/image-20210819223132474.png" alt="image-20210819223132474" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>vue介绍</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-00/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-00/</guid>
      <source url="https://wangyawei.top/rss.xml">vue介绍</source>
      <category>vue</category>
      <pubDate>Sat, 21 Aug 2021 12:04:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="组件化"> 组件化</h2>
<blockquote>
<p>vue组件系统提供了一种抽象，让我们可以使用独立可复用的组件来构建大型应用，任意类型的应用界面都可以抽象为一个组件树。组件化能提高开发效率，方便重复使用，简化调试步骤，提升项目可维护 性，便于多人协同开发。</p>
</blockquote>
<p><img src="./assets/image-20210815235112275.png" alt="image-20210815235112275" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>vue指令</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-01/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-01/</guid>
      <source url="https://wangyawei.top/rss.xml">vue指令</source>
      <category>vue</category>
      <pubDate>Sun, 02 May 2021 16:04:30 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>在<code>vue</code>中，指令是带有<code>v-</code>前缀的特殊特性；指令特性的值，预期是单个JavaScript<strong>表达式</strong>(v-for除外)，责任就是当表达式的值改变时，就响应式的作用于DOM，从而做出改变。</p>
</blockquote>
<h2 id="v-if"> <code>v-if</code></h2>
<blockquote>
<p>条件渲染；</p>
</blockquote>
<ul>
<li>
<p>根据绑定数据的真假来决定是否渲染这个元素；</p>
</li>
<li>
<p>属性值类型为布尔类型；</p>
</li>
<li>
<p>当属性值为<code>false</code>时，则隐藏被作用的元素对象；</p>
</li>
</ul>
<div><pre><code><span>&lt;!-- 语法：--></span>
<span><span><span>&lt;</span>div</span> <span>v-if</span><span><span>=</span><span>'</span>true<span>'</span></span><span>></span></span>我是第四个div<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="v-show"> <code>v-show</code></h2>
<blockquote>
<p>条件显示；隐藏的本质是 css 属性<code>display: none</code>；</p>
</blockquote>
<ul>
<li>
<p>无论条件的真假始终都渲染元素；</p>
<ul>
<li>元素会始终渲染，至于是否显示则取决于<code>css</code>；</li>
</ul>
</li>
<li>
<p>属性值类型为布尔类型；</p>
</li>
<li>
<p>当属性值为<code>false</code>时，则隐藏被作用的元素对象；不显示（display: none）</p>
</li>
</ul>
<div><pre><code><span>&lt;!--语法--></span>
<span><span><span>&lt;</span>div</span> <span>v-show</span><span><span>=</span><span>'</span>false<span>'</span></span><span>></span></span>我是第三个div<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="v-text"> <code>v-text</code></h2>
<ul>
<li>可以在标签中插入一段文本；</li>
<li>无闪烁问题；</li>
</ul>
<div><pre><code><span>&lt;!--语法--></span>
<span><span><span>&lt;</span>p</span> <span>v-text</span><span><span>=</span><span>"</span>msg<span>"</span></span><span>></span></span>
  - `{{msg1}}` 插值表达式；
  - 可以进行简单的逻辑运算；
  - `{{ user.gender === 0 ? '男' : '女' }}`;
  - **有闪烁问题**；
  - 可以通过`v-cloak`解决闪烁问题；并结合`[v-cloak]{display: none;}`来使用；
<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code>[v-cloak]{
   display: none;
  }

<span><span><span>&lt;</span>p</span> <span>v-cloak</span><span>></span></span>++++++++ {{ msg }} ----------<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>闪烁</strong>：</p>
<ul>
<li>当网速较慢时，此时的<code>vue.js</code>文件还未加载过来，但是此时页面已经显示了<code>内容</code>,当文件加载完毕后又进行了替换；</li>
</ul>
<h2 id="v-html"> <code>v-html</code></h2>
<ul>
<li>在渲染时可以解析<code>html</code>标签；</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>v-html</span><span><span>=</span><span>"</span>msg<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="v-bind"> <code>v-bind</code></h2>
<blockquote>
<p>1、用来<strong>动态的绑定一个或者多个特性</strong>。没有参数时，可以绑定到一个包含键值对的对象。</p>
<p>2、可以简写为：  :class=&quot;{w: true}&quot; ；</p>
</blockquote>
<ul>
<li>
<p>为属性绑定  用于<code>vue</code>操作；</p>
</li>
<li>
<p><code>v-bind:class=&quot;{w: true}&quot;</code> :主要用于应用 <code>class</code>  类样式；</p>
<ul>
<li><code>属性</code> ：表示要应用的类样式；</li>
<li><code>属性值</code> ：为 <code>true</code> 应用，为<code>false</code>则不应用；</li>
</ul>
</li>
<li>
<p><code>v-bind:style=&quot;{color: 'red',fontSize: '40px'}&quot;</code>:主要用于设置<code>css</code>样式；</p>
</li>
<li>
<p><code>v-bind:style='obj1'</code>:此时的<code>obj1</code>为一个对象；</p>
</li>
</ul>
<div><pre><code><span>&lt;!--语法--></span>
<span><span><span>&lt;</span>p</span> <span><span>v-bind:</span>class</span><span><span>=</span><span>"</span>{w: true}<span>"</span></span><span>></span></span>我是一个p标签<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>p</span> <span><span>v-bind:</span>style</span><span><span>=</span><span>"</span>{color: <span>'</span>red<span>'</span>,fontSize: <span>'</span>40px<span>'</span>}<span>"</span></span><span>></span></span>我是一个大大的p标签<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;</span>span</span> <span><span>v-bind:</span>style</span><span><span>=</span><span>'</span>obj1<span>'</span></span><span>></span></span>我是span标签<span><span><span>&lt;/</span>span</span><span>></span></span>
<span>&lt;!--绑定标准属性实现vue操作--></span>
<span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>'</span>asd<span>'</span></span> <span><span>v-bind:</span>title</span><span><span>=</span><span>"</span>title<span>"</span></span><span>></span></span>我是div标签<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="v-else"> <code>v-else</code></h2>
<ul>
<li>主要用于判断，可以参考<code>if(){}</code>;</li>
<li><code>v-else</code>是搭配<code>v-if</code>使用的，它必须紧跟在<code>v-if</code>或者<code>v-else-if</code>后面，否则不起作用。</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>span</span> <span>v-if</span><span><span>=</span><span>"</span>age>=78<span>"</span></span><span>></span></span>{{adult}}<span><span><span>&lt;/</span>span</span><span>></span></span>
<span><span><span>&lt;</span>span</span> <span>v-else-if</span><span><span>=</span><span>"</span>age>=58<span>"</span></span><span>></span></span>{{juveniles}}<span><span><span>&lt;/</span>span</span><span>></span></span>
<span><span><span>&lt;</span>span</span> <span>v-else</span><span><span>=</span><span>"</span>juveniles<span>"</span></span><span>></span></span>{{juveniles}}<span><span><span>&lt;/</span>span</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="v-model"> <code>v-model</code></h2>
<blockquote>
<p>1、双向绑定，即数据和视图的实时更新；</p>
<p>2、在内部为不同的输入元素使用不同的属性并抛出不同的事件；</p>
</blockquote>
<ul>
<li>当应用于<code>text</code> 和 <code>textarea</code> 元素时<code>v-model</code>将用于监听 <code>value</code> 属性值的变化并触发 <code>input</code> 事件；</li>
<li>当应用于<code>checkbox</code> 和 <code>radio</code> 元素时<code>v-model</code> 将用于监听<code>checked</code> 属性值的变化并触发 <code>change</code> 事件；</li>
<li>当应用于<code>select</code> 字段将 <code>value</code> 作为 prop 并将 <code>change</code> 作为事件。</li>
<li>可以直接获取表单的文本内容；</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>v-model</span><span><span>=</span><span>"</span>text<span>"</span></span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="修饰符"> 修饰符：</h3>
<ul>
<li>
<p><code>.trim</code>：</p>
<ul>
<li>其作用是清空两端空白符；</li>
<li>**注意：**此时若监听<code>text</code>的值，则前面空格的输入不会触发监听函数的执行；</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>v-model.trim</span><span><span>=</span><span>"</span>username<span>"</span></span> <span>/></span></span><span><span><span>&lt;/</span>li</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p><code>.lazy</code>：</p>
<ul>
<li>用于取代原先的 input事件，改为 change事件;
<ul>
<li>不会在输入内容时触发事件了，而是在输入完毕后失去焦点时触发事件；</li>
</ul>
</li>
</ul>
<div><pre><code><span>&lt;!--用于取代原先的 input事件，改为 change事件；--></span>
<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>v-model.lazy</span><span><span>=</span><span>"</span>msg<span>"</span></span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p><code>.number</code>：</p>
<ul>
<li>把数字字符转换为<strong>数字类型</strong>，若第一次输入的是数字则会触发change事件，若后面继续输入其它的字符则不会在触发change事件；</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>v-model.number</span><span><span>=</span><span>"</span>msg1<span>"</span></span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p><code>.</code></p>
</li>
</ul>
<h3 id="事件修饰符"> 事件修饰符：</h3>
<ul>
<li>
<p><code>.stop</code>：</p>
<ul>
<li>阻止事件冒泡；</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>a</span> <span><span>v-on:</span>click.stop</span><span><span>=</span><span>"</span>doThis<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p><code>.prevent</code>：</p>
<ul>
<li>事件不再重载页面 ；</li>
<li>可以用于阻止<code>submit</code>的页面的默认跳转；</li>
</ul>
</li>
<li>
<p><code>.self</code>：</p>
<ul>
<li>只当在 <code>event.target</code> 是当前元素<strong>自身</strong>时触发处理函数 ;</li>
</ul>
</li>
<li>
<p><code>.once</code>：</p>
<ul>
<li>事件将只会触发一次 ；</li>
</ul>
</li>
<li>
<p><code>.passive</code>：</p>
<ul>
<li>告诉浏览器你不想阻止事件的默认行为 ；</li>
</ul>
</li>
</ul>
<blockquote>
<p>使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用<code>v-on:click.prevent.self</code>会<strong>阻止所有的点击</strong>，而 <code>v-on:click.self.prevent</code> 只会阻止对元素自身的点击。</p>
</blockquote>
<h2 id="v-on"> <code>v-on</code></h2>
<blockquote>
<p>支持动态参数绑定；</p>
</blockquote>
<ul>
<li>用于事件的绑定；</li>
<li><code>v-on</code>简写为<code>@</code>;</li>
</ul>
<div><pre><code> <span><span><span>&lt;</span>input</span> <span>@change</span><span><span>=</span><span>"</span>change<span>"</span></span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>v-model</span><span><span>=</span><span>"</span>text<span>"</span></span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="v-for"> <code>v-for</code></h2>
<blockquote>
<p>注意：v-for 不能 与 v-if  一起使用；</p>
</blockquote>
<ul>
<li>用于循环遍历：</li>
</ul>
<div><pre><code><span>//当参数为 1 个时；为值；</span>
<span>&lt;</span>h3 v<span>-</span><span>for</span><span>=</span><span>"key in arr"</span><span>></span><span>{</span><span>{</span>key<span>}</span><span>}</span><span>&lt;</span><span>/</span>h3<span>></span>

<span>//当参数为 2 个时； 为值==键；</span>
<span>&lt;</span>p v<span>-</span><span>for</span><span>=</span><span>"(value, name) in user"</span><span>></span><span>&lt;</span><span>/</span>p<span>></span>

<span>//当参数为 3 个时； 为值==键==索引；</span>
<span>&lt;</span>p v<span>-</span><span>for</span><span>=</span><span>"(value, name, index) in user"</span><span>></span><span>&lt;</span><span>/</span>p<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><ul>
<li>
<p>值范围的遍历；</p>
<ul>
<li>也可以接受整数。在这种情况下，它会把模板重复对应次数。</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span>
  <span><span><span>&lt;</span>span</span> <span>v-for</span><span><span>=</span><span>"</span>n in 10<span>"</span></span><span>></span></span>{{ n }} <span><span><span>&lt;/</span>span</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p><strong><code>key</code>的使用；</strong></p>
<ul>
<li><code>key</code>用作唯一的身份标识，用于告知vue，进行<code>Dom</code>的重新(创建)渲染，而不是<code>复用</code>；</li>
<li>在<code>Dom</code>节点的更新过程中，vue会识别<code>key</code>值的变化，然后判断是否进行<code>Dom</code>的重新渲染；</li>
</ul>
</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>body</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>"</span>ok<span>"</span></span><span>></span></span>点击反转<span><span><span>&lt;/</span>button</span><span>></span></span>
  <span><span><span>&lt;</span>ul</span><span>></span></span>
      <span>&lt;!--key 的值要唯一，key的值不能使用索引值，--></span>
    <span><span><span>&lt;</span>li</span> <span>v-for</span><span><span>=</span><span>"</span>item in msg<span>"</span></span> <span>:key</span><span><span>=</span><span>"</span>item.id<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>span</span><span>></span></span>{{item.name}}<span><span><span>&lt;/</span>span</span><span>></span></span>
      <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span><span>></span></span>
    <span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;/</span>ul</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>../../libs/vue.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
  <span>new</span> <span>Vue</span><span>(</span><span>{</span>
    el<span>:</span> <span>"#app"</span><span>,</span>
    data<span>:</span> <span>{</span>
      msg<span>:</span> <span>[</span>
        <span>{</span>id<span>:</span> <span>1</span><span>,</span> name<span>:</span> <span>"小明"</span><span>}</span><span>,</span>
        <span>{</span>id<span>:</span> <span>2</span><span>,</span> name<span>:</span> <span>"小红"</span><span>}</span><span>,</span>
        <span>{</span>id<span>:</span> <span>3</span><span>,</span> name<span>:</span> <span>"小李"</span><span>}</span><span>,</span>
        <span>{</span>id<span>:</span> <span>4</span><span>,</span> name<span>:</span> <span>"小绿"</span><span>}</span>
      <span>]</span>
    <span>}</span><span>,</span>
    methods<span>:</span> <span>{</span>
      <span>ok</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>//点击反转数组</span>
        <span>this</span><span>.</span>msg<span>.</span><span>reverse</span><span>(</span><span>)</span>
      <span>}</span>
    <span>}</span>
  <span>}</span><span>)</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h2 id="v-once"> <code>v-once</code></h2>
<ul>
<li>只渲染元素一次;</li>
</ul>
<div><pre><code><span>&lt;!--只渲染一次，点击事件的触发不会改变其内容；相当于禁用了响应式--></span>
<span><span><span>&lt;</span>span</span> <span>v-once</span><span>></span></span>{{msg}}<span><span><span>&lt;/</span>span</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="v-pre"> <code>v-pre</code></h2>
<ul>
<li>所在元素不会被编译处理，可以理解为不被解析或渲染；</li>
</ul>
<div><pre><code><span>&lt;!--此时的{{msg}}不会被解析--></span>
<span><span><span>&lt;</span>span</span> <span>v-pre</span><span>></span></span>{{msg}}哈哈哈<span><span><span>&lt;/</span>span</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>响应式原理(对象)</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-02-01/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-02-01/</guid>
      <source url="https://wangyawei.top/rss.xml">响应式原理(对象)</source>
      <category>vue</category>
      <pubDate>Wed, 11 Aug 2021 23:04:30 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>说起<code>vue</code>的响应式原理，大家也许只知道它的底层是对<code>js</code>的原生方法<code>defineProperty</code>的封装，而具体的实现却是一头雾水。下面我们就一探究竟。</p>
</blockquote>
<h2 id="_1、封装defineproperty。"> 1、封装<code>defineProperty</code>。</h2>
<blockquote>
<p>主要目的：就是存取拦截；在<code>get</code>中收集依赖，在<code>set</code>中触发依赖；</p>
<p>依赖是什么？依赖就是用到数据的地方，那个地方用到了这个属性，那么我们就通知谁，也就是触发依赖；</p>
</blockquote>
<div><pre><code><span>const</span> Dep <span>=</span> <span>require</span><span>(</span><span>'./Dep.js'</span><span>)</span>
<span>const</span> Observer <span>=</span> <span>require</span><span>(</span><span>'./Observer.js'</span><span>)</span>
<span>/**
 * 存取描述符
 */</span>
<span>function</span> <span>defineReactive</span><span>(</span><span>data<span>,</span> key<span>,</span> val</span><span>)</span> <span>{</span>
  <span>// 新增 递归子属性；</span>
  <span>if</span> <span>(</span><span>typeof</span> val <span>===</span> <span>'object'</span><span>)</span> <span>{</span>
    <span>new</span> <span>Observer</span><span>(</span>val<span>)</span>
  <span>}</span>
  <span>// 每一个属性都会有一个依赖表，用来收集自己的依赖；</span>
  <span>let</span> dep <span>=</span> <span>new</span> <span>Dep</span><span>(</span><span>)</span>
  Object<span>.</span><span>defineProperty</span><span>(</span>data<span>,</span> key<span>,</span> <span>{</span>
    enumerable<span>:</span> <span>true</span><span>,</span>
    configurable<span>:</span> <span>true</span><span>,</span>
    <span>get</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>// 收集依赖</span>
      dep<span>.</span><span>depend</span><span>(</span><span>)</span>
      <span>return</span> val
    <span>}</span><span>,</span>
    <span>set</span><span>:</span> <span>function</span> <span>(</span><span>newval</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>val <span>===</span> newval<span>)</span> <span>{</span>
        <span>return</span>
      <span>}</span>
      val <span>=</span> newval
      <span>// 通知触发收集的依赖项</span>
      dep<span>.</span><span>notify</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span><span>)</span>
<span>}</span>
exports<span>.</span>defineReactive <span>=</span>  defineReactive
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><h2 id="_2、封装-dep的类"> 2、封装 <code>Dep</code>的类；</h2>
<blockquote>
<p>主要目的：用于处理依赖。</p>
</blockquote>
<div><pre><code><span>/**
 * 收集依赖
 */</span>
<span>let</span> uid <span>=</span> <span>0</span>

<span>/**
 * 此id 会在每一次new Dep的时候执行，也就是只会在 首次转换为 get 和set 的时候执行；
 */</span>
 <span>class</span> <span>Dep</span> <span>{</span>
  <span>constructor</span> <span>(</span><span>)</span> <span>{</span>
    <span>// 收集依赖的集合</span>
    <span>this</span><span>.</span>id <span>=</span> uid<span>++</span>
    <span>this</span><span>.</span>subs <span>=</span> <span>[</span><span>]</span>
  <span>}</span>

  <span>// 添加依赖；</span>
  <span>addSub</span> <span>(</span><span>sub</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>subs<span>.</span><span>push</span><span>(</span>sub<span>)</span>
  <span>}</span>

  <span>// 删除依赖；</span>
  <span>removeSub</span> <span>(</span><span>sub</span><span>)</span> <span>{</span>
    <span>remove</span><span>(</span><span>this</span><span>.</span>subs<span>,</span> sub<span>)</span>
  <span>}</span>

  <span>// 收集依赖</span>
  <span>depend</span> <span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>global<span>.</span>target<span>)</span> <span>{</span>
      global<span>.</span>target<span>.</span><span>addDep</span><span>(</span><span>this</span><span>)</span>
    <span>}</span>
  <span>}</span>

  <span>// 通知</span>
  <span>notify</span> <span>(</span><span>)</span> <span>{</span>
    <span>const</span> subs <span>=</span> <span>this</span><span>.</span>subs<span>.</span><span>slice</span><span>(</span><span>)</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> subs<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      subs<span>[</span>i<span>]</span><span>.</span><span>update</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>remove</span> <span>(</span><span>arr<span>,</span> item</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>arr<span>.</span>length<span>)</span> <span>{</span>
    <span>const</span> index <span>=</span> arr<span>.</span><span>indexOf</span><span>(</span>item<span>)</span>
    <span>if</span> <span>(</span>index <span>></span> <span>-</span><span>1</span><span>)</span> <span>{</span>
      <span>return</span> arr<span>.</span><span>splice</span><span>(</span>index<span>,</span> <span>1</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

exports<span>.</span>Dep <span>=</span> Dep

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><h2 id="_3、observer"> 3、<code>Observer;</code></h2>
<blockquote>
<p>作用：将一个数据内的所有的属性都转换成getter/setter的形式。然后去追踪他们的变化;</p>
</blockquote>
<div><pre><code><span>const</span> defineReactive <span>=</span> <span>require</span><span>(</span><span>'./defineReactive.js'</span><span>)</span>

<span>class</span> <span>Observer</span> <span>{</span>
  <span>constructor</span> <span>(</span><span>value</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>value <span>=</span> value
    <span>if</span> <span>(</span><span>!</span>Array<span>.</span><span>isArray</span><span>(</span>value<span>)</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span><span>walk</span><span>(</span>value<span>)</span>
    <span>}</span>
  <span>}</span>

  <span>walk</span> <span>(</span><span>obj</span><span>)</span> <span>{</span>
    <span>const</span> keys <span>=</span> Object<span>.</span><span>keys</span><span>(</span>obj<span>)</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> keys<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
     defineReactive<span>.</span><span>defineReactive</span><span>(</span>obj<span>,</span> keys<span>[</span>i<span>]</span><span>,</span> obj<span>[</span>keys<span>[</span>i<span>]</span><span>]</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
exports<span>.</span>Observer <span>=</span> Observer

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="_4、watcher"> 4、<code>Watcher</code>;</h2>
<blockquote>
<p>一个 Watcher 中介的角色，收集的依赖就是它。</p>
<p>因为它知道你要访问的属性；</p>
</blockquote>
<div><pre><code><span>class</span> <span>Watcher</span> <span>{</span>
  <span>constructor</span><span>(</span><span>vm<span>,</span> expOrFn<span>,</span> cb</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>vm <span>=</span> vm
    <span>this</span><span>.</span>deps <span>=</span> <span>[</span><span>]</span>
    <span>this</span><span>.</span>depIds <span>=</span> <span>new</span> <span>Set</span><span>(</span><span>)</span>
    <span>// 执行this.getter(),就可以读取data.a.b.c的内容</span>
    <span>this</span><span>.</span>getter <span>=</span> <span>parsePath</span><span>(</span>expOrFn<span>)</span>
    <span>this</span><span>.</span>cb <span>=</span> cb
    <span>this</span><span>.</span>value <span>=</span> <span>this</span><span>.</span><span>get</span><span>(</span><span>)</span>
  <span>}</span>

  <span>get</span><span>(</span><span>)</span> <span>{</span>
    <span>// 把依赖存在 global.target 上，</span>
    global<span>.</span>target <span>=</span> <span>this</span>
    <span>// 这一步会触发 getter 函数从而把自己添加到依赖表中；value 是读取到的值。</span>
    <span>let</span> value <span>=</span> <span>this</span><span>.</span><span>getter</span><span>.</span><span>call</span><span>(</span><span>this</span><span>.</span>vm<span>,</span> <span>this</span><span>.</span>vm<span>)</span>
    <span>// 避免重复添加依赖，但是在通知更新的时候依然添加了重复的依赖；</span>
    global<span>.</span>target <span>=</span> <span>undefined</span>
    <span>return</span> value
  <span>}</span>

  <span>update</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> oldValue <span>=</span> <span>this</span><span>.</span>value
    <span>this</span><span>.</span>value <span>=</span> <span>this</span><span>.</span><span>get</span><span>(</span><span>)</span>
    <span>this</span><span>.</span><span>cb</span><span>.</span><span>call</span><span>(</span><span>this</span><span>.</span>vm<span>,</span> <span>this</span><span>.</span>value<span>,</span> oldValue<span>)</span>
  <span>}</span>

  <span>addDep</span><span>(</span><span>dep</span><span>)</span> <span>{</span>
    <span>const</span> id <span>=</span> dep<span>.</span>id
    <span>/**
     * 主要目的：避免通知更新的时候重复收集依赖；
     */</span>
    <span>if</span> <span>(</span><span>!</span><span>this</span><span>.</span>depIds<span>.</span><span>has</span><span>(</span>id<span>)</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>depIds<span>.</span><span>add</span><span>(</span>id<span>)</span>
      <span>this</span><span>.</span>deps<span>.</span><span>push</span><span>(</span>dep<span>)</span>
      dep<span>.</span><span>addSub</span><span>(</span><span>this</span><span>)</span>
    <span>}</span>
  <span>}</span>

  <span>// 取消观察；</span>
  <span>teardown</span><span>(</span><span>)</span> <span>{</span>
    <span>let</span> i <span>=</span> <span>this</span><span>.</span>deps<span>.</span>length
    <span>while</span> <span>(</span>i<span>--</span><span>)</span> <span>{</span>
      <span>this</span><span>.</span>deps<span>[</span>i<span>]</span><span>.</span><span>removeSub</span><span>(</span><span>this</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>// 用于根据路径来读取属性的值；</span>
<span>const</span> bailRE <span>=</span> <span><span>/</span><span>[^\w.$]</span><span>/</span></span>

<span>function</span> <span>parsePath</span><span>(</span><span>path</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>bailRE<span>.</span><span>test</span><span>(</span>path<span>)</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>
  <span>const</span> segments <span>=</span> path<span>.</span><span>split</span><span>(</span><span>'.'</span><span>)</span>
  <span>return</span> <span>function</span> <span>(</span><span>obj</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> segments<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>!</span>obj<span>)</span> <span>return</span>
      <span>// obj[segments[i]] 在读取值时会触发 get 拦截函数；</span>
      obj <span>=</span> obj<span>[</span>segments<span>[</span>i<span>]</span><span>]</span>
    <span>}</span>
    <span>return</span> obj
  <span>}</span>
<span>}</span>

exports<span>.</span>Watcher <span>=</span> Watcher

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br></div></div><h2 id="_5、使用"> 5、使用；</h2>
<blockquote>
<p>实现：<code>vm.$watch()</code></p>
</blockquote>
<div><pre><code><span>const</span> Observer <span>=</span> <span>require</span><span>(</span><span>'./Observer.js'</span><span>)</span>
<span>const</span> Watcher <span>=</span> <span>require</span><span>(</span><span>'./Watcher.js'</span><span>)</span>

<span>var</span> data <span>=</span> <span>{</span>
  name<span>:</span> <span>'小红'</span><span>,</span>
  age<span>:</span> <span>18</span><span>,</span>
  skill<span>:</span> <span>{</span>
    dance<span>:</span> <span>'芭蕾舞'</span><span>,</span>
    exercise<span>:</span> <span>'跑步'</span>
  <span>}</span>
<span>}</span>
<span>// 观测所有的属性的变化</span>
<span>new</span> <span>Observer<span>.</span>Observer</span><span>(</span>data<span>)</span>

<span>function</span> <span>Vm</span><span>(</span><span>)</span> <span>{</span><span>}</span>

<span>Vm</span><span>.</span>prototype<span>.</span><span>$watch</span> <span>=</span> <span>function</span> <span>(</span><span>obj<span>,</span> path<span>,</span> cb</span><span>)</span> <span>{</span>
  <span>const</span> watcher <span>=</span> <span>new</span> <span>Watcher<span>.</span>Watcher</span><span>(</span>obj<span>,</span> path<span>,</span> cb<span>)</span>

  <span>// 取消观察</span>
  <span>return</span> <span>function</span> <span>unwatchFn</span><span>(</span><span>)</span> <span>{</span>
    watcher<span>.</span><span>teardown</span><span>(</span><span>)</span>
  <span>}</span>
<span>}</span>
<span>var</span> vm <span>=</span> <span>new</span> <span>Vm</span><span>(</span><span>)</span>

vm<span>.</span><span>$watch</span><span>(</span>data<span>,</span> <span>'skill.dance'</span><span>,</span> <span>(</span><span>newVal<span>,</span> oldVal</span><span>)</span> <span>=></span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'我执行了'</span><span>,</span> newVal<span>,</span> oldVal<span>)</span>
<span>}</span><span>)</span>
data<span>.</span>skill<span>.</span>dance <span>=</span> <span>'哈哈=='</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><div><pre><code>object
    ├── defineReactive.js
    ├── Dep.js
    ├── index.js
    ├── Observer.js
    ├── Watcher.js
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="总结"> 总结；</h2>
<blockquote>
<p><code>vue</code>通过对<code>js</code>的原生方法的封装；来达到对数据的访问和赋值的拦截，然后做执行自己的逻辑代码；</p>
<p>要想达到对数据的响应，就要对数据进行处理，就是把用到这个数据的地方收集起来，然后当这个值发生变化时，通过便会通过触发<code>get</code>函数，来通知用到这个数据的地方，则其修改；</p>
</blockquote>
<p><img src="./assets/1589695503414.png" alt="1589695503414" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>响应式原理(数组)</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-02-02/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-02-02/</guid>
      <source url="https://wangyawei.top/rss.xml">响应式原理(数组)</source>
      <category>vue</category>
      <pubDate>Wed, 11 Aug 2021 23:04:30 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>说起<code>vue</code>的响应式原理，大家也许只知道它的底层是对<code>js</code>的原生方法<code>defineProperty</code>的封装，而具体的实现却是一头雾水。下面我们就一探究竟。</p>
<p>然而数组的响应式与对象又有点区别，因为当你用 <code>list.push(1)</code>方法往数组里面添加元素时，依赖并不会触发。</p>
<p>解决方法：就是拦截<code>push()</code>方法，用自己的<code>push</code>方法覆盖原始方法，这样当你用<code>push()</code>方法时，便可以做一些其他的操作；</p>
</blockquote>
<h2 id="_1、封装拦截器。"> 1、封装拦截器。</h2>
<blockquote>
<p>主要目的：生成自己的push相关方法。</p>
</blockquote>
<div><pre><code><span>// arrayMethods.js</span>
<span>const</span> utils <span>=</span> <span>require</span><span>(</span><span>'./utils/utils.js'</span><span>)</span>
<span>/**
 * 实现拦截器
 */</span>
<span>const</span> arrayProto <span>=</span> <span>Array</span><span>.</span>prototype
<span>const</span> arrayMethods <span>=</span> Object<span>.</span><span>create</span><span>(</span>arrayProto<span>)</span>
<span>;</span><span>[</span>
  <span>'push'</span><span>,</span>
  <span>'pop'</span><span>,</span>
  <span>'shift'</span><span>,</span>
  <span>'unshift'</span><span>,</span>
  <span>'splice'</span><span>,</span>
  <span>'sort'</span><span>,</span>
  <span>'reverse'</span>
<span>]</span><span>.</span><span>forEach</span><span>(</span><span>function</span> <span>(</span><span>method</span><span>)</span> <span>{</span>
  <span>// 缓存原始方法</span>
  <span>const</span> original <span>=</span> arrayProto<span>[</span>method<span>]</span>
  utils<span>.</span><span>def</span><span>(</span>arrayMethods<span>,</span> method<span>,</span> <span>function</span> <span>mutator</span><span>(</span><span><span>...</span>args</span><span>)</span> <span>{</span>
    <span>// 让缓存的原始的方法指向 数组；</span>
    <span>const</span> result <span>=</span> <span>original</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> args<span>)</span>
    <span>const</span> ob <span>=</span> <span>this</span><span>.</span>__ob__
    <span>let</span> inserted<span>;</span>
    <span>switch</span> <span>(</span>method<span>)</span> <span>{</span>
      <span>case</span> <span>'push'</span><span>:</span>
      <span>case</span> <span>'unshift'</span><span>:</span>
        inserted <span>=</span> args
        <span>break</span>
      <span>case</span> <span>'splice'</span><span>:</span>
        <span>// 因为 splice 可传入三个参数，从第三个参数开始 便是新增的元素，我们只对新增的元素变换侦测</span>
        inserted <span>=</span> args<span>.</span><span>splice</span><span>(</span><span>2</span><span>)</span>
        <span>break</span>
    <span>}</span>
    <span>if</span> <span>(</span>inserted<span>)</span> ob<span>.</span><span>observeArray</span><span>(</span>inserted<span>)</span>
    ob<span>.</span>dep<span>.</span><span>notify</span><span>(</span><span>)</span>
    <span>return</span> result
  <span>}</span><span>)</span>
<span>}</span><span>)</span>
exports<span>.</span>arrayMethods <span>=</span> arrayMethods
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h2 id="_2、封装defineproperty。"> 2、封装<code>defineProperty</code>。</h2>
<div><pre><code><span>// defineReactive.js</span>
<span>const</span> Dep <span>=</span> <span>require</span><span>(</span><span>'./Dep.js'</span><span>)</span>
<span>const</span> utils <span>=</span> <span>require</span><span>(</span><span>'./utils/utils.js'</span><span>)</span>

<span>function</span> <span>defineReactive</span><span>(</span><span>data<span>,</span> key<span>,</span> val</span><span>)</span> <span>{</span>
  <span>let</span> childOb <span>=</span> utils<span>.</span><span>observe</span><span>(</span>val<span>)</span>
  <span>let</span> dep <span>=</span> <span>new</span> <span>Dep<span>.</span>Dep</span><span>(</span><span>)</span>
  Object<span>.</span><span>defineProperty</span><span>(</span>data<span>,</span> key<span>,</span> <span>{</span>
    <span>// 描述该属性是否会出现在for in 或者 Object.keys()的遍历中</span>
    enumerable<span>:</span> <span>true</span><span>,</span>
    <span>// 描述属性该属性是否配置，以及可否删除</span>
    configurable<span>:</span> <span>true</span><span>,</span>
    <span>get</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      dep<span>.</span><span>depend</span><span>(</span><span>)</span>
      <span>// 这里收集数组的依赖</span>
      <span>if</span> <span>(</span>childOb<span>)</span> <span>{</span>
        childOb<span>.</span>dep<span>.</span><span>depend</span><span>(</span><span>)</span>
      <span>}</span>
      <span>return</span> val
    <span>}</span><span>,</span>
    <span>set</span><span>:</span> <span>function</span> <span>(</span><span>newval</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span>val <span>===</span> newval<span>)</span> <span>{</span>
        <span>return</span>
      <span>}</span>

      val <span>=</span> newval
      dep<span>.</span><span>notify</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span><span>)</span>
<span>}</span>

exports<span>.</span>defineReactive <span>=</span> defineReactive
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h2 id="_2、封装-dep的类"> 2、封装 <code>Dep</code>的类；</h2>
<blockquote>
<p>主要目的：用于处理依赖。</p>
</blockquote>
<div><pre><code><span>/**
 * 收集依赖  Dep.js
 */</span>
 <span>class</span> <span>Dep</span> <span>{</span>
  <span>constructor</span> <span>(</span><span>)</span> <span>{</span>
    <span>// 收集依赖的集合</span>
    <span>this</span><span>.</span>subs <span>=</span> <span>[</span><span>]</span>
  <span>}</span>

  <span>// 添加依赖；</span>
  <span>addSub</span> <span>(</span><span>sub</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>subs<span>.</span><span>push</span><span>(</span>sub<span>)</span>
  <span>}</span>

  <span>// 删除依赖；</span>
  <span>removeSub</span> <span>(</span><span>sub</span><span>)</span> <span>{</span>
    <span>remove</span><span>(</span><span>this</span><span>.</span>subs<span>,</span> sub<span>)</span>
  <span>}</span>

  <span>// 收集依赖</span>
  <span>depend</span> <span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>global<span>.</span>target<span>)</span> <span>{</span>
      <span>this</span><span>.</span><span>addSub</span><span>(</span>global<span>.</span>target<span>)</span>
    <span>}</span>
  <span>}</span>

  <span>// 通知</span>
  <span>notify</span> <span>(</span><span>)</span> <span>{</span>
    <span>const</span> subs <span>=</span> <span>this</span><span>.</span>subs<span>.</span><span>slice</span><span>(</span><span>)</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> subs<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      subs<span>[</span>i<span>]</span><span>.</span><span>update</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

<span>function</span> <span>remove</span> <span>(</span><span>arr<span>,</span> item</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>arr<span>.</span>length<span>)</span> <span>{</span>
    <span>const</span> index <span>=</span> arr<span>.</span><span>indexOf</span><span>(</span>item<span>)</span>
    <span>if</span> <span>(</span>index <span>></span> <span>-</span><span>1</span><span>)</span> <span>{</span>
      <span>return</span> arr<span>.</span><span>splice</span><span>(</span>index<span>,</span> <span>1</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

exports<span>.</span>Dep <span>=</span> Dep

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br></div></div><h2 id="_3、observer"> 3、<code>Observer;</code></h2>
<blockquote>
<p>作用：将一个数据内的所有的属性都转换成getter/setter的形式。然后去追踪他们的变化;</p>
</blockquote>
<div><pre><code><span>// Observer.js</span>
<span>const</span> defineReactive <span>=</span> <span>require</span><span>(</span><span>'./defineReactive.js'</span><span>)</span>
<span>const</span> utils <span>=</span> <span>require</span><span>(</span><span>'./utils/utils.js'</span><span>)</span>
<span>const</span> arrayMethods <span>=</span> <span>require</span><span>(</span><span>'./arrayMethods.js'</span><span>)</span>
<span>const</span> Dep <span>=</span> <span>require</span><span>(</span><span>'./Dep.js'</span><span>)</span>

<span>/**
 * 覆盖Array原型；
 */</span>

<span>/**
 * 因为有些浏览器可能不支持 __proto__ 属性；所以需要判断。
 * in关键字可以用来检测某个对象里是否存在某个属性，
 * 既可以是这个对象自身的属性，也可以是这个对象继承的属性
 * */</span>
<span>const</span> hasProto <span>=</span> <span>'__proto__'</span> <span>in</span> <span>{</span><span>}</span>
<span>// Object.getOwnPropertyNames 可以获取不可枚举属性 和 object.keys类似；</span>
<span>const</span> arraykeys <span>=</span> Object<span>.</span><span>getOwnPropertyNames</span><span>(</span>arrayMethods<span>.</span>arrayMethods<span>)</span>

<span>class</span> <span>Observer</span> <span>{</span>
  <span>constructor</span><span>(</span><span>value</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>value <span>=</span> value
    <span>// 收集数组的依赖</span>
    <span>this</span><span>.</span>dep <span>=</span> <span>new</span> <span>Dep<span>.</span>Dep</span><span>(</span><span>)</span>
    utils<span>.</span><span>def</span><span>(</span>value<span>,</span> <span>'__ob__'</span><span>,</span> <span>this</span><span>)</span>
    <span>// 判断 value 是否为数组</span>
    <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>value<span>)</span><span>)</span> <span>{</span>
      <span>/**
       * 将拦截器挂载到数组的属性上；
       */</span>
        <span>// 如果为数组则判断当前浏览器是否支持 __proto__ 属性</span>
      <span>const</span> augment <span>=</span> hasProto <span>?</span> utils<span>.</span>protoAugment <span>:</span> utils<span>.</span>copyAugment
      <span>augment</span><span>(</span>value<span>,</span> arrayMethods<span>,</span> arraykeys<span>)</span>
      <span>this</span><span>.</span><span>observeArray</span><span>(</span>value<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>this</span><span>.</span><span>walk</span><span>(</span>value<span>)</span>
    <span>}</span>
  <span>}</span>

  <span>/**
   * 侦测Array中的每一项；
   */</span>
  <span>observeArray</span><span>(</span><span>items</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> items<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      utils<span>.</span><span>observe</span><span>(</span>items<span>[</span>i<span>]</span><span>)</span>
    <span>}</span>
  <span>}</span>

  <span>// 此方法只在数据类型为对象时，调用；</span>
  <span>walk</span><span>(</span><span>obj</span><span>)</span> <span>{</span>
    <span>const</span> keys <span>=</span> Object<span>.</span><span>keys</span><span>(</span>obj<span>)</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> keys<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      defineReactive<span>.</span><span>defineReactive</span><span>(</span>obj<span>,</span> keys<span>[</span>i<span>]</span><span>,</span> obj<span>[</span>keys<span>[</span>i<span>]</span><span>]</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>

exports<span>.</span>Observer <span>=</span> Observer

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br></div></div><h2 id="_4、watcher"> 4、<code>Watcher</code>;</h2>
<blockquote>
<p>一个 Watcher 中介的角色，收集的依赖就是它。</p>
<p>因为它知道你要访问的属性；</p>
</blockquote>
<div><pre><code><span>// Watcher.js</span>
<span>class</span> <span>Watcher</span> <span>{</span>
  <span>constructor</span><span>(</span><span>vm<span>,</span> expOrFn<span>,</span> cb</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>vm <span>=</span> vm
    <span>this</span><span>.</span>getter <span>=</span> <span>parsePath</span><span>(</span>expOrFn<span>)</span>
    <span>this</span><span>.</span>cb <span>=</span> cb
    <span>this</span><span>.</span>value <span>=</span> <span>this</span><span>.</span><span>get</span><span>(</span><span>)</span>
  <span>}</span>

  <span>get</span><span>(</span><span>)</span> <span>{</span>
    global<span>.</span>target <span>=</span> <span>this</span>
    <span>// 避免对象的引用导致 像数组中添加元素时 不会返回原数据的问题</span>
    <span>let</span> value <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>this</span><span>.</span><span>getter</span><span>.</span><span>call</span><span>(</span><span>this</span><span>.</span>vm<span>,</span> <span>this</span><span>.</span>vm<span>)</span><span>)</span><span>)</span>
    global<span>.</span>target <span>=</span> <span>undefined</span>
    <span>return</span> value
  <span>}</span>

  <span>update</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> oldValue <span>=</span> <span>this</span><span>.</span>value
    <span>this</span><span>.</span>value <span>=</span> <span>this</span><span>.</span><span>get</span><span>(</span><span>)</span>
    <span>this</span><span>.</span><span>cb</span><span>.</span><span>call</span><span>(</span><span>this</span><span>.</span>vm<span>,</span> <span>this</span><span>.</span>value<span>,</span> oldValue<span>)</span>
  <span>}</span>
<span>}</span>

<span>// 用于根据路径来读取属性的值；</span>
<span>const</span> bailRE <span>=</span> <span><span>/</span><span>[^\w.$]</span><span>/</span></span>

<span>function</span> <span>parsePath</span><span>(</span><span>path</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>bailRE<span>.</span><span>test</span><span>(</span>path<span>)</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>
  <span>const</span> segments <span>=</span> path<span>.</span><span>split</span><span>(</span><span>'.'</span><span>)</span>
  <span>return</span> <span>function</span> <span>(</span><span>obj</span><span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> segments<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>!</span>obj<span>)</span> <span>return</span>
      obj <span>=</span> obj<span>[</span>segments<span>[</span>i<span>]</span><span>]</span>
    <span>}</span>
    <span>return</span> obj
  <span>}</span>
<span>}</span>

exports<span>.</span>Watcher <span>=</span> Watcher

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><h2 id="_5、工具函数"> 5、工具函数</h2>
<div><pre><code><span>// utils/utils.js</span>
<span>const</span> defineReactive <span>=</span> <span>require</span><span>(</span><span>'../defineReactive.js'</span><span>)</span>
<span>const</span> Observer <span>=</span> <span>require</span><span>(</span><span>'../Observer.js'</span><span>)</span>
<span>/**
 * 当前浏览器不支持时，执行该方法，
 * 目的：将 arrayMethods 的方法，设置到被侦测的数组上。
 * 原因：当访问一个对象的方法时，只有其自身不存在这个方法，才会去它的原型上找这个方法，
 * */</span>
<span>function</span> <span>copyAugment</span><span>(</span><span>target<span>,</span> src<span>,</span> keys</span><span>)</span> <span>{</span>
  <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> keys<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
    <span>const</span> key <span>=</span> keys<span>[</span>i<span>]</span>
    defineReactive<span>.</span><span>defineReactive</span><span>(</span>target<span>,</span> key<span>,</span> src<span>[</span>key<span>]</span><span>)</span>
  <span>}</span>
<span>}</span>

<span>// 当前浏览器支持 __proto__ 属性时，执行该方法。</span>
<span>// 目的：覆盖数组的原始__proto__ 。</span>
<span>function</span> <span>protoAugment</span><span>(</span><span>target<span>,</span> src<span>,</span> keys</span><span>)</span> <span>{</span>
  target<span>.</span>__proto__ <span>=</span> src<span>.</span>arrayMethods
<span>}</span>

<span>// 判断是否为对象；</span>
<span>function</span> <span>isObject</span><span>(</span><span>obj</span><span>)</span> <span>{</span>
  <span>return</span> obj <span>!==</span> <span>null</span> <span>&amp;&amp;</span> <span>typeof</span> obj <span>===</span> <span>'object'</span>
<span>}</span>

<span>const</span> hasOwnProperty <span>=</span> <span>Object</span><span>.</span>prototype<span>.</span>hasOwnProperty

<span>function</span> <span>hasOwn</span><span>(</span><span>obj<span>,</span> key</span><span>)</span> <span>{</span>
  <span>return</span> <span>hasOwnProperty</span><span>.</span><span>call</span><span>(</span>obj<span>,</span> key<span>)</span>
<span>}</span>

<span>// 工具函数；</span>
<span>function</span> <span>def</span><span>(</span><span>obj<span>,</span> key<span>,</span> val<span>,</span> enumerable</span><span>)</span> <span>{</span>
  Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
    value<span>:</span> val<span>,</span>
    enumerable<span>:</span> <span>!</span><span>!</span>enumerable<span>,</span>
    writable<span>:</span> <span>true</span><span>,</span>
    configurable<span>:</span> <span>true</span>
  <span>}</span><span>)</span>
<span>}</span>

<span>function</span> <span>observe</span><span>(</span><span>value</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span><span>!</span><span>isObject</span><span>(</span>value<span>)</span><span>)</span> <span>{</span>
    <span>return</span>
  <span>}</span>
  <span>let</span> ob
  <span>if</span> <span>(</span><span>hasOwn</span><span>(</span>value<span>,</span> <span>'__ob__'</span><span>)</span> <span>&amp;&amp;</span> value<span>.</span>__ob__ <span>instanceof</span> <span>Observer<span>.</span>Observer</span><span>)</span> <span>{</span>
    ob <span>=</span> value<span>.</span>__ob__
  <span>}</span> <span>else</span> <span>{</span>
    ob <span>=</span> <span>new</span> <span>Observer<span>.</span>Observer</span><span>(</span>value<span>)</span>
  <span>}</span>
  <span>return</span> ob
<span>}</span>

module<span>.</span>exports <span>=</span> <span>{</span>
  copyAugment<span>,</span>
  protoAugment<span>,</span>
  def<span>,</span>
  observe
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br></div></div><div><pre><code>array
├── arrayMethods.js
├── defineReactive.js
├── Dep.js
├── index.js
├── Observer.js
├── utils
│   └── utils.js
├── Watcher.js
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="_6、使用"> 6、使用；</h2>
<blockquote>
<p>实现：<code>vm.$watch()</code></p>
</blockquote>
<div><pre><code><span>const</span> Observer <span>=</span> <span>require</span><span>(</span><span>'./Observer.js'</span><span>)</span>
<span>const</span> Watcher <span>=</span> <span>require</span><span>(</span><span>'./Watcher.js'</span><span>)</span>

<span>var</span> data <span>=</span> <span>{</span>
  name<span>:</span> <span>'熊明'</span><span>,</span>
  arr<span>:</span> <span>[</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>]</span>
<span>}</span>
<span>new</span> <span>Observer<span>.</span>Observer</span><span>(</span>data<span>)</span>

<span>function</span> <span>Vm</span><span>(</span><span>)</span> <span>{</span><span>}</span>
<span>Vm</span><span>.</span>prototype<span>.</span><span>$watch</span> <span>=</span> <span>function</span> <span>(</span><span>obj<span>,</span> path<span>,</span> cb</span><span>)</span> <span>{</span>
  <span>new</span> <span>Watcher<span>.</span>Watcher</span><span>(</span>obj<span>,</span> path<span>,</span> cb<span>)</span>
<span>}</span>

<span>var</span> vm <span>=</span> <span>new</span> <span>Vm</span><span>(</span><span>)</span>
vm<span>.</span><span>$watch</span><span>(</span>data<span>,</span> <span>'arr'</span><span>,</span> <span>(</span><span>newVal<span>,</span> oldVal</span><span>)</span> <span>=></span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'我执行了'</span><span>,</span> newVal<span>,</span> <span>'==='</span><span>,</span> oldVal<span>)</span>
<span>}</span><span>)</span>

<span>// data.arr.push('q', 'w', 'r')</span>
data<span>.</span>arr<span>.</span><span>splice</span><span>(</span><span>2</span><span>,</span> <span>5</span><span>)</span>
<span>// data.name = '你好'</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="总结"> 总结；</h2>
<blockquote>
<p><code>vue</code>通过对<code>js</code>的原生方法的封装；来达到对数据的访问和赋值的拦截，然后做执行自己的逻辑代码；</p>
<p>要想达到对数据的响应，就要对数据进行处理，就是把用到这个数据的地方收集起来，然后当这个值发生变化时，通过便会通过触发<code>get</code>函数，来通知用到这个数据的地方，则其修改；</p>
<p>问题：</p>
<p>但是正是由于实现的方法是通过拦截原型，所以有些操作这侧不到；</p>
<p>1、this.list[0] = 9</p>
<p>2、this.list.length = 0</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>计算属性</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-02/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-02/</guid>
      <source url="https://wangyawei.top/rss.xml">计算属性</source>
      <category>vue</category>
      <pubDate>Sun, 02 May 2021 16:04:30 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>1、 模板内的表达式非常便利，但是设计它们的初衷是用于<strong>简单运算的</strong>。在模板中放入太多的逻辑会让模板过重且难以维护 ；</p>
<p>2、 在一个计算属性里可以完成各种<strong>复杂的逻辑</strong>，包括运算、函数调用等，只要最终返回一个结果就可以。</p>
<p>3、<strong>计算属性禁用箭头函数</strong> ；</p>
<p>4、<strong>计算属性自带缓存机制</strong>；</p>
</blockquote>
<h2 id="spa"> SPA</h2>
<blockquote>
<ul>
<li>传统模式 每个页面及其内容都需要从服务器一次次请求  如果网络差, 体验则会感觉很慢；</li>
<li>spa模式, **<code>第一次</code>**加载 会将所有的资源都请求到页面 **<code>模块之间切换</code>**不会再请求服务器；</li>
</ul>
</blockquote>
<ol>
<li>
<p><strong>优点；</strong></p>
<ul>
<li>用户体验好,因为前段操作几乎感受不到网络的延迟；</li>
<li>完全组件化开发 ,原来属于一个个页面的工作被归类为一个个**<code>组件</code>**.；</li>
</ul>
</li>
<li>
<p><strong>缺点；</strong></p>
<ul>
<li><strong><code>首屏</code><strong>加载慢-&gt;</strong><code>按需加载</code></strong> 不刷新页面 只请求js模块</li>
<li>不利于SEO-&gt;<strong><code>服务端渲染</code></strong>；</li>
<li><strong><code>开发难度高</code></strong>(框架) ；</li>
</ul>
</li>
<li>
<p><strong>实现原理；</strong></p>
<div><pre><code><span>*</span> 可以通过页面地址的锚链接来实现spa<span>;</span><span>*</span> <span>hash</span><span>(</span>锚链接<span>)</span>位于链接地址 <span><span>`</span><span>#</span><span>`</span></span>之后<span>;</span><span>*</span> hash值的改变<span><span>`</span><span>不会触发</span><span>`</span></span>页面刷新<span>;</span><span>*</span> hash值是url地址的一部分<span>,</span>会存储在页面地址上 我们可以获取到<span>;</span><span>*</span> 可以通过<span><span>`</span><span>事件监听</span><span>`</span></span>hash值得改变<span>;</span><span>*</span> 拿到了hash值<span>,</span>就可以根据不同的hash值进行不同的<span><span>`</span><span>模块切换</span><span>`</span></span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>侦听器</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-03/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-03/</guid>
      <source url="https://wangyawei.top/rss.xml">侦听器</source>
      <category>vue</category>
      <pubDate>Sun, 02 May 2021 14:14:30 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>能够监听到数据的变化并执行特定的逻辑，只要数据发生变化就执行相关的逻辑代码；</p>
</blockquote>
<div><pre><code><span>// 深度监听；</span>
todos<span>:</span> <span>{</span>   
    <span>handler</span><span>(</span><span>)</span> <span>{</span>     
        window<span>.</span>localStorage<span>.</span><span>setItem</span><span>(</span><span>"todos"</span><span>,</span><span>JSON</span><span>.</span><span>stringify</span><span>(</span><span>this</span><span>.</span>todos<span>)</span><span>)</span>    
    <span>}</span><span>,</span>     
    deep<span>:</span> <span>true</span><span>,</span> <span>// 默认为false</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>列表的更新</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-04/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-04/</guid>
      <source url="https://wangyawei.top/rss.xml">列表的更新</source>
      <category>vue</category>
      <pubDate>Wed, 11 Aug 2021 14:14:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="遍历数组"> 遍历数组</h2>
<p>可以利用一些常用的数组的方法来更新数组；</p>
<ul>
<li>push()</li>
<li>pop()</li>
<li>shift()</li>
<li>unshift()</li>
<li>splice()</li>
<li>sort()</li>
<li>reverse()</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>  
        <span><span><span>&lt;</span>ul</span><span>></span></span>    
            <span><span><span>&lt;</span>li</span> <span>v-for</span><span><span>=</span><span>"</span>item in arr<span>"</span></span><span>></span></span>{{item}}<span><span><span>&lt;/</span>li</span><span>></span></span>  
        <span><span><span>&lt;/</span>ul</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>../../libs/vue.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>  
    <span>var</span> vm<span>=</span><span>new</span> <span>Vue</span><span>(</span><span>{</span>    
        el<span>:</span> <span>"#app"</span><span>,</span>    
        data<span>:</span> <span>{</span>
            arr<span>:</span><span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>,</span><span>4</span><span>,</span><span>5</span><span>,</span><span>6</span><span>,</span><span>7</span><span>,</span><span>8</span><span>,</span><span>9</span><span>]</span><span>,</span>    
        <span>}</span>
    <span>}</span><span>)</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><div><p>提示</p>
<p>以下两种情况都不会更新视图：</p>
<ul>
<li>当你利用索引直接设置一个数组项时，例如：<code>vm.items[indexOfItem] = newValue</code></li>
<li>当你修改数组的长度时，例如：<code>vm.items.length = newLength</code>
<ul>
<li><code>vm.items.splice(newLength)</code>；</li>
</ul>
</li>
</ul>
<p>解决：<code>Vue.set(vm.items, indexOfItem, newValue)</code></p>
<ul>
<li>参数1： 实例的数组</li>
<li>参数2：索引</li>
<li>参数3：你要修改的那个数据新值</li>
</ul>
<div><pre><code><span>//例： </span>
Vue<span>.</span><span>set</span><span>(</span>vm<span>.</span>arr<span>,</span> <span>6</span><span>,</span> <span>100</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></div>
<h2 id="遍历对象"> 遍历对象</h2>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>    
    <span><span><span>&lt;</span>ul</span><span>></span></span>      
        <span><span><span>&lt;</span>li</span> <span>v-for</span><span><span>=</span><span>"</span>item in msg<span>"</span></span><span>></span></span>{{item.id}}--{{item.title}}<span><span><span>&lt;/</span>li</span><span>></span></span>    
    <span><span><span>&lt;/</span>ul</span><span>></span></span>    
    <span>&lt;!--如果obj对象中没有初始化的对象成员name，那么对象的修改不会响应到视图中--></span>    <span><span><span>&lt;</span>h1</span><span>></span></span>{{obj.name}}<span><span><span>&lt;/</span>h1</span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>  
    <span>var</span> vm <span>=</span><span>new</span> <span>Vue</span><span>(</span><span>{</span>    
        el<span>:</span> <span>"#app"</span><span>,</span>    
        data<span>:</span> <span>{</span> 
            <span>// //初始化的数据可以正常遍历；  </span>
            msg<span>:</span> <span>[</span>                
                <span>{</span> id<span>:</span> <span>1</span><span>,</span> title<span>:</span> <span>'吃饭1'</span> <span>}</span><span>,</span>        
                <span>{</span> id<span>:</span> <span>2</span><span>,</span> title<span>:</span> <span>'吃饭2'</span> <span>}</span><span>,</span>        
                <span>{</span> id<span>:</span> <span>3</span><span>,</span> title<span>:</span> <span>'吃饭3'</span> <span>}</span><span>,</span>        
                <span>{</span> id<span>:</span> <span>4</span><span>,</span> title<span>:</span> <span>'吃饭4'</span> <span>}</span>      
            <span>]</span><span>,</span>  
            obj<span>:</span> <span>{</span><span>}</span><span>,</span>    
        <span>}</span>
    <span>}</span><span>)</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p><strong>对象的更新：</strong></p>
<ol>
<li>已经初始化的数据可以直接<code>对象.属性=&quot;值&quot;</code>的方式来进行数据的更新；</li>
<li>未初始化的数据可以采用<strong>重新赋值</strong>的方式进行数据的更新：<code>app.obj={&quot;name&quot;: &quot;小明&quot;}</code>；</li>
<li>未初始化的数据可以采用<code>vue</code>提供的方法来进行数的更新；</li>
<li><code>Vue.set(vm.obj,&quot;name&quot;,&quot;小明&quot;)</code>
<ul>
<li>参数1：实例的数据对象</li>
<li>参数2：属性名</li>
<li>参数3：属性值</li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>template</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-05/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-05/</guid>
      <source url="https://wangyawei.top/rss.xml">template</source>
      <category>vue</category>
      <pubDate>Wed, 11 Aug 2021 14:14:30 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>当需要遍历多个元素而又不想增加额外的元素节点的时候，可以结合 <code>Vue</code> 中提供的 <code>template</code> 遍历渲染；</p>
</blockquote>
<ul>
<li>结合<code>v-for</code>使用；</li>
<li>可以结合<code>v-if</code>使用；</li>
<li><strong>不能结合<code>v-show</code>使用；</strong></li>
<li>渲染的结果<code>template</code>标签不会在<code>Dom</code>中出现；</li>
</ul>
<div><p>提示</p>
<p>template 上不能使用 key，要把 key 加到真实的 DOM 节点</p>
</div>
<div><pre><code><span><span><span>&lt;</span>body</span><span>></span></span>   
    <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>    
        <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>"</span>ok<span>"</span></span><span>></span></span>点击反转<span><span><span>&lt;/</span>button</span><span>></span></span>    
        <span><span><span>&lt;</span>template</span> <span>v-for</span><span><span>=</span><span>"</span>item in msg<span>"</span></span><span>></span></span>      
			<span><span><span>&lt;</span>div</span> <span>:key</span><span><span>=</span><span>"</span>item.id<span>"</span></span><span>></span></span>        
    			{{item.name}}        
    			<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span><span>></span></span>      
            <span><span><span>&lt;/</span>div</span><span>></span></span>    
        <span><span><span>&lt;/</span>template</span><span>></span></span>  
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>  
    <span>new</span> <span>Vue</span><span>(</span><span>{</span>    
        el<span>:</span> <span>"#app"</span><span>,</span>    
        data<span>:</span> <span>{</span>      
            msg<span>:</span> <span>[</span>        
                <span>{</span>id<span>:</span> <span>1</span><span>,</span> name<span>:</span> <span>"小明"</span><span>}</span><span>,</span>        
                <span>{</span>id<span>:</span> <span>2</span><span>,</span> name<span>:</span> <span>"小红"</span><span>}</span><span>,</span>        
                <span>{</span>id<span>:</span> <span>3</span><span>,</span> name<span>:</span> <span>"小李"</span><span>}</span><span>,</span>        
                <span>{</span>id<span>:</span> <span>4</span><span>,</span> name<span>:</span> <span>"小绿"</span><span>}</span>      
            <span>]</span>    
        <span>}</span><span>,</span>
        methods<span>:</span> <span>{</span>      
            <span>ok</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>        
                <span>//点击反转数组        </span>
                <span>this</span><span>.</span>msg<span>.</span><span>reverse</span><span>(</span><span>)</span>      
            <span>}</span>    
        <span>}</span>  
    <span>}</span><span>)</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>component</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-06/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-06/</guid>
      <source url="https://wangyawei.top/rss.xml">component</source>
      <category>vue</category>
      <pubDate>Sun, 02 May 2021 14:14:30 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<ol>
<li>
<p>概述：优化页面结构，简化开发过程；</p>
</li>
<li>
<p>组件特点：</p>
<ol>
<li>简单、高效、不重复；</li>
<li>组件是一个<strong>特殊的 <code>Vue</code>实例</strong>；<code>Vue</code>实例有的 组件基本都有；</li>
<li>组件没有<code>el</code> ,但是有<code>template</code>组件页面结构；</li>
</ol>
</li>
<li>
<p>注意：</p>
<ol>
<li>组件中<code>data</code>为一个函数没有<code>el</code>选项 ；</li>
<li>组件的<code>data</code>是一个带<strong>返回值</strong>的函数;</li>
<li><code>template</code>代表其<strong>页面结构</strong> (有且只能有一个根元素)；</li>
<li>每个组件都是**<code>独立</code>** 数据 逻辑没有任何关联；</li>
</ol>
</li>
<li>
<p>语法；</p>
<div><pre><code><span>&lt;!--语法--></span>
<span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>  
    <span>&lt;!-- 使用组件 直接写组件的名称标签即可   --></span>  
    <span>&lt;!-- 写了一个标签 相当于 一个组件实例 --></span>  
    <span><span><span>&lt;</span>eight-eight</span><span>></span></span><span><span><span>&lt;/</span>eight-eight</span><span>></span></span>  
    <span><span><span>&lt;</span>eight-eight</span><span>></span></span><span><span><span>&lt;/</span>eight-eight</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span> 
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
Vue<span>.</span><span>component</span><span>(</span><span>"组件名称"</span><span>,</span> <span>{</span>    
    <span>// 组件对象    </span>
    template<span>:</span> <span><span>`</span><span>`</span></span><span>,</span>    
    <span>data</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>      
         <span>return</span> <span>{</span>name<span>:</span> <span>"字节跳动"</span><span>}</span><span>;</span>    
    <span>}</span><span>,</span>
    methods<span>:</span> <span>{</span><span>}</span><span>,</span>    
    computed<span>:</span> <span>{</span><span>}</span><span>,</span>    
    watch<span>:</span> <span>{</span><span>}</span><span>,</span>    
    <span>created</span><span>(</span><span>)</span> <span>{</span>    <span>}</span><span>,</span>    
    <span>mounted</span><span>(</span><span>)</span> <span>{</span>    <span>}</span>  
<span>}</span><span>)</span><span>;</span>  
<span>var</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>    
	el<span>:</span> <span>"#app"</span><span>,</span>    
	data<span>:</span> <span>{</span><span>}</span><span>,</span>    
	methods<span>:</span> <span>{</span><span>}</span>  
<span>}</span><span>)</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div></li>
</ol>
</blockquote>
<h2 id="全局组件"> 全局组件</h2>
<ul>
<li>注册组件名称推荐小写字母加横向的结构；</li>
<li>全局组件注册应该放在<code>Vue</code>实例化之前 ;</li>
<li>全局组件创建后，新创建的<code>Vue</code>实例也可以使用；</li>
<li>加减进步器案例；</li>
</ul>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>  
    <span><span><span>&lt;</span>step-counter</span><span>></span></span><span><span><span>&lt;/</span>step-counter</span><span>></span></span>  
    <span><span><span>&lt;</span>step-counter</span><span>></span></span><span><span><span>&lt;/</span>step-counter</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app1<span>"</span></span><span>></span></span>    
    新创建的VUE实例也可以直接使用  
    <span><span><span>&lt;</span>step-counter</span><span>></span></span><span><span><span>&lt;/</span>step-counter</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>  
    Vue<span>.</span><span>component</span><span>(</span><span>"step-counter"</span><span>,</span> <span>{</span>    
        <span>// 页面结构    </span>
        template<span>:</span> <span><span>`</span><span>&lt;div>        
						&lt;button @click="cut">-&lt;/button>       
						&lt;span>{{count}}&lt;/span>        
						&lt;button @click="add">+&lt;/button>        
   				   &lt;/div></span><span>`</span></span><span>,</span>    
        <span>data</span><span>(</span><span>)</span> <span>{</span>      
            <span>return</span> <span>{</span>        
                count<span>:</span> <span>0</span>      
            <span>}</span><span>;</span>    
        <span>}</span><span>,</span>    
        methods<span>:</span> <span>{</span>      
            <span>cut</span><span>(</span><span>)</span> <span>{</span>         
                <span>//简化写法，如果前面的不执行，则后面的也不执行，否则执行；        </span>
                <span>this</span><span>.</span>count <span>&amp;&amp;</span> <span>this</span><span>.</span>count<span>--</span><span>;</span>      
            <span>}</span><span>,</span> 
            <span>add</span><span>(</span><span>)</span> <span>{</span>        
                <span>this</span><span>.</span>count<span>++</span><span>;</span>      
            <span>}</span>    
        <span>}</span>  
    <span>}</span><span>)</span><span>;</span>
    <span>var</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>    
        el<span>:</span> <span>"#app"</span><span>,</span>    
        data<span>:</span> <span>{</span><span>}</span><span>,</span>    
        methods<span>:</span> <span>{</span><span>}</span>  
    <span>}</span><span>)</span><span>;</span> 
    <span>var</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>    
        el<span>:</span> <span>"#app1"</span><span>,</span> 
    <span>}</span><span>)</span><span>;</span></span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><h2 id="局部组件"> 局部组件</h2>
<blockquote>
<p>局部组件只能在当前实例上注册；</p>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>  
    <span><span><span>&lt;</span>abc-d</span><span>></span></span><span><span><span>&lt;/</span>abc-d</span><span>></span></span>  
    <span><span><span>&lt;</span>abc-d</span><span>></span></span><span><span><span>&lt;/</span>abc-d</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>  
    <span>// 局部组件需要在当前实例上注册  </span>
    <span>var</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>    
        el<span>:</span> <span>"#app"</span><span>,</span>    
        components<span>:</span> <span>{</span> 
            <span>// key(组件名称):value(组件对象)      </span>
            <span>"abc-d"</span><span>:</span> <span>{</span>        
                template<span>:</span> <span><span>`</span><span>&lt;p>我最牛&lt;/p></span><span>`</span></span><span>,</span>      
            <span>}</span>    
        <span>}</span>  
    <span>}</span><span>)</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="组件嵌套"> 组件嵌套；</h2>
<blockquote>
<ol>
<li>组件嵌套就是在**<code>组件中</code><strong>使用</strong><code>其他组件</code>**;</li>
<li>一旦形成组件嵌套 ,就有了**<code>父子关系</code>** ;</li>
<li>组件嵌套最多不要超过三级；</li>
<li>嵌套组件不要跨级访问；</li>
<li>组件名称最好采用小写或驼峰命名法；</li>
</ol>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>  
    <span><span><span>&lt;</span>abc-p</span><span>></span></span><span><span><span>&lt;/</span>abc-p</span><span>></span></span>   
    <span>&lt;!--&lt;edf>&lt;/edf>--></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>  
    <span>//创建全局组件；  </span>
    Vue<span>.</span><span>component</span><span>(</span><span>"edf"</span><span>,</span> <span>{</span>    
        template<span>:</span> <span><span>`</span><span>&lt;p style='color:blue'>我是一个全局组件edf&lt;/p></span><span>`</span></span>  
    <span>}</span><span>)</span><span>;</span>  
    Vue<span>.</span><span>component</span><span>(</span><span>"abc-p"</span><span>,</span> <span>{</span>    
        template<span>:</span> <span><span>`</span><span>&lt;div>我是一个全局组件abc-p&lt;child>&lt;/child>&lt;edf>&lt;/edf>&lt;!--&lt;qwe>&lt;/qwe> 跨级访问不到 -->        &lt;/div></span><span>`</span></span><span>,</span>    
        components<span>:</span> <span>{</span>      
            child<span>:</span> <span>{</span> 
                template<span>:</span> <span><span>`</span><span>&lt;div style='color:red'>我是一个局部组件child&lt;qwe>&lt;/qwe>&lt;/div></span><span>`</span></span><span>,</span>        
                components<span>:</span> <span>{</span> 
                    qwe <span>:</span> <span>{</span> 
                        template<span>:</span> <span><span>`</span><span>&lt;div style="color:chartreuse">我式第二个局部组件&lt;/div></span><span>`</span></span>          
                    <span>}</span>        
                <span>}</span>      
            <span>}</span>    
        <span>}</span>  
    <span>}</span><span>)</span><span>;</span>  
    <span>var</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>    
        el<span>:</span> <span>"#app"</span><span>,</span>  
    <span>}</span><span>)</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>vue-router</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-07/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-07/</guid>
      <source url="https://wangyawei.top/rss.xml">vue-router</source>
      <category>vue</category>
      <pubDate>Wed, 11 Aug 2021 23:14:30 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<ul>
<li>Vue-Router 是 <a href="http://cn.vuejs.org/" target="_blank" rel="noopener noreferrer">Vue.js</a> 官方的路由管理器。它和 Vue.js 的核心深度集成，让构建<strong>单页面</strong>应用变得易如反掌   <strong>它是一个插件</strong></li>
<li>Vuejs中不包含vue-router</li>
<li>实现根据不同的请求地址 而**<code>显示不同的组件</code>**</li>
<li>如果要使用 vue开发项目,前端路由功能**<code>必须使用</code>**vue-router来实现</li>
</ul>
</blockquote>
<h2 id="使用步骤"> 使用步骤</h2>
<ol>
<li>
<p>导入<code>vue</code>和<code>vue-router</code>;</p>
<div><pre><code><span>&lt;</span>script src<span>=</span><span>"./vue-router.js"</span><span>></span><span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>设置HTML中的内容;</p>
<div><pre><code><span>&lt;!-- router-link 最终会被渲染成a标签，to指定路由的跳转地址 --></span>
<span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/users<span>"</span></span><span>></span></span>用户管理<span><span><span>&lt;/</span>router-link</span><span>></span></span>
<span>&lt;!-- 路由匹配到的组件将渲染在这里 --></span>
<span>&lt;!--定义容器--></span>
<span><span><span>&lt;</span>router-view</span><span>></span></span><span><span><span>&lt;/</span>router-view</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>创建组件;</p>
<div><pre><code><span>// 创建组件</span>
<span>// 组件也可以放到单独的js文件中</span>
<span>var</span> Home <span>=</span> <span>{</span>template<span>:</span> <span>'&lt;div>这是Home内容&lt;/div>'</span><span>}</span><span>;</span>
<span>var</span> Users <span>=</span> <span>{</span>template<span>:</span> <span>'&lt;div>这是用户管理内容&lt;/div>'</span><span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>实例化路由对象,配置路由规则;</p>
<div><pre><code><span>// 配置路由规则</span>
<span>var</span> router <span>=</span> <span>new</span> <span>VueRouter</span><span>(</span><span>{</span>
    routes<span>:</span> <span>[</span>
        <span>{</span> name<span>:</span> <span>'home'</span><span>,</span> path<span>:</span> <span>'/'</span><span>,</span> component<span>:</span> Home <span>}</span><span>,</span>
        <span>{</span> name<span>:</span> <span>'users'</span><span>,</span> path<span>:</span> <span>'/users'</span><span>,</span> component<span>:</span> Users 
        <span>}</span>
    <span>]</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
<li>
<p><code>vue</code>实例挂载router实例;</p>
<div><pre><code><span>var</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>el<span>:</span> <span>'#app'</span><span>,</span>router<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div></li>
</ol>
<h2 id="动态路由"> 动态路由;</h2>
<blockquote>
<ul>
<li>点击**<code>列表页</code>** 跳转到**<code>详情页</code><strong>时,跳转的链接需要携带参数,会导致</strong><code>path</code>**不同；</li>
<li>当path不同却需要对应同一个组件时,需要用到动态路由这一概念；</li>
<li>动态路由传参 =&gt;  列表 =&gt;详情 =&gt; 动态路由id传过去；</li>
<li><strong>注意</strong> 动态路由的参数 可以通过 <code>vue</code>实例.<code>$route.params</code>获取;</li>
</ul>
</blockquote>
<ol>
<li>
<p><strong>动态路由传参；</strong></p>
<div><pre><code><span>{</span> name<span>:</span> <span>'users'</span><span>,</span> path<span>:</span> <span>'/users/:id'</span><span>,</span> component<span>:</span> Users <span>}</span><span>,</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>通过 <code>&lt;router-link&gt;</code> 传参，在路径上传入具体的值;</p>
<div><pre><code><span>&lt;</span>router<span>-</span>link to<span>=</span><span>"/users/120"</span><span>></span>用户管理<span>&lt;</span><span>/</span>router<span>-</span>link<span>></span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>在组件内部使用<strong>this.$route</strong> 获取当前路由对象;</p>
<div><pre><code><span>var</span> Users <span>=</span> <span>{</span>   
    template<span>:</span> <span>'&lt;div>这是用户管理内容 {{ $route.params.id }}&lt;/div>'</span><span>,</span>  
    <span>mounted</span><span>(</span><span>)</span> <span>{</span>       
        console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>$route<span>.</span>params<span>.</span>id<span>)</span><span>;</span>   
    <span>}</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
</ol>
<h2 id="属性赋值"> 属性赋值；</h2>
<blockquote>
<p>to 有多种赋值方式  ;</p>
</blockquote>
<div><pre><code><span>&lt;!-- 常规跳转 --></span>      
<span>&lt;!-- &lt;router-link to="/sport">体育&lt;/router-link> --></span>      
<span>&lt;!-- 变量 --></span>      
<span>&lt;!-- &lt;router-link :to="path">体育&lt;/router-link> --></span>      
<span>&lt;!-- 根据对象name跳转 --></span>      
<span>&lt;!-- &lt;router-link :to="{name:'abcdefg'}">体育&lt;/router-link> --></span>      
<span>&lt;!-- 根据对象path跳转 --></span>      
<span>&lt;!-- &lt;router-link :to="{path:'/sport'}">体育&lt;/router-link> --></span>      
<span>&lt;!-- 带参数的跳转 --></span>      
<span><span><span>&lt;</span>router-link</span> <span>:to</span><span><span>=</span><span>"</span>{name:<span>'</span>abcdefg<span>'</span>,params:{a:1}}<span>"</span></span><span>></span></span>体育<span><span><span>&lt;/</span>router-link</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>vue-cli使用</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-08/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-08/</guid>
      <source url="https://wangyawei.top/rss.xml">vue-cli使用</source>
      <category>vue</category>
      <pubDate>Wed, 11 Aug 2021 23:14:30 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<ul>
<li>
<p>介绍: <strong><code>vue-cli</code><strong>是一个</strong><code>辅助开发工具</code></strong>=&gt; <strong><code>代码编译</code></strong> + <strong><code>样式</code></strong> + 语法校验 + 输出设置 + 其他 ...</p>
</li>
<li>
<p>作用: 可以为开发者提供一个**<code>标准的项目开发结构</code>** 和配置</p>
</li>
<li>
<p>vue-cli 一个**<code>命令行</code><strong>工具,最新版本也支持</strong><code>图形化</code>**操作,可快速搭建大型网页应用</p>
</li>
</ul>
</blockquote>
<h2 id="vue-cli安装"> <code>vue-cli</code>安装</h2>
<blockquote>
<p>vue-cli本质上是一个npm包,也需要通过npm去安装下载</p>
<div><pre><code><span>npm</span> i -g @vue/cli  // 全局安装脚手架  默认安装的最新版本 <span>4.0</span>+
</code></pre>
<div><span>1</span><br></div></div><p>查看版本</p>
<div><pre><code>vue -V  // 查看脚手架版本号
or 
vue --version // 和上面等价 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><code>注意</code>: 默认安装的4.0+ 版本,但是企业很多还在用2.0+版本 怎么破?</p>
<p>执行以下命令就可以 2.0 和 3.0 /4.0兼得</p>
<ul>
<li><strong><code>2.0和3.0/4.0创建项目的命令是不一样的</code></strong></li>
</ul>
<div><pre><code><span>npm</span> <span>install</span> -g @vue/cli-init  // 安装桥接工具 将2.0的功能补齐到目前的脚手架上
</code></pre>
<div><span>1</span><br></div></div><p><strong>注意</strong>: vue生成的模板有难有易</p>
<ul>
<li>
<p>简单业务 =&gt; 简易模板</p>
</li>
<li>
<p>复杂业务 =&gt; 内容丰富模板</p>
</li>
</ul>
</blockquote>
<h2 id="vue-cli2-0创建项目"> <code>vue-cli2.0</code>创建项目</h2>
<blockquote>
<p>创建项目: 采用<code>cli 2.0</code>的特性 (生成简易模板)</p>
<div><pre><code><span>#  heroes 创建的项目名称</span>
$ vue  init webpack-simple heroes //  webpack-simple 为模板名称 固定写法

<span># 切换到当前目录</span>
$ <span>cd</span>  heroes 

<span># 安装依赖</span>
$ <span>npm</span> <span>install</span>  

<span># 在开发模式下 启动运行项目</span>
$ <span>npm</span> run dev
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></blockquote>
<h3 id="项目目录解释"> 项目目录解释</h3>
<blockquote>
<p>**<code>目标</code>**对<code>2.0</code>项目目录生成的模板文件进行识别认识</p>
<p>.bablelrc=&gt;存放 babel编译的配置信息 () =&gt; es6 =&gt; es5</p>
<p>.editorconfig =&gt; 存放编辑器的配置信息</p>
<p>.gitignore =&gt; git忽略文件</p>
<p>index.html =&gt; 单页应用的html</p>
<p>package.json =&gt; 用于存放依赖信息 及 其他项目信息</p>
<p>README.md =&gt; 项目介绍信息 github上的页面信息</p>
<p>webpack.config.js =&gt; wepack工具的配置文件 =&gt; webpack是一个前端工程化的工具  编译代码 -压缩代码- 处理代码,其他....</p>
<p>webpack =&gt; 代码编译,打包 压缩</p>
<p>build.js =&gt;  不是人写的 =&gt; webpack 打包而来 =&gt; webpack中可以配置文件的**<code>入口</code>** ,可以配置文件的**<code>出口</code>**</p>
<p>webpack 文件的出口 =&gt;buildjs =&gt;  配置信息  =&gt;  webpack.config.js</p>
<p>entry =&gt; 整个项目的入口文件=&gt; main.js</p>
<p>output =&gt; 整个项目的出口文件 =&gt; filename =&gt; build.js  =&gt;  build.js 启动项目时  并不是物理文件,而是内存中一个文件流</p>
</blockquote>
<h2 id="vuecli4-0配置项目"> <code>VueCli4.0</code>配置项目</h2>
<div><pre><code><span># 4.0/3.0下创建项目</span>
$ vue create heroes   <span># create(创建) 为关键字</span>

<span># 切换到当前目录</span>
$ <span>cd</span>  heroes 

<span># 在开发模式下 启动运行项目</span>
$ <span>npm</span> run serve
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p><strong>注意</strong>:</p>
<p>3.0 +创建项目时有两种模式, 一种**<code>默认模式</code>**, 一种选择模式,</p>
<p><strong>默认模式</strong>:一种标准的模板;</p>
<p><strong>选择模式</strong>:可以根据自己的需求选择需要的工具和模式;</p>
</blockquote>
<h3 id="个性化配置"> 个性化配置;</h3>
<ol>
<li>
<p>初始化一个项目(4.0)</p>
<div><pre><code>$ vue create toutiao-81 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>选择模式：简易(默认)或个性化；
<img src="./assets/1580819778118.png" alt="1580819778118" /></p>
</li>
<li>
<p>选择个性化进入下一步；
<img src="./assets/1580819877747.png" alt="1580819877747" /></p>
<p>使用键盘上下箭头进行移动，使用空格切换选中与否。</p>
<p><code>Babel</code>：将 ECMAScript  6 转 ECMAScript 5用的一个工具</p>
<p><code>Router</code>：Vue Router 路由</p>
<p><code>CSS Pre-processors</code>：CSS预处理器（SASS、Less、Stylus。。。。）</p>
<p><code>Linter / Formatter</code>：代码校验和格式化</p>
</li>
<li>
<p>勾选好以后，回车进入下一步。
<img src="./assets/1580819976525.png" alt="1580819976525" /></p>
<p>选择路由模式</p>
<p>路由路径有两种模式：</p>
<ul>
<li>hash锚点模式：<code>http://协议:端口号/path路径/#/路由路径</code>
<ul>
<li>简单，兼容好</li>
</ul>
</li>
<li>history模式：<code>http://协议:端口号/路由路径</code>
<ul>
<li>url简洁</li>
<li>兼容差，需要额外的服务器配置</li>
</ul>
</li>
</ul>
</li>
<li>
<p>输入 <code>n</code> ,使用默认的路由模式。 回车进入下一步。
<img src="./assets/1580820088789.png" alt="1580820088789" /></p>
<p>选择 CSS 预处理器</p>
</li>
<li>
<p>使用 Less 预处理器。回车下一步；
<img src="./assets/1580820147137.png" alt="1580820147137" /></p>
<p>选择代码格式校验风格；</p>
</li>
<li>
<p>这里我们选择 <code>ESLint + Standard config</code> 模式。进入下一步；
<img src="./assets/1580820361235.png" alt="1580820361235" /></p>
<p>选择代码格式校验方式</p>
<p><code>Lint on save</code>：每当代码文件保存的时候进行格式校验。</p>
<p><code>Lint and fix on commit</code>：当执行 git commit 代码提交的时候进行校验和尝试自动修复校验失败的语法格式，如果校验失败并且自动修复也失败，就无法完成代码提交。你需要手动解决了代码格式问题然后重新提交，这样就确保版本历史中的代码一定没有代码格式问题。</p>
</li>
<li>
<p>选择完毕进入下一步；
<img src="./assets/1580820478078.png" alt="1580820478078" /></p>
<p>VueCLI 会在项目中生成一些工具的配置文件。配置文件可以存储在两个地方：</p>
<p><code>In dedicated config files</code>：生成独立的配置文件，推荐，维护方便</p>
<p><code>In package.json</code> 混到 package.json 文件中，不推荐，维护麻烦</p>
<p>这里我们选择第1种，将这些工具的配置文件保存到独立的配置文件中，方便查看和修改。</p>
</li>
<li>
<p>选择完毕进入下一步；
<img src="./assets/1580820544731.png" alt="1580820544731" /></p>
<p>你可以把你刚才那些选择配置项保存为一个模板，下次使用 <code>vue create</code> 创建项目的时候它会提示你是否可以使用这个选择模板直接创建你的项目。</p>
<p>如果你需要，就输入 <code>y</code>，然后它会让你给这个模板起个名字，下次就可以直接使用；</p>
<p>如果不需要，就输入 <code>n</code>，继续下一步。</p>
<p>这里我们不需要，输入 <code>n</code> 继续下一步。</p>
</li>
<li>
<p>进入下一步；开始安装；
<img src="./assets/1580820614618.png" alt="1580820614618" /></p>
</li>
</ol>
<h3 id="项目目录介绍"> 项目目录介绍</h3>
<div><pre><code>│  .browserslistrc 该文件会被 Babel 和 Autoprefix 用来根据浏览器的版本确定需要转译的 JavaScript 特性和 CSS 浏览器前缀
│  .editorconfig 编辑器配置文件，编辑器会根据该文件选择编辑格式
│  .eslintrc.js ESLint配置文件
│  .gitignore Git忽略配置文件
│  babel.config.js Babel转码工具配置文件
│  package-lock.json 包管理工具的锁定文件
│  package.json	包说明文件
│  postcss.config.js	postcss配置文件
│  README.md 说明文档
│  
├─node_modules 第三方包
├─public 公共资源目录
│      favicon.ico
│      index.html
│      
└─src 源码目录
    │  App.vue 根组件
    │  main.js 入口模块
    │  router.js 路由模块
    │  
    ├─assets 静态资源目录
    │      logo.png
    │      
    ├─components 非路由组件目录
    │      HelloWorld.vue
    │      
    └─views 路由组件目录
            About.vue
            Home.vue
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>wepy-cli的使用</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-09/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-09/</guid>
      <source url="https://wangyawei.top/rss.xml">wepy-cli的使用</source>
      <category>vue</category>
      <pubDate>Wed, 11 Aug 2021 23:14:30 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="wepy框架概述"> WePY框架概述</h2>
<blockquote>
<p><strong>WePY</strong> 是腾讯官方出品的一个小程序快速开发框架，对原生小程序的开发模式进行了再次封装，更贴近于 MVVM 架构模式，并支持ES6/7的一些新特性，同时语法风格更接近于 Vue.js，使用 WePY 框架能够提高小程序的开发效率。</p>
</blockquote>
<p>**注意：**WePY 只是小程序的快速开发框架之一，市面上还有诸如 mpvue、taro、uniapp 之类的小程序开发框架也比较流行。</p>
<h2 id="为什么要使用wepy"> 为什么要使用WePY</h2>
<ol>
<li>
<p><strong>WePY</strong> 相比于原生小程序开发，拥有众多的<strong>开发特性</strong>和<strong>优化方案</strong>，例如：</p>
<ul>
<li>
<p>开发风格接近于 Vue.js，支持很多vue中的语法特性；</p>
</li>
<li>
<p>通过 polyfill 让小程序完美支持 Promise；</p>
</li>
<li>
<p>可以使用ES6等诸多高级语法特性，简化代码，提高开发效率；</p>
</li>
<li>
<p>对小程序本身的性能做出了进一步的优化；</p>
</li>
<li>
<p>支持第三方的 npm 资源；</p>
</li>
<li>
<p>支持多种插件处理和编译器；</p>
</li>
<li>
<p>letc…</p>
</li>
</ul>
</li>
</ol>
<h2 id="安装-wepy-框架"> <strong>安装</strong> <strong>WePY</strong> <strong>框架</strong></h2>
<blockquote>
<p>WePY 的安装或更新都通过 npm 进行，全局安装或更新 WePY 命令行工具，可以在终端运行以下命令：</p>
</blockquote>
<div><pre><code><span>npm</span> <span>install</span> wepy-cli -g
</code></pre>
<div><span>1</span><br></div></div><h2 id="初始化-wepy-项目"> 初始化 <strong>WePY</strong> <strong>项目</strong></h2>
<div><pre><code>wepy init standard myproject
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>其中，”wepy init” 是固定写法，代表要初始化 wepy 项目；</p>
<p>”standard” 代表模板类型为标准模板，可以运行 ”wepy list” 命令查看所有可用的项目模板；</p>
<p>”myproject” 为自定义的项目名称。</p>
<p>**注意：**创建项目的时候，要勾选 ESLint 选项！</p>
</blockquote>
<h2 id="wepy项目与小程序项目的关系"> WePY项目与小程序项目的关系</h2>
<blockquote>
<p>通过 wepy init 命令初始化的 wepy 项目，准确来说只是一个模板项目，不能直接当作小程序运行。需要运行相关的命令，<strong>把模板项目编译为小程序项目</strong>，才可以运行。</p>
</blockquote>
<p><img src="./assets/1582021822995.png" alt="1582021822995" /></p>
<h2 id="实时编译wepy项目"> 实时编译WePY项目</h2>
<blockquote>
<p>使用 wepy init 命令初始化项目后，只是得到了一个模板项目，如果想开启实时编译，得到小程序项目，步骤如下：</p>
<p>①运行 cd myproject 切换至 WePY 项目根目录</p>
<p>②运行 npm install 安装 WePY 项目依赖项</p>
<p>③运行 wepy build --watch 开启实时编译</p>
<p><strong>注意：<strong>wepy build --watch 命令，会循环监听 WePY 项目中源代码的变化，自动编译生成小程序项目，生成的小程序项目默认被存放于 dist 目录中</strong>。</strong></p>
</blockquote>
<p><img src="./assets/1582021954024.png" alt="1582021954024" /></p>
<h2 id="加载wepy-项目到微信开发者工具"> 加载<strong>WePY</strong> <strong>项目到微信开发者工具</strong></h2>
<blockquote>
<p>1.7.0 版本之后的 wepy-cli 工具生成的项目根目录下，包含 <strong>project.config.json</strong> 文件，记录了项目的基本配置信息，例如：项目的名称、appId、生成的小程序项目根路径等。</p>
<p>如果项目中存在 <strong>project.config.json</strong> 文件，使用 微信开发者工具 --&gt; 导入项目，”项目目录”请选择 wepy 项目根目录，即可根据 project.config.json 文件中的配置，把 wepy 编译生成的小程序项目加载到微信开发者工具中。</p>
</blockquote>
<h3 id="wpy文件的组成部分"> <code>.wpy</code>文件的组成部分</h3>
<blockquote>
<p>一个 .wpy 文件可分为三大部分，各自对应于一个标签：</p>
<ol>
<li><strong>脚本部分</strong>，即 <script></script> 标签中的内容，又可分为两个部分：</li>
</ol>
<ul>
<li><strong>逻辑部分</strong>，除了 config 对象之外的部分，对应于原生的 .js 文件</li>
<li><strong>配置部分</strong>，即 config 对象，对应于原生的 .json 文件</li>
</ul>
<ol>
<li>
<p><strong>结构部分</strong>，即 <template></template> 模板部分，对应于原生的 .wxml 文件。</p>
</li>
<li>
<p><strong>样式部分</strong>，即<style></style>样式部分，对应于原生的 .wxss 文件。</p>
</li>
</ol>
<p>其中，<strong>小程序入口文件</strong> <strong>app.wpy</strong> <strong>不需要</strong> <strong>template</strong>，所以编译时会被忽略。</p>
</blockquote>
<p><img src="./assets/1582022260306.png" alt="1582022260306" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>组件通信</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-10/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-10/</guid>
      <source url="https://wangyawei.top/rss.xml">组件通信</source>
      <category>vue</category>
      <pubDate>Sat, 21 Aug 2021 23:14:30 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>vue的组件用于组件之间相互传递数据，比如父子组件或兄弟组件的数据传递。</p>
</blockquote>
<p>组件通信常用方式</p>
<ol>
<li>props</li>
<li>eventbus</li>
<li>vuex</li>
<li>自定义事件</li>
<li>边界情况
<ul>
<li>$parent</li>
<li>$children</li>
<li>$root</li>
<li>$refs</li>
<li>provide/inject</li>
</ul>
</li>
<li>非prop特性
<ul>
<li>$attrs</li>
<li>$listeners</li>
</ul>
</li>
</ol>
<h2 id="props"> props</h2>
<blockquote>
<ul>
<li>父给子传值。</li>
<li>父组件传递给子组件的数据是**<code>只读</code><strong>的,即</strong><code>只可以用,不可以改</code>**。</li>
<li>用props完成父组件给子组件传值  传值的属性都是定义在子组件的标签上,可以采用v-bind的形式传递动态值。</li>
<li>在子组件中声明接收的属性。</li>
<li>props是组件的选项 用于定义接收属性</li>
</ul>
</blockquote>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>  
    <span>&lt;!-- 1.定义属性 => 给谁传就在谁的标签上写属性 属性名随便写--></span>  
    <span><span><span>&lt;</span>food-meat</span> <span>:foods</span><span><span>=</span><span>"</span>list<span>"</span></span> <span>a</span><span><span>=</span><span>"</span>1<span>"</span></span> <span>b</span><span><span>=</span><span>"</span>2<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>food-meat</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>  
    <span>var</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>    
        el<span>:</span> <span>"#app"</span><span>,</span>    
        data<span>:</span> <span>{</span>      
            list<span>:</span> <span>[</span><span>"红烧肉"</span><span>,</span> <span>"回锅肉"</span><span>,</span> <span>"四喜丸子"</span><span>,</span> <span>"刀削面"</span><span>]</span>    
        <span>}</span><span>,</span>    
        components<span>:</span> <span>{</span>      
            <span>"food-meat"</span><span>:</span> <span>{</span>        
                <span>//   2 接收属性  props => 字符串/数组        </span>
                template<span>:</span> <span><span>`</span><span>&lt;div>我是饭--{{foods}}{{b}}&lt;button @click="oncl">按钮&lt;/button>&lt;/div></span><span>`</span></span><span>,</span>
                props<span>:</span> <span>[</span><span>"foods"</span><span>,</span> <span>"b"</span><span>]</span><span>,</span>       
                methods<span>:</span> <span>{</span>          
                    <span>oncl</span><span>(</span><span>)</span> <span>{</span>            
                        console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>foods<span>,</span><span>this</span><span>.</span>b<span>,</span><span>this</span><span>.</span>list<span>,</span><span>this</span> <span>instanceof</span> <span>Vue</span><span>)</span>                    
                    <span>}</span><span>,</span>        
                <span>}</span>      
            <span>}</span>    
        <span>}</span>  
    <span>}</span><span>)</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id="eventbus"> eventbus</h2>
<blockquote>
<p>利用发布订阅，进行数据的传递；</p>
</blockquote>
<div><pre><code><span>&lt;!-- child1.vue--></span>
<span><span><span>&lt;</span>template</span><span>></span></span>
    <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>"</span>onClick<span>"</span></span><span>></span></span>我是child1<span><span><span>&lt;/</span>button</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>import</span> eventBus <span>from</span> <span>'../utils/eventBus.js'</span>
<span>export</span> <span>default</span> <span>{</span>
    methods<span>:</span> <span>{</span>
        <span>onClick</span><span>(</span><span>)</span> <span>{</span>
            eventBus<span>.</span><span>$emit</span><span>(</span><span>'child1'</span><span>,</span> <span>'我是child1'</span><span>)</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code><span>&lt;!-- child1.vue--></span>
<span><span><span>&lt;</span>template</span><span>></span></span>
    <span><span><span>&lt;</span>div</span><span>></span></span>我是child2<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>import</span> eventBus <span>from</span> <span>'../utils/eventBus.js'</span>
<span>export</span> <span>default</span> <span>{</span>
    <span>created</span><span>(</span><span>)</span> <span>{</span>
        eventBus<span>.</span><span>$on</span><span>(</span><span>'child1'</span><span>,</span> <span>(</span><span>val</span><span>)</span> <span>=></span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span>val<span>)</span><span>;</span>
        <span>}</span><span>)</span>
    <span>}</span><span>,</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code><span>&lt;!-- index.vue--></span>
<span><span><span>&lt;</span>template</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>child-1</span><span>></span></span><span><span><span>&lt;/</span>child-1</span><span>></span></span>
    <span><span><span>&lt;</span>child-2</span><span>></span></span><span><span><span>&lt;/</span>child-2</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>import</span> child1 <span>from</span> <span>'./child1.vue'</span>
<span>import</span> child2 <span>from</span> <span>'./child2.vue'</span>
<span>export</span> <span>default</span> <span>{</span>
  name<span>:</span> <span>'HelloWorld'</span><span>,</span>
  components<span>:</span> <span>{</span>
    child1<span>,</span>
    child2
  <span>}</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><div><pre><code><span>// eventBus.js</span>
<span>import</span> Vue <span>from</span> <span>'vue'</span><span>;</span>
<span>export</span> <span>default</span> <span>new</span> <span>Vue</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><blockquote>
<p>在<code>index.vue</code>中，引入<code>child1.vue</code>和<code>child2.vue</code>，然后通过eventBus进行数据传递；</p>
</blockquote>
<div><p>提示</p>
<p>要想触发订阅的事件，那么就需要在组件加载时，先完成事件的订阅；</p>
</div>
<h2 id="vuex"> vuex</h2>
<blockquote>
<p>vue的状态管理插件，vue默认不提供这个功能，需要你安装它；</p>
</blockquote>
<div><pre><code><span>// store.js</span>

<span>import</span> Vue <span>from</span> <span>'vue'</span><span>;</span>
<span>import</span> Vuex <span>from</span> <span>'vuex'</span><span>;</span>

Vue<span>.</span><span>use</span><span>(</span>Vuex<span>)</span>

<span>export</span> <span>default</span> <span>new</span> <span>Vuex<span>.</span>Store</span><span>(</span><span>{</span>
    state<span>:</span> <span>{</span>
        text<span>:</span> <span>''</span>
    <span>}</span><span>,</span>
    mutations<span>:</span> <span>{</span>
        <span>saveText</span><span>(</span><span>state<span>,</span> val</span><span>)</span> <span>{</span>
            state<span>.</span>text <span>=</span> val<span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><pre><code><span>&lt;!-- child1.vue--></span>
<span><span><span>&lt;</span>template</span><span>></span></span>
    <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>"</span>onClick<span>"</span></span><span>></span></span>我是child1<span><span><span>&lt;/</span>button</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
    methods<span>:</span> <span>{</span>
        <span>onClick</span><span>(</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span>$store<span>.</span><span>commit</span><span>(</span><span>'saveText'</span><span>,</span> <span>'我是child1'</span><span>)</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span>&lt;!-- child2.vue--></span>
<span><span><span>&lt;</span>template</span><span>></span></span>
    <span><span><span>&lt;</span>div</span><span>></span></span>我是child2
        <span><span><span>&lt;</span>h1</span><span>></span></span>{{ text }}<span><span><span>&lt;/</span>h1</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
    
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
    computed<span>:</span> <span>{</span>
        <span>text</span><span>(</span><span>)</span> <span>{</span>
            <span>return</span> <span>this</span><span>.</span>$store<span>.</span>state<span>.</span>text<span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><blockquote>
<p>我们通过在child1组件中设置，然后把数据保存在vuex，这样我们就可以在child2中直接取处vuex中的数据使用了；</p>
</blockquote>
<h2 id="自定义事件"> 自定义事件</h2>
<blockquote>
<p>这种方式其实就是发布订阅；</p>
</blockquote>
<div><pre><code><span>&lt;!-- child1.vue--></span>
<span><span><span>&lt;</span>template</span><span>></span></span>
    <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>"</span>onClick<span>"</span></span><span>></span></span>我是child1<span><span><span>&lt;/</span>button</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
    methods<span>:</span> <span>{</span>
        <span>onClick</span><span>(</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span><span>$emit</span><span>(</span><span>'child1'</span><span>,</span> <span>'我是child1'</span><span>)</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span>&lt;!-- index.vue--></span>
<span><span><span>&lt;</span>template</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>child-1</span> <span>@child1</span><span><span>=</span><span>"</span>onChild1<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>child-1</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>import</span> child1 <span>from</span> <span>'./child1.vue'</span>
<span>export</span> <span>default</span> <span>{</span>
  components<span>:</span> <span>{</span>
    child1<span>,</span>
  <span>}</span><span>,</span>
  methods<span>:</span> <span>{</span>
    <span>onChild1</span><span>(</span><span>val</span><span>)</span> <span>{</span>
      console<span>.</span><span>log</span><span>(</span>val<span>)</span><span>;</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><blockquote>
<p>通过在child1中发布，然后在index.vue中 child1的组件上订阅这个事件就可以了；</p>
</blockquote>
<h2 id="parent"> $parent</h2>
<blockquote>
<p>可以通过祖辈搭桥来使用发布订阅；</p>
</blockquote>
<div><pre><code><span>&lt;!--child1--></span>
<span><span><span>&lt;</span>template</span><span>></span></span>
    <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>"</span>onClick<span>"</span></span><span>></span></span>我是child1<span><span><span>&lt;/</span>button</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
    methods<span>:</span> <span>{</span>
        <span>onClick</span><span>(</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span>$parent<span>.</span><span>$emit</span><span>(</span><span>'child1'</span><span>,</span> <span>'我是child1'</span><span>)</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><pre><code><span>&lt;!--child2--></span>
<span><span><span>&lt;</span>template</span><span>></span></span>
    <span><span><span>&lt;</span>div</span><span>></span></span>我是child2
        <span><span><span>&lt;</span>h1</span><span>></span></span>{{ text }}<span><span><span>&lt;/</span>h1</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
    
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
    <span>data</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>{</span>
            text<span>:</span> <span>''</span><span>,</span>
        <span>}</span>
    <span>}</span><span>,</span>
    <span>created</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>$parent<span>.</span><span>$on</span><span>(</span><span>'child1'</span><span>,</span> <span>(</span><span>val</span><span>)</span> <span>=></span> <span>{</span>
            <span>this</span><span>.</span>text <span>=</span> val
        <span>}</span> <span>)</span>
    <span>}</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><div><pre><code><span>&lt;!--index--></span>
<span><span><span>&lt;</span>template</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>child-1</span><span>></span></span><span><span><span>&lt;/</span>child-1</span><span>></span></span>
    <span><span><span>&lt;</span>child-2</span><span>></span></span><span><span><span>&lt;/</span>child-2</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>import</span> child1 <span>from</span> <span>'./child1.vue'</span>
<span>import</span> child2 <span>from</span> <span>'./child2.vue'</span>
<span>export</span> <span>default</span> <span>{</span>
  name<span>:</span> <span>'HelloWorld'</span><span>,</span>
  components<span>:</span> <span>{</span>
    child1<span>,</span>
    child2
  <span>}</span><span>,</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="children"> $children</h2>
<blockquote>
<p>父组件可以通过$children访问子组件实现父子通信</p>
</blockquote>
<div><pre><code><span>this</span><span>.</span>$children<span>[</span><span>0</span><span>]</span><span>.</span>xx <span>=</span> <span>'xxx'</span>
</code></pre>
<div><span>1</span><br></div></div><div><p>注意</p>
<p>$children不能保证子元素顺序</p>
</div>
<h2 id="provide-inject"> provide/inject</h2>
<blockquote>
<p>由于vue有$parent属性可以让子组件访问父组件。但孙组件想要访问祖先组件就比较困难。通过provide/inject可以轻松实现跨级访问祖先组件的数据</p>
</blockquote>
<div><pre><code><span>&lt;!--index--></span>
<span><span><span>&lt;</span>template</span><span>></span></span>
  <span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>child-1</span><span>></span></span><span><span><span>&lt;/</span>child-1</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>import</span> child1 <span>from</span> <span>'./child1.vue'</span>
<span>export</span> <span>default</span> <span>{</span>
  components<span>:</span> <span>{</span>
    child1<span>,</span>
  <span>}</span><span>,</span>
  <span>provide</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span> Hello<span>:</span> <span>this</span> <span>}</span>
  <span>}</span><span>,</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      HelloWorld<span>:</span> <span>'HelloWorld'</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><div><pre><code><span>&lt;!--child1 省略 --></span>
<span>&lt;!--child2--></span>
<span><span><span>&lt;</span>template</span><span>></span></span>
    <span><span><span>&lt;</span>div</span><span>></span></span>我是child2
        <span><span><span>&lt;</span>h1</span><span>></span></span>{{ text }}<span><span><span>&lt;/</span>h1</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
    
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
    <span>data</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>{</span>
            text<span>:</span> <span>''</span><span>,</span>
        <span>}</span>
    <span>}</span><span>,</span>
    inject<span>:</span> <span>[</span><span>'Hello'</span><span>]</span><span>,</span>
    <span>created</span><span>(</span><span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>Hello<span>.</span>HelloWorld<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="attrs-listeners"> $attrs/$listeners</h2>
<blockquote>
<p>包含了父作用域中不作为 prop 被识别 (且获取) 的特性绑定 ( class 和 style 除外)。当一个组件没有声明任何 prop 时，这里会包含所有父作用域的绑定 ( class 和 style 除外)，并且可以通过 vbind=&quot;$attrs&quot; 传入内部组件——在创建高级别的组件时非常有用;</p>
</blockquote>
<div><pre><code><span>// child：并未在props中声明foo</span>
<span>&lt;</span>p<span>></span><span>{</span><span>{</span>$attrs<span>.</span>foo<span>}</span><span>}</span><span>&lt;</span><span>/</span>p<span>></span>

<span>// parent</span>
<span>&lt;</span>HelloWorld foo<span>=</span><span>"foo"</span><span>/</span><span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="refs"> refs</h2>
<blockquote>
<p>获取子节点引用</p>
</blockquote>
<div><pre><code><span>// parent</span>
<span>&lt;</span>HelloWorld ref<span>=</span><span>"hw"</span><span>/</span><span>></span>
<span>mounted</span><span>(</span><span>)</span> <span>{</span>
	<span>this</span><span>.</span>$refs<span>.</span>hw<span>.</span>xx <span>=</span> <span>'xxx'</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>vue在实例化之前初始化了什么？</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-100/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-100/</guid>
      <source url="https://wangyawei.top/rss.xml">vue在实例化之前初始化了什么？</source>
      <category>vue</category>
      <pubDate>Sun, 19 Sep 2021 17:53:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>我们知道vue在实例化的时候会做一些初始化工作，但是初始化之前vue也添加了很多的东西，下面就来看一下；</p>
</blockquote>
<p>这是一段来自vue中的代码：</p>
<div><pre><code><span>import</span> <span>{</span> initMixin <span>}</span> <span>from</span> <span>'./init'</span>
<span>import</span> <span>{</span> stateMixin <span>}</span> <span>from</span> <span>'./state'</span>
<span>import</span> <span>{</span> renderMixin <span>}</span> <span>from</span> <span>'./render'</span>
<span>import</span> <span>{</span> eventsMixin <span>}</span> <span>from</span> <span>'./events'</span>
<span>import</span> <span>{</span> lifecycleMixin <span>}</span> <span>from</span> <span>'./lifecycle'</span>
<span>import</span> <span>{</span> warn <span>}</span> <span>from</span> <span>'../util/index'</span>

<span>function</span> <span>Vue</span> <span>(</span><span>options</span><span>)</span> <span>{</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span>
    <span>!</span><span>(</span><span>this</span> <span>instanceof</span> <span>Vue</span><span>)</span>
  <span>)</span> <span>{</span>
    <span>warn</span><span>(</span><span>'Vue is a constructor and should be called with the `new` keyword'</span><span>)</span>
  <span>}</span>
  <span>this</span><span>.</span><span>_init</span><span>(</span>options<span>)</span>
<span>}</span>

<span>initMixin</span><span>(</span>Vue<span>)</span>
<span>stateMixin</span><span>(</span>Vue<span>)</span>
<span>eventsMixin</span><span>(</span>Vue<span>)</span>
<span>lifecycleMixin</span><span>(</span>Vue<span>)</span>
<span>renderMixin</span><span>(</span>Vue<span>)</span>

<span>export</span> <span>default</span> Vue
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><blockquote>
<p>通过以上代码我们可以看出，在实例化vue的时候，又分别调用了5个方法，下面我们就看下这些方法；</p>
</blockquote>
<h2 id="initmixin"> initMixin</h2>
<p>这个函数的调用没有做太多的事情，函数里面的代码都是在实例化vue的时候执行的，</p>
<div><pre><code><span>export</span> <span>function</span> <span>initMixin</span> <span>(</span><span>Vue<span>:</span> Class<span>&lt;</span>Component<span>></span></span><span>)</span> <span>{</span>
  <span>Vue</span><span>.</span>prototype<span>.</span><span>_init</span> <span>=</span> <span>function</span> <span>(</span><span>options<span>?</span><span>:</span> Object</span><span>)</span> <span>{</span>
   <span>...</span>省略
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>
<p>initMixin这个函数只是往vue的原型对象中添加了一个<code>_init</code>方法，具体的细节我们在new Vue()的时候在提起</p>
</blockquote>
<h2 id="statemixin"> stateMixin</h2>
<div><pre><code><span>export</span> <span>function</span> <span>stateMixin</span> <span>(</span><span>Vue<span>:</span> Class<span>&lt;</span>Component<span>></span></span><span>)</span> <span>{</span>
  <span>const</span> dataDef <span>=</span> <span>{</span><span>}</span>
  dataDef<span>.</span><span>get</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span> <span>return</span> <span>this</span><span>.</span>_data <span>}</span>
  <span>const</span> propsDef <span>=</span> <span>{</span><span>}</span>
  propsDef<span>.</span><span>get</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span> <span>return</span> <span>this</span><span>.</span>_props <span>}</span>
  <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
    dataDef<span>.</span><span>set</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>warn</span><span>(</span>
        <span>'Avoid replacing instance root $data. '</span> <span>+</span>
        <span>'Use nested data properties instead.'</span><span>,</span>
        <span>this</span>
      <span>)</span>
    <span>}</span>
    propsDef<span>.</span><span>set</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>warn</span><span>(</span><span><span>`</span><span>$props is readonly.</span><span>`</span></span><span>,</span> <span>this</span><span>)</span>
    <span>}</span>
  <span>}</span>
  Object<span>.</span><span>defineProperty</span><span>(</span><span>Vue</span><span>.</span>prototype<span>,</span> <span>'$data'</span><span>,</span> dataDef<span>)</span>
  Object<span>.</span><span>defineProperty</span><span>(</span><span>Vue</span><span>.</span>prototype<span>,</span> <span>'$props'</span><span>,</span> propsDef<span>)</span>

  <span>Vue</span><span>.</span>prototype<span>.</span>$set <span>=</span> <span>set</span>
  <span>Vue</span><span>.</span>prototype<span>.</span>$<span>delete</span> <span>=</span> del

  <span>Vue</span><span>.</span>prototype<span>.</span><span>$watch</span> <span>=</span> <span>function</span> <span>(</span>
    <span>expOrFn<span>:</span> string <span>|</span> Function<span>,</span>
    cb<span>:</span> any<span>,</span>
    options<span>?</span><span>:</span> Object</span>
  <span>)</span><span>:</span> Function <span>{</span>
   <span>...</span>省略
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><blockquote>
<p>通过以上代码我们可以看出，vue往原型对象上又分别加入了<code>$data、$props</code>只读属性和全局方法<code>($set、$delete、$watch)</code></p>
</blockquote>
<h2 id="eventsmixin"> eventsMixin</h2>
<div><pre><code><span>export</span> <span>function</span> <span>eventsMixin</span> <span>(</span><span>Vue<span>:</span> Class<span>&lt;</span>Component<span>></span></span><span>)</span> <span>{</span>
  <span>Vue</span><span>.</span>prototype<span>.</span><span>$on</span> <span>=</span> <span>function</span> <span>(</span><span>event<span>:</span> string <span>|</span> Array<span>&lt;</span>string<span>></span><span>,</span> fn<span>:</span> Function</span><span>)</span><span>:</span> Component <span>{</span><span>...</span>省略<span>}</span>

  <span>Vue</span><span>.</span>prototype<span>.</span><span>$once</span> <span>=</span> <span>function</span> <span>(</span><span>event<span>:</span> string<span>,</span> fn<span>:</span> Function</span><span>)</span><span>:</span> Component <span>{</span><span>...</span>省略<span>}</span>

  <span>Vue</span><span>.</span>prototype<span>.</span><span>$off</span> <span>=</span> <span>function</span> <span>(</span><span>event<span>?</span><span>:</span> string <span>|</span> Array<span>&lt;</span>string<span>></span><span>,</span> fn<span>?</span><span>:</span> Function</span><span>)</span><span>:</span> Component <span>{</span><span>...</span>省略<span>}</span>

  <span>Vue</span><span>.</span>prototype<span>.</span><span>$emit</span> <span>=</span> <span>function</span> <span>(</span><span>event<span>:</span> string</span><span>)</span><span>:</span> Component <span>{</span><span>...</span>省略<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>
<p>通过以上代码我们可以看出，vue往原型对象上又分别加入了<code>$on、$once、$off、$emit</code>用于发布订阅</p>
</blockquote>
<h2 id="lifecyclemixin"> lifecycleMixin</h2>
<div><pre><code><span>export</span> <span>function</span> <span>lifecycleMixin</span> <span>(</span><span>Vue<span>:</span> Class<span>&lt;</span>Component<span>></span></span><span>)</span> <span>{</span>
  <span>Vue</span><span>.</span>prototype<span>.</span><span>_update</span> <span>=</span> <span>function</span> <span>(</span><span>vnode<span>:</span> VNode<span>,</span> hydrating<span>?</span><span>:</span> boolean</span><span>)</span> <span>{</span><span>...</span>省略<span>}</span>

  <span>Vue</span><span>.</span>prototype<span>.</span><span>$forceUpdate</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span><span>...</span>省略<span>}</span>

  <span>Vue</span><span>.</span>prototype<span>.</span><span>$destroy</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span><span>...</span>省略<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>
<p>我们最常提到的生命周期就是在这里初始化的，但是这里只有三个；</p>
</blockquote>
<h2 id="rendermixin"> renderMixin</h2>
<div><pre><code><span>export</span> <span>function</span> <span>renderMixin</span> <span>(</span><span>Vue<span>:</span> Class<span>&lt;</span>Component<span>></span></span><span>)</span> <span>{</span>

  <span>Vue</span><span>.</span>prototype<span>.</span><span>$nextTick</span> <span>=</span> <span>function</span> <span>(</span><span>fn<span>:</span> Function</span><span>)</span> <span>{</span>
    <span>return</span> <span>nextTick</span><span>(</span>fn<span>,</span> <span>this</span><span>)</span>
  <span>}</span>

  <span>Vue</span><span>.</span>prototype<span>.</span><span>_render</span> <span>=</span> <span>function</span> <span>(</span><span>)</span><span>:</span> VNode <span>{</span><span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p>这里挂载了一个比较重要的一个东西<code>$nextTick</code>.</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>插槽</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-11/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-11/</guid>
      <source url="https://wangyawei.top/rss.xml">插槽</source>
      <category>vue</category>
      <pubDate>Sat, 21 Aug 2021 23:14:30 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>插槽语法是Vue 实现的内容分发 API，用于复合组件开发。该技术在通用组件库开发中有大量应用。</p>
</blockquote>
<h2 id="匿名插槽"> 匿名插槽</h2>
<div><pre><code><span>// comp1</span>
<span>&lt;</span>div<span>></span>
	<span>&lt;</span>slot<span>></span><span>&lt;</span><span>/</span>slot<span>></span>
<span>&lt;</span><span>/</span>div<span>></span>

<span>// parent</span>
<span>&lt;</span>comp<span>></span>hello<span>&lt;</span><span>/</span>comp<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="具名插槽"> 具名插槽</h2>
<div><pre><code><span>// comp2</span>
<span>&lt;</span>div<span>></span>
	<span>&lt;</span>slot<span>></span><span>&lt;</span><span>/</span>slot<span>></span>
	<span>&lt;</span>slot name<span>=</span><span>"content"</span><span>></span><span>&lt;</span><span>/</span>slot<span>></span>
<span>&lt;</span><span>/</span>div<span>></span>

<span>// parent</span>
<span>&lt;</span>Comp2<span>></span>
	<span>&lt;</span><span>!</span><span>--</span> 默认插槽用<span>default</span>做参数 <span>--</span><span>></span>
	<span>&lt;</span>template v<span>-</span>slot<span>:</span><span>default</span><span>></span>具名插槽<span>&lt;</span><span>/</span>template<span>></span>
	<span>&lt;</span><span>!</span><span>--</span> 具名插槽用插槽名做参数 <span>--</span><span>></span>
	<span>&lt;</span>template v<span>-</span>slot<span>:</span>content<span>></span>内容<span>...</span><span>&lt;</span><span>/</span>template<span>></span>
<span>&lt;</span><span>/</span>Comp2<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="作用域插槽"> 作用域插槽</h2>
<blockquote>
<p>分发内容到要用到子组件中的数据</p>
</blockquote>
<div><pre><code><span>// comp3</span>
<span>&lt;</span>div<span>></span>
	<span>&lt;</span>slot <span>:</span>foo<span>=</span><span>"foo"</span><span>></span><span>&lt;</span><span>/</span>slot<span>></span>
<span>&lt;</span><span>/</span>div<span>></span>

<span>// parent</span>
<span>&lt;</span>Comp3<span>></span>
	<span>&lt;</span><span>!</span><span>--</span> 把v<span>-</span>slot的值指定为作用域上下文对象 <span>--</span><span>></span>
	<span>&lt;</span>template v<span>-</span>slot<span>:</span><span>default</span><span>=</span><span>"slotProps"</span><span>></span>
	来自子组件数据：<span>{</span><span>{</span>slotProps<span>.</span>foo<span>}</span><span>}</span>
	<span>&lt;</span><span>/</span>template<span>></span>
<span>&lt;</span><span>/</span>Comp3<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>vue-router源码实现1</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-12/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-12/</guid>
      <source url="https://wangyawei.top/rss.xml">vue-router源码实现1</source>
      <category>vue</category>
      <pubDate>Sat, 28 Aug 2021 19:55:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Vue Router 是 <a href="http://cn.vuejs.org/" target="_blank" rel="noopener noreferrer">Vue.js (opens new window)</a>官方的路由管理器。它和 Vue.js 的核心深度集成，让构建单页面应用变得易如反掌。</p>
</blockquote>
<p>包含的功能有：</p>
<ul>
<li>嵌套的路由/视图表</li>
<li>模块化的、基于组件的路由配置</li>
<li>路由参数、查询、通配符</li>
<li>基于 Vue.js 过渡系统的视图过渡效果</li>
<li>细粒度的导航控制</li>
<li>带有自动激活的 CSS class 的链接</li>
<li>HTML5 历史模式或 hash 模式，在 IE9 中自动降级</li>
<li>自定义的滚动条行为</li>
</ul>
<h2 id="基本使用"> 基本使用</h2>
<ul>
<li>
<p>安装：</p>
<div><pre><code>vue <span>add</span> router
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>使用vue-router插件，router.js</p>
<div><pre><code><span>import</span> Router <span>from</span> <span>'vue-router'</span>
Vue<span>.</span><span>use</span><span>(</span>Router<span>)</span>

<span>// 创建Router实例 并导出</span>
<span>export</span> <span>default</span> <span>new</span> <span>Router</span><span>(</span><span>{</span><span>...</span><span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>在根组件上添加该实例，main.js</p>
<div><pre><code><span>import</span> router <span>from</span> <span>'./router'</span>
<span>new</span> <span>Vue</span><span>(</span><span>{</span>
	router<span>,</span>
<span>}</span><span>)</span><span>.</span><span>$mount</span><span>(</span><span>"#app"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>添加路由视图，App.vue</p>
<div><pre><code><span><span><span>&lt;</span>router-view</span><span>></span></span><span><span><span>&lt;/</span>router-view</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>导航</p>
<div><pre><code><span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/<span>"</span></span><span>></span></span>Home<span><span><span>&lt;/</span>router-link</span><span>></span></span>
<span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/about<span>"</span></span><span>></span></span>About<span><span><span>&lt;/</span>router-link</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
<h2 id="源码实现"> 源码实现</h2>
<blockquote>
<p>要做的事情就是防着vue-router官方的路由，写一个简单的自己的路由；</p>
</blockquote>
<p>分析：</p>
<ul>
<li>根据官方路由的使用和配置，我们需要实现一个插件；</li>
<li>它可以监听<code>#</code>后面值的变化，然后匹配不同的组件从而显示不同的页面；</li>
<li>需要考虑嵌套路由；</li>
<li>需要实现<code>&lt;router-view&gt;&lt;/router-view&gt;</code>和<code>&lt;router-link&gt;&lt;/router-link&gt;</code>组件；</li>
</ul>
<h2 id="vue-router"> vue-router</h2>
<blockquote>
<p>创建一个vue-router类并导出；</p>
</blockquote>
<div><pre><code><span>class</span> <span>Router</span> <span>{</span>
    <span>constructor</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>$options <span>=</span> options<span>;</span>
    <span>}</span>

    <span>// vue默认会执行这个Install方法</span>
    <span>static</span> <span>install</span> <span>(</span><span>Vue</span><span>)</span> <span>{</span>
        Vue<span>.</span><span>mixin</span><span>(</span><span>{</span>
            <span>beforeCreate</span><span>(</span><span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>$options<span>)</span>
                <span>// 只有vue根示例有 router 选项；</span>
                <span>if</span> <span>(</span><span>this</span><span>.</span>$options<span>.</span>router<span>)</span> <span>{</span>
                    <span>// 把vue根示例的选项挂载到vue的原型上；</span>
                    <span>Vue</span><span>.</span>prototype<span>.</span>$router <span>=</span> <span>this</span><span>.</span>$options<span>.</span>router
                <span>}</span>
            <span>}</span>
        <span>}</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>export</span> <span>default</span> Router
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="创建router-link"> 创建router-link</h2>
<blockquote>
<p>实现全局组件router-link，用来导航。</p>
</blockquote>
<div><pre><code><span>// vue默认会执行这个Install方法</span>
<span>static</span> <span>install</span> <span>(</span><span>Vue</span><span>)</span> <span>{</span>
   <span>...</span>省略
    <span>// 创建&lt;router-link>全局组件</span>
    <span>// 注意这里不可以使用template选项，因为没有编译器</span>
    Vue<span>.</span><span>component</span><span>(</span><span>'router-link'</span><span>,</span> <span>{</span>
        props<span>:</span> <span>{</span>
            to<span>:</span> <span>{</span><span>}</span>
        <span>}</span><span>,</span>
        <span>render</span><span>(</span><span>createElement</span><span>)</span> <span>{</span>
            <span>return</span> <span>createElement</span><span>(</span><span>'a'</span><span>,</span> <span>{</span>
                attrs<span>:</span> <span>{</span>
                    href<span>:</span> <span><span>`</span><span>#/</span><span><span>${</span><span>this</span><span>.</span>to<span>}</span></span><span>`</span></span><span>,</span>
                <span>}</span><span>,</span>
            <span>}</span><span>,</span> <span>this</span><span>.</span>$slots<span>.</span>default<span>,</span><span>)</span>
        <span>}</span>
    <span>}</span><span>)</span>
<span>}</span>

<span>// 使用</span>
<span>&lt;</span>router<span>-</span>link to<span>=</span><span>"/about"</span><span>></span><span>&lt;</span><span>/</span>router<span>-</span>link<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="创建router-view"> 创建router-view</h2>
<blockquote>
<p>实现全局组件router-view，用作容器书写子路由。</p>
</blockquote>
<div><pre><code><span>// vue默认会执行这个Install方法</span>
<span>static</span> <span>install</span> <span>(</span><span>Vue</span><span>)</span> <span>{</span>
   <span>...</span>省略
   <span>// 创建&lt;router-view>全局组件</span>
   Vue<span>.</span><span>component</span><span>(</span><span>'router-view'</span><span>,</span> <span>{</span>
       <span>render</span><span>(</span><span>createElement</span><span>)</span> <span>{</span>
           <span>return</span> <span>createElement</span><span>(</span><span>'div'</span><span>,</span> <span>'123'</span><span>)</span>
       <span>}</span>
   <span>}</span><span>)</span>
<span>}</span>

<span>// 使用</span>
<span>&lt;</span>router<span>-</span>view<span>></span><span>&lt;</span><span>/</span>router<span>-</span>view<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="监听路由变化"> 监听路由变化</h2>
<blockquote>
<p>前面实现的内容目前达不到切换路由匹配不同组件的能力，接下载就是监听路由更新组件；</p>
</blockquote>
<div><pre><code>
<span>class</span> <span>Router</span> <span>{</span>
    <span>constructor</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>$options <span>=</span> options<span>;</span>

        <span>this</span><span>.</span>currentRouter <span>=</span> <span>'/'</span><span>;</span>

        <span>// 监听路由的变化</span>
        window<span>.</span><span>addEventListener</span><span>(</span><span>'hashchange'</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
            <span>this</span><span>.</span>currentRouter <span>=</span> window<span>.</span>location<span>.</span>hash<span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span>
        <span>}</span><span>)</span>
    <span>}</span>

	<span>...</span> 省略
    <span>// 创建&lt;router-view>全局组件</span>
    Vue<span>.</span><span>component</span><span>(</span><span>'router-view'</span><span>,</span> <span>{</span>
        <span>render</span><span>(</span><span>createElement</span><span>)</span> <span>{</span>
            <span>let</span> component <span>=</span> <span>null</span><span>;</span>
            <span>// 查找当前的路由并获取组件</span>
            <span>this</span><span>.</span>$router<span>.</span>$options<span>.</span>routers<span>.</span><span>forEach</span><span>(</span><span>(</span><span>router</span><span>)</span> <span>=></span> <span>{</span>
                <span>if</span> <span>(</span>router<span>.</span>path <span>===</span> <span>this</span><span>.</span>$router<span>.</span>currentRouter<span>)</span> <span>{</span>
                    component <span>=</span> router<span>.</span>component
                <span>}</span>
            <span>}</span><span>)</span>
            <span>return</span> <span>createElement</span><span>(</span>component<span>)</span>
        <span>}</span>
    <span>}</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>export</span> <span>default</span> Router
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><blockquote>
<p>以上代码就可以在哈希路由变化的时候，匹配不同的组件；</p>
</blockquote>
<p>::: wanging</p>
<p>但是还有一个问题就是，路由变化了，但是render函数没有重新执行;这里需要考虑响应式；</p>
<p>:::</p>
<h2 id="实时渲染"> 实时渲染</h2>
<blockquote>
<p>这里做的目的就是，当匹配到路由变化时，重新执行render函数，达到重新渲染的目的；</p>
</blockquote>
<div><pre><code>
<span>let</span> Vue<span>;</span>

<span>class</span> <span>Router</span> <span>{</span>
    <span>constructor</span><span>(</span><span>options</span><span>)</span> <span>{</span>

        <span>this</span><span>.</span>currentRouter <span>=</span> <span>'/'</span><span>;</span>
        <span>// 响应式 currentRouter</span>
        Vue<span>.</span>util<span>.</span><span>defineReactive</span><span>(</span><span>this</span><span>,</span> <span>'currentRouter'</span><span>,</span> <span>'/'</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>export</span> <span>default</span> Router

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="解决刷新视图消失"> 解决刷新视图消失</h2>
<div><pre><code>
<span>let</span> Vue<span>;</span>

<span>class</span> <span>Router</span> <span>{</span>
    <span>constructor</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>$options <span>=</span> options<span>;</span>

        <span>this</span><span>.</span>currentRouter <span>=</span> <span>'/'</span><span>;</span>

        <span>// 响应式 currentRouter</span>
        Vue<span>.</span>util<span>.</span><span>defineReactive</span><span>(</span><span>this</span><span>,</span> <span>'currentRouter'</span><span>,</span> <span>'/'</span><span>)</span><span>;</span>

        <span>// 监听路由的变化</span>
        window<span>.</span><span>addEventListener</span><span>(</span><span>'hashchange'</span><span>,</span> <span>this</span><span>.</span><span>onhashchange</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>)</span>

        <span>// 解决刷新时，不渲染render的问题；</span>
        window<span>.</span><span>addEventListener</span><span>(</span><span>'load'</span><span>,</span> <span>this</span><span>.</span><span>onhashchange</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>)</span>
    <span>}</span>

    <span>onhashchange</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>currentRouter <span>=</span> window<span>.</span>location<span>.</span>hash<span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>export</span> <span>default</span> Router
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id="完整代码"> 完整代码</h2>
<div><pre><code>
<span>let</span> Vue<span>;</span>

<span>class</span> <span>Router</span> <span>{</span>
    <span>constructor</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>$options <span>=</span> options<span>;</span>

        <span>this</span><span>.</span>currentRouter <span>=</span> <span>'/'</span><span>;</span>

        <span>// 响应式 currentRouter</span>
        Vue<span>.</span>util<span>.</span><span>defineReactive</span><span>(</span><span>this</span><span>,</span> <span>'currentRouter'</span><span>,</span> <span>'/'</span><span>)</span><span>;</span>

        <span>// 监听路由的变化</span>
        window<span>.</span><span>addEventListener</span><span>(</span><span>'hashchange'</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
            <span>this</span><span>.</span>currentRouter <span>=</span> window<span>.</span>location<span>.</span>hash<span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span>
        <span>}</span><span>)</span>
    <span>}</span>

    <span>// vue默认会执行这个Install方法</span>
    <span>static</span> <span>install</span> <span>(</span><span>_Vue</span><span>)</span> <span>{</span>
        Vue <span>=</span> _Vue
        Vue<span>.</span><span>mixin</span><span>(</span><span>{</span>
            <span>beforeCreate</span><span>(</span><span>)</span> <span>{</span>
                <span>// 只有vue根示例有 router 选项；</span>
                <span>if</span> <span>(</span><span>this</span><span>.</span>$options<span>.</span>router<span>)</span> <span>{</span>
                    <span>Vue</span><span>.</span>prototype<span>.</span>$router <span>=</span> <span>this</span><span>.</span>$options<span>.</span>router
                <span>}</span>
            <span>}</span>
        <span>}</span><span>)</span>

        <span>// 创建&lt;router-link>全局组件</span>
        <span>// 注意这里不可以使用template选项，因为没有编译器</span>
        Vue<span>.</span><span>component</span><span>(</span><span>'router-link'</span><span>,</span> <span>{</span>
            props<span>:</span> <span>{</span>
                to<span>:</span> <span>{</span><span>}</span>
            <span>}</span><span>,</span>
            <span>render</span><span>(</span><span>createElement</span><span>)</span> <span>{</span>
                <span>return</span> <span>createElement</span><span>(</span><span>'a'</span><span>,</span> <span>{</span>
                    attrs<span>:</span> <span>{</span>
                        href<span>:</span> <span><span>`</span><span>#</span><span><span>${</span><span>this</span><span>.</span>to<span>}</span></span><span>`</span></span><span>,</span>
                    <span>}</span><span>,</span>
                <span>}</span><span>,</span> <span>this</span><span>.</span>$slots<span>.</span>default<span>,</span><span>)</span>
            <span>}</span>
        <span>}</span><span>)</span>

        <span>// 创建&lt;router-view>全局组件</span>
        Vue<span>.</span><span>component</span><span>(</span><span>'router-view'</span><span>,</span> <span>{</span>
            <span>render</span><span>(</span><span>createElement</span><span>)</span> <span>{</span>
                <span>let</span> component <span>=</span> <span>null</span><span>;</span>
                <span>this</span><span>.</span>$router<span>.</span>$options<span>.</span>routers<span>.</span><span>forEach</span><span>(</span><span>(</span><span>router</span><span>)</span> <span>=></span> <span>{</span>
                    <span>if</span> <span>(</span>router<span>.</span>path <span>===</span> <span>this</span><span>.</span>$router<span>.</span>currentRouter<span>)</span> <span>{</span>
                        component <span>=</span> router<span>.</span>component
                    <span>}</span>
                <span>}</span><span>)</span>
                <span>return</span> <span>createElement</span><span>(</span>component<span>)</span>
            <span>}</span>
        <span>}</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>export</span> <span>default</span> Router

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div><blockquote>
<p>好了，至此router的初始版本就这样了，目的也是用于学习，所有实现一个简单的router;</p>
</blockquote>
<div><p>提示</p>
<p>使用方式和官方的 <code>vue-router</code>一样，不过这里只是实现了路由和容器，有很多细节并没有考虑，比如嵌套路由；</p>
</div>
<h2 id="嵌套路由"> 嵌套路由</h2>
]]></content:encoded>
    </item>
    <item>
      <title>vue-router源码实现2</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-13/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-13/</guid>
      <source url="https://wangyawei.top/rss.xml">vue-router源码实现2</source>
      <category>vue</category>
      <pubDate>Sun, 29 Aug 2021 18:38:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本篇承接上篇，在上一节中我们简单实现了一个vue路由，但是，还有一些细节需要处理，不过我这里只想整理下上节中的代码和实现嵌套路由；</p>
</blockquote>
<h2 id="提取link和view"> 提取<code>link</code>和<code>view</code></h2>
<div><pre><code><span>// router-link</span>
<span>export</span> <span>default</span> <span>{</span>
    props<span>:</span> <span>{</span>
        to<span>:</span> <span>{</span><span>}</span>
    <span>}</span><span>,</span>
    <span>render</span><span>(</span><span>createElement</span><span>)</span> <span>{</span>
        <span>return</span> <span>createElement</span><span>(</span><span>'a'</span><span>,</span> <span>{</span>
            attrs<span>:</span> <span>{</span>
                href<span>:</span> <span><span>`</span><span>#</span><span><span>${</span><span>this</span><span>.</span>to<span>}</span></span><span>`</span></span><span>,</span>
            <span>}</span><span>,</span>
        <span>}</span><span>,</span> <span>this</span><span>.</span>$slots<span>.</span>default<span>)</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>// router-view</span>
<span>export</span> <span>default</span> <span>{</span>
    <span>render</span><span>(</span><span>createElement</span><span>)</span> <span>{</span>
        <span>let</span> component <span>=</span> <span>null</span><span>;</span>
        <span>this</span><span>.</span>$router<span>.</span>$options<span>.</span>routers<span>.</span><span>forEach</span><span>(</span><span>(</span><span>router</span><span>)</span> <span>=></span> <span>{</span>
            <span>if</span> <span>(</span>router<span>.</span>path <span>===</span> <span>this</span><span>.</span>$router<span>.</span>currentRouter<span>)</span> <span>{</span>
                component <span>=</span> router<span>.</span>component
            <span>}</span>
        <span>}</span><span>)</span>
        <span>return</span> <span>createElement</span><span>(</span>component<span>)</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>import</span> View <span>from</span> <span>'./components/View'</span><span>;</span>
<span>import</span> Link <span>from</span> <span>'./components/Link'</span><span>;</span>

<span>// 使用</span>
Vue<span>.</span><span>component</span><span>(</span><span>'router-link'</span><span>,</span> Link<span>)</span>
Vue<span>.</span><span>component</span><span>(</span><span>'router-view'</span><span>,</span> View<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h2 id="路由记录"> 路由记录</h2>
<blockquote>
<p>我们的目的是实现嵌套路由，那么需要知道路由的层级记录，也就是说需要记录匹配到的每一层的路由，所以我们需要把它们保存起来；</p>
</blockquote>
<p>index.js修改如下：</p>
<div><pre><code><span>import</span> View <span>from</span> <span>'./components/View'</span><span>;</span>
<span>import</span> Link <span>from</span> <span>'./components/Link'</span><span>;</span>

<span>let</span> Vue<span>;</span>

<span>class</span> <span>Router</span> <span>{</span>
    <span>constructor</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>$options <span>=</span> options<span>;</span>
<span>+</span>        <span>this</span><span>.</span>currentRouter <span>=</span> window<span>.</span>location<span>.</span>hash<span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span> <span>||</span> <span>'/'</span><span>;</span>
         <span>// 保存路由记录 </span>
<span>+</span>        <span>this</span><span>.</span>matched <span>=</span> <span>[</span><span>]</span><span>;</span>
        <span>// 响应式 currentRouter</span>
<span>+</span>        Vue<span>.</span>util<span>.</span><span>defineReactive</span><span>(</span><span>this</span><span>,</span> <span>'matched'</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>

        <span>// 监听路由的变化</span>
        window<span>.</span><span>addEventListener</span><span>(</span><span>'hashchange'</span><span>,</span> <span>this</span><span>.</span><span>onhashchange</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>)</span>

        <span>// 解决刷新时，不渲染render的问题；</span>
        window<span>.</span><span>addEventListener</span><span>(</span><span>'load'</span><span>,</span> <span>this</span><span>.</span><span>onhashchange</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>)</span>
    <span>}</span>
    
    <span>...</span>省略以下部分
<span>}</span>

<span>export</span> <span>default</span> Router
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h2 id="遍历路由"> 遍历路由</h2>
<blockquote>
<p>我们需要根据当前的浏览器url来匹配routes中的全部路由，并保存到 matched中；</p>
</blockquote>
<p>index.js修改如下：</p>
<div><pre><code>
<span>import</span> View <span>from</span> <span>'./components/View'</span><span>;</span>
<span>import</span> Link <span>from</span> <span>'./components/Link'</span><span>;</span>

<span>let</span> Vue<span>;</span>

<span>class</span> <span>Router</span> <span>{</span>
    <span>constructor</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>$options <span>=</span> options<span>;</span>
        <span>this</span><span>.</span>currentRouter <span>=</span> window<span>.</span>location<span>.</span>hash<span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span> <span>||</span> <span>'/'</span><span>;</span>
        <span>this</span><span>.</span>matched <span>=</span> <span>[</span><span>]</span><span>;</span>
        <span>this</span><span>.</span><span>match</span><span>(</span><span>)</span><span>;</span>
        <span>// 响应式 currentRouter</span>
        Vue<span>.</span>util<span>.</span><span>defineReactive</span><span>(</span><span>this</span><span>,</span> <span>'matched'</span><span>,</span> <span>[</span><span>]</span><span>)</span><span>;</span>

        <span>// 监听路由的变化</span>
        window<span>.</span><span>addEventListener</span><span>(</span><span>'hashchange'</span><span>,</span> <span>this</span><span>.</span><span>onhashchange</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>)</span>

        <span>// 解决刷新时，不渲染render的问题；</span>
        window<span>.</span><span>addEventListener</span><span>(</span><span>'load'</span><span>,</span> <span>this</span><span>.</span><span>onhashchange</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>)</span>
    <span>}</span>

    <span>onhashchange</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>currentRouter <span>=</span> window<span>.</span>location<span>.</span>hash<span>.</span><span>slice</span><span>(</span><span>1</span><span>)</span>
        <span>// 当前路由改变时清空，然后重新匹配；</span>
        <span>this</span><span>.</span>matched <span>=</span> <span>[</span><span>]</span><span>;</span>
        <span>this</span><span>.</span><span>match</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>// 添加路由记录</span>
    <span>addRouteRecord</span><span>(</span><span>pathList<span>,</span> pathMap<span>,</span> route<span>,</span> parent</span><span>)</span> <span>{</span>
        <span>const</span> <span>{</span> path <span>}</span> <span>=</span> route<span>;</span>
        <span>const</span> normalizedPath <span>=</span> <span>this</span><span>.</span><span>normalizePath</span><span>(</span>path<span>,</span> parent<span>)</span>
        <span>const</span> record <span>=</span> <span>{</span>
            path<span>:</span> normalizedPath<span>,</span>
            component<span>:</span> route<span>.</span>component<span>,</span>
            parent<span>,</span>
        <span>}</span>
        <span>if</span> <span>(</span>
            <span>!</span>pathMap<span>[</span>record<span>.</span>path<span>]</span>
            <span>&amp;&amp;</span> <span>this</span><span>.</span>currentRouter<span>.</span><span>includes</span><span>(</span>path<span>)</span>
            <span>&amp;&amp;</span> <span>this</span><span>.</span>currentRouter <span>!==</span> <span>'/'</span>
            <span>&amp;&amp;</span> path <span>!==</span> <span>'/'</span>
        <span>)</span> <span>{</span>
            pathList<span>.</span><span>push</span><span>(</span>record<span>)</span>
            pathMap<span>[</span>record<span>.</span>path<span>]</span> <span>=</span> record
        <span>}</span>
        <span>// 递归子路由</span>
        <span>if</span> <span>(</span>route<span>.</span>children<span>)</span> <span>{</span>
            route<span>.</span>children<span>.</span><span>forEach</span><span>(</span><span>child</span> <span>=></span> <span>{</span>
                <span>this</span><span>.</span><span>addRouteRecord</span><span>(</span>pathList<span>,</span> pathMap<span>,</span> child<span>,</span> record<span>)</span>
            <span>}</span><span>)</span>
        <span>}</span>
    <span>}</span>

    <span>normalizePath</span><span>(</span><span>path<span>,</span> parent</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>path<span>[</span><span>0</span><span>]</span> <span>===</span> <span>'/'</span><span>)</span> <span>return</span> path
        <span>if</span> <span>(</span>parent <span>==</span> <span>null</span><span>)</span> <span>return</span> path
        <span>return</span> <span><span>`</span><span><span>${</span>parent<span>.</span>path<span>}</span></span><span>/</span><span><span>${</span>path<span>}</span></span><span>`</span></span><span>.</span><span>replace</span><span>(</span><span><span>/</span><span>\/\/</span><span>/</span><span>g</span></span><span>,</span> <span>'/'</span><span>)</span>
    <span>}</span>

    <span>match</span><span>(</span><span>routes<span>,</span> oldPathList<span>,</span> oldPathMap<span>,</span> parentRoute</span><span>)</span> <span>{</span>
        routes <span>=</span> <span>this</span><span>.</span>$options<span>.</span>routes <span>||</span> <span>[</span><span>]</span><span>;</span>
        <span>const</span> pathList <span>=</span> oldPathList <span>||</span> <span>[</span><span>]</span><span>;</span>
        <span>const</span> pathMap <span>=</span> oldPathMap <span>||</span> Object<span>.</span><span>create</span><span>(</span><span>null</span><span>)</span>

        routes<span>.</span><span>forEach</span><span>(</span><span>route</span> <span>=></span> <span>{</span>
            <span>this</span><span>.</span><span>addRouteRecord</span><span>(</span>pathList<span>,</span> pathMap<span>,</span> route<span>,</span> parentRoute<span>)</span>
        <span>}</span><span>)</span>
        <span>// 保存匹配的路由记录</span>
        <span>this</span><span>.</span>matched <span>=</span> pathList
    <span>}</span>
<span>}</span>

<span>export</span> <span>default</span> Router
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br></div></div><h2 id="标记view"> 标记view</h2>
<blockquote>
<p>上节中的代码不支持路由嵌套的，如果你尝试的话，它会报出栈溢出错误；因为子路由会始终匹配父路由，最终导致栈溢出。解决办法就是，我们标记view组件，然后匹配对应的子路由；</p>
</blockquote>
<p>View.js修改如下：</p>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
    <span>render</span><span>(</span><span>createElement</span><span>)</span> <span>{</span>
        <span>// 标记view组件,用于判断是否为 view 组件；</span>
        <span>this</span><span>.</span>$vnode<span>.</span>data<span>.</span>routerView <span>=</span> <span>true</span><span>;</span>

        <span>// 标记深度；嵌套几层</span>
        <span>let</span> depth <span>=</span> <span>0</span><span>;</span>
        <span>let</span> parent <span>=</span> <span>this</span><span>.</span>$parent<span>;</span>
        <span>while</span> <span>(</span>parent<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>parent<span>.</span>$vnode <span>&amp;&amp;</span> parent<span>.</span>$vnode<span>.</span>data <span>&amp;&amp;</span> parent<span>.</span>$vnode<span>.</span>data<span>.</span>routerView<span>)</span> <span>{</span>
                depth<span>++</span><span>;</span>
            <span>}</span>
            parent <span>=</span> parent<span>.</span>$parent<span>;</span>
        <span>}</span>

        <span>let</span> component <span>=</span> <span>null</span><span>;</span>
        <span>const</span> route <span>=</span> <span>this</span><span>.</span>$router<span>.</span>matched<span>[</span>depth<span>]</span><span>;</span>
        <span>if</span> <span>(</span>route<span>)</span> <span>{</span>
            component <span>=</span> route<span>.</span>component<span>;</span>
        <span>}</span>
        <span>return</span> <span>createElement</span><span>(</span>component<span>)</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="解决-无法匹配"> 解决 <code>/</code>无法匹配；</h2>
<p>index.js修改如下：</p>
<div><pre><code>
<span>import</span> View <span>from</span> <span>'./components/View'</span><span>;</span>
<span>import</span> Link <span>from</span> <span>'./components/Link'</span><span>;</span>

<span>let</span> Vue<span>;</span>

<span>class</span> <span>Router</span> <span>{</span>
	<span>...</span>省略
    <span>addRouteRecord</span><span>(</span><span>pathList<span>,</span> pathMap<span>,</span> route<span>,</span> parent</span><span>)</span> <span>{</span>
        <span>const</span> <span>{</span> path <span>}</span> <span>=</span> route<span>;</span>
        <span>const</span> normalizedPath <span>=</span> <span>this</span><span>.</span><span>normalizePath</span><span>(</span>path<span>,</span> parent<span>)</span>
        <span>const</span> record <span>=</span> <span>{</span>
            path<span>:</span> normalizedPath<span>,</span>
            component<span>:</span> route<span>.</span>component<span>,</span>
            parent<span>,</span>
        <span>}</span>
<span>+</span>        <span>if</span> <span>(</span>path <span>===</span> <span>'/'</span> <span>&amp;&amp;</span> <span>this</span><span>.</span>currentRouter <span>===</span> <span>'/'</span><span>)</span> <span>{</span>
<span>+</span>            pathList<span>.</span><span>push</span><span>(</span>record<span>)</span><span>;</span>
<span>+</span>            <span>return</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span>
            <span>!</span>pathMap<span>[</span>record<span>.</span>path<span>]</span>
            <span>&amp;&amp;</span> <span>this</span><span>.</span>currentRouter<span>.</span><span>includes</span><span>(</span>path<span>)</span>
            <span>&amp;&amp;</span> <span>this</span><span>.</span>currentRouter <span>!==</span> <span>'/'</span>
            <span>&amp;&amp;</span> path <span>!==</span> <span>'/'</span>
        <span>)</span> <span>{</span>
            pathList<span>.</span><span>push</span><span>(</span>record<span>)</span>
            pathMap<span>[</span>record<span>.</span>path<span>]</span> <span>=</span> record
        <span>}</span>
        <span>if</span> <span>(</span>route<span>.</span>children<span>)</span> <span>{</span>
            route<span>.</span>children<span>.</span><span>forEach</span><span>(</span><span>child</span> <span>=></span> <span>{</span>
                <span>this</span><span>.</span><span>addRouteRecord</span><span>(</span>pathList<span>,</span> pathMap<span>,</span> child<span>,</span> record<span>)</span>
            <span>}</span><span>)</span>
        <span>}</span>
    <span>}</span>
	<span>...</span>省略
<span>}</span>

<span>export</span> <span>default</span> Router

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><div><p>提示</p>
<p>到现在为止，你已经完成了一个简易版的vue-router了。</p>
</div>
<h2 id="测试"> 测试</h2>
<p>我的router.js如下：</p>
<div><pre><code>
<span>import</span> Vue <span>from</span> <span>'vue'</span><span>;</span>
<span>import</span> Router <span>from</span> <span>'../plugin/vue-router'</span><span>;</span>

Vue<span>.</span><span>use</span><span>(</span>Router<span>)</span><span>;</span>

<span>export</span> <span>default</span> <span>new</span> <span>Router</span><span>(</span><span>{</span>
    routes<span>:</span> <span>[</span>
        <span>{</span>
            path<span>:</span> <span>'/'</span><span>,</span>
            <span>component</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>import</span><span>(</span><span>'../components/home'</span><span>)</span>
        <span>}</span><span>,</span>
        <span>{</span>
            path<span>:</span> <span>'/child1'</span><span>,</span>
            <span>component</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>import</span><span>(</span><span>'../components/child1'</span><span>)</span><span>,</span>
            children<span>:</span> <span>[</span>
                <span>{</span>
                    path<span>:</span> <span>'info'</span><span>,</span>
                    <span>component</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>import</span><span>(</span><span>'../components/info'</span><span>)</span>
                <span>}</span>
            <span>]</span>
        <span>}</span><span>,</span>
        <span>{</span>
            path<span>:</span> <span>'child2'</span><span>,</span>
            <span>component</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>import</span><span>(</span><span>'../components/child2'</span><span>)</span>
        <span>}</span><span>,</span>
    <span>]</span>
<span>}</span><span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><p>app.vue如下：</p>
<div><pre><code><span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/<span>"</span></span><span>></span></span>home<span><span><span>&lt;/</span>router-link</span><span>></span></span> |
      <span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/child1<span>"</span></span><span>></span></span>child1<span><span><span>&lt;/</span>router-link</span><span>></span></span> |
      <span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/child2<span>"</span></span><span>></span></span>child2<span><span><span>&lt;/</span>router-link</span><span>></span></span> |
      <span><span><span>&lt;</span>router-link</span> <span>to</span><span><span>=</span><span>"</span>/child1/info<span>"</span></span><span>></span></span>info<span><span><span>&lt;/</span>router-link</span><span>></span></span> |
      <span><span><span>&lt;</span>router-view</span><span>></span></span><span><span><span>&lt;/</span>router-view</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>各页面内容如下：</p>
<div><pre><code>// home.vue
<span><span><span>&lt;</span>template</span><span>></span></span>
<span><span><span>&lt;</span>h1</span><span>></span></span>HOME<span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

// child1.vue
<span><span><span>&lt;</span>template</span><span>></span></span>
    <span><span><span>&lt;</span>div</span><span>></span></span>
        我是child1
        <span><span><span>&lt;</span>router-view</span><span>></span></span><span><span><span>&lt;/</span>router-view</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

// child2.vue
<span><span><span>&lt;</span>template</span><span>></span></span>
    <span><span><span>&lt;</span>div</span><span>></span></span>
        <span><span><span>&lt;</span>h1</span><span>></span></span>我是child2<span><span><span>&lt;/</span>h1</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

// info.vue
<span><span><span>&lt;</span>template</span><span>></span></span>
<span><span><span>&lt;</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>h1</span><span>></span></span>info<span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>效果如下：</p>
<p><img src="./assets/Video_2021-08-29_180240.gif" alt="Video_2021-08-29_180240" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>vuex源码实现</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-14/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-14/</guid>
      <source url="https://wangyawei.top/rss.xml">vuex源码实现</source>
      <category>vue</category>
      <pubDate>Mon, 30 Aug 2021 21:25:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。组件树构成了一个巨大的“视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为！</p>
</blockquote>
<p><img src="./assets/vuex.png" alt="vuex" /></p>
<h2 id="基本使用"> 基本使用</h2>
<ul>
<li>
<p>安装：</p>
<div><pre><code><span>yarn</span> <span>add</span> vuex
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>引入vuex插件 <code>store/index.js</code></p>
<div><pre><code><span>import</span> Vue <span>from</span> <span>'vue'</span>
<span>import</span> Vuex <span>from</span> <span>'vuex'</span>

Vue<span>.</span><span>use</span><span>(</span>Vuex<span>)</span>

<span>export</span> <span>default</span> <span>new</span> <span>Vuex<span>.</span>Store</span><span>(</span><span>{</span><span>...</span><span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>在根示例上添加该实例：<code>main.js</code>:</p>
<div><pre><code><span>import</span> store <span>from</span> <span>'./store'</span>
<span>new</span> <span>Vue</span><span>(</span><span>{</span>
  store<span>,</span>
  <span>render</span><span>:</span> <span>h</span> <span>=></span> <span>h</span><span>(</span>App<span>)</span><span>,</span>
<span>}</span><span>)</span><span>.</span><span>$mount</span><span>(</span><span>'#app'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>使用：</p>
<div><pre><code><span>export</span> <span>default</span> <span>new</span> <span>Vuex<span>.</span>Store</span><span>(</span><span>{</span>
    state<span>:</span> <span>{</span>
        count<span>:</span> <span>''</span>
    <span>}</span><span>,</span>
    mutations<span>:</span> <span>{</span>
        <span>increment</span> <span>(</span><span>state</span><span>)</span> <span>{</span>
            state<span>.</span>count<span>++</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>"</span>click<span>"</span></span><span>></span></span>点击<span><span><span>&lt;/</span>button</span><span>></span></span>
      {{ $store.state.count }}
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>

<span>export</span> <span>default</span> <span>{</span>
  	name<span>:</span> <span>'App'</span><span>,</span>
    methods<span>:</span> <span>{</span>
        <span>click</span><span>(</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span>$store<span>.</span><span>commit</span><span>(</span><span>'increment'</span><span>)</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div></li>
</ul>
<h2 id="自己的vuex"> 自己的vuex</h2>
<blockquote>
<p>仿着vuex的基本功能实现一个自己的vuex；vuex基本使用的方式不变，我们简单实现下vuex内部的代码；</p>
</blockquote>
<p>新建<code>vuex/index.js</code>，添加Store类和install方法并导出；</p>
<div><pre><code>
<span>let</span> Vue <span>=</span> <span>null</span><span>;</span>

<span>class</span> <span>Store</span> <span>{</span>
    <span>constructor</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>// 因为vue中的data是响应式的，所以我们可以直接new Vue();</span>
        <span>this</span><span>.</span>state <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
            data<span>:</span> options<span>.</span>state<span>,</span>
        <span>}</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>function</span> <span>install</span> <span>(</span><span>_Vue</span><span>)</span> <span>{</span>
    Vue <span>=</span> _Vue<span>;</span>
    Vue<span>.</span><span>mixin</span><span>(</span><span>{</span>
        <span>beforeCreate</span><span>(</span><span>)</span> <span>{</span>
            <span>// 访问到根组件时，将其挂载到vue的原型链上；</span>
            <span>if</span> <span>(</span><span>this</span><span>.</span>$options<span>.</span>store<span>)</span> <span>{</span>
                <span>Vue</span><span>.</span>prototype<span>.</span>$store <span>=</span> <span>this</span><span>.</span>$options<span>.</span>store<span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span><span>)</span>
<span>}</span>

<span>export</span> <span>default</span> <span>{</span>
    Store<span>,</span>
    install
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><blockquote>
<p>以上的实现代码，可以满足<strong>基本使用</strong>中count的访问，但是commit还不能使用。</p>
</blockquote>
<h2 id="实现commit"> 实现commit</h2>
<div><pre><code><span>class</span> <span>Store</span> <span>{</span>
    <span>constructor</span><span>(</span><span>options</span><span>)</span> <span>{</span>
<span>+</span>       <span>this</span><span>.</span>_mutations <span>=</span> options<span>.</span>mutations<span>,</span>
        <span>this</span><span>.</span>state <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
            data<span>:</span> options<span>.</span>state<span>,</span>
        <span>}</span><span>)</span>
    <span>}</span>

<span>+</span>    <span>commit</span><span>(</span><span>type<span>,</span> palyload</span><span>)</span> <span>{</span>
<span>+</span>        <span>const</span> enter <span>=</span> <span>this</span><span>.</span>_mutations<span>[</span>type<span>]</span><span>;</span>
<span>+</span>        <span>if</span> <span>(</span>enter<span>)</span> <span>{</span>
<span>+</span>            <span>enter</span><span>(</span><span>this</span><span>.</span>state<span>,</span> palyload<span>)</span><span>;</span>
<span>+</span>        <span>}</span>
<span>+</span>    <span>}</span>
<span>+</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><blockquote>
<p>以上的实现代码，可以满足<strong>基本使用</strong>中count的设置了，<code>this.$store.commit('increment')</code>。</p>
</blockquote>
<h2 id="实现dispatch"> 实现dispatch</h2>
<div><pre><code><span>let</span> Vue <span>=</span> <span>null</span><span>;</span>

<span>class</span> <span>Store</span> <span>{</span>
    <span>constructor</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>_mutations <span>=</span> options<span>.</span>mutations<span>;</span>
<span>+</span>        <span>this</span><span>.</span>_actions <span>=</span> options<span>.</span>actions<span>;</span>

        <span>this</span><span>.</span>state <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
            data<span>:</span> options<span>.</span>state<span>,</span>
        <span>}</span><span>)</span>

        <span>// 解决this指向问题</span>
<span>+</span>        <span>this</span><span>.</span>commit <span>=</span> <span>this</span><span>.</span><span>commit</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>;</span>
<span>+</span>        <span>this</span><span>.</span>dispatch <span>=</span> <span>this</span><span>.</span><span>commit</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>}</span>

	<span>...</span>省略中间代码

<span>+</span>    <span>dispatch</span><span>(</span><span>type<span>,</span> payload</span><span>)</span> <span>{</span>
<span>+</span>        <span>const</span> enter <span>=</span> <span>this</span><span>.</span>_actions<span>[</span>type<span>]</span><span>;</span>
<span>+</span>        <span>if</span> <span>(</span>enter<span>)</span> <span>{</span>
<span>+</span>            <span>enter</span><span>(</span><span>this</span><span>,</span> payload<span>)</span>
<span>+</span>        <span>}</span>
<span>+</span>    <span>}</span>
<span>+</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><blockquote>
<p>以上的实现代码，你可以<code>this.$store.dispatch('increment')</code>，来使用了。</p>
</blockquote>
<h2 id="实现getter"> 实现getter</h2>
<blockquote>
<p>vuex的getter其实就是计算属性，所以实现getter就是实现vue的计算属性；</p>
</blockquote>
<div><pre><code><span>let</span> Vue <span>=</span> <span>null</span><span>;</span>

<span>class</span> <span>Store</span> <span>{</span>
    <span>constructor</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>_mutations <span>=</span> options<span>.</span>mutations<span>;</span>
        <span>this</span><span>.</span>_actions <span>=</span> options<span>.</span>actions<span>;</span>
<span>+</span>        <span>this</span><span>.</span>_wapperdGetters <span>=</span> options<span>.</span>getters<span>;</span>
<span>+</span>        <span>this</span><span>.</span>getters <span>=</span> <span>{</span><span>}</span><span>;</span>

        <span>// 初始化 state</span>
<span>+</span>        <span>this</span><span>.</span><span>initVm</span><span>(</span>options<span>)</span><span>;</span>

        <span>this</span><span>.</span>commit <span>=</span> <span>this</span><span>.</span><span>commit</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>dispatch <span>=</span> <span>this</span><span>.</span><span>dispatch</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>}</span>

    <span>initVm</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>const</span> computed <span>=</span> <span>{</span><span>}</span><span>;</span>
        Object<span>.</span><span>keys</span><span>(</span><span>this</span><span>.</span>_wapperdGetters<span>)</span><span>.</span><span>forEach</span><span>(</span><span>key</span> <span>=></span> <span>{</span>
    
            <span>// 获取用户定义的getter；</span>
            <span>const</span> fn <span>=</span> <span>this</span><span>.</span>_wapperdGetters<span>[</span>key<span>]</span><span>;</span>
            computed<span>[</span>key<span>]</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
                <span>return</span> <span>fn</span><span>(</span><span>this</span><span>.</span>state<span>)</span>
            <span>}</span>

            <span>// 定义只读</span>
            Object<span>.</span><span>defineProperty</span><span>(</span><span>this</span><span>.</span>getters<span>,</span> key<span>,</span> <span>{</span>
                <span>get</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
                    <span>return</span> <span>this</span><span>.</span>_vm<span>[</span>key<span>]</span> 
                <span>}</span>
            <span>}</span><span>)</span>
        <span>}</span><span>)</span>
        <span>this</span><span>.</span>_vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
            data<span>:</span> options<span>.</span>state<span>,</span>
            computed<span>,</span>
        <span>}</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><blockquote>
<p>以上的实现代码，你可以<code>this.$store.getter.xxx</code>，来使用了。</p>
</blockquote>
<h2 id="禁止直接修改state"> 禁止直接修改state</h2>
<blockquote>
<p>以上的代码实现简单实现了vuex的基本功能，但是用户还可以直接<code>this.$store.state = xxx</code>来修改，这样是不应该的，所以我们需要限制用户直接修改state中的值；</p>
</blockquote>
<div><pre><code><span>class</span> <span>Store</span> <span>{</span>
<span>+</span>   <span>get</span> <span>state</span> <span>(</span><span>)</span> <span>{</span>
    	<span>// 需要this._vm._data访问</span>
<span>+</span>       <span>return</span> <span>this</span><span>.</span>_vm<span>.</span>_data<span>.</span>$$state<span>;</span>
<span>+</span>   <span>}</span>

<span>+</span>   <span>set</span> <span>state</span> <span>(</span><span>v</span><span>)</span> <span>{</span>
<span>+</span>       console<span>.</span><span>error</span><span>(</span><span>'禁止直接修改state'</span><span>)</span>
<span>+</span>   <span>}</span>

    <span>initVm</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>_vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
            data<span>:</span> <span>{</span>
<span>+</span>                $$state<span>:</span> options<span>.</span>state<span>,</span>
            <span>}</span><span>,</span>
            computed<span>,</span>
        <span>}</span><span>)</span>
    <span>}</span>
<span>+</span><span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="完整代码"> 完整代码</h2>
<div><pre><code><span>let</span> Vue <span>=</span> <span>null</span><span>;</span>

<span>class</span> <span>Store</span> <span>{</span>
    <span>constructor</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>_mutations <span>=</span> options<span>.</span>mutations<span>;</span>
        <span>this</span><span>.</span>_actions <span>=</span> options<span>.</span>actions<span>;</span>
        <span>this</span><span>.</span>_wapperdGetters <span>=</span> options<span>.</span>getters<span>;</span>
        <span>this</span><span>.</span>getters <span>=</span> <span>{</span><span>}</span><span>;</span>

        <span>// 初始化 state</span>
        <span>this</span><span>.</span><span>initVm</span><span>(</span>options<span>)</span><span>;</span>

        <span>this</span><span>.</span>commit <span>=</span> <span>this</span><span>.</span><span>commit</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>dispatch <span>=</span> <span>this</span><span>.</span><span>dispatch</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>}</span>

    <span>get</span> <span>state</span> <span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>this</span><span>.</span>_vm<span>.</span>_data<span>.</span>$$state<span>;</span>
    <span>}</span>

    <span>set</span> <span>state</span> <span>(</span><span>v</span><span>)</span> <span>{</span>
        console<span>.</span><span>error</span><span>(</span><span>'禁止直接修改state'</span><span>)</span>
    <span>}</span>

    <span>initVm</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>const</span> computed <span>=</span> <span>{</span><span>}</span><span>;</span>
        Object<span>.</span><span>keys</span><span>(</span><span>this</span><span>.</span>_wapperdGetters<span>)</span><span>.</span><span>forEach</span><span>(</span><span>key</span> <span>=></span> <span>{</span>
    
            <span>// 获取用户定义的getter；</span>
            <span>const</span> fn <span>=</span> <span>this</span><span>.</span>_wapperdGetters<span>[</span>key<span>]</span><span>;</span>
            computed<span>[</span>key<span>]</span> <span>=</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
                <span>return</span> <span>fn</span><span>(</span><span>this</span><span>.</span>state<span>)</span>
            <span>}</span>

            <span>// 定义只读</span>
            Object<span>.</span><span>defineProperty</span><span>(</span><span>this</span><span>.</span>getters<span>,</span> key<span>,</span> <span>{</span>
                <span>get</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
                    <span>return</span> <span>this</span><span>.</span>_vm<span>[</span>key<span>]</span> 
                <span>}</span>
            <span>}</span><span>)</span>
            
        <span>}</span><span>)</span>
        <span>this</span><span>.</span>_vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
            data<span>:</span> <span>{</span>
                $$state<span>:</span> options<span>.</span>state<span>,</span>
            <span>}</span><span>,</span>
            computed<span>,</span>
        <span>}</span><span>)</span>
    <span>}</span>

    <span>commit</span><span>(</span><span>type<span>,</span> palyload</span><span>)</span> <span>{</span>
        <span>const</span> enter <span>=</span> <span>this</span><span>.</span>_mutations<span>[</span>type<span>]</span><span>;</span>
        <span>if</span> <span>(</span>enter<span>)</span> <span>{</span>
            <span>enter</span><span>(</span><span>this</span><span>.</span>state<span>,</span> palyload<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>dispatch</span><span>(</span><span>type<span>,</span> payload</span><span>)</span> <span>{</span>
        <span>const</span> enter <span>=</span> <span>this</span><span>.</span>_actions<span>[</span>type<span>]</span><span>;</span>
        <span>if</span> <span>(</span>enter<span>)</span> <span>{</span>
            <span>enter</span><span>(</span><span>this</span><span>,</span> payload<span>)</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>function</span> <span>install</span> <span>(</span><span>_Vue</span><span>)</span> <span>{</span>
    Vue <span>=</span> _Vue<span>;</span>
    Vue<span>.</span><span>mixin</span><span>(</span><span>{</span>
        <span>beforeCreate</span><span>(</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>this</span><span>.</span>$options<span>.</span>store<span>)</span> <span>{</span>
                <span>Vue</span><span>.</span>prototype<span>.</span>$store <span>=</span> <span>this</span><span>.</span>$options<span>.</span>store<span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span><span>)</span>
<span>}</span>

<span>export</span> <span>default</span> <span>{</span>
    Store<span>,</span>
    install
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br></div></div><blockquote>
<p>以上就是vuex的核心内容了，但是只是一个简单的vuex，主要用于学习目的；</p>
</blockquote>
<h2 id="测试"> 测试</h2>
<div><pre><code><span>import</span> Vue <span>from</span> <span>'vue'</span><span>;</span>
<span>// 引入自己写的vuex</span>
<span>import</span> Vuex <span>from</span> <span>'../plugin/vuex'</span><span>;</span>

Vue<span>.</span><span>use</span><span>(</span>Vuex<span>)</span>

<span>export</span> <span>default</span> <span>new</span> <span>Vuex<span>.</span>Store</span><span>(</span><span>{</span>
    state<span>:</span> <span>{</span>
        count<span>:</span> <span>100</span>
    <span>}</span><span>,</span>
    mutations<span>:</span> <span>{</span>
        <span>increment</span><span>(</span><span>state</span><span>)</span> <span>{</span>
            state<span>.</span>count<span>++</span><span>;</span>
        <span>}</span>
    <span>}</span><span>,</span>
    actions<span>:</span> <span>{</span>
        <span>increment</span><span>(</span><span><span>{</span> commit <span>}</span></span><span>)</span> <span>{</span>
            <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
                <span>commit</span><span>(</span><span>'increment'</span><span>)</span>
            <span>}</span><span>,</span> <span>1000</span><span>)</span>
        <span>}</span>
    <span>}</span><span>,</span>
    getters<span>:</span> <span>{</span>
        <span>num</span><span>(</span><span>state</span><span>)</span><span>{</span>
            <span>return</span> state<span>.</span>count <span>+</span> <span>10</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span><span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
      <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>"</span>click<span>"</span></span><span>></span></span>commit<span><span><span>&lt;/</span>button</span><span>></span></span>
      {{ $store.getters.num }}
      <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>"</span>onclick<span>"</span></span><span>></span></span>dispatch<span><span><span>&lt;/</span>button</span><span>></span></span>
      {{ $store.state.count }}<span><span><span>&lt;</span>br</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
    methods<span>:</span> <span>{</span>
        <span>click</span><span>(</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span>$store<span>.</span><span>commit</span><span>(</span><span>'increment'</span><span>)</span>
        <span>}</span><span>,</span>
        <span>onclick</span><span>(</span><span>)</span> <span>{</span>
            <span>this</span><span>.</span>$store<span>.</span><span>dispatch</span><span>(</span><span>'increment'</span><span>)</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p><img src="./assets/Video_2021-08-30_212240.gif" alt="Video_2021-08-30_212240" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>实现一个简单的MVVM框架</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-15/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-15/</guid>
      <source url="https://wangyawei.top/rss.xml">实现一个简单的MVVM框架</source>
      <category>vue</category>
      <pubDate>Tue, 31 Aug 2021 21:42:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>在实现mvvm之前我们需要先来认识下什么是mvvm？</p>
</blockquote>
<p><img src="./assets/image-20210830234126983.png" alt="image-20210830234126983" /></p>
<h2 id="什么是mvvm"> 什么是MVVM ？</h2>
<blockquote>
<p>MVVM（Model–view–viewmodel）是一种软件<a href="https://zh.wikipedia.org/wiki/%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener noreferrer">架构模式</a>；MVVM有助于将<a href="https://zh.wikipedia.org/wiki/%E5%9B%BE%E5%BD%A2%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2" target="_blank" rel="noopener noreferrer">图形用户界面</a>的开发与<a href="https://zh.wikipedia.org/wiki/%E4%B8%9A%E5%8A%A1%E9%80%BB%E8%BE%91" target="_blank" rel="noopener noreferrer">业务逻辑</a>或<a href="https://zh.wikipedia.org/wiki/%E5%89%8D%E7%AB%AF%E5%92%8C%E5%90%8E%E7%AB%AF" target="_blank" rel="noopener noreferrer">后端</a>逻辑（<em>数据模型</em>）的开发<a href="https://zh.wikipedia.org/wiki/%E5%85%B3%E6%B3%A8%E7%82%B9%E5%88%86%E7%A6%BB" target="_blank" rel="noopener noreferrer">分离</a>开来，这是通过<a href="https://zh.wikipedia.org/wiki/%E7%BD%AE%E6%A0%87%E8%AF%AD%E8%A8%80" target="_blank" rel="noopener noreferrer">置标语言</a>或GUI代码实现的。</p>
</blockquote>
<ul>
<li><strong>MVC</strong>：
<ul>
<li><code>Model</code> 数据 → <code>View</code> 视图 → <code>Controller</code> 控制器；</li>
</ul>
</li>
<li>MVP：
<ul>
<li><code>Model</code>模型→ <code>View</code> 视图 → <code>Presenter</code>表现层；</li>
<li>由MVC模式进化而来；</li>
</ul>
</li>
<li>MVVM：
<ul>
<li><code>Model</code> 模型 → <code>View</code> 视图 → <code>ViewModel</code> 视图模型；</li>
<li>三者的关系：<code>view</code> 可以通过事件绑定的方式影响 <code>model</code>，<code>model</code> 可以通过数据绑定的形式影响到<code>view</code>，<code>viewModel</code>是把 <code>model</code> 和 <code>view</code> 连起来的连接器；</li>
</ul>
</li>
</ul>
<h2 id="mvvm模式的组成部分"> <code>MVVM</code>模式的组成部分</h2>
<p><strong>模型</strong>：是指代表真实状态内容的<a href="https://zh.wikipedia.org/wiki/%E9%A2%86%E5%9F%9F%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener noreferrer">领域模型</a>（面向对象），或指代表内容的<a href="https://zh.wikipedia.org/wiki/%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE%E5%B1%82" target="_blank" rel="noopener noreferrer">数据访问层</a>（以数据为中心）。</p>
<p><strong>视图</strong>：就像在<a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="noopener noreferrer">MVC</a>和<a href="https://zh.wikipedia.org/wiki/Model-view-presenter" target="_blank" rel="noopener noreferrer">MVP</a>模式中一样，视图是用户在屏幕上看到的结构、布局和外观（UI）。</p>
<p><strong>视图模型</strong>：视图模型是暴露公共属性和命令的视图的抽象。</p>
<div><p>提示</p>
<p>MVVM没有MVC模式的控制器，也没有MVP模式的presenter，有的是一个绑定器。在视图模型中，绑定器在视图和<a href="https://zh.wikipedia.org/w/index.php?title=%E6%95%B0%E6%8D%AE%E7%BB%91%E5%AE%9A%E5%99%A8&amp;action=edit&amp;redlink=1" target="_blank" rel="noopener noreferrer">数据绑定器</a>之间进行通信。</p>
</div>
<h2 id="mvvm-框架的三大要素"> <code>MVVM</code> 框架的三大要素</h2>
<ul>
<li>数据响应式：监听数据变化并在视图中更新。
<ul>
<li>Object.defineProperty()</li>
<li>Proxy</li>
</ul>
</li>
<li>模板引擎：提供描述视图的模版语法
<ul>
<li>插值：{{}}</li>
<li>指令：v-bind，v-on，v-model，v-for，v-if</li>
</ul>
</li>
<li>渲染：如何将模板转换为html
<ul>
<li>模板 =&gt; vdom =&gt; dom</li>
</ul>
</li>
</ul>
<h2 id="编写mvvm框架"> 编写MVVM框架</h2>
<h3 id="数据响应式"> 数据响应式</h3>
<div><pre><code><span>const</span> obj <span>=</span> <span>{</span><span>}</span>

<span>// 封装响应式函数</span>
<span>function</span> <span>defineReactive</span><span>(</span><span>obj<span>,</span> key<span>,</span> val</span><span>)</span> <span>{</span>
    Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
        <span>get</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>get </span><span><span>${</span>key<span>}</span></span><span>:</span><span><span>${</span>val<span>}</span></span><span>`</span></span><span>)</span><span>;</span> <span>// get name:小明</span>
            <span>return</span> val
        <span>}</span><span>,</span>
        <span>set</span><span>(</span>newVal<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>newVal <span>!==</span> val<span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>set </span><span><span>${</span>key<span>}</span></span><span>:</span><span><span>${</span>newVal<span>}</span></span><span>`</span></span><span>)</span><span>;</span> <span>// set name:小红</span>
                val <span>=</span> newVal
            <span>}</span>
        <span>}</span><span>,</span>
    <span>}</span><span>)</span>
<span>}</span>

<span>// 把 obj 转化为 响应式；</span>
<span>defineReactive</span><span>(</span>obj<span>,</span> <span>'name'</span><span>,</span> <span>'小明'</span><span>)</span><span>;</span>

obj<span>.</span>name

obj<span>.</span>name <span>=</span> <span>'小红'</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="结合视图"> 结合视图</h3>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
	<span><span><span>&lt;</span>h1</span> <span>id</span><span><span>=</span><span>"</span>#app<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
    <span>const</span> obj <span>=</span> <span>{</span><span>}</span>
    <span>const</span> appEl <span>=</span> document<span>.</span><span>getElementById</span><span>(</span><span>'#app'</span><span>)</span>
    <span>function</span> <span>render</span><span>(</span><span>val</span><span>)</span> <span>{</span>
        appEl<span>.</span>innerText <span>=</span> val<span>;</span>
    <span>}</span>
    <span>// 封装响应式函数</span>
    <span>function</span> <span>defineReactive</span><span>(</span><span>obj<span>,</span> key<span>,</span> val</span><span>)</span> <span>{</span>
        Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
            <span>get</span><span>(</span><span>)</span> <span>{</span>
                <span>return</span> val
            <span>}</span><span>,</span>
            <span>set</span><span>(</span>newVal<span>)</span> <span>{</span>
                <span>if</span> <span>(</span>newVal <span>!==</span> val<span>)</span> <span>{</span>
                    <span>// 数据变化，更新视图</span>
                    <span>render</span><span>(</span>newVal<span>)</span>
                    val <span>=</span> newVal
                <span>}</span>
            <span>}</span><span>,</span>
        <span>}</span><span>)</span>
    <span>}</span>

    <span>// 把 obj 转化为 响应式；</span>
    <span>defineReactive</span><span>(</span>obj<span>,</span> <span>'date'</span><span>,</span> <span>''</span><span>)</span><span>;</span>

    <span>// 每秒更新数据</span>
    <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        obj<span>.</span>date <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span><span>.</span><span>toLocaleTimeString</span><span>(</span><span>)</span><span>;</span>
    <span>}</span><span>,</span> <span>1000</span><span>)</span>

</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><blockquote>
<p>以上代码可以在浏览器中直接运行，可以看到实现响应式的大致原理；</p>
</blockquote>
<h3 id="为所有属性添加响应式"> 为所有属性添加响应式</h3>
<div><pre><code><span>const</span> obj <span>=</span> <span>{</span>
    eat<span>:</span> <span>{</span>
        panda<span>:</span> <span>'熊猫'</span>
    <span>}</span><span>,</span>
    drink<span>:</span> <span>'喝'</span>
<span>}</span>

<span>// 封装响应式函数</span>
<span>function</span> <span>defineReactive</span><span>(</span><span>obj<span>,</span> key<span>,</span> val</span><span>)</span> <span>{</span>
<span>+</span>    <span>observe</span><span>(</span>val<span>)</span><span>;</span>
    Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
        <span>get</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>get </span><span><span>${</span>key<span>}</span></span><span>:</span><span><span>${</span>val<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
            <span>return</span> val
        <span>}</span><span>,</span>
        <span>set</span><span>(</span>newVal<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>newVal <span>!==</span> val<span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>set </span><span><span>${</span>key<span>}</span></span><span>:</span><span><span>${</span>newVal<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
                val <span>=</span> newVal
            <span>}</span>
        <span>}</span><span>,</span>
    <span>}</span><span>)</span>
<span>}</span>

<span>// 遍历观察者为所有对象添加响应式；</span>
<span>function</span> <span>observe</span> <span>(</span><span>obj</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span><span>(</span>obj <span>instanceof</span> <span>Object</span><span>)</span> <span>||</span> obj <span>===</span> <span>null</span> <span>||</span> obj <span>===</span> <span>undefined</span><span>)</span> <span>return</span><span>;</span>
    <span>for</span> <span>(</span><span>const</span> key <span>in</span> obj<span>)</span> <span>{</span>
        <span>defineReactive</span><span>(</span>obj<span>,</span> key<span>,</span> obj<span>[</span>key<span>]</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>observe</span><span>(</span>obj<span>)</span><span>;</span>

obj<span>.</span>eat<span>.</span>panda

obj<span>.</span>drink
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><blockquote>
<p>新增加方法 observe 遍历对象中的所有属性并转化为响应式；</p>
</blockquote>
<h3 id="解决新添加属性"> 解决新添加属性</h3>
<div><pre><code><span>function</span> <span>set</span><span>(</span><span>obj<span>,</span> key<span>,</span> val</span><span>)</span> <span>{</span>
    <span>defineReactive</span><span>(</span>obj<span>,</span> key<span>,</span> val<span>)</span><span>;</span>
<span>}</span>

<span>// 设置新属性</span>
<span>set</span><span>(</span>obj<span>,</span> <span>'beverages'</span><span>,</span> <span>'饮料'</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>
<p>defineProperty无法观察到添加或删除属性的变化，所以我们需要自己触发响应式；</p>
</blockquote>
<div><p>提示</p>
<p>defineProperty() 不支持数组，所以数组的监听需要其他处理方式；</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>手写vue</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-16/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-16/</guid>
      <source url="https://wangyawei.top/rss.xml">手写vue</source>
      <category>vue</category>
      <pubDate>Sat, 04 Sep 2021 20:25:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>根据前面介绍的mvvm框架，手写一个简单的vue，以进一步的了解vue。目标代码如下：</p>
</blockquote>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>h1</span><span>></span></span>{{ count }}<span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>./vue.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>

<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
    <span>const</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
        el<span>:</span> <span>'#app'</span><span>,</span>
        data<span>:</span> <span>{</span>
            count<span>:</span> <span>1</span>
        <span>}</span>
    <span>}</span><span>)</span>

    <span>setInterval</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        app<span>.</span>count<span>++</span>
    <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>

</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="原理分析"> 原理分析</h2>
<ul>
<li>new Vue() 首先执行初始化，对data执行响应化处理，这个过程发生在Observer中。</li>
<li>同时对模板执行编译，找到其中动态绑定的数据，从data中获取并初始化视图，这个过程发生在Compile中。</li>
<li>同时定义一个更新函数和Watcher，将来对应数据变化时Watcher会调用更新函数。</li>
<li>由于data的某个key在一个视图中可能出现多次，所以每个key都需要一个管家Dep来管理多个Watcher。</li>
<li>将来data中数据一旦发生变化，会首先找到对应的Dep，通知所有Watcher执行更新函数  。</li>
</ul>
<p><img src="./assets/image-20210902225734775.png" alt="image-20210902225734775" /></p>
<h2 id="名词介绍"> 名词介绍</h2>
<ul>
<li>KVue：框架构造函数。</li>
<li>Observer：执行数据响应化（分辨数据是对象还是数组）。</li>
<li>Compile：编译模板，初始化视图，收集依赖（更新函数、watcher创建）。</li>
<li>Watcher：执行更新函数（更新dom）。</li>
<li>Dep：管理多个Watcher，批量更新  。</li>
</ul>
<h2 id="vuejs"> vuejs</h2>
<blockquote>
<p>vue框架的构造函数，对vue进行初始化同时把data进行响应式处理；</p>
</blockquote>
<div><pre><code><span>class</span> <span>Vue</span> <span>{</span>
    <span>constructor</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>$options <span>=</span> options<span>;</span>
        <span>this</span><span>.</span>$data <span>=</span> options<span>.</span>data<span>;</span>

        <span>// 初始化所有属性</span>
        <span>observe</span><span>(</span><span>this</span><span>.</span>$data<span>)</span>
    <span>}</span>
<span>}</span>

<span>// 封装响应式函数</span>
<span>function</span> <span>defineReactive</span><span>(</span><span>obj<span>,</span> key<span>,</span> val</span><span>)</span> <span>{</span>
    Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
        <span>get</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>get </span><span><span>${</span>key<span>}</span></span><span>:</span><span><span>${</span>val<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
            <span>return</span> val
        <span>}</span><span>,</span>
        <span>set</span><span>(</span>newVal<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>newVal <span>!==</span> val<span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>set </span><span><span>${</span>key<span>}</span></span><span>:</span><span><span>${</span>newVal<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
                val <span>=</span> newVal
            <span>}</span>
        <span>}</span><span>,</span>
    <span>}</span><span>)</span>
<span>}</span>

<span>// 劫持监听所有属性；</span>
<span>function</span> <span>observe</span> <span>(</span><span>obj</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span><span>(</span>obj <span>instanceof</span> <span>Object</span><span>)</span> <span>||</span> obj <span>===</span> <span>null</span> <span>||</span> obj <span>===</span> <span>undefined</span><span>)</span> <span>return</span><span>;</span>
    <span>new</span> <span>Observer</span><span>(</span>obj<span>)</span><span>;</span>
<span>}</span>

<span>class</span> <span>Observer</span> <span>{</span>
    <span>constructor</span><span>(</span><span>value</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>value <span>=</span> value<span>;</span>
        <span>this</span><span>.</span><span>walk</span><span>(</span>value<span>)</span><span>;</span>
    <span>}</span>

    <span>// 遍历属性转化为响应式</span>
    <span>walk</span><span>(</span><span>value</span><span>)</span> <span>{</span>
        Object<span>.</span><span>keys</span><span>(</span>value<span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span>key</span><span>)</span> <span>=></span> <span>{</span>
            <span>defineReactive</span><span>(</span>value<span>,</span> key<span>,</span> value<span>[</span>key<span>]</span><span>)</span>
        <span>}</span><span>)</span>
    <span>}</span>
<span>}</span>

window<span>.</span>Vue <span>=</span> Vue<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><blockquote>
<p>把上面的代码引入到你的目标代码后，你就可以正常访问了，不过现在还没有编译html，需要<code>$data.count</code>才能访问；</p>
</blockquote>
<p><strong>为$data做代理</strong></p>
<p>这样就可以在外面使用<code>app.count</code>来访问属性了，而不需要<code>app.$data.count</code>;</p>
<div><pre><code><span>class</span> <span>Vue</span> <span>{</span>
    <span>constructor</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>$options <span>=</span> options<span>;</span>
        <span>this</span><span>.</span>$data <span>=</span> options<span>.</span>data<span>;</span>

        <span>observe</span><span>(</span><span>this</span><span>.</span>$data<span>)</span>
<span>+</span>        <span>proxy</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>// 为vue做代理访问，这样就可以简化访问了；</span>
<span>function</span> <span>proxy</span> <span>(</span><span>vm</span><span>)</span> <span>{</span>
    Object<span>.</span><span>keys</span><span>(</span>vm<span>.</span>$data<span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span>key</span><span>)</span> <span>=></span> <span>{</span>
        Object<span>.</span><span>defineProperty</span><span>(</span>vm<span>,</span> key<span>,</span> <span>{</span>
            <span>get</span><span>(</span><span>)</span> <span>{</span>
                <span>return</span> vm<span>.</span>$data<span>[</span>key<span>]</span><span>;</span>
            <span>}</span><span>,</span>
            <span>set</span><span>(</span>newVal<span>)</span> <span>{</span>
                vm<span>.</span>$data<span>[</span>key<span>]</span> <span>=</span> newVal<span>;</span>
            <span>}</span>
        <span>}</span><span>)</span>
    <span>}</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="编译模板"> 编译模板</h2>
<blockquote>
<p>编译模板中vue模板特殊语法，初始化视图、更新视图;</p>
</blockquote>
<p><img src="./assets/image-20210903004459850.png" alt="image-20210903004459850" /></p>
<h3 id="初始化视图"> 初始化视图</h3>
<div><pre><code><span>class</span> <span>Compile</span> <span>{</span>
    <span>constructor</span><span>(</span><span>el<span>,</span> vm</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>$vm <span>=</span> vm<span>;</span>
        <span>this</span><span>.</span>$el <span>=</span> document<span>.</span><span>querySelector</span><span>(</span>el<span>)</span><span>;</span>

        <span>if</span> <span>(</span><span>this</span><span>.</span>$el<span>)</span> <span>{</span>
            <span>this</span><span>.</span><span>compile</span><span>(</span><span>this</span><span>.</span>$el<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>compile</span><span>(</span><span>el</span><span>)</span><span>{</span>
        <span>const</span> childNodes <span>=</span> el<span>.</span>childNodes<span>;</span>
        <span>// 根据节点类型编译</span>
        Array<span>.</span><span>form</span><span>(</span>childNodes<span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span>node</span><span>)</span> <span>=></span> <span>{</span>
            <span>if</span> <span>(</span><span>this</span><span>.</span><span>isElement</span><span>(</span>node<span>)</span><span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span>'编译元素'</span> <span>+</span> node<span>.</span>nodeName<span>)</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>this</span><span>.</span><span>isInterPolation</span><span>(</span>node<span>)</span><span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span>'编译插值文本'</span> <span>+</span> node<span>.</span>textContent<span>)</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>node<span>.</span>chilNodes <span>&amp;&amp;</span> node<span>.</span>chilNodes<span>.</span>lenght<span>)</span> <span>{</span>
                <span>this</span><span>.</span><span>compile</span><span>(</span>node<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span>
    <span>}</span>

    <span>isElement</span><span>(</span><span>node</span><span>)</span> <span>{</span>
        <span>return</span> node<span>.</span>nodeType <span>===</span> <span>1</span><span>;</span>
    <span>}</span>

    <span>isInterPolation</span><span>(</span><span>node</span><span>)</span> <span>{</span>
        <span>return</span> node<span>.</span>nodeType <span>===</span> <span>3</span> <span>&amp;&amp;</span> <span><span>/</span><span>\{\{(.*)\}\}</span><span>/</span></span><span>.</span><span>test</span><span>(</span>node<span>.</span>textContent<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h3 id="编译插值"> 编译插值</h3>
<div><pre><code><span>class</span> <span>Compile</span> <span>{</span>
    <span>...</span>省略
    <span>compile</span><span>(</span><span>el</span><span>)</span><span>{</span>
        <span>const</span> childNodes <span>=</span> el<span>.</span>childNodes<span>;</span>
        Array<span>.</span><span>from</span><span>(</span>childNodes<span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span>node</span><span>)</span> <span>=></span> <span>{</span>
            <span>if</span> <span>(</span><span>this</span><span>.</span><span>isElement</span><span>(</span>node<span>)</span><span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span>'编译元素：'</span><span>,</span> node<span>.</span>nodeName<span>)</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>this</span><span>.</span><span>isInterPolation</span><span>(</span>node<span>)</span><span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span>'编译插值文本：'</span><span>,</span> node<span>.</span>textContent<span>)</span><span>;</span>
<span>+</span>                <span>this</span><span>.</span><span>compileText</span><span>(</span>node<span>)</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>node<span>.</span>childNodes <span>&amp;&amp;</span> node<span>.</span>childNodes<span>.</span>length<span>)</span> <span>{</span>
                <span>this</span><span>.</span><span>compile</span><span>(</span>node<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span>
    <span>}</span>
    <span>isElement</span><span>(</span><span>node</span><span>)</span> <span>{</span>
        <span>return</span> node<span>.</span>nodeType <span>===</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>isInterPolation</span><span>(</span><span>node</span><span>)</span> <span>{</span>
        <span>return</span> node<span>.</span>nodeType <span>===</span> <span>3</span> <span>&amp;&amp;</span> <span><span>/</span><span>\{\{(.*)\}\}</span><span>/</span></span><span>.</span><span>test</span><span>(</span>node<span>.</span>textContent<span>)</span><span>;</span>
    <span>}</span>
<span>+</span>    <span>compileText</span><span>(</span><span>node</span><span>)</span> <span>{</span>
<span>+</span>        node<span>.</span>textContent <span>=</span> <span>this</span><span>.</span>$vm<span>[</span>RegExp<span>.</span>$<span>1</span><span>]</span>
<span>+</span>    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><blockquote>
<p>这个时候你的页面中可以使用{{count}}插值表达式了，</p>
</blockquote>
<h3 id="编译元素"> 编译元素</h3>
<div><pre><code><span>class</span> <span>Compile</span> <span>{</span>
    <span>...</span>省略
    <span>compile</span><span>(</span><span>el</span><span>)</span><span>{</span>
        <span>const</span> childNodes <span>=</span> el<span>.</span>childNodes<span>;</span>
        Array<span>.</span><span>from</span><span>(</span>childNodes<span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span>node</span><span>)</span> <span>=></span> <span>{</span>
            <span>if</span> <span>(</span><span>this</span><span>.</span><span>isElement</span><span>(</span>node<span>)</span><span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span>'编译元素：'</span><span>,</span> node<span>.</span>nodeName<span>)</span>
<span>+</span>                 <span>this</span><span>.</span><span>compileElement</span><span>(</span>node<span>)</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>this</span><span>.</span><span>isInterPolation</span><span>(</span>node<span>)</span><span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span>'编译插值文本：'</span><span>,</span> node<span>.</span>textContent<span>)</span><span>;</span>
               <span>this</span><span>.</span><span>compileText</span><span>(</span>node<span>)</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>node<span>.</span>childNodes <span>&amp;&amp;</span> node<span>.</span>childNodes<span>.</span>length<span>)</span> <span>{</span>
                <span>this</span><span>.</span><span>compile</span><span>(</span>node<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span>
    <span>}</span>
    <span>isElement</span><span>(</span><span>node</span><span>)</span> <span>{</span>
        <span>return</span> node<span>.</span>nodeType <span>===</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>isInterPolation</span><span>(</span><span>node</span><span>)</span> <span>{</span>
        <span>return</span> node<span>.</span>nodeType <span>===</span> <span>3</span> <span>&amp;&amp;</span> <span><span>/</span><span>\{\{(.*)\}\}</span><span>/</span></span><span>.</span><span>test</span><span>(</span>node<span>.</span>textContent<span>)</span><span>;</span>
    <span>}</span>
<span>+</span>	<span>compileElement</span><span>(</span><span>node</span><span>)</span> <span>{</span>
        <span>let</span> nodeAttrs <span>=</span> node<span>.</span>attributes<span>;</span>
    	<span>// 遍历node的属性并查找是否有v-html的属性；</span>
        Array<span>.</span><span>from</span><span>(</span>nodeAttrs<span>)</span><span>.</span><span>forEach</span><span>(</span><span>attr</span> <span>=></span> <span>{</span>
            <span>let</span> attrName <span>=</span> attr<span>.</span>name<span>;</span>
            <span>let</span> exp <span>=</span> attr<span>.</span>value<span>;</span>
            <span>if</span> <span>(</span><span>this</span><span>.</span><span>isDirective</span><span>(</span>attrName<span>)</span><span>)</span> <span>{</span>
                <span>let</span> dir <span>=</span> attrName<span>.</span><span>substring</span><span>(</span><span>2</span><span>)</span><span>;</span>
                <span>this</span><span>[</span>dir<span>]</span> <span>&amp;&amp;</span> <span>this</span><span>[</span>dir<span>]</span><span>(</span>node<span>,</span> exp<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span>
    <span>}</span>
<span>+</span>	<span>isDirective</span><span>(</span><span>attr</span><span>)</span> <span>{</span>
        <span>return</span> attr<span>.</span><span>indexOf</span><span>(</span><span>"v-"</span><span>)</span> <span>===</span> <span>0</span><span>;</span>
    <span>}</span>
<span>+</span>	<span>html</span><span>(</span><span>node<span>,</span> exp</span><span>)</span> <span>{</span>
    	<span>// 替换节点文本</span>
        node<span>.</span>innerHTML <span>=</span> <span>this</span><span>.</span>$vm<span>[</span>exp<span>]</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><blockquote>
<p>上面的代码可以让我们使用v-html指令，例：<code>&lt;h1 v-html=&quot;html&quot;&gt;&lt;/h1&gt;</code></p>
</blockquote>
<div><p>说明</p>
<p>以上代码的实现可以简单的显示插值表达式和v-html指令了，但是现在还缺少视图的更新；</p>
</div>
<h2 id="依赖收集"> 依赖收集</h2>
<blockquote>
<p>视图中会用到data中某key，这称为依赖。同一个key可能出现多次，每次都需要收集出来用一个Watcher来维护它们，此过程称为依赖收集。</p>
</blockquote>
<p><strong>多个Watcher需要一个Dep来管理，需要更新时由Dep统一通知。</strong></p>
<p>例：</p>
<div><pre><code>new Vue({
        template:
            `
                <span><span><span>&lt;</span>div</span><span>></span></span>
                <span><span><span>&lt;</span>p</span><span>></span></span>{{ name1 }}<span><span><span>&lt;/</span>p</span><span>></span></span>
                <span><span><span>&lt;</span>p</span><span>></span></span>{{ name2 }}<span><span><span>&lt;/</span>p</span><span>></span></span>
                <span><span><span>&lt;</span>p</span><span>></span></span>{{ name1 }}<span><span><span>&lt;/</span>p</span><span>></span></span>
                <span><span><span>&lt;/</span>div</span><span>></span></span>`,
        data: {
            name1: 'name1',
            name2: 'name2',
        },
    });
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p><img src="./assets/image-20210902225529990.png" alt="image-20210902225529990" /></p>
<p><strong>实现思路</strong></p>
<ul>
<li>defineReactive时为每一个key创建一个Dep实例。</li>
<li>初始化视图时读取某个key，例如name1，创建一个watcher1。</li>
<li>由于触发name1的getter方法，便将watcher1添加到name1对应的Dep中。</li>
<li>当name1更新，setter触发时，便可通过对应Dep通知其管理所有Watcher更新。</li>
</ul>
<p><img src="./assets/image-20210902225734775.png" alt="image-20210902225734775" /></p>
<h3 id="创建watcher"> 创建Watcher</h3>
<div><pre><code><span>//临时用于保存watcher测试用</span>
<span>const</span> watchers <span>=</span> <span>[</span><span>]</span><span>;</span>

<span>// 监听器：负责更新视图</span>
<span>class</span> <span>Watcher</span> <span>{</span>
    <span>constructor</span><span>(</span><span>vm<span>,</span> key<span>,</span> updateFn</span><span>)</span> <span>{</span>
        <span>// kvue实例</span>
        <span>this</span><span>.</span>vm <span>=</span> vm<span>;</span>
        <span>// 依赖key</span>
        <span>this</span><span>.</span>key <span>=</span> key<span>;</span>
        <span>// 更新函数</span>
        <span>this</span><span>.</span>updateFn <span>=</span> updateFn<span>;</span>
        <span>// 临时放入watchers数组</span>
        watchers<span>.</span><span>push</span><span>(</span><span>this</span><span>)</span>
    <span>}</span>
    <span>// 更新</span>
    <span>update</span><span>(</span><span>)</span> <span>{</span>
        <span>// 调用保存的更新函数</span>
        <span>this</span><span>.</span><span>updateFn</span><span>.</span><span>call</span><span>(</span><span>this</span><span>.</span>vm<span>,</span> <span>this</span><span>.</span>vm<span>[</span><span>this</span><span>.</span>key<span>]</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><blockquote>
<p>保存着某一个Key的使用者传入的更新函数；</p>
</blockquote>
<h3 id="编写更新函数"> 编写更新函数</h3>
<div><pre><code><span>class</span> <span>compile</span> <span>{</span>
    <span>...</span>省略
    <span>update</span><span>(</span><span>node<span>,</span> exp<span>,</span> dir</span><span>)</span> <span>{</span>
        <span>const</span> fn <span>=</span> <span>this</span><span>[</span>dir<span>+</span><span>'Updater'</span><span>]</span>
        fn <span>&amp;&amp;</span> <span>fn</span><span>(</span>node<span>,</span> <span>this</span><span>.</span>$vm<span>[</span>exp<span>]</span><span>)</span>
        <span>// 首次初始化的时候，创建一个观察者，并传入一个更新函数，更新函数的调用则会更新视图；</span>
        <span>new</span> <span>Watcher</span><span>(</span><span>this</span><span>.</span>$vm<span>,</span> exp<span>,</span> <span>function</span><span>(</span><span>val</span><span>)</span><span>{</span>
            fn <span>&amp;&amp;</span> <span>fn</span><span>(</span>node<span>,</span> val<span>)</span>
        <span>}</span><span>)</span>
    <span>}</span>
    <span>textUpdater</span><span>(</span><span>node<span>,</span> val</span><span>)</span> <span>{</span>
        node<span>.</span>textContent <span>=</span> val<span>;</span>
    <span>}</span>
    <span>htmlUpdater</span><span>(</span><span>node<span>,</span> val</span><span>)</span> <span>{</span>
        node<span>.</span>innerHTML <span>=</span> val
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="调用更新函数"> 调用更新函数</h3>
<div><pre><code><span>class</span> <span>compile</span> <span>{</span>
    <span>// v-text</span>
    <span>text</span><span>(</span><span>node<span>,</span> exp</span><span>)</span> <span>{</span>
        <span>// node.textContent = this.$vm[exp];</span>
        <span>this</span><span>.</span><span>update</span><span>(</span>node<span>,</span> exp<span>,</span> <span>'text'</span><span>)</span>
    <span>}</span>

    <span>// v-html</span>
    <span>html</span><span>(</span><span>node<span>,</span> exp</span><span>)</span> <span>{</span>
        <span>// node.innerHTML = this.$vm[exp]</span>
        <span>this</span><span>.</span><span>update</span><span>(</span>node<span>,</span> exp<span>,</span> <span>'html'</span><span>)</span>
    <span>}</span>

    <span>// {{xxxx}}</span>
    <span>compileText</span><span>(</span><span>node</span><span>)</span> <span>{</span>
        <span>// node.textContent = this.$vm[RegExp.$1]</span>
        <span>this</span><span>.</span><span>update</span><span>(</span>node<span>,</span> RegExp<span>.</span>$<span>1</span><span>,</span> <span>'text'</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><blockquote>
<p>数据发生变更调用不同的更新函数更新视图；</p>
</blockquote>
<h3 id="更新通知"> 更新通知</h3>
<div><pre><code><span>function</span> <span>defineReactive</span><span>(</span><span>obj<span>,</span> key<span>,</span> val</span><span>)</span> <span>{</span>
    Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
        <span>get</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>get </span><span><span>${</span>key<span>}</span></span><span>:</span><span><span>${</span>val<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
            <span>return</span> val
        <span>}</span><span>,</span>
        <span>set</span><span>(</span>newVal<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>newVal <span>!==</span> val<span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>set </span><span><span>${</span>key<span>}</span></span><span>:</span><span><span>${</span>newVal<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
<span>+</span>                watchers<span>.</span><span>forEach</span><span>(</span><span>(</span><span>fn</span><span>)</span> <span>=></span> fn<span>.</span><span>update</span><span>(</span><span>)</span><span>)</span>
                val <span>=</span> newVal
            <span>}</span>
        <span>}</span><span>,</span>
    <span>}</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><blockquote>
<p>数据发生变更后，我们遍历所有的观察者，将观察者所有收集到的更新函数全局执行一遍，就可以更新视图了；</p>
</blockquote>
<h3 id="收集watcher"> 收集watcher</h3>
<blockquote>
<p>在上面的代码中我们把观察者统一放在了watchers中；然后统一处理调用，但是这样带来的缺点就是，那些没有变更的数据也重复更新了，所以我们要基于key创建一个收集者，专门用于保存某个属性key的观察者。这里我们把依赖收集到dep中。</p>
</blockquote>
<p><strong>创建Dep：</strong></p>
<div><pre><code><span>class</span> <span>Dep</span> <span>{</span>
    <span>constructor</span> <span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>deps <span>=</span> <span>[</span><span>]</span>
    <span>}</span>
    <span>addDep</span> <span>(</span><span>dep</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>deps<span>.</span><span>push</span><span>(</span>dep<span>)</span>
    <span>}</span>
    <span>notify</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>deps<span>.</span><span>forEach</span><span>(</span><span>dep</span> <span>=></span> dep<span>.</span><span>update</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p><strong>在dep中保存当前watcher</strong></p>
<div><pre><code><span>class</span> <span>Watcher</span> <span>{</span>
    <span>constructor</span><span>(</span><span>vm<span>,</span> key<span>,</span> updateFn</span><span>)</span> <span>{</span>
        <span>// kvue实例</span>
        <span>this</span><span>.</span>vm <span>=</span> vm<span>;</span>
        <span>// 依赖key</span>
        <span>this</span><span>.</span>key <span>=</span> key<span>;</span>
        <span>// 更新函数</span>
        <span>this</span><span>.</span>updateFn <span>=</span> updateFn<span>;</span>
        <span>// 将当前的watcher保存到dep中</span>
<span>+</span>        Dep<span>.</span>target <span>=</span> <span>this</span><span>;</span>
        <span>// 读取属性会执行getter函数</span>
<span>+</span>        <span>this</span><span>.</span>vm<span>[</span><span>this</span><span>.</span>key<span>]</span><span>;</span>
<span>+</span>        Dep<span>.</span>target <span>=</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>// 更新</span>
    <span>update</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>updateFn</span><span>.</span><span>call</span><span>(</span><span>this</span><span>.</span>vm<span>,</span> <span>this</span><span>.</span>vm<span>[</span><span>this</span><span>.</span>key<span>]</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><p><strong>依赖收集，创建Dep实例：</strong></p>
<div><pre><code><span>// 封装响应式函数</span>
<span>function</span> <span>defineReactive</span><span>(</span><span>obj<span>,</span> key<span>,</span> val</span><span>)</span> <span>{</span>
    <span>observe</span><span>(</span>val<span>)</span><span>;</span>
    <span>// 在对key的值进行响应化的时候，创建一个dep，专门用于收集key的watcher</span>
    <span>const</span> dep <span>=</span> <span>new</span> <span>Dep</span><span>(</span><span>)</span>
    Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
        <span>get</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>get </span><span><span>${</span>key<span>}</span></span><span>:</span><span><span>${</span>val<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
            <span>// 我们可以从上一步中读取到收集的watcher,然后将其保存到dep中；</span>
            Dep<span>.</span>target <span>&amp;&amp;</span> dep<span>.</span><span>addDep</span><span>(</span>Dep<span>.</span>target<span>)</span><span>;</span>
            <span>return</span> val
        <span>}</span><span>,</span>
        <span>set</span><span>(</span>newVal<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>newVal <span>!==</span> val<span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>set </span><span><span>${</span>key<span>}</span></span><span>:</span><span><span>${</span>newVal<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
                val <span>=</span> newVal
            <span>}</span>
        <span>}</span><span>,</span>
    <span>}</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="指定派发更新"> <strong>指定派发更新</strong>：</h3>
<div><pre><code><span>// 封装响应式函数</span>
<span>function</span> <span>defineReactive</span><span>(</span><span>obj<span>,</span> key<span>,</span> val</span><span>)</span> <span>{</span>
    <span>observe</span><span>(</span>val<span>)</span><span>;</span>
    <span>const</span> dep <span>=</span> <span>new</span> <span>Dep</span><span>(</span><span>)</span>
    Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
        <span>get</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>get </span><span><span>${</span>key<span>}</span></span><span>:</span><span><span>${</span>val<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
            Dep<span>.</span>target <span>&amp;&amp;</span> dep<span>.</span><span>addDep</span><span>(</span>Dep<span>.</span>target<span>)</span><span>;</span>
            <span>return</span> val
        <span>}</span><span>,</span>
        <span>set</span><span>(</span>newVal<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>newVal <span>!==</span> val<span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>set </span><span><span>${</span>key<span>}</span></span><span>:</span><span><span>${</span>newVal<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
                <span>// 通知使用到这个key的所有地方</span>
<span>+</span>                dep<span>.</span><span>notify</span><span>(</span><span>)</span><span>;</span>
                val <span>=</span> newVal
            <span>}</span>
        <span>}</span><span>,</span>
    <span>}</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><blockquote>
<p>通过<code>dep.notify()</code>我们就可以通知更新所有使用到这个key的所有观察者，这样dep key watcher就关联到一起了；</p>
</blockquote>
<h2 id="数组响应式"> 数组响应式</h2>
<blockquote>
<p>在前面的代码中我们只实现了对象的响应式，并不能对数组进行响应式，数组的响应式代码如下：</p>
</blockquote>
<p>数据的响应式的详细介绍：<a href="(./vue-note-02-02.md)">响应式原理(数组)</a>；</p>
<p><strong>添加如下代码：</strong></p>
<div><pre><code><span>// 数组的响应式</span>
<span>const</span> originPrototype  <span>=</span> <span>Array</span><span>.</span>prototype<span>;</span>
<span>const</span> arrayPrototype <span>=</span> Object<span>.</span><span>create</span><span>(</span>originPrototype<span>)</span><span>;</span>
<span>// 修改方法 这里我只写了2个 做演示</span>
<span>[</span><span>'push'</span><span>,</span> <span>'pop'</span><span>]</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span>method</span><span>)</span> <span>=></span> <span>{</span>
    arrayPrototype<span>[</span>method<span>]</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>// 原始操作</span>
        originPrototype<span>[</span>method<span>]</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> arguments<span>)</span><span>;</span>
        <span>// 通知更新</span>
        <span>const</span> ob <span>=</span> <span>this</span><span>.</span>__ob__<span>;</span>
        ob<span>.</span>dep<span>.</span><span>notify</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span>

<span>// 往数组对象中添加一个不可遍历属性 __ob__</span>
<span>function</span> <span>def</span> <span>(</span><span>obj<span>,</span> key<span>,</span> val<span>,</span> enumerable</span><span>)</span> <span>{</span>
    Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
        value<span>:</span> val<span>,</span>
        enumerable<span>:</span> <span>!</span><span>!</span>enumerable<span>,</span>
        writable<span>:</span> <span>true</span><span>,</span>
        configurable<span>:</span> <span>true</span><span>,</span>
    <span>}</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p><strong>修改:  <code>Observer</code></strong></p>
<div><pre><code><span>class</span> <span>Observer</span> <span>{</span>
    <span>constructor</span><span>(</span><span>value</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>value <span>=</span> value<span>;</span>
        <span>// 用于收集数组的依赖</span>
<span>+</span>        <span>this</span><span>.</span>dep <span>=</span> <span>new</span> <span>Dep</span><span>(</span><span>)</span><span>;</span>
        <span>// 用于在数组中获取 observer 执行更新；</span>
<span>+</span>        <span>def</span><span>(</span>value<span>,</span> <span>'__ob__'</span><span>,</span> <span>this</span><span>)</span>

        <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>value<span>)</span><span>)</span> <span>{</span>
            <span>// 往数组上挂载我们修改过的数组方法；</span>
<span>+</span>            value<span>.</span>__proto__ <span>=</span> arrayPrototype<span>;</span>
            <span>// 数组的子项也执行响应式</span>
<span>+</span>            value<span>.</span><span>forEach</span><span>(</span><span>(</span><span>item</span><span>)</span> <span>=></span> <span>{</span>
                <span>observe</span><span>(</span>item<span>)</span><span>;</span>
            <span>}</span><span>)</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>this</span><span>.</span><span>walk</span><span>(</span>value<span>)</span><span>;</span>
        <span>}</span>

    <span>}</span>
<span>...</span>省略
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p><strong>修改：<code>defineReactive</code></strong></p>
<div><pre><code><span>// 劫持监听所有属性；</span>
<span>function</span> <span>observe</span><span>(</span><span>obj</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span><span>(</span>obj <span>instanceof</span> <span>Object</span><span>)</span> <span>||</span> obj <span>===</span> <span>null</span> <span>||</span> obj <span>===</span> <span>undefined</span><span>)</span> <span>return</span><span>;</span>
<span>+</span>    <span>return</span> <span>new</span> <span>Observer</span><span>(</span>obj<span>)</span><span>;</span>
<span>}</span>

<span>// 封装响应式函数</span>
<span>function</span> <span>defineReactive</span><span>(</span><span>obj<span>,</span> key<span>,</span> val</span><span>)</span> <span>{</span>
    <span>// 解决对象嵌套问题</span>
<span>+</span>    <span>const</span> childOb <span>=</span> <span>observe</span><span>(</span>val<span>)</span><span>;</span>
    <span>// 每读取一个属性就创建一个dep；</span>
    <span>const</span> dep <span>=</span> <span>new</span> <span>Dep</span><span>(</span><span>)</span>
    Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
        <span>get</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>get </span><span><span>${</span>key<span>}</span></span><span>:</span><span><span>${</span>val<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
            <span>// 收集watcjer</span>
<span>+</span>            <span>if</span> <span>(</span>childOb<span>)</span> <span>{</span>
<span>+</span>                Dep<span>.</span>target <span>&amp;&amp;</span> childOb<span>.</span>dep<span>.</span><span>addDep</span><span>(</span>Dep<span>.</span>target<span>)</span><span>;</span>
            <span>}</span>
            Dep<span>.</span>target <span>&amp;&amp;</span> dep<span>.</span><span>addDep</span><span>(</span>Dep<span>.</span>target<span>)</span><span>;</span>
            <span>return</span> val
        <span>}</span><span>,</span>
        <span>set</span><span>(</span>newVal<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>newVal <span>!==</span> val<span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>set </span><span><span>${</span>key<span>}</span></span><span>:</span><span><span>${</span>newVal<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
                <span>// 值变化时通知所有watcher</span>
                dep<span>.</span><span>notify</span><span>(</span><span>)</span><span>;</span>
                val <span>=</span> newVal
            <span>}</span>
        <span>}</span><span>,</span>
    <span>}</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><blockquote>
<p>以上代码的就实现了数组的更新，这个时候你就可以使用push方法，往数组添加元素了；</p>
</blockquote>
<h2 id="事件绑定"> 事件绑定</h2>
<blockquote>
<p>在vue中我们会使用@来绑定事件，是我们用起来很简单，这里就简单实现下；</p>
</blockquote>
<div><pre><code><span>class</span> <span>Compile</span> <span>{</span>
    <span>...</span>省略
    <span>compileElement</span><span>(</span><span>node</span><span>)</span> <span>{</span>
        <span>let</span> nodeAttrs <span>=</span> node<span>.</span>attributes<span>;</span>
        Array<span>.</span><span>from</span><span>(</span>nodeAttrs<span>)</span><span>.</span><span>forEach</span><span>(</span><span>attr</span> <span>=></span> <span>{</span>
            <span>let</span> attrName <span>=</span> attr<span>.</span>name<span>;</span>
            <span>let</span> exp <span>=</span> attr<span>.</span>value<span>;</span>
            <span>if</span> <span>(</span><span>this</span><span>.</span><span>isDirective</span><span>(</span>attrName<span>)</span><span>)</span> <span>{</span>
                <span>let</span> dir <span>=</span> attrName<span>.</span><span>substring</span><span>(</span><span>2</span><span>)</span><span>;</span>
                <span>this</span><span>[</span>dir<span>]</span> <span>&amp;&amp;</span> <span>this</span><span>[</span>dir<span>]</span><span>(</span>node<span>,</span> exp<span>)</span><span>;</span>
            <span>}</span>
<span>+</span>            <span>if</span> <span>(</span><span>this</span><span>.</span><span>isEvent</span><span>(</span>attrName<span>)</span><span>)</span> <span>{</span>
                <span>// 截取事件名</span>
                <span>const</span> dir <span>=</span> attrName<span>.</span><span>substring</span><span>(</span><span>1</span><span>)</span><span>;</span>
                <span>// 事件监听</span>
                <span>this</span><span>.</span><span>eventHandler</span><span>(</span>node<span>,</span> dir<span>,</span> exp<span>)</span>
            <span>}</span>
        <span>}</span><span>)</span>
    <span>}</span>

<span>+</span>	<span>isEvent</span><span>(</span><span>dir</span><span>)</span> <span>{</span>
        <span>return</span> dir<span>.</span><span>indexOf</span><span>(</span><span>'@'</span><span>)</span> <span>===</span> <span>0</span>
    <span>}</span>

    <span>// 绑定事件</span>
<span>+</span>    <span>eventHandler</span><span>(</span><span>node<span>,</span> dir<span>,</span> exp</span><span>)</span><span>{</span>
        node<span>.</span><span>addEventListener</span><span>(</span>dir<span>,</span> <span>this</span><span>.</span>$vm<span>.</span>$options<span>.</span>methods<span>[</span>exp<span>]</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>.</span>$vm<span>)</span><span>)</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><blockquote>
<p>添加以上代码后就可以使用<code>@click</code>来绑定事件了；</p>
</blockquote>
<h2 id="实现v-model"> 实现<code>v-model</code></h2>
<blockquote>
<p>v-model实际上只是个语法糖而已，它的实质就是绑定了一个事件，然后完成赋值操作了；</p>
</blockquote>
<div><pre><code><span>class</span> <span>Compile</span> <span>{</span>
	<span>// v-model</span>
    <span>model</span><span>(</span><span>node<span>,</span> exp</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>update</span><span>(</span>node<span>,</span> exp<span>,</span> <span>'model'</span><span>)</span>

        node<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>e</span> <span>=></span> <span>{</span>
            <span>this</span><span>.</span>$vm<span>[</span>exp<span>]</span> <span>=</span> e<span>.</span>target<span>.</span>value<span>;</span>
        <span>}</span><span>)</span>
    <span>}</span>

    <span>// 表单元素赋值</span>
    <span>modelUpdater</span><span>(</span><span>node<span>,</span> value</span><span>)</span> <span>{</span>
        node<span>.</span>value <span>=</span> value<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="完整代码"> 完整代码</h2>
<div><pre><code><span>// vue类</span>
<span>class</span> <span>Vue</span> <span>{</span>
    <span>constructor</span><span>(</span><span>options</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>$options <span>=</span> options<span>;</span>
        <span>this</span><span>.</span>$data <span>=</span> options<span>.</span>data<span>;</span>

        <span>// 初始化data转化为get/set</span>
        <span>observe</span><span>(</span><span>this</span><span>.</span>$data<span>)</span>
        <span>// 代理所有的data</span>
        <span>proxy</span><span>(</span><span>this</span><span>)</span><span>;</span>
        <span>// 编译模板</span>
        <span>new</span> <span>Compile</span><span>(</span>options<span>.</span>el<span>,</span> <span>this</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>// 封装响应式函数</span>
<span>function</span> <span>defineReactive</span><span>(</span><span>obj<span>,</span> key<span>,</span> val</span><span>)</span> <span>{</span>
    <span>// 解决对象嵌套问题</span>
    <span>const</span> childOb <span>=</span> <span>observe</span><span>(</span>val<span>)</span><span>;</span>
    <span>// 每读取一个属性就创建一个dep；</span>
    <span>const</span> dep <span>=</span> <span>new</span> <span>Dep</span><span>(</span><span>)</span>
    Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
        <span>get</span><span>(</span><span>)</span> <span>{</span>
            console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>get </span><span><span>${</span>key<span>}</span></span><span>:</span><span><span>${</span>val<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
            <span>// 收集watcjer 这一步是处理数组的情况</span>
            <span>if</span> <span>(</span>childOb<span>)</span> <span>{</span>
                Dep<span>.</span>target <span>&amp;&amp;</span> childOb<span>.</span>dep<span>.</span><span>addDep</span><span>(</span>Dep<span>.</span>target<span>)</span><span>;</span>
            <span>}</span>
            Dep<span>.</span>target <span>&amp;&amp;</span> dep<span>.</span><span>addDep</span><span>(</span>Dep<span>.</span>target<span>)</span><span>;</span>
            <span>return</span> val
        <span>}</span><span>,</span>
        <span>set</span><span>(</span>newVal<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>newVal <span>!==</span> val<span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span><span>`</span><span>set </span><span><span>${</span>key<span>}</span></span><span>:</span><span><span>${</span>newVal<span>}</span></span><span>`</span></span><span>)</span><span>;</span>
                <span>// 值变化时通知所有watcher</span>
                val <span>=</span> newVal
                dep<span>.</span><span>notify</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>,</span>
    <span>}</span><span>)</span>
<span>}</span>

<span>// 劫持监听所有属性；</span>
<span>function</span> <span>observe</span><span>(</span><span>obj</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span><span>(</span>obj <span>instanceof</span> <span>Object</span><span>)</span> <span>||</span> obj <span>===</span> <span>null</span> <span>||</span> obj <span>===</span> <span>undefined</span><span>)</span> <span>return</span><span>;</span>
    <span>return</span> <span>new</span> <span>Observer</span><span>(</span>obj<span>)</span><span>;</span>
<span>}</span>

<span>class</span> <span>Observer</span> <span>{</span>
    <span>constructor</span><span>(</span><span>value</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>value <span>=</span> value<span>;</span>
        <span>this</span><span>.</span>dep <span>=</span> <span>new</span> <span>Dep</span><span>(</span><span>)</span><span>;</span>
        <span>// 添加一个不可遍历属性，并保存Oberver实例</span>
        <span>def</span><span>(</span>value<span>,</span> <span>'__ob__'</span><span>,</span> <span>this</span><span>)</span>

        <span>if</span> <span>(</span>Array<span>.</span><span>isArray</span><span>(</span>value<span>)</span><span>)</span> <span>{</span>
            value<span>.</span>__proto__ <span>=</span> arrayPrototype<span>;</span>
            value<span>.</span><span>forEach</span><span>(</span><span>(</span><span>item</span><span>)</span> <span>=></span> <span>{</span>
                <span>observe</span><span>(</span>item<span>)</span><span>;</span>
            <span>}</span><span>)</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>this</span><span>.</span><span>walk</span><span>(</span>value<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>// 遍历属性转化为响应式</span>
    <span>walk</span><span>(</span><span>value</span><span>)</span> <span>{</span>
        Object<span>.</span><span>keys</span><span>(</span>value<span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span>key</span><span>)</span> <span>=></span> <span>{</span>
            <span>defineReactive</span><span>(</span>value<span>,</span> key<span>,</span> value<span>[</span>key<span>]</span><span>)</span>
        <span>}</span><span>)</span>
    <span>}</span>
<span>}</span>

<span>// 模板编译</span>
<span>class</span> <span>Compile</span> <span>{</span>
    <span>constructor</span><span>(</span><span>el<span>,</span> vm</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>$vm <span>=</span> vm<span>;</span>
        <span>// 读取根节点</span>
        <span>this</span><span>.</span>$el <span>=</span> document<span>.</span><span>querySelector</span><span>(</span>el<span>)</span><span>;</span>

        <span>// 初始化根节点</span>
        <span>if</span> <span>(</span><span>this</span><span>.</span>$el<span>)</span> <span>{</span>
            <span>this</span><span>.</span><span>compile</span><span>(</span><span>this</span><span>.</span>$el<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>compile</span><span>(</span><span>el</span><span>)</span> <span>{</span>
        <span>const</span> childNodes <span>=</span> el<span>.</span>childNodes<span>;</span>
        Array<span>.</span><span>from</span><span>(</span>childNodes<span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span>node</span><span>)</span> <span>=></span> <span>{</span>
            <span>if</span> <span>(</span><span>this</span><span>.</span><span>isElement</span><span>(</span>node<span>)</span><span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span>'编译元素：'</span><span>,</span> node<span>.</span>nodeName<span>)</span>
                <span>this</span><span>.</span><span>compileElement</span><span>(</span>node<span>)</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>this</span><span>.</span><span>isInterPolation</span><span>(</span>node<span>)</span><span>)</span> <span>{</span>
                console<span>.</span><span>log</span><span>(</span><span>'编译插值文本：'</span><span>,</span> node<span>.</span>textContent<span>)</span><span>;</span>
                <span>this</span><span>.</span><span>compileText</span><span>(</span>node<span>)</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>node<span>.</span>childNodes <span>&amp;&amp;</span> node<span>.</span>childNodes<span>.</span>length<span>)</span> <span>{</span>
                <span>this</span><span>.</span><span>compile</span><span>(</span>node<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span>
    <span>}</span>

    <span>isElement</span><span>(</span><span>node</span><span>)</span> <span>{</span>
        <span>return</span> node<span>.</span>nodeType <span>===</span> <span>1</span><span>;</span>
    <span>}</span>

    <span>isInterPolation</span><span>(</span><span>node</span><span>)</span> <span>{</span>
        <span>return</span> node<span>.</span>nodeType <span>===</span> <span>3</span> <span>&amp;&amp;</span> <span><span>/</span><span>\{\{(.*)\}\}</span><span>/</span></span><span>.</span><span>test</span><span>(</span>node<span>.</span>textContent<span>)</span><span>;</span>
    <span>}</span>

    <span>compileElement</span><span>(</span><span>node</span><span>)</span> <span>{</span>
        <span>let</span> nodeAttrs <span>=</span> node<span>.</span>attributes<span>;</span>
        Array<span>.</span><span>from</span><span>(</span>nodeAttrs<span>)</span><span>.</span><span>forEach</span><span>(</span><span>attr</span> <span>=></span> <span>{</span>
            <span>let</span> attrName <span>=</span> attr<span>.</span>name<span>;</span>
            <span>let</span> exp <span>=</span> attr<span>.</span>value<span>;</span>
            <span>if</span> <span>(</span><span>this</span><span>.</span><span>isDirective</span><span>(</span>attrName<span>)</span><span>)</span> <span>{</span>
                <span>let</span> dir <span>=</span> attrName<span>.</span><span>substring</span><span>(</span><span>2</span><span>)</span><span>;</span>
                <span>this</span><span>[</span>dir<span>]</span> <span>&amp;&amp;</span> <span>this</span><span>[</span>dir<span>]</span><span>(</span>node<span>,</span> exp<span>)</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span><span>this</span><span>.</span><span>isEvent</span><span>(</span>attrName<span>)</span><span>)</span> <span>{</span>
                <span>// 截取事件名</span>
                <span>const</span> dir <span>=</span> attrName<span>.</span><span>substring</span><span>(</span><span>1</span><span>)</span><span>;</span>
                <span>// 事件监听</span>
                <span>this</span><span>.</span><span>eventHandler</span><span>(</span>node<span>,</span> dir<span>,</span> exp<span>)</span>
            <span>}</span>
        <span>}</span><span>)</span>
    <span>}</span>

    <span>// 判断是否是指令</span>
    <span>isDirective</span><span>(</span><span>attr</span><span>)</span> <span>{</span>
        <span>return</span> attr<span>.</span><span>indexOf</span><span>(</span><span>'v-'</span><span>)</span> <span>==</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>// v-text</span>
    <span>text</span><span>(</span><span>node<span>,</span> exp</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>update</span><span>(</span>node<span>,</span> exp<span>,</span> <span>'text'</span><span>)</span>
    <span>}</span>

    <span>// v-html</span>
    <span>html</span><span>(</span><span>node<span>,</span> exp</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>update</span><span>(</span>node<span>,</span> exp<span>,</span> <span>'html'</span><span>)</span>
    <span>}</span>

    <span>// {{xxxx}}</span>
    <span>compileText</span><span>(</span><span>node</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>update</span><span>(</span>node<span>,</span> RegExp<span>.</span>$<span>1</span><span>,</span> <span>'text'</span><span>)</span>
    <span>}</span>

    <span>// 更新并创建watchet</span>
    <span>update</span><span>(</span><span>node<span>,</span> exp<span>,</span> dir</span><span>)</span> <span>{</span>
        <span>const</span> fn <span>=</span> <span>this</span><span>[</span>dir<span>+</span><span>'Updater'</span><span>]</span>
        fn <span>&amp;&amp;</span> <span>fn</span><span>(</span>node<span>,</span> <span>this</span><span>.</span>$vm<span>[</span>exp<span>]</span><span>)</span>
        <span>new</span> <span>Watcher</span><span>(</span><span>this</span><span>.</span>$vm<span>,</span> exp<span>,</span> <span>function</span><span>(</span><span>val</span><span>)</span><span>{</span>
            fn <span>&amp;&amp;</span> <span>fn</span><span>(</span>node<span>,</span> val<span>)</span>
        <span>}</span><span>)</span>
    <span>}</span>
    <span>textUpdater</span><span>(</span><span>node<span>,</span> val</span><span>)</span> <span>{</span>
        node<span>.</span>textContent <span>=</span> val<span>;</span>
    <span>}</span>
    <span>htmlUpdater</span><span>(</span><span>node<span>,</span> val</span><span>)</span> <span>{</span>
        node<span>.</span>innerHTML <span>=</span> val
    <span>}</span>

    <span>isEvent</span><span>(</span><span>dir</span><span>)</span> <span>{</span>
        <span>return</span> dir<span>.</span><span>indexOf</span><span>(</span><span>'@'</span><span>)</span> <span>===</span> <span>0</span>
    <span>}</span>

    <span>// 绑定事件</span>
    <span>eventHandler</span><span>(</span><span>node<span>,</span> dir<span>,</span> exp</span><span>)</span><span>{</span>
        node<span>.</span><span>addEventListener</span><span>(</span>dir<span>,</span> <span>this</span><span>.</span>$vm<span>.</span>$options<span>.</span>methods<span>[</span>exp<span>]</span><span>.</span><span>bind</span><span>(</span><span>this</span><span>.</span>$vm<span>)</span><span>)</span>
    <span>}</span>

    <span>// v-model</span>
    <span>model</span><span>(</span><span>node<span>,</span> exp</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>update</span><span>(</span>node<span>,</span> exp<span>,</span> <span>'model'</span><span>)</span>

        node<span>.</span><span>addEventListener</span><span>(</span><span>'input'</span><span>,</span> <span>e</span> <span>=></span> <span>{</span>
            <span>this</span><span>.</span>$vm<span>[</span>exp<span>]</span> <span>=</span> e<span>.</span>target<span>.</span>value<span>;</span>
        <span>}</span><span>)</span>
    <span>}</span>

    <span>// 表单元素赋值</span>
    <span>modelUpdater</span><span>(</span><span>node<span>,</span> value</span><span>)</span> <span>{</span>
        node<span>.</span>value <span>=</span> value<span>;</span>
    <span>}</span>
<span>}</span>

<span>// 监听器：负责更新视图</span>
<span>class</span> <span>Watcher</span> <span>{</span>
    <span>constructor</span><span>(</span><span>vm<span>,</span> key<span>,</span> updateFn</span><span>)</span> <span>{</span>
        <span>// kvue实例</span>
        <span>this</span><span>.</span>vm <span>=</span> vm<span>;</span>
        <span>// 依赖key</span>
        <span>this</span><span>.</span>key <span>=</span> key<span>;</span>
        <span>// 更新函数</span>
        <span>this</span><span>.</span>updateFn <span>=</span> updateFn<span>;</span>
        <span>// 将当前的watcher保存到dep中</span>
        Dep<span>.</span>target <span>=</span> <span>this</span><span>;</span>
        <span>// 读取属性会执行getter函数</span>
        <span>this</span><span>.</span>vm<span>[</span><span>this</span><span>.</span>key<span>]</span><span>;</span>
        Dep<span>.</span>target <span>=</span> <span>null</span><span>;</span>
    <span>}</span>
    <span>// 更新</span>
    <span>update</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>updateFn</span><span>.</span><span>call</span><span>(</span><span>this</span><span>.</span>vm<span>,</span> <span>this</span><span>.</span>vm<span>[</span><span>this</span><span>.</span>key<span>]</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>// 依赖收集者</span>
<span>class</span> <span>Dep</span> <span>{</span>
    <span>constructor</span> <span>(</span><span>)</span> <span>{</span>
        <span>// 保存所有的watcher</span>
        <span>this</span><span>.</span>deps <span>=</span> <span>[</span><span>]</span>
    <span>}</span>
    <span>addDep</span> <span>(</span><span>dep</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>deps<span>.</span><span>push</span><span>(</span>dep<span>)</span>
    <span>}</span>
    <span>// 派发通知</span>
    <span>notify</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>deps<span>.</span><span>forEach</span><span>(</span><span>dep</span> <span>=></span> dep<span>.</span><span>update</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>


<span>// 数组的响应式</span>
<span>const</span> originPrototype  <span>=</span> <span>Array</span><span>.</span>prototype<span>;</span>
<span>const</span> arrayPrototype <span>=</span> Object<span>.</span><span>create</span><span>(</span>originPrototype<span>)</span><span>;</span>
<span>// 修改方法</span>
<span>[</span><span>'push'</span><span>,</span> <span>'pop'</span><span>]</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span>method</span><span>)</span> <span>=></span> <span>{</span>
    arrayPrototype<span>[</span>method<span>]</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>// 原始操作</span>
        originPrototype<span>[</span>method<span>]</span><span>.</span><span>apply</span><span>(</span><span>this</span><span>,</span> arguments<span>)</span><span>;</span>
        <span>// 通知更新</span>
        <span>const</span> ob <span>=</span> <span>this</span><span>.</span>__ob__<span>;</span>
        ob<span>.</span>dep<span>.</span><span>notify</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span>

<span>function</span> <span>def</span> <span>(</span><span>obj<span>,</span> key<span>,</span> val<span>,</span> enumerable</span><span>)</span> <span>{</span>
    Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> key<span>,</span> <span>{</span>
        value<span>:</span> val<span>,</span>
        enumerable<span>:</span> <span>!</span><span>!</span>enumerable<span>,</span>
        writable<span>:</span> <span>true</span><span>,</span>
        configurable<span>:</span> <span>true</span><span>,</span>
    <span>}</span><span>)</span>
<span>}</span>

<span>// 为vue做代理访问，这样就可以简化访问了；</span>
<span>function</span> <span>proxy</span><span>(</span><span>vm</span><span>)</span> <span>{</span>
    Object<span>.</span><span>keys</span><span>(</span>vm<span>.</span>$data<span>)</span><span>.</span><span>forEach</span><span>(</span><span>(</span><span>key</span><span>)</span> <span>=></span> <span>{</span>
        Object<span>.</span><span>defineProperty</span><span>(</span>vm<span>,</span> key<span>,</span> <span>{</span>
            <span>get</span><span>(</span><span>)</span> <span>{</span>
                <span>return</span> vm<span>.</span>$data<span>[</span>key<span>]</span><span>;</span>
            <span>}</span><span>,</span>
            <span>set</span><span>(</span>newVal<span>)</span> <span>{</span>
                vm<span>.</span>$data<span>[</span>key<span>]</span> <span>=</span> newVal<span>;</span>
            <span>}</span><span>,</span>
        <span>}</span><span>)</span>
    <span>}</span><span>)</span>
<span>}</span>

window<span>.</span>Vue <span>=</span> Vue<span>;</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br></div></div><div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span><span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
    {{count}}
    <span><span><span>&lt;</span>h1</span> <span>v-html</span><span><span>=</span><span>"</span>html<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>h1</span><span>></span></span>
    {{name}}
    <span><span><span>&lt;</span>h1</span><span>></span></span>{{arr}}<span><span><span>&lt;/</span>h1</span><span>></span></span>
    <span><span><span>&lt;</span>button</span> <span>@click</span><span><span>=</span><span>"</span>onClick<span>"</span></span><span>></span></span>加<span><span><span>&lt;/</span>button</span><span>></span></span>
    <span><span><span>&lt;</span>h5</span><span>></span></span>{{text}}<span><span><span>&lt;/</span>h5</span><span>></span></span>
    <span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>v-model</span><span><span>=</span><span>"</span>text<span>"</span></span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>./vue.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
    <span>const</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
        el<span>:</span> <span>'#app'</span><span>,</span>
        data<span>:</span> <span>{</span>
            count<span>:</span> <span>1</span><span>,</span>
            name<span>:</span> <span>'小明'</span><span>,</span>
            html<span>:</span> <span><span>`</span><span>&lt;p>345&lt;/p></span><span>`</span></span><span>,</span>
            arr<span>:</span> <span>[</span><span>1</span><span>,</span><span>2</span><span>,</span><span>3</span><span>]</span><span>,</span>
            text<span>:</span> <span>'22222222'</span>
        <span>}</span><span>,</span>
        methods<span>:</span> <span>{</span>
            <span>onClick</span><span>(</span><span>)</span> <span>{</span>
                <span>this</span><span>.</span>count<span>++</span><span>;</span>
                console<span>.</span><span>log</span><span>(</span><span>this</span><span>.</span>count<span>)</span>
            <span>}</span>
        <span>}</span>
    <span>}</span><span>)</span>
    
    <span>// setInterval(() => {</span>
        <span>// app.count++</span>
        <span>// app.html = `&lt;p>${new Date().toLocaleTimeString()}&lt;/p>`</span>
        <span>// app.arr.push(app.count)</span>
    <span>// }, 1000);</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div><blockquote>
<p>至此我们的vue框架就结束了，这只是为了学习而实现的一个简单vue框架demo，更复杂的功能就不尝试了，主要就是为了了解veu的工作方式；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>ssr介绍</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-17/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-17/</guid>
      <source url="https://wangyawei.top/rss.xml">ssr介绍</source>
      <category>vue</category>
      <pubDate>Wed, 08 Sep 2021 20:25:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Vue.js 是构建客户端应用程序的框架。默认情况下，可以在浏览器中输出 Vue 组件，进行生成 DOM 和操作 DOM。然而，也可以将同一个组件渲染为服务器端的 HTML 字符串，将它们直接发送到浏览器，最后将这些静态标记&quot;激活&quot;为客户端上完全可交互的应用程序。</p>
</blockquote>
<div><p>提示</p>
<p>服务器渲染的 Vue.js 应用程序也可以被认为是&quot;同构&quot;或&quot;通用&quot;，因为应用程序的大部分代码都可以在<strong>服务器</strong>和<strong>客户端</strong>上运行。</p>
</div>
<h2 id="理解ssr"> 理解SSR</h2>
<ul>
<li>传统服务端渲染SSR</li>
<li>单页面应用SPA</li>
<li>服务端渲染SSR</li>
</ul>
<h2 id="传统web开发"> 传统WEB开发</h2>
<blockquote>
<p>传统web开发，网页内容在服务端渲染完成，一次性传输到浏览器</p>
</blockquote>
<p><img src="./assets/image-20210908231545949.png" alt="image-20210908231545949" /></p>
<h2 id="单页应用spa"> 单页应用SPA</h2>
<blockquote>
<p>单页应用优秀的用户体验，使其逐渐成为主流，页面内容由JS渲染出来，这种方式称为客户端渲染</p>
</blockquote>
<p><img src="./assets/image-20210908231746302.png" alt="image-20210908231746302" /></p>
<p><strong>vue的项目中，浏览器拿到的仅有宿主元素#app，并没有内容。</strong></p>
<h2 id="服务端渲染"> 服务端渲染</h2>
<blockquote>
<p>SSR解决方案，后端渲染出完整的首屏的dom结构返回，前端拿到的内容包括首屏及完整spa结构，应用激活后依然按照spa方式运行，这种页面渲染方式被称为服务端渲染 (server side render)</p>
</blockquote>
<p><img src="./assets/image-20210908232018498.png" alt="image-20210908232018498" /></p>
<h2 id="为什么使用服务器端渲染-ssr"> 为什么使用服务器端渲染 (SSR)？</h2>
<p>与传统 SPA (单页应用程序 (Single-Page Application)) 相比，服务器端渲染 (SSR) 的优势主要在于：</p>
<ul>
<li>
<p>更好的 SEO。搜索引擎爬虫抓取工具可以直接查看完全渲染的页面。</p>
</li>
<li>
<p>更快的内容到达时间 (time-to-content)，特别是对于缓慢的网络情况或运行缓慢的设备。</p>
<blockquote>
<p>相对于客户端渲染，服务端渲染在浏览器请求<code>URL</code>之后已经得到了一个带有数据的<code>HTML</code>文本，浏览器只需要解析<code>HTML</code>，直接构建<code>DOM</code>树就可以。而客户端渲染，需要先得到一个空的<code>HTML</code>页面，这个时候页面已经进入白屏，之后还需要经过加载并执行<code>JavaScript</code>、请求后端服务器获取数据、<code>JavaScript</code> 渲染页面几个过程才可以看到最后的页面。特别是在复杂应用中，由于需要加载 <code>JavaScript</code> 脚本，越是复杂的应用，需要加载的 <code>JavaScript</code> 脚本就越多、越大，这会导致应用的首屏加载时间非常长，进而降低了体验感。
链接：https://www.jianshu.com/p/3df5fde98995</p>
</blockquote>
</li>
</ul>
<p>使用服务器端渲染 (SSR) 时还需要有一些权衡之处：</p>
<ul>
<li>开发条件所限。浏览器特定的代码，只能在某些生命周期钩子函数 (lifecycle hook) 中使用；一些外部扩展库 (external library) 可能需要特殊处理，才能在服务器渲染应用程序中运行。</li>
<li>涉及构建设置和部署的更多要求。与可以部署在任何静态文件服务器上的完全静态单页面应用程序 (SPA) 不同，服务器渲染应用程序，需要处于 Node.js server 运行环境。</li>
<li>更多的服务器端负载。在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用 CPU 资源 (CPU-intensive - CPU 密集)，因此如果你预料在高流量环境 (high traffic) 下使用，请准备相应的服务器负载，并明智地采用缓存策略。</li>
</ul>
<div><p>提示</p>
<p>在对你的应用程序使用服务器端渲染 (SSR) 之前，你应该问的第一个问题是，是否真的需要它。这主要取决于内容到达时间 (time-to-content) 对应用程序的重要程度。例如，如果你正在构建一个内部仪表盘，初始加载时的额外几百毫秒并不重要，这种情况下去使用服务器端渲染 (SSR) 将是一个小题大作之举。然而，内容到达时间 (time-to-content) 要求是绝对关键的指标，在这种情况下，服务器端渲染 (SSR) 可以帮助你实现最佳的初始加载性能。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>vue中ssr的基本用法</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-18/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-18/</guid>
      <source url="https://wangyawei.top/rss.xml">vue中ssr的基本用法</source>
      <category>vue</category>
      <pubDate>Wed, 08 Sep 2021 20:25:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>使用vue和nodejs实现vue的ssr渲染；</p>
</blockquote>
<h2 id="初始化"> 初始化</h2>
<ol>
<li>
<p>新建文件夹</p>
<div><pre><code><span>mkdir</span> ssr
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>npm初始化</p>
<div><pre><code><span>cd</span> ./ssr
<span>npm</span> init -y
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>安装依赖</p>
<div><pre><code>npm install express --save
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>启动服务</p>
<div><pre><code><span>// app.js</span>
<span>const</span> express <span>=</span> <span>require</span><span>(</span><span>'express'</span><span>)</span><span>;</span>

<span>const</span> app <span>=</span> <span>express</span><span>(</span><span>)</span><span>;</span>

app<span>.</span><span>get</span><span>(</span><span>'/'</span><span>,</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>=></span> <span>{</span>
    res<span>.</span><span>send</span><span>(</span><span>'&lt;h1>晚上好&lt;/h1>'</span><span>)</span>
<span>}</span><span>)</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>,</span> <span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'服务启动成功！端口3000'</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></li>
</ol>
<h2 id="渲染vue实例"> 渲染Vue实例</h2>
<blockquote>
<p>前面的例子只是简单的启动了一个node服务器，下面我们将创建一个vue实例，并渲染vue组件；</p>
</blockquote>
<p><strong>安装依赖</strong></p>
<div><pre><code><span>npm</span> <span>install</span> vue vue-server-renderer --save
</code></pre>
<div><span>1</span><br></div></div><div><p>提示</p>
<ul>
<li>推荐使用 Node.js 版本 6+。</li>
<li><code>vue-server-renderer</code> 和 <code>vue</code> 必须匹配版本。</li>
<li><code>vue-server-renderer</code> 依赖一些 Node.js 原生模块，因此只能在 Node.js 中使用。</li>
</ul>
</div>
<p>我们对<code>app.js</code>文件进行修改：</p>
<div><pre><code><span>const</span> express <span>=</span> <span>require</span><span>(</span><span>'express'</span><span>)</span><span>;</span>
<span>const</span> Vue <span>=</span> <span>require</span><span>(</span><span>'vue'</span><span>)</span>
<span>const</span> renderer <span>=</span> <span>require</span><span>(</span><span>'vue-server-renderer'</span><span>)</span><span>.</span><span>createRenderer</span><span>(</span><span>)</span>

<span>const</span> app <span>=</span> <span>express</span><span>(</span><span>)</span><span>;</span>

app<span>.</span><span>get</span><span>(</span><span>'/'</span><span>,</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>=></span> <span>{</span>
    <span>// 创建vue实例</span>
    <span>const</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
        template<span>:</span> <span><span>`</span><span>&lt;h1>{{ msg }}&lt;/h1></span><span>`</span></span><span>,</span>
        data<span>:</span> <span>{</span>
            msg<span>:</span> <span>'Hello World'</span>
        <span>}</span>
    <span>}</span><span>)</span>
    <span>// 将 Vue 实例渲染为 HTML,并发送给前端</span>
    renderer<span>.</span><span>renderToString</span><span>(</span>app<span>)</span><span>.</span><span>then</span><span>(</span><span>html</span> <span>=></span> <span>{</span>
        res<span>.</span><span>send</span><span>(</span>html<span>)</span>
    <span>}</span><span>)</span>
<span>}</span><span>)</span>

app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>,</span> <span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span>err<span>)</span> <span>{</span>
        console<span>.</span><span>log</span><span>(</span><span>'服务启动成功！端口3000'</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><blockquote>
<p>重启服务器，浏览器访问：<code>http://localhost:3000</code>。至此一个简单的ssr就完成了；</p>
</blockquote>
<div><p>提示</p>
<p>现在的页面内容只有死的内容(没有交互没有点击事件)，如果要使程序可以交互还需要激活；</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>项目初始化</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-20/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-20/</guid>
      <source url="https://wangyawei.top/rss.xml">项目初始化</source>
      <category>vue</category>
      <pubDate>Wed, 08 Sep 2021 20:25:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>ssr实战开发</p>
</blockquote>
<h2 id="项目初始化"> 项目初始化</h2>
<ul>
<li>
<p>使用vue-cli创建项目</p>
<div><pre><code>vue create ssr
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>安装依赖</p>
<div><pre><code><span>npm</span> <span>install</span> vue vue-server-renderer express -D
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>确保vue、vue-server-renderer、vue-template-compiler版本一致  我的版本<code>2.6.11</code></p>
</blockquote>
</li>
<li>
<p>新建node脚本文件，并添加ssr；<code>./bin/server.js</code></p>
<div><pre><code><span>// 导入express作为渲染服务器</span>
<span>const</span> express <span>=</span> <span>require</span><span>(</span><span>"express"</span><span>)</span><span>;</span>

<span>// 导入Vue用于声明待渲染实例</span>
<span>const</span> Vue <span>=</span> <span>require</span><span>(</span><span>"vue"</span><span>)</span><span>;</span>

<span>// 导入createRenderer用于获取渲染器</span>
<span>const</span> <span>{</span> createRenderer <span>}</span> <span>=</span> <span>require</span><span>(</span><span>"vue-server-renderer"</span><span>)</span><span>;</span>

<span>// 创建express实例</span>
<span>const</span> app <span>=</span> <span>express</span><span>(</span><span>)</span><span>;</span>

<span>// 获取渲染器</span>
<span>const</span> renderer <span>=</span> <span>createRenderer</span><span>(</span><span>)</span><span>;</span>

<span>// 待渲染vue实例</span>
<span>const</span> vm <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
    template<span>:</span> <span><span>`</span><span>&lt;h1>{{name}}&lt;/h1></span><span>`</span></span><span>,</span>
    data<span>:</span> <span>{</span>
        name<span>:</span> <span>"SSR"</span>
    <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>

app<span>.</span><span>get</span><span>(</span><span>"*"</span><span>,</span> <span>async</span> <span>function</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>{</span>
    <span>try</span> <span>{</span>
        <span>// 若未传递回调函数，则返回Promise</span>
        <span>// renderToString可以将vue实例转换为html字符串</span>
        <span>const</span> html <span>=</span> <span>await</span> renderer<span>.</span><span>renderToString</span><span>(</span>vm<span>)</span><span>;</span>
        res<span>.</span><span>send</span><span>(</span>html<span>)</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span>error<span>)</span> <span>{</span>
        res<span>.</span><span>status</span><span>(</span><span>500</span><span>)</span><span>.</span><span>send</span><span>(</span><span>"Internal Server Error"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span><span>;</span>

<span>// 启动node服务</span>
app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"启动成功"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><blockquote>
<p>使用Node启动服务，<code>node ./server.js</code> 浏览器访问：<code>http://localhost:3000</code>显示SSR。</p>
</blockquote>
</li>
</ul>
<div><p>提示</p>
<p>上面的代码只是简单的完成了把vue实例转换为html的过程，但是还没有路由，没有交互，不能添加事件等；</p>
</div>
<p>项目目录</p>
<div><pre><code>ssr
├── babel.config.js
├── bin
│   └── server.js
├── package.json
├── public
│   ├── favicon.ico
│   └── index.html
├── README.md
├── src
│   ├── App.vue
│   ├── assets
│   │   └── logo.png
│   ├── components
│   │   └── HelloWorld.vue
│   └── main.js
└── yarn.lock
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>处理路由</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-30/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-30/</guid>
      <source url="https://wangyawei.top/rss.xml">处理路由</source>
      <category>vue</category>
      <pubDate>Thu, 09 Sep 2021 08:03:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>因为我们使用的是vue的服务端渲染，显然对于交互少不了路由，但是我们又不太想使用传统的服务端渲染一样，自己重新对请求url处理，然后响应不同的模板页面，既然使用的是vue，那么肯定想使用vue-router。答案是可以的；</p>
</blockquote>
<h2 id="安装"> 安装</h2>
<div><pre><code><span># @3.5.2后面会出错  @3.1.x后面不会出错</span>
<span>npm</span> <span>install</span> vue-router -D
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="使用"> 使用</h2>
<p>新建<code>src/router/index.js</code>和<code>src/views/about.vue</code>、<code>src/views/home.vue</code>文件，内容如下：</p>
<div><pre><code><span>// src/router/index.js</span>
<span>import</span> Vue <span>from</span> <span>'vue'</span><span>;</span>
<span>import</span> VueRouter <span>from</span> <span>'vue-router'</span><span>;</span>

Vue<span>.</span><span>use</span><span>(</span>VueRouter<span>)</span><span>;</span>

<span>//导出工厂函数</span>
<span>export</span> <span>function</span> <span>createRouter</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>VueRouter</span><span>(</span><span>{</span>
        routes<span>:</span> <span>[</span>
            <span>{</span>
                path<span>:</span> <span>'/'</span><span>,</span>
                <span>compoment</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>import</span><span>(</span><span>'@/views/home.vue'</span><span>)</span>
            <span>}</span><span>,</span>
            <span>{</span>
                path<span>:</span> <span>'about'</span><span>,</span>
                <span>compoment</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>import</span><span>(</span><span>'@/views/about.vue'</span><span>)</span>
            <span>}</span>
        <span>]</span>
    <span>}</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><div><pre><code><span>// src/views/about.vue</span>
<span>&lt;</span>template<span>></span>
    <span>&lt;</span>h1<span>></span>about<span>&lt;</span><span>/</span>h1<span>></span>
<span>&lt;</span><span>/</span>template<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p>上面的代码中和以往不同的是。我导出的不是一个vueRouter实例，<strong>而是一个工厂函数</strong>，之所以这样处理是因为在将来访问我们的网站的用户会又很多个，而不同的用户所访问的页面和内容都不相同，所以需要每次都返回一份最新的router给前台，从而避免污染；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>处理favicon.icon</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-25/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-25/</guid>
      <source url="https://wangyawei.top/rss.xml">处理favicon.icon</source>
      <category>vue</category>
      <pubDate>Thu, 09 Sep 2021 07:25:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>通过前面的代码你可以看出，每次我们刷新页面，浏览器都会额外的发送favicon请求，显然对于favicon这个请求我们不需要每次都对它做处理；</p>
</blockquote>
<ul>
<li>
<p>安装依赖</p>
<div><pre><code><span># 可以用于请求并指定网页的favicon图标</span>
<span>npm</span> <span>install</span> serve-favicon -S
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>使用：<code>/bin/server.js</code>添加如下代码</p>
<div><pre><code><span>const</span> favicon <span>=</span> <span>require</span><span>(</span><span>'serve-favicon'</span><span>)</span><span>;</span>
<span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span><span>;</span>

<span>// 创建express实例</span>
<span>const</span> app <span>=</span> <span>express</span><span>(</span><span>)</span><span>;</span>
<span>// 处理 favicon</span>
app<span>.</span><span>use</span><span>(</span><span>favicon</span><span>(</span>path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>'../public'</span><span>,</span> <span>'favicon.ico'</span><span>)</span><span>)</span><span>)</span>
<span>...</span>省略
<span>// 启动node服务</span>
app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"启动成功"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>
<p>添加上面的代码后，当请求到来时会先处理favicon,并返回给前端。</p>
</blockquote>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>构建流程</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-35/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-35/</guid>
      <source url="https://wangyawei.top/rss.xml">构建流程</source>
      <category>vue</category>
      <pubDate>Thu, 09 Sep 2021 08:12:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>对于客户端应用程序和服务器应用程序，我们都要使用 webpack 打包 - 服务器需要「服务器 bundle」然后用于服务器端渲染(SSR)，而「客户端 bundle」会发送给浏览器，用于混合静态标记。</p>
</blockquote>
<p><img src="./assets/image-20210909080700313.png" alt="image-20210909080700313" /></p>
<p>所以我们需要两份webpack的入口文件，分别用于客户端和服务端的打包；</p>
<div><pre><code>src
├── main.js <span># 用于创建vue实例</span>
├── entry-client.js <span># 客户端入口，用于静态内容“激活”</span>
└── entry-server.js <span># 服务端入口，用于首屏内容渲染</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>创建VUE实例</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-40/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-40/</guid>
      <source url="https://wangyawei.top/rss.xml">创建VUE实例</source>
      <category>vue</category>
      <pubDate>Thu, 09 Sep 2021 08:22:23 GMT</pubDate>
      <content:encoded><![CDATA[<p>修改<code>src/main.js</code></p>
<div><pre><code><span>import</span> Vue <span>from</span> <span>'vue'</span>
<span>import</span> App <span>from</span> <span>'./App.vue'</span>
<span>import</span> <span>{</span> createRouter <span>}</span> <span>from</span> <span>"./router"</span><span>;</span>

Vue<span>.</span>config<span>.</span>productionTip <span>=</span> <span>false</span>

<span>// 导出Vue实例工厂函数，为每次请求创建独立实例</span>
<span>export</span> <span>function</span> <span>createApp</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> router <span>=</span> <span>createRouter</span><span>(</span><span>)</span><span>;</span>
  <span>const</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
    router<span>,</span>
    <span>render</span><span>:</span> <span>h</span> <span>=></span> <span>h</span><span>(</span>App<span>)</span>
  <span>}</span><span>)</span><span>;</span>
  <span>return</span> <span>{</span> app<span>,</span> router <span>}</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><p>提示</p>
<p>这里我们也是需要导出一个vue实例的工厂函数，因为需要每次都重新创建一个全新的vue实例给前台；</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>服务端入口</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-45/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-45/</guid>
      <source url="https://wangyawei.top/rss.xml">服务端入口</source>
      <category>vue</category>
      <pubDate>Thu, 09 Sep 2021 08:22:23 GMT</pubDate>
      <content:encoded><![CDATA[<p>服务端入口文件<code>src/entry-server.js</code></p>
<div><pre><code><span>import</span> <span>{</span> createApp <span>}</span> <span>from</span> <span>"./main"</span><span>;</span>
<span>// 返回一个函数，接收请求上下文，返回创建的vue实例</span>
<span>export</span> <span>default</span> <span>context</span> <span>=></span> <span>{</span>
    <span>// 这里返回一个Promise，确保客户端入口准备就绪  </span>
    <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>
        <span>const</span> <span>{</span> app<span>,</span> router <span>}</span> <span>=</span> <span>createApp</span><span>(</span>context<span>)</span><span>;</span>
        <span>// 跳转到首屏的地址</span>
        router<span>.</span><span>push</span><span>(</span>context<span>.</span>url<span>)</span><span>;</span>
        <span>// 路由就绪，返回结果</span>
        router<span>.</span><span>onReady</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
            <span>resolve</span><span>(</span>app<span>)</span><span>;</span>
        <span>}</span><span>,</span> reject<span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>客户端入口</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-50/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-50/</guid>
      <source url="https://wangyawei.top/rss.xml">客户端入口</source>
      <category>vue</category>
      <pubDate>Thu, 09 Sep 2021 08:28:23 GMT</pubDate>
      <content:encoded><![CDATA[<p>客户端入口只需创建vue实例并执行挂载，这一步称为激活。创建entry-client.js：</p>
<div><pre><code><span>import</span> <span>{</span> createApp <span>}</span> <span>from</span> <span>"./main"</span><span>;</span>
<span>// 创建vue、router实例</span>
<span>const</span> <span>{</span> app<span>,</span> router <span>}</span> <span>=</span> <span>createApp</span><span>(</span><span>)</span><span>;</span>
<span>// 路由就绪，执行挂载</span>
router<span>.</span><span>onReady</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    app<span>.</span><span>$mount</span><span>(</span><span>"#app"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>配置webpack</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-55/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-55/</guid>
      <source url="https://wangyawei.top/rss.xml">配置webpack</source>
      <category>vue</category>
      <pubDate>Thu, 09 Sep 2021 21:10:23 GMT</pubDate>
      <content:encoded><![CDATA[<ol>
<li>安装依赖<code>npm install webpack-node-externals lodash.merge -D</code></li>
<li>在项目的根目录新建<code>vue.config.js</code>文件;</li>
</ol>
<div><pre><code><span>// vue.config.js</span>
<span>// 两个插件分别负责打包客户端和服务端</span>
<span>const</span> VueSSRServerPlugin <span>=</span> <span>require</span><span>(</span><span>"vue-server-renderer/server-plugin"</span><span>)</span><span>;</span>
<span>const</span> VueSSRClientPlugin <span>=</span> <span>require</span><span>(</span><span>"vue-server-renderer/client-plugin"</span><span>)</span><span>;</span>
<span>const</span> nodeExternals <span>=</span> <span>require</span><span>(</span><span>"webpack-node-externals"</span><span>)</span><span>;</span>
<span>const</span> merge <span>=</span> <span>require</span><span>(</span><span>"lodash.merge"</span><span>)</span><span>;</span>
<span>// 根据传入环境变量决定入口文件和相应配置项</span>
<span>const</span> <span>TARGET_NODE</span> <span>=</span> process<span>.</span>env<span>.</span><span>WEBPACK_TARGET</span> <span>===</span> <span>"node"</span><span>;</span>
<span>const</span> target <span>=</span> <span>TARGET_NODE</span> <span>?</span> <span>"server"</span> <span>:</span> <span>"client"</span><span>;</span>
module<span>.</span>exports <span>=</span> <span>{</span>
    css<span>:</span> <span>{</span>
        extract<span>:</span> <span>false</span>
    <span>}</span><span>,</span>
    outputDir<span>:</span> <span>'./dist/'</span> <span>+</span> target<span>,</span>
    <span>configureWebpack</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>(</span><span>{</span>
        <span>// 将 entry 指向应用程序的 server / client 文件</span>
        entry<span>:</span> <span><span>`</span><span>./src/entry-</span><span><span>${</span>target<span>}</span></span><span>.js</span><span>`</span></span><span>,</span>
        <span>// 对 bundle renderer 提供 source map 支持</span>
        devtool<span>:</span> <span>'source-map'</span><span>,</span>
        <span>// target设置为node使webpack以Node适用的方式处理动态导入</span>
        <span>// 并且还会在编译Vue组件时告知`vue-loader`输出面向服务器代码。</span>
        target<span>:</span> <span>TARGET_NODE</span> <span>?</span> <span>"node"</span> <span>:</span> <span>"web"</span><span>,</span>
        <span>// 是否模拟node全局变量</span>
        node<span>:</span> <span>TARGET_NODE</span> <span>?</span> <span>undefined</span> <span>:</span> <span>false</span><span>,</span>
        output<span>:</span> <span>{</span>
            <span>// 此处使用Node风格导出模块</span>
            libraryTarget<span>:</span> <span>TARGET_NODE</span> <span>?</span> <span>"commonjs2"</span> <span>:</span> <span>undefined</span>
        <span>}</span><span>,</span>
        <span>// https://webpack.js.org/configuration/externals/#function</span>
        <span>// https://github.com/liady/webpack-node-externals</span>
        <span>// 外置化应用程序依赖模块。可以使服务器构建速度更快，并生成较小的打包文件。</span>
        externals<span>:</span> <span>TARGET_NODE</span>
            <span>?</span> <span>nodeExternals</span><span>(</span><span>{</span>
                <span>// 不要外置化webpack需要处理的依赖模块。</span>
                <span>// 可以在这里添加更多的文件类型。例如，未处理 *.vue 原始文件，</span>
                <span>// 还应该将修改`global`（例如polyfill）的依赖模块列入白名单</span>
                allowlist<span>:</span> <span>[</span><span><span>/</span><span>\.css$</span><span>/</span></span><span>]</span>
            <span>}</span><span>)</span>
            <span>:</span> <span>undefined</span><span>,</span>
        optimization<span>:</span> <span>{</span>
            splitChunks<span>:</span> <span>undefined</span>
        <span>}</span><span>,</span>
        <span>// 这是将服务器的整个输出构建为单个 JSON 文件的插件。</span>
        <span>// 服务端默认文件名为 `vue-ssr-server-bundle.json`</span>
        <span>// 客户端默认文件名为 `vue-ssr-client-manifest.json`。</span>
        plugins<span>:</span> <span>[</span><span>TARGET_NODE</span> <span>?</span> <span>new</span> <span>VueSSRServerPlugin</span><span>(</span><span>)</span> <span>:</span> <span>new</span> <span>VueSSRClientPlugin</span><span>(</span><span>)</span><span>]</span>
    <span>}</span><span>)</span><span>,</span>
    <span>chainWebpack</span><span>:</span> <span>config</span> <span>=></span> <span>{</span>
        <span>// cli4项目添加</span>
        <span>if</span> <span>(</span><span>TARGET_NODE</span><span>)</span> <span>{</span>
            config<span>.</span>optimization<span>.</span><span>delete</span><span>(</span><span>'splitChunks'</span><span>)</span>
        <span>}</span>
        config<span>.</span>module
            <span>.</span><span>rule</span><span>(</span><span>"vue"</span><span>)</span>
            <span>.</span><span>use</span><span>(</span><span>"vue-loader"</span><span>)</span>
            <span>.</span><span>tap</span><span>(</span><span>options</span> <span>=></span> <span>{</span>
                <span>merge</span><span>(</span>options<span>,</span> <span>{</span>
                    optimizeSSR<span>:</span> <span>false</span>
                <span>}</span><span>)</span><span>;</span>
            <span>}</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>脚本配置</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-60/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-60/</guid>
      <source url="https://wangyawei.top/rss.xml">脚本配置</source>
      <category>vue</category>
      <pubDate>Thu, 09 Sep 2021 21:10:23 GMT</pubDate>
      <content:encoded><![CDATA[<p>由于我们需要根据环境来控制打包输出，同时为了平台的兼容，我们选择<code>cross-env</code>；</p>
<ol>
<li>
<p>安装依赖</p>
<div><pre><code><span>npm</span> i cross-env -D
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>配置脚本</p>
<div><pre><code><span>"scripts"</span><span>:</span> <span>{</span>
    <span>"build:client"</span><span>:</span> <span>"vue-cli-service build"</span><span>,</span>
    <span>"build:server"</span><span>:</span> <span>"cross-env WEBPACK_TARGET=node vue-cli-service build"</span><span>,</span>
    <span>"build"</span><span>:</span> <span>"npm run build:server &amp;&amp; npm run build:client"</span>
<span>}</span><span>,</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>打包</p>
<div><pre><code><span>npm</span> run build
</code></pre>
<div><span>1</span><br></div></div><div><p>提示</p>
<p>如果打包的过程中报：Option 'whitelist' is not supported. Did you mean 'allowlist'? ，那么就把<code>whitelist</code>改为<code>allowlist</code>即可；</p>
</div>
</li>
<li>
<p>打包结果</p>
<div><pre><code>dist
├── client
│   ├── favicon.ico
│   ├── img
│   │   └── logo.82b9c7a5.png
│   ├── index.html
│   ├── js
│   │   ├── chunk-2d0cfa15.827237a2.js
│   │   ├── chunk-2d0cfa15.827237a2.js.map
│   │   ├── chunk-2d0d6f02.9f0d2cb3.js
│   │   ├── chunk-2d0d6f02.9f0d2cb3.js.map
│   │   ├── chunk-vendors.af8121ee.js
│   │   ├── chunk-vendors.af8121ee.js.map
│   │   ├── main.152046db.js
│   │   └── main.152046db.js.map
│   └── vue-ssr-client-manifest.json
└── server
    └── vue-ssr-server-bundle.json
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><blockquote>
<ul>
<li>
<p>dist里面的文件其实需要托管到Nodejs里面的，因为前端需要下载激活；</p>
</li>
<li>
<p>vue-ssr-client-manifest.json，vue-ssr-server-bundle.json：主要用于告诉webpack首屏渲染时怎么工作，需要用到那些文件等。</p>
</li>
</ul>
</blockquote>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>宿主文件</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-65/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-65/</guid>
      <source url="https://wangyawei.top/rss.xml">宿主文件</source>
      <category>vue</category>
      <pubDate>Thu, 09 Sep 2021 21:10:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>最后需要定义宿主文件，修改./public/index.html</p>
</blockquote>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span><span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>utf-8<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>http-equiv</span><span><span>=</span><span>"</span>X-UA-Compatible<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>IE=edge<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>name</span><span><span>=</span><span>"</span>viewport<span>"</span></span> <span>content</span><span><span>=</span><span>"</span>width=device-width,initial-scale=1.0<span>"</span></span><span>></span></span>
  <span><span><span>&lt;/</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>body</span><span>></span></span>
    <span>&lt;!-- 此处必须这样写 是一种约定 --></span>
    <span>&lt;!--vue-ssr-outlet--></span>
  <span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>
<p>由于采用的服务器端渲染，所以之前的#app之类就不再需要了；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>托管静态资源</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-70/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-70/</guid>
      <source url="https://wangyawei.top/rss.xml">托管静态资源</source>
      <category>vue</category>
      <pubDate>Thu, 09 Sep 2021 21:10:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>在前面的打包输出的dist文件需要托管在Node服务中，所以需要配置静态资源托管；</p>
</blockquote>
<p>修改<code>/bin/server.js</code>文件添加如下代码：</p>
<div><pre><code>app<span>.</span><span>use</span><span>(</span>express<span>.</span><span>static</span><span>(</span><span>'../dist/client'</span><span>)</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>配置清单</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-75/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-75/</guid>
      <source url="https://wangyawei.top/rss.xml">配置清单</source>
      <category>vue</category>
      <pubDate>Thu, 09 Sep 2021 21:10:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>前面的打包文件中我们输出了，<code>vue-ssr-server-bundle.json</code>和<code>vue-ssr-client-manifest.json</code>文件，这里我们需要在服务启动时配置这两个文件；</p>
</blockquote>
<h2 id="配置修改"> 配置修改</h2>
<p>修改<code>/bin/server.js</code>文件：</p>
<div><pre><code><span>// 导入express作为渲染服务器</span>
<span>const</span> express <span>=</span> <span>require</span><span>(</span><span>"express"</span><span>)</span><span>;</span>
<span>const</span> favicon <span>=</span> <span>require</span><span>(</span><span>'serve-favicon'</span><span>)</span><span>;</span>
<span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span><span>;</span>
<span>const</span> fs <span>=</span> <span>require</span><span>(</span><span>'fs'</span><span>)</span><span>;</span>

<span>// 获取绝对路径</span>
<span>const</span> <span>resolve</span> <span>=</span> <span>dir</span> <span>=></span> <span>{</span>
    <span>return</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> dir<span>)</span>
<span>}</span>

<span>// 创建express实例</span>
<span>const</span> app <span>=</span> <span>express</span><span>(</span><span>)</span><span>;</span>

<span>// 导入createRenderer用于获取渲染器</span>
<span>const</span> <span>{</span> createBundleRenderer <span>}</span> <span>=</span> <span>require</span><span>(</span><span>"vue-server-renderer"</span><span>)</span><span>;</span>
<span>// 导入打包文件</span>
<span>const</span> bundle <span>=</span> <span>require</span><span>(</span><span>resolve</span><span>(</span><span>"../dist/server/vue-ssr-server-bundle.json"</span><span>)</span><span>)</span><span>;</span>
<span>const</span> clientManifest <span>=</span> <span>require</span><span>(</span><span>resolve</span><span>(</span><span>"../dist/client/vue-ssr-client-manifest.json"</span><span>)</span><span>)</span><span>;</span>
<span>// 导入宿主文件</span>
<span>const</span> template <span>=</span> fs<span>.</span><span>readFileSync</span><span>(</span><span>resolve</span><span>(</span><span>"../public/index.html"</span><span>)</span><span>,</span> <span>"utf-8"</span><span>)</span><span>;</span>

<span>const</span> renderer <span>=</span> <span>createBundleRenderer</span><span>(</span>bundle<span>,</span> <span>{</span>
    runInNewContext<span>:</span> <span>false</span><span>,</span> <span>// https://ssr.vuejs.org/zh/api/#runinnewcontext</span>
    template<span>,</span> <span>// 宿主文件</span>
    clientManifest <span>// 客户端清单</span>
<span>}</span><span>)</span><span>;</span>

<span>// 处理favicon图标</span>
app<span>.</span><span>use</span><span>(</span><span>favicon</span><span>(</span>path<span>.</span><span>join</span><span>(</span>__dirname<span>,</span> <span>'../public'</span><span>,</span> <span>'favicon.ico'</span><span>)</span><span>)</span><span>)</span>
app<span>.</span><span>use</span><span>(</span>express<span>.</span><span>static</span><span>(</span><span>'../dist/client'</span><span>,</span> <span>{</span>index<span>:</span> <span>false</span><span>}</span><span>)</span><span>)</span>
<span>// 路由是通配符，表示所有url都接受</span>
app<span>.</span><span>get</span><span>(</span><span>"*"</span><span>,</span> <span>function</span> <span>(</span><span>req<span>,</span> res</span><span>)</span> <span>{</span>
    <span>// 设置url参数</span>
    <span>const</span> context <span>=</span> <span>{</span>url<span>:</span> req<span>.</span>url<span>}</span>
    <span>// 若未传递回调函数，则返回Promise</span>
    <span>// renderToString可以将vue实例转换为html字符串</span>
    renderer<span>.</span><span>renderToString</span><span>(</span>context<span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>html</span><span>)</span> <span>=></span> <span>{</span>
        res<span>.</span><span>send</span><span>(</span>html<span>)</span><span>;</span>
    <span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>(</span><span>err</span><span>)</span> <span>=></span><span>{</span>
        res<span>.</span><span>status</span><span>(</span>err<span>.</span>code<span>)</span><span>.</span><span>send</span><span>(</span>err<span>.</span>msg<span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>

<span>// 启动node服务</span>
app<span>.</span><span>listen</span><span>(</span><span>3000</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"启动成功"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><blockquote>
<p>以上代码设置完毕之后，一个ssr就基本完毕了，现在你可以执行<code>npm run build</code>完成打包后执行<code>node server.js</code>;然后浏览器访问<code>http://localhost:3000</code>就可以了；</p>
</blockquote>
<p><img src="./assets/image-20210911163339080.png" alt="image-20210911163339080" /></p>
<h2 id="注意事项"> 注意事项</h2>
<ol>
<li>
<p>如果你访问的url不是正确的路由地址：<code>http://localhost:3000/qwe#/</code>类似的地址，那么你会收到控制台的报错：</p>
<p><img src="./assets/image-20210911163652266.png" alt="image-20210911163652266" /></p>
<blockquote>
<p>出现这种情况的原因是，你输入的url地址没有匹配的路由，找不到相关页面；但是这种只是针对刷新页面的时候，而且不影响路由导航。</p>
</blockquote>
</li>
<li>
<p>如果正常访问后控制台不报错，但是路由对应的页面不显示，那么这是因为你的路由对象参数写的不对：</p>
<div><pre><code><span>{</span>
    path<span>:</span> <span>'home'</span><span>,</span>
    <span>// 此处如果不小心写错了 component 那么不会出现任何的报错提示，只是路由无法显示；</span>
    component<span>:</span> Home<span>,</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>整合VUEX</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-80/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-80/</guid>
      <source url="https://wangyawei.top/rss.xml">整合VUEX</source>
      <category>vue</category>
      <pubDate>Sat, 11 Sep 2021 15:20:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>使用vue开发项目，那么vuex是必不可少的功能了，下面就添加vuex到项目中；</p>
</blockquote>
<h2 id="安装"> 安装</h2>
<div><pre><code><span>npm</span> <span>install</span> -S vuex
</code></pre>
<div><span>1</span><br></div></div><h2 id="创建createstore"> 创建createStore</h2>
<div><pre><code><span>import</span> Vue <span>from</span> <span>'vue'</span>
<span>import</span> Vuex <span>from</span> <span>'vuex'</span>

Vue<span>.</span><span>use</span><span>(</span>Vuex<span>)</span>

<span>export</span> <span>function</span> <span>createStore</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Vuex<span>.</span>Store</span><span>(</span><span>{</span>
        state<span>:</span> <span>{</span>
            count<span>:</span><span>108</span>
        <span>}</span><span>,</span>
        mutations<span>:</span> <span>{</span>
            <span>add</span><span>(</span><span>state</span><span>)</span><span>{</span>
                state<span>.</span>count <span>+=</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="挂载"> 挂载</h2>
<div><pre><code><span>import</span> Vue <span>from</span> <span>'vue'</span>
<span>import</span> App <span>from</span> <span>'./App.vue'</span>
<span>import</span> <span>{</span> createRouter <span>}</span> <span>from</span> <span>"./router"</span><span>;</span>
<span>import</span> <span>{</span> createStore <span>}</span> <span>from</span> <span>'./store'</span>

Vue<span>.</span>config<span>.</span>productionTip <span>=</span> <span>false</span>

<span>// 导出Vue实例工厂函数，为每次请求创建独立实例</span>
<span>export</span> <span>function</span> <span>createApp</span><span>(</span><span>)</span> <span>{</span>
  <span>const</span> router <span>=</span> <span>createRouter</span><span>(</span><span>)</span><span>;</span>
  <span>const</span> store <span>=</span> <span>createStore</span><span>(</span><span>)</span><span>;</span>
  <span>const</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
    router<span>,</span>
    store<span>,</span> <span>// 挂载</span>
    <span>render</span><span>:</span> <span>h</span> <span>=></span> <span>h</span><span>(</span>App<span>)</span>
  <span>}</span><span>)</span><span>;</span>
  <span>return</span> <span>{</span> app<span>,</span> store<span>,</span> router <span>}</span><span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="使用"> 使用</h2>
<div><pre><code><span>&lt;</span>h2 @click<span>=</span><span>"$store.commit('add')"</span><span>></span><span>{</span><span>{</span>$store<span>.</span>state<span>.</span>count<span>}</span><span>}</span><span>&lt;</span><span>/</span>h2<span>></span>
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>数据预取</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-85/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-85/</guid>
      <source url="https://wangyawei.top/rss.xml">数据预取</source>
      <category>vue</category>
      <pubDate>Sat, 11 Sep 2021 20:20:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>在服务器端渲染(SSR)期间，我们本质上是在渲染我们应用程序的&quot;快照&quot;，所以如果应用程序依赖于一些异步数据，<strong>那么在开始渲染过程之前，需要先预取和解析好这些数据</strong>。</p>
</blockquote>
<h2 id="异步数据获取"> 异步数据获取</h2>
<p>在这里需要先提一个小问题，其实在一开始我不太明白为什么要进行服务器端异步数据预处理？异步数据在客户端请求和在服务端请求，单对请求响应时间来说都是一样的，那为什么还要在服务端预处理异步数据呢？如果在服务端请求的接口响应时间比较长的话，那么客户端不是一样会长时间的白屏吗？</p>
<p><strong>其实答案很简单：主要是为了SEO,如果提前把异步数据加载好，那么就利于爬虫爬取我们的页面；</strong></p>
<p>修改<code>store/index.js</code></p>
<div><pre><code><span>import</span> Vue <span>from</span> <span>'vue'</span>
<span>import</span> Vuex <span>from</span> <span>'vuex'</span>

Vue<span>.</span><span>use</span><span>(</span>Vuex<span>)</span>

<span>export</span> <span>function</span> <span>createStore</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>Vuex<span>.</span>Store</span><span>(</span><span>{</span>
        state<span>:</span> <span>{</span>
            count<span>:</span><span>108</span>
        <span>}</span><span>,</span>
        mutations<span>:</span> <span>{</span>
            <span>add</span><span>(</span><span>state<span>,</span> count</span><span>)</span><span>{</span>
                state<span>.</span>count <span>=</span> count<span>;</span>
            <span>}</span>
        <span>}</span><span>,</span>
        actions<span>:</span> <span>{</span>
            <span>// 加一个异步请求count的action</span>
            <span>getCount</span><span>(</span><span><span>{</span> commit <span>}</span></span><span>)</span> <span>{</span>
                <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>resolve</span> <span>=></span> <span>{</span>
                    <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
                        <span>commit</span><span>(</span><span>"add"</span><span>,</span> Math<span>.</span><span>random</span><span>(</span><span>)</span> <span>*</span> <span>100</span><span>)</span><span>;</span>
                        <span>resolve</span><span>(</span><span>)</span><span>;</span>
                    <span>}</span><span>,</span> <span>1000</span><span>)</span><span>;</span>
                <span>}</span><span>)</span><span>;</span>
            <span>}</span><span>,</span>
        <span>}</span><span>,</span>
    <span>}</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><blockquote>
<p>这一步的主要操作是用于模拟异步请求；异步请求的数据保存在vuex里面；</p>
</blockquote>
<h2 id="组件中的数据预取"> 组件中的数据预取</h2>
<p>修改<code>views/home.vue</code></p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>
    <span><span><span>&lt;</span>div</span><span>></span></span>
        <span><span><span>&lt;</span>h2</span> <span>@click</span><span><span>=</span><span>"</span>$store.commit(<span>'</span>add<span>'</span>)<span>"</span></span><span>></span></span>{{$store.state.count}}<span><span><span>&lt;/</span>h2</span><span>></span></span>
        <span><span><span>&lt;</span>h1</span><span>></span></span>HOME<span><span><span>&lt;/</span>h1</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
    <span>// 约定预取逻辑编写在预取钩子asyncData中</span>
    <span>asyncData</span><span>(</span><span><span>{</span> store <span>}</span></span><span>)</span> <span>{</span>
        <span>// 触发action后，返回promise以便确定请求结果</span>
        <span>return</span> store<span>.</span><span>dispatch</span><span>(</span><span>'getCount'</span><span>)</span><span>;</span>
    <span>}</span><span>,</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><blockquote>
<p>在当前页面中从vuex中获取数据；</p>
</blockquote>
<h2 id="客户端数据预取"> 客户端数据预取</h2>
<p>在客户端，处理数据预取有两种不同方式：</p>
<ol>
<li>在路由导航之前解析数据</li>
<li>匹配要渲染的视图后，再获取数据</li>
</ol>
<h3 id="在路由导航之前解析数据"> 在路由导航之前解析数据</h3>
<p>修改<code>entry-server.js</code></p>
<div><pre><code><span>import</span> <span>{</span> createApp <span>}</span> <span>from</span> <span>"./main"</span><span>;</span>
<span>// 返回一个函数，接收请求上下文，返回创建的vue实例</span>
<span>export</span> <span>default</span> <span>context</span> <span>=></span> <span>{</span>
    <span>// 这里返回一个Promise，确保客户端入口准备就绪  </span>
    <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>
        <span>const</span> <span>{</span> app<span>,</span> router<span>,</span> store <span>}</span> <span>=</span> <span>createApp</span><span>(</span><span>)</span><span>;</span>
        <span>// 跳转到首屏的地址</span>
        router<span>.</span><span>push</span><span>(</span>context<span>.</span>url<span>)</span><span>;</span>
        <span>// 路由就绪，返回结果</span>
        router<span>.</span><span>onReady</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
            <span>// 获取匹配的路由组件数组</span>
            <span>const</span> matchedComponents <span>=</span> router<span>.</span><span>getMatchedComponents</span><span>(</span><span>)</span><span>;</span>

            <span>// 若无匹配则抛出异常；</span>
            <span>if</span> <span>(</span><span>!</span>matchedComponents<span>.</span>length<span>)</span> <span>{</span>
                <span>return</span> <span>reject</span><span>(</span><span>{</span> code<span>:</span> <span>404</span><span>,</span> msg<span>:</span> <span>'页面找不到！'</span> <span>}</span><span>)</span>
            <span>}</span>
            <span>// 对所有匹配的路由组件调用可能存在的asyncData();</span>
            Promise<span>.</span><span>all</span><span>(</span>matchedComponents<span>.</span><span>map</span><span>(</span><span>component</span> <span>=></span> <span>{</span>
                <span>if</span> <span>(</span>component<span>.</span>asyncData<span>)</span> <span>{</span>
                    <span>return</span> component<span>.</span><span>asyncData</span><span>(</span><span>{</span>
                        store<span>,</span>
                        route<span>:</span> router<span>.</span>currentRoute<span>,</span>
                    <span>}</span><span>)</span>
                <span>}</span>
            <span>}</span><span>)</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
                <span>// 所有预取钩子 resolve 后，</span>
                <span>// store 已经填充完预渲染应用所需数据</span>
                <span>// 将状态附加到上下文，且 `template` 选项用于 renderer 时，</span>
                <span>// 状态将自动序列化为 `window.__INITIAL_STATE__`，并注入 HTML。</span>
                context<span>.</span>state <span>=</span> store<span>.</span>state<span>;</span>
                <span>resolve</span><span>(</span>app<span>)</span><span>;</span>
            <span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span>reject<span>)</span><span>;</span>
        <span>}</span><span>,</span> reject<span>)</span><span>;</span>
    <span>}</span><span>)</span><span>;</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><blockquote>
<p>查找当前路由所有可能匹配的页面，然后调用异步请求函数获取异步请求数据，然后异步数据获取之后自动序列化为 <code>window.__INITIAL_STATE__</code>，并注入 HTML。这一步主要特点是数据在路由导航之前就解析好了。</p>
</blockquote>
<h3 id="匹配要渲染的视图后"> 匹配要渲染的视图后</h3>
<p>修改<code>main.js</code>,并添加以下代码</p>
<div><pre><code>Vue<span>.</span><span>mixin</span><span>(</span><span>{</span>
  <span>beforeMount</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> <span>{</span> asyncData <span>}</span> <span>=</span> <span>this</span><span>.</span>$options<span>;</span>
    <span>if</span> <span>(</span>asyncData<span>)</span> <span>{</span>
      <span>// 将获取数据操作分配给 promise</span>
      <span>// 以便在组件中，我们可以在数据准备就绪后</span>
      <span>// 通过运行 `this.dataPromise.then(...)` 来执行其他任务</span>
      <span>this</span><span>.</span>dataPromise <span>=</span> <span>asyncData</span><span>(</span><span>{</span>
        store<span>:</span> <span>this</span><span>.</span>$store<span>,</span>
        route<span>:</span> <span>this</span><span>.</span>$route<span>,</span>
      <span>}</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><blockquote>
<p>主要特点是：数据是在客户端获取的，在页面加载完后再发送异步请求填充数据；</p>
</blockquote>
<h2 id="客户端恢复数据"> 客户端恢复数据</h2>
<blockquote>
<p>当使用 <code>template</code> 时，<code>context.state</code> 将作为 <code>window.__INITIAL_STATE__</code> 状态，自动嵌入到最终的 HTML 中。而在客户端，在挂载到应用程序之前，store 就应该获取到状态：</p>
</blockquote>
<p>修改<code>entry-client.js</code></p>
<div><pre><code><span>import</span> <span>{</span> createApp <span>}</span> <span>from</span> <span>"./main"</span><span>;</span>
<span>// 创建vue、router实例</span>
<span>const</span> <span>{</span> app<span>,</span> router<span>,</span> store <span>}</span> <span>=</span> <span>createApp</span><span>(</span><span>)</span><span>;</span>

<span>if</span> <span>(</span>window<span>.</span>__INITIAL_STATE__<span>)</span> <span>{</span>
    store<span>.</span><span>replaceState</span><span>(</span>window<span>.</span>__INITIAL_STATE__<span>)</span><span>;</span>
<span>}</span>

<span>// 路由就绪，执行挂载</span>
router<span>.</span><span>onReady</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    app<span>.</span><span>$mount</span><span>(</span><span>"#app"</span><span>,</span> <span>true</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="url改变时重新获取数据"> url改变时重新获取数据</h2>
<blockquote>
<p>当页面url改变时，尤其是一些详情页，那么页面的数据就需要重新获取；</p>
</blockquote>
<p>修改<code>main.js</code></p>
<div><pre><code>Vue<span>.</span><span>mixin</span><span>(</span><span>{</span>
  <span>beforeUpdate</span><span>(</span><span>)</span> <span>{</span>
    <span>const</span> <span>{</span> asyncData <span>}</span> <span>=</span> <span>this</span><span>.</span>$options<span>;</span>
    <span>if</span> <span>(</span>asyncData<span>)</span> <span>{</span>
      <span>// 将获取数据操作分配给 promise</span>
      <span>// 以便在组件中，我们可以在数据准备就绪后</span>
      <span>// 通过运行 `this.dataPromise.then(...)` 来执行其他任务</span>
      <span>this</span><span>.</span>dataPromise <span>=</span> <span>asyncData</span><span>(</span><span>{</span>
        store<span>:</span> <span>this</span><span>.</span>$store<span>,</span>
        route<span>:</span> <span>this</span><span>.</span>$route<span>,</span>
      <span>}</span><span>)</span><span>;</span>
    <span>}</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><blockquote>
<p>利用全局混入，在路由路径改变时重新获取最新的数据；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>总结</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-90/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-90/</guid>
      <source url="https://wangyawei.top/rss.xml">总结</source>
      <category>vue</category>
      <pubDate>Sat, 11 Sep 2021 20:20:23 GMT</pubDate>
      <content:encoded><![CDATA[<p>通过srr的一个简单demo,梳理下vue-srr使用的心得，整个流程体验完后，感觉和直接写客户端代码没太大区别，大致流程是：</p>
<ol>
<li>srr需要node服务，所以需要有一个启动文件写后端代码，用来托管静态资源和响应html内容；</li>
<li>webpack需要打包出两份文件，一个用于服务端一个用于客户端；</li>
<li>整合vueRouter和vuex；</li>
<li>数据的预处理；</li>
</ol>
<p>需要注意的点：</p>
<ol>
<li>vue、vuex、vuerouter都需要返回一个工厂函数，因为用户会有多个，每个用户访问的页面都不相同，所以路由及数据需要独立存在；</li>
<li>异步数据预处理；</li>
</ol>
<p>特点：</p>
<ul>
<li>vue的ssr只是在首屏渲染的时候用到，之后再切换页面就是spa了；而且是交互的页面(有点击事件等)</li>
<li>异步数据的同步，通过预处理可以让服务端获取的数据同步到客户端，达到数据的一致性；</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>el和$mount的区别</title>
      <link>https://wangyawei.top/views/frontEnd/vue/vue-note-95/</link>
      <guid>https://wangyawei.top/views/frontEnd/vue/vue-note-95/</guid>
      <source url="https://wangyawei.top/rss.xml">el和$mount的区别</source>
      <category>vue</category>
      <pubDate>Sun, 19 Sep 2021 16:50:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>在使用vue并去new vue({})一个实例的时候，往往都会传入一个el或render函数或者直接调用$mount方法，那么这之间都是什么区别呢？</p>
</blockquote>
<h2 id="区别"> 区别</h2>
<blockquote>
<p>都是用于给vue实例指定一个挂载的目标；</p>
</blockquote>
<ul>
<li>
<p>el：指定挂载的dom元素或一个选择器</p>
<div><pre><code><span>new</span> <span>Vue</span><span>(</span><span>{</span>
    el<span>:</span> String <span>|</span> Element
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>render：渲染函数，可以直接生成vnode，不需要再执行模板编译；</p>
<div><pre><code><span>new</span> <span>Vue</span><span>(</span><span>{</span>
    <span>render</span><span>:</span> <span>(</span><span>h</span><span>)</span> <span>=></span> <span>h</span><span>(</span>Component<span>)</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>template：一个字符串模板作为 Vue 实例的标识使用。模板将会<strong>替换</strong>挂载的元素。挂载元素的内容都将被忽略；</p>
<div><pre><code><span>new</span> <span>Vue</span><span>(</span><span>{</span>
    template<span>:</span> <span>&lt;</span>div<span>></span><span>&lt;</span><span>/</span>div<span>></span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>$mount：挂载函数，其实无论你采用那一种方式，最后都会调用$mount函数,</p>
<ul>
<li><strong>第一个参数和el选项效果相同，都是执行一个挂载元素</strong></li>
</ul>
<div><pre><code><span>new</span> <span>Vue</span><span>(</span><span>{</span>
    <span>render</span><span>:</span> <span>(</span><span>h</span><span>)</span> <span>=></span> <span>h</span><span>(</span>Component<span>)</span>
<span>}</span><span>)</span><span>.</span><span>$mount</span><span>(</span>el<span>?</span><span>:</span> string <span>|</span> Element<span>,</span>hydrating<span>?</span><span>:</span> boolean<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ul>
<div><p>提示</p>
<ul>
<li>el选项只在用 <code>new</code> 创建实例时生效，</li>
<li>el选项不能是 <code>&lt;html&gt;</code> 或者 <code>&lt;body&gt;</code> 。</li>
<li>如果没有提供el选项那么你需要手动执行<code>$mount('#app')</code>方法；</li>
<li>render和template选项是用于提供组件模板，组件模板可以直接替换掉挂载的元素；</li>
<li>如果提供了el选项，那么vue会在<code>Init</code>的时候自动调用$Mount函数；</li>
</ul>
</div>
<h2 id="优先级"> 优先级</h2>
<ol>
<li>render</li>
<li>template</li>
<li>el</li>
<li>$mount</li>
</ol>
<div><p>提示</p>
<p>$mount其实最后都是会执行的，即便你只传入了el 或 template，vue也会将其转化为render函数，然后执行$mount方法；如果你只传入了render那么vue会直接执行$mount进行挂载。</p>
</div>
<p>以下是部分vue源码，说明了优先级这个问题：</p>
<div><pre><code><span>Vue</span><span>.</span>prototype<span>.</span><span>$mount</span> <span>=</span> <span>function</span> <span>(</span>
  <span>el<span>?</span><span>:</span> string <span>|</span> Element<span>,</span>
  hydrating<span>?</span><span>:</span> boolean</span>
<span>)</span><span>:</span> Component <span>{</span>
  el <span>=</span> el <span>&amp;&amp;</span> <span>query</span><span>(</span>el<span>)</span>

  <span>const</span> options <span>=</span> <span>this</span><span>.</span>$options
  <span>// resolve template/el and convert to render function</span>
  <span>if</span> <span>(</span><span>!</span>options<span>.</span>render<span>)</span> <span>{</span>
    <span>let</span> template <span>=</span> options<span>.</span>template
    <span>if</span> <span>(</span>template<span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>typeof</span> template <span>===</span> <span>'string'</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>template<span>.</span><span>charAt</span><span>(</span><span>0</span><span>)</span> <span>===</span> <span>'#'</span><span>)</span> <span>{</span>
          template <span>=</span> <span>idToTemplate</span><span>(</span>template<span>)</span>
        <span>}</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span>template<span>.</span>nodeType<span>)</span> <span>{</span>
        template <span>=</span> template<span>.</span>innerHTML
      <span>}</span> <span>else</span> <span>{</span>
        <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>)</span> <span>{</span>
          <span>warn</span><span>(</span><span>'invalid template option:'</span> <span>+</span> template<span>,</span> <span>this</span><span>)</span>
        <span>}</span>
        <span>return</span> <span>this</span>
      <span>}</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>el<span>)</span> <span>{</span>
      template <span>=</span> <span>getOuterHTML</span><span>(</span>el<span>)</span>
    <span>}</span>
    <span>if</span> <span>(</span>template<span>)</span> <span>{</span>
      <span>const</span> <span>{</span> render<span>,</span> staticRenderFns <span>}</span> <span>=</span> <span>compileToFunctions</span><span>(</span>template<span>,</span> <span>{</span>
        outputSourceRange<span>:</span> process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span><span>,</span>
        shouldDecodeNewlines<span>,</span>
        shouldDecodeNewlinesForHref<span>,</span>
        delimiters<span>:</span> options<span>.</span>delimiters<span>,</span>
        comments<span>:</span> options<span>.</span>comments
      <span>}</span><span>,</span> <span>this</span><span>)</span>
      options<span>.</span>render <span>=</span> render
      options<span>.</span>staticRenderFns <span>=</span> staticRenderFns
    <span>}</span>
  <span>}</span>
  <span>return</span> <span>mount</span><span>.</span><span>call</span><span>(</span><span>this</span><span>,</span> el<span>,</span> hydrating<span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/frontEnd/webpack/</link>
      <guid>https://wangyawei.top/views/frontEnd/webpack/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>WEBPACK</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些自己平时学习webpack的一些相关的知识；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>webpack项目初始化</title>
      <link>https://wangyawei.top/views/frontEnd/webpack/webpack-note-00/</link>
      <guid>https://wangyawei.top/views/frontEnd/webpack/webpack-note-00/</guid>
      <source url="https://wangyawei.top/rss.xml">webpack项目初始化</source>
      <category>WEBPACK</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1、安装webpack"> 1、安装<code>webpack</code>;</h2>
<blockquote>
<p>说明：webpack是一个打包工具，可以通过插件配置打包各种文件，然后输出，但是输出的文件，我们需要自己引入html文件后才能使用(可以配置自动化注入)</p>
</blockquote>
<ol>
<li>
<p>在任意目录中新建一个<code>web</code>项目；</p>
</li>
<li>
<p>在创建好的文件夹中执行<code>npm init</code>来进行项目的初始化；</p>
</li>
<li>
<p>安装<code>webpack</code>到本项目中；</p>
<div><pre><code><span># 安装最新的稳定版</span>
<span>npm</span> i -D webpack

<span># 安装指定版本；</span>
<span>npm</span> i -D webpack@<span>&lt;</span>version<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><ul>
<li>
<p>安装完成后我们可以执行一下命令来运行<code>webpack</code>；</p>
<div><pre><code><span># 1、直接运行</span>
node_modules/.bin/webpack

<span># 2、设置脚本命令运行；</span>
<span>"scripts"</span><span>:</span> <span>{</span>
  <span>"test"</span><span>:</span> <span>"echo <span title="\&quot;">\"</span>Error: no test specified<span title="\&quot;">\"</span> &amp;&amp; exit 1"</span>,
  <span>"start"</span><span>:</span> <span>"webpack"</span>
<span>}</span>,
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p>此时执行你会出现这种提示；</p>
<p>No configuration file found and no output filename configured via CLI option.
A configuration file could be named 'webpack.config.js' in the current directory.
Use --help to display the CLI options.</p>
<p>翻译：没有找到配置文件，也没有通过CLI选项配置输出文件名。</p>
<p>配置文件可以命名为“webpack.config”。js'在当前目录中。</p>
<p>使用——help显示CLI选项。</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>根据提示我们新建<code>webpack.config.js</code>文件；内容如下：</p>
<div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>
module<span>.</span>exports <span>=</span> <span>{</span>
  <span>// 配置入口文件</span>
  entry<span>:</span> <span>'./main.js'</span><span>,</span>
  <span>// 配置输入文件名和路径</span>
  output<span>:</span> <span>{</span>
    filename<span>:</span> <span>'bundle.js'</span><span>,</span>
    path<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'./dist'</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>此时在执行脚本，<code>webpack</code>便会进行打包并在当前目录多出一个dist文件夹，即为webpack的输入文件，</p>
</blockquote>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>webpack打包进度条</title>
      <link>https://wangyawei.top/views/frontEnd/webpack/webpack-note-03/</link>
      <guid>https://wangyawei.top/views/frontEnd/webpack/webpack-note-03/</guid>
      <source url="https://wangyawei.top/rss.xml">webpack打包进度条</source>
      <category>WEBPACK</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="添加webpack打包进度条"> 添加<code>webpack</code>打包进度条</h2>
<div><pre><code><span>"webpack"</span><span>:</span> <span>"^4.46"</span><span>,</span>
<span>"webpack-dev-middleware"</span><span>:</span> <span>"^3.7.3"</span><span>,</span>
<span>"webpack-hot-middleware"</span><span>:</span> <span>"^2.25.0"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="方式一"> 方式一</h3>
<div><pre><code><span>// ...省略</span>
<span>const</span> webpack <span>=</span> <span>require</span><span>(</span><span>"webpack"</span><span>)</span><span>;</span>
<span>const</span> complier <span>=</span> <span>webpack</span><span>(</span>webpackConfig<span>)</span><span>;</span>
<span>complier</span><span>.</span><span>apply</span><span>(</span><span>new</span> <span>webpack<span>.</span>ProgressPlugin</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 重点是这行</span>
<span>const</span> hotMiddleware <span>=</span> <span>webpackHotMiddleware</span><span>(</span>complier<span>)</span><span>;</span>
<span>const</span> app <span>=</span> <span>new</span> <span>express</span><span>(</span><span>)</span><span>;</span>

app<span>.</span><span>use</span><span>(</span><span>webpackDevMiddleware</span><span>(</span>complier<span>,</span> <span>{</span>
  noInfo<span>:</span> <span>true</span><span>,</span>
  publicPath<span>:</span> webpackConfig<span>.</span>output<span>.</span>publicPath<span>,</span>
<span>}</span><span>)</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>
<p>添加完成即可实现和<code>vue-dev-service</code>一样的打包进度条效果。</p>
</blockquote>
<h3 id="方式二"> 方式二</h3>
<ul>
<li>
<p>安装：<code>progress-bar-webpack-plugin</code>插件，<a href="https://www.npmjs.com/package/progress-webpack-plugin" target="_blank" rel="noopener noreferrer">传送门</a></p>
<div><pre><code><span>npm</span> i progress-webpack-plugin
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>使用：</p>
<div><pre><code>const ProgressBarPlugin = require(&#39;progress-bar-webpack-plugin&#39;);

module.exports = {
    ...
    plugins:[
        new ProgressPlugin(true)
    ]
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
</ul>
<h3 id="方式三"> 方式三</h3>
<ul>
<li>
<p>安装：<code>simple-progress-webpack-plugin</code>插件，<a href="https://cnpmjs.org/package/simple-progress-webpack-plugin" target="_blank" rel="noopener noreferrer">传送门</a></p>
<div><pre><code><span>npm</span> <span>install</span> simple-progress-webpack-plugin --save-dev
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>使用：</p>
<div><pre><code><span>const</span> SimpleProgressWebpackPlugin <span>=</span> <span>require</span><span>(</span> <span>'simple-progress-webpack-plugin'</span> <span>)</span><span>;</span>

module<span>.</span>exports <span>=</span> <span>{</span>
    <span>...</span>
    plugins<span>:</span><span>[</span>
        <span>new</span> <span>SimpleProgressWebpackPlugin</span><span>(</span><span>)</span>
    <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
</ul>
<h3 id="方式四"> 方式四</h3>
<ul>
<li>
<p>安装：<code>progress-webpack-plugin</code>插件，<a href="https://www.npmjs.com/package/progress-webpack-plugin" target="_blank" rel="noopener noreferrer">传送门</a></p>
<div><pre><code><span>npm</span> i progress-webpack-plugin
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>使用：</p>
<div><pre><code><span>var</span> ProgressPlugin <span>=</span> <span>require</span><span>(</span><span>'progress-webpack-plugin'</span><span>)</span>

module<span>.</span>exports <span>=</span> <span>{</span>
    <span>...</span>
    plugins<span>:</span><span>[</span>
        <span>new</span> <span>ProgressPlugin</span><span>(</span><span>true</span><span>)</span>
    <span>]</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p>注意：这个插件我在使用时出现了错误，没在其它<code>webpack</code>的版本试过。建议用上面几个，基本就可以满足需求了。</p>
</blockquote>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>webpack、webpack-cli、webpack-dev-server的关系</title>
      <link>https://wangyawei.top/views/frontEnd/webpack/webpack-note-02/</link>
      <guid>https://wangyawei.top/views/frontEnd/webpack/webpack-note-02/</guid>
      <source url="https://wangyawei.top/rss.xml">webpack、webpack-cli、webpack-dev-server的关系</source>
      <category>WEBPACK</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="webpack、webpack-cli、webpack-dev-server的关系"> <code>webpack、webpack-cli、webpack-dev-server</code>的关系</h2>
<blockquote>
<p>概述：webpack的核心是用于现代JavaScript应用程序的静态模块打包器。当webpack处理您的应用程序时，它会在内部构建一个<a href="https://webpack.js.org/concepts/dependency-graph/" target="_blank" rel="noopener noreferrer">依赖关系图</a>，该图映射您项目所需的每个模块并生成一个或多个包。<a href="https://webpack.js.org/" target="_blank" rel="noopener noreferrer">官方文档</a></p>
</blockquote>
<p><img src="./assets/1615011412595.png" alt="1615011412595" /></p>
<ul>
<li><code>webpackv1</code>和<code>webpackv2</code>可以查看的说明可以查看 <a href="https://blog.csdn.net/weixin_42614080/article/details/106297384" target="_blank" rel="noopener noreferrer">CSDN博主的介绍</a>；</li>
</ul>
<h2 id="webpack-3-xx"> <code>webpack@3.xx</code></h2>
<blockquote>
<p>根据官方文档介绍我们知道<code>webpack</code>主要提供打包服务。</p>
<p>比如vue项目中，webpack会根据配置的入口文件，递归的去构建你的文件依赖关系树并根据你提供的loader去编译解析你的代码，然后输出一个编译后的文件。</p>
</blockquote>
<ol>
<li>
<p>示例：</p>
<ul>
<li>
<p>初始化一个项目；新建一个文件夹，并再文件中打开cmd然后输入以下命令：</p>
<div><pre><code>npm init 
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>安装<code>webpack@3.8.1</code>;</p>
<div><pre><code>npm i webpack@3.8.1
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>新建<code>webpack.config.js</code>文件；并写入以下代码；</p>
<div><pre><code><span>// 导入path 模块</span>
<span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>

module<span>.</span>exports <span>=</span> <span>{</span>
  entry<span>:</span> <span>'./main.js'</span><span>,</span>
  output<span>:</span> <span>{</span>
    <span>// 将所有依赖的模块合并输出到一个[name].js文件</span>
    <span>// 若不指定静态的文件名则的默认的name为：main；</span>
    <span>// filename: '[name]_[id]_[hash:8].js',</span>
    filename<span>:</span> <span>'[name].js'</span><span>,</span>
    <span>// 将输出文件都放在dist目录下；</span>
    path<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'./dist'</span><span>)</span>
  <span>}</span><span>,</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div></li>
<li>
<p>添加脚本；</p>
<div><pre><code><span>"build"</span><span>:</span> <span>"webpack --config webpack.config.js"</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>新建<code>main.js</code>文件,并写入以下代码；</p>
<div><pre><code>window<span>.</span>document<span>.</span><span>getElementById</span><span>(</span><span>'app'</span><span>)</span><span>.</span>innerText <span>=</span> <span>'hello'</span> <span>+</span> <span>'webpack'</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>新建<code>index.html</code>文件，并写入以下代码；</p>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span> <span>/></span></span>
    <span><span><span>&lt;</span>title</span><span>></span></span>Title<span><span><span>&lt;/</span>title</span><span>></span></span>
  <span><span><span>&lt;/</span>head</span><span>></span></span>
  <span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
  <span><span><span>&lt;/</span>body</span><span>></span></span>
  <span>&lt;!--导入webpack输出时的js文件 直接打开index.html文件时使用 --></span>
  <span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>./dist/main.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></li>
<li>
<p>运行脚本后，我们可以看到在当前目录下会多出一个dist文件夹，里面会有一个<code>main.js</code>文件。</p>
</li>
<li>
<p>在index.html中引入打包的main.js文件，然后再浏览器中打开index.html文件。我们可以看到<code>hellowebpack</code>文字。</p>
</li>
</ul>
</li>
<li>
<p>启动一个服务：</p>
<blockquote>
<p>webpack只是提供了打包文件的能力，但是实际开发中我们不可能每次都手动在文件中引入打包出来的文件，因为这会是一个想当繁琐的一项工作。</p>
</blockquote>
<ul>
<li>
<p>安装<code>webpack-dev-server</code>；</p>
<blockquote>
<p>webpack-dev-server是webpack官方提供的一个小型Express服务器。使用它可以为webpack打包生成的资源文件提供web服务。</p>
<p>webpack-dev-server 主要提供两个功能：</p>
<ul>
<li>为静态文件提供web服务</li>
<li>自动刷新和热替换(HMR)</li>
</ul>
</blockquote>
<div><pre><code>npm i webpack-dev-server@2.6.1
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>配置并启动脚本：</p>
<div><pre><code>&quot;serve&quot;: &quot;webpack-dev-server --hot&quot;, // --hot 表示 热更新
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>启动成功：</p>
<div><pre><code>
<span>></span> webpack_@1.0.0 serve
<span>></span> webpack-dev-server --hot

Project is running at http://localhost:8081/
webpack output is served from /
Hash: 9c59c5f60ee3be57c42d
Version: webpack <span>3.8</span>.1
Time: 576ms
  Asset    Size  Chunks                    Chunk Names
main.js  <span>362</span> kB       <span>0</span>  <span>[</span>emitted<span>]</span>  <span>[</span>big<span>]</span>  main
  <span>[</span><span>19</span><span>]</span> <span>(</span>webpack<span>)</span>/hot/log.js <span>1</span> kB <span>{</span><span>0</span><span>}</span> <span>[</span>built<span>]</span>
  <span>[</span><span>35</span><span>]</span> <span>(</span>webpack<span>)</span>/hot/emitter.js <span>75</span> bytes <span>{</span><span>0</span><span>}</span> <span>[</span>built<span>]</span>
  <span>[</span><span>36</span><span>]</span> multi <span>(</span>webpack<span>)</span>-dev-server/client?http://localhost:8081 webpack/hot/dev-server ./main.js <span>52</span> bytes <span>{</span><span>0</span><span>}</span> <span>[</span>built<span>]</span>
  <span>[</span><span>37</span><span>]</span> <span>(</span>webpack<span>)</span>-dev-server/client?http://localhost:8081 <span>5.83</span> kB <span>{</span><span>0</span><span>}</span> <span>[</span>built<span>]</span>
  <span>[</span><span>38</span><span>]</span> ./node_modules/url/url.js <span>23.3</span> kB <span>{</span><span>0</span><span>}</span> <span>[</span>built<span>]</span>
  <span>[</span><span>39</span><span>]</span> ./node_modules/punycode/punycode.js <span>14.7</span> kB <span>{</span><span>0</span><span>}</span> <span>[</span>built<span>]</span>
  <span>[</span><span>40</span><span>]</span> ./node_modules/url/util.js <span>314</span> bytes <span>{</span><span>0</span><span>}</span> <span>[</span>built<span>]</span>
  <span>[</span><span>44</span><span>]</span> ./node_modules/strip-ansi/index.js <span>161</span> bytes <span>{</span><span>0</span><span>}</span> <span>[</span>built<span>]</span>
  <span>[</span><span>46</span><span>]</span> ./node_modules/loglevel/lib/loglevel.js <span>8.61</span> kB <span>{</span><span>0</span><span>}</span> <span>[</span>built<span>]</span>
  <span>[</span><span>47</span><span>]</span> <span>(</span>webpack<span>)</span>-dev-server/client/socket.js <span>856</span> bytes <span>{</span><span>0</span><span>}</span> <span>[</span>built<span>]</span>
  <span>[</span><span>79</span><span>]</span> <span>(</span>webpack<span>)</span>-dev-server/client/overlay.js <span>3.6</span> kB <span>{</span><span>0</span><span>}</span> <span>[</span>built<span>]</span>
  <span>[</span><span>85</span><span>]</span> <span>(</span>webpack<span>)</span>/hot nonrecursive ^<span>\</span>.<span>\</span>/log$ <span>170</span> bytes <span>{</span><span>0</span><span>}</span> <span>[</span>built<span>]</span>
  <span>[</span><span>87</span><span>]</span> <span>(</span>webpack<span>)</span>/hot/dev-server.js <span>1.56</span> kB <span>{</span><span>0</span><span>}</span> <span>[</span>built<span>]</span>
  <span>[</span><span>88</span><span>]</span> <span>(</span>webpack<span>)</span>/hot/log-apply-result.js <span>1.27</span> kB <span>{</span><span>0</span><span>}</span> <span>[</span>built<span>]</span>
  <span>[</span><span>89</span><span>]</span> ./src/main.js <span>265</span> bytes <span>{</span><span>0</span><span>}</span> <span>[</span>built<span>]</span>
    + <span>75</span> hidden modules
webpack: Compiled successfully.

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div><blockquote>
<p>服务启动成功默认会占用8080端口，并托管你的整个项目文件。</p>
</blockquote>
</li>
</ul>
</li>
</ol>
<h2 id="webpack-4-xx"> <code>webpack@4.xx</code></h2>
<blockquote>
<p>webpack@4.xx的示例就不做演示了，这里只说下区别；</p>
<ul>
<li>在webpack4以前，也就是我上面的那个例子，你会发现我没有使用<code>webpack-cli</code>工具。webpak提供打包，dev-server提供服务。但是在webpack4以后，你会发现，如果你只安装一个webpack4.xx，就直接开始打包，日志会提示你安装webpack-cli工具。这是因为，在webpack4.xx以前<code>webpack和webpack-cli</code>是在一起的，而在webpack4.xx之后，官方把二者分开了既命令行工具由<code>webpack-cli</code>提供。</li>
</ul>
</blockquote>
<h2 id="webpack-dev-server版本差异"> <code>webpack-dev-server</code>版本差异；</h2>
<p>在webpack-dev-server@2.xx中，我们只需要安装一个<code>webpack-dev-server</code>就可以配合<code>webpack</code>进行项目的开发。但是在webapck-dev-server@3.xx中，你会发现在启动webapck-dev-server是，会报一个<code>Cannot find module 'webpack-cli/bin/config-yargs</code>错误；这是因为在这个版本中它依赖于webpack-cli；</p>
<h2 id="版本对比"> 版本对比</h2>
<table>
<thead>
<tr>
<th>webpack</th>
<th>webpack-dev-server</th>
<th>webpack-cli</th>
</tr>
</thead>
<tbody>
<tr>
<td>3.xx</td>
<td>2.xx</td>
<td></td>
</tr>
<tr>
<td>4.xx</td>
<td>3.xx</td>
<td>3.xx</td>
</tr>
<tr>
<td>5.xx</td>
<td>暂未使用</td>
<td>4.xx</td>
</tr>
</tbody>
</table>
]]></content:encoded>
    </item>
    <item>
      <title>dirname和filename</title>
      <link>https://wangyawei.top/views/frontEnd/webpack/webpack-note-05/</link>
      <guid>https://wangyawei.top/views/frontEnd/webpack/webpack-note-05/</guid>
      <source url="https://wangyawei.top/rss.xml">dirname和filename</source>
      <category>WEBPACK</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="dirname和-filename"> <code>__dirname</code>和<code>__filename</code></h2>
<blockquote>
<p>都可以动态的获取当前的绝对路径</p>
</blockquote>
<div><pre><code>tem<span>.</span>js

<span>// __dirname和filename是nodejs内置的全局变量；</span>
console<span>.</span><span>log</span><span>(</span>__dirname<span>,</span> __filename<span>)</span>

<span>// C:\Users\ASUS\Desktop\webpackProject\src C:\Users\ASUS\Desktop\webpackProject\src\tem.js</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>
<p>__dirname会获取当前<strong>文件夹</strong>的绝对路径</p>
<p>__filename会获取当前<strong>文件</strong>的绝对路径</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>path.join()和path.resolve()</title>
      <link>https://wangyawei.top/views/frontEnd/webpack/webpack-note-06/</link>
      <guid>https://wangyawei.top/views/frontEnd/webpack/webpack-note-06/</guid>
      <source url="https://wangyawei.top/rss.xml">path.join()和path.resolve()</source>
      <category>WEBPACK</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="path-join-和path-resolve"> <code>path.join()</code>和<code>path.resolve()</code></h2>
<blockquote>
<p>path 为<code>nodejs</code>的内置模块；</p>
</blockquote>
<ol>
<li>
<p>使用：path.join(  path1, path2, ... );</p>
<ul>
<li>用于连接路径。主要用途在于，会正确使用当前系统的路径分隔符，Unix系统是&quot;/&quot;，Windows系统是&quot;&quot;。</li>
</ul>
<div><pre><code><span>// join方法只是将两个路径进行拼接，</span>
<span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>join</span><span>(</span><span>'a'</span><span>)</span><span>)</span>  <span>// a</span>
console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>join</span><span>(</span><span>'a'</span><span>,</span> <span>''</span><span>)</span><span>)</span>  <span>// a</span>
console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>join</span><span>(</span><span>''</span><span>,</span> <span>'b'</span><span>)</span><span>)</span>  <span>// b</span>

console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>join</span><span>(</span><span>'a'</span><span>,</span> <span>'b'</span><span>)</span><span>)</span>  <span>// a\b</span>
console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>join</span><span>(</span><span>'a'</span><span>,</span> <span>'./b'</span><span>)</span><span>)</span>  <span>// a\b</span>
console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>join</span><span>(</span><span>'a'</span><span>,</span> <span>'/b'</span><span>)</span><span>)</span>  <span>// a\b</span>

console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>join</span><span>(</span><span>'/a'</span><span>,</span> <span>'b'</span><span>)</span><span>)</span>  <span>// \a\b</span>
console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>join</span><span>(</span><span>'/a'</span><span>,</span> <span>'./b'</span><span>)</span><span>)</span>  <span>// \a\b</span>
console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>join</span><span>(</span><span>'/a'</span><span>,</span> <span>'/b'</span><span>)</span><span>)</span>  <span>// \a\b</span>

console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>join</span><span>(</span><span>'./a'</span><span>,</span> <span>'b'</span><span>)</span><span>)</span>  <span>// a\b</span>
console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>join</span><span>(</span><span>'./a'</span><span>,</span> <span>'./b'</span><span>)</span><span>)</span>  <span>// a\b</span>
console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>join</span><span>(</span><span>'./a'</span><span>,</span> <span>'/b'</span><span>)</span><span>)</span>  <span>// a\b</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div></li>
<li>
<p>使用：path.resolve( <strong>[from ...], to</strong> );</p>
<ul>
<li>将 <strong>to</strong> 参数解析为绝对路径，给定的路径的序列是从右往左被处理的，后面每个 path 被依次解析，直到构造完成一个绝对路径。 例如，给定的路径片段的序列为：/foo、/bar、baz，则调用 path.resolve('/foo', '/bar', 'baz') 会返回 /bar/baz。</li>
</ul>
<div><pre><code><span>/**
 * path.resolve() 会以当前的文件的根路径进行拼接，
 * 如果第一个参数或第二个参数以 / 开头，那么会作为根路径进行拼接，
 */</span>
<span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>
console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>resolve</span><span>(</span><span>'a'</span><span>)</span><span>)</span>  <span>// C:\Users\ASUS\Desktop\webpackProject\src\a</span>
console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>resolve</span><span>(</span><span>'a'</span><span>,</span> <span>''</span><span>)</span><span>)</span>  <span>// C:\Users\ASUS\Desktop\webpackProject\src\a</span>
console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>resolve</span><span>(</span><span>''</span><span>,</span> <span>'b'</span><span>)</span><span>)</span>  <span>// C:\Users\ASUS\Desktop\webpackProject\src\b</span>

console<span>.</span><span>log</span><span>(</span><span>'======='</span><span>)</span>

console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>resolve</span><span>(</span><span>'a'</span><span>,</span> <span>'b'</span><span>)</span><span>)</span>  <span>// C:\Users\ASUS\Desktop\webpackProject\src\a\b</span>
console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>resolve</span><span>(</span><span>'a'</span><span>,</span> <span>'./b'</span><span>)</span><span>)</span>  <span>// C:\Users\ASUS\Desktop\webpackProject\src\a\b</span>
console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>resolve</span><span>(</span><span>'a'</span><span>,</span> <span>'/b'</span><span>)</span><span>)</span>  <span>// C:\b</span>

console<span>.</span><span>log</span><span>(</span><span>'======='</span><span>)</span>

console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>resolve</span><span>(</span><span>'/a'</span><span>,</span> <span>'b'</span><span>)</span><span>)</span>  <span>// C:\a\b</span>
console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>resolve</span><span>(</span><span>'/a'</span><span>,</span> <span>'./b'</span><span>)</span><span>)</span>  <span>// C:\a\b</span>
console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>resolve</span><span>(</span><span>'/a'</span><span>,</span> <span>'/b'</span><span>)</span><span>)</span>  <span>// C:\b</span>

console<span>.</span><span>log</span><span>(</span><span>'======='</span><span>)</span>

console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>resolve</span><span>(</span><span>'./a'</span><span>,</span> <span>'b'</span><span>)</span><span>)</span>  <span>// C:\Users\ASUS\Desktop\webpackProject\src\a\b</span>
console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>resolve</span><span>(</span><span>'./a'</span><span>,</span> <span>'./b'</span><span>)</span><span>)</span>  <span>// C:\Users\ASUS\Desktop\webpackProject\src\a\b</span>
console<span>.</span><span>log</span><span>(</span>path<span>.</span><span>resolve</span><span>(</span><span>'./a'</span><span>,</span> <span>'/b'</span><span>)</span><span>)</span>  <span>// C:\b</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><blockquote>
<p>注意：path.resolve()的拼接是有<strong>盘符</strong>的；</p>
</blockquote>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>css-loader</title>
      <link>https://wangyawei.top/views/frontEnd/webpack/webpack-note-07/</link>
      <guid>https://wangyawei.top/views/frontEnd/webpack/webpack-note-07/</guid>
      <source url="https://wangyawei.top/rss.xml">css-loader</source>
      <category>WEBPACK</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="使用css-loader-0-28-4"> 使用<code>css-loader@0.28.4</code></h2>
<blockquote>
<p><code>webpack@3.81</code></p>
<p><code>webpack</code>将一切文件看作模块，当然<code>css</code>也不例外，我们可以直接在<code>js</code>文件中引入<code>css</code>文件，但是<code>webpack</code>原生并不支持解析<code>css</code>文件，如果要支持非<code>js</code>类型的文件，则需要使用<code>webpack</code>的<code>loader</code>机制。</p>
</blockquote>
<ol>
<li>
<p>我们需要在<code>webpack.config.js</code>文件中做如下配置。</p>
<div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>

module<span>.</span>exports <span>=</span> <span>{</span>
  entry<span>:</span> <span>'./src/main.js'</span><span>,</span>
  output<span>:</span> <span>{</span>
    filename<span>:</span> <span>'bundle.js'</span><span>,</span>
    path<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'./dist'</span><span>)</span>
  <span>}</span><span>,</span>
  module<span>:</span> <span>{</span>
    rules<span>:</span> <span>[</span>
      <span>{</span>
        <span>// 用正则表达式去匹配要用该loader转换的css文件；</span>
        test<span>:</span> <span><span>/</span><span>\.css$</span><span>/</span></span><span>,</span>
        <span>// loader的执行顺序由后到前 既先使用 css-loader 解析 css文件，</span>
        <span>// 在由 style-loader 将css的内容注入到js中然后再</span>
        <span>// 在js中动态创建&lt;style>&lt;/style>标签并插入到head头部。</span>
        <span>// 我用的webpack 3.8对应的是css-loader3.5版本，再高点会报错</span>
        use<span>:</span> <span>[</span>
          <span>'style-loader'</span><span>,</span> <span>// 2.0.0版本</span>
          <span>{</span>
            loader<span>:</span> <span>"css-loader"</span><span>,</span> 
            <span>// minimize压缩功能在1.0.0版本中被移除，功能开启会去掉多余的空格</span>
            options<span>:</span> <span>{</span>
              minimize<span>:</span> <span>true</span><span>,</span><span>// 0.28.4版本</span>
            <span>}</span><span>,</span>
          <span>}</span>
        <span>]</span>
      <span>}</span>
    <span>]</span>
  <span>}</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><blockquote>
<p>此时我们便可以在js文件中引入css文件了，打包出来的css会进行压缩，</p>
</blockquote>
</li>
<li>
<p>把css直接插入js到,会造成js文件过大和加载时间变长，这个时候我可以把css部分单独提取到独立的css文件中，然后再页面中去引用。</p>
<ul>
<li>执行命令<code>npm i -D extract-text-webpack-plugin</code>下载插件，版本3.0.2</li>
</ul>
<div><pre><code><span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>
<span>// 引入提取css的插件。</span>
<span>const</span> ExtractTextWebpackPlugin <span>=</span> <span>require</span><span>(</span><span>'extract-text-webpack-plugin'</span><span>)</span>

module<span>.</span>exports <span>=</span> <span>{</span>
  entry<span>:</span> <span>'./src/main.js'</span><span>,</span>
  output<span>:</span> <span>{</span>
    filename<span>:</span> <span>'bundle.js'</span><span>,</span>
    path<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'./dist'</span><span>)</span>
  <span>}</span><span>,</span>
  module<span>:</span> <span>{</span>
    rules<span>:</span> <span>[</span>
      <span>{</span>
        test<span>:</span> <span><span>/</span><span>\.css$</span><span>/</span></span><span>,</span>
        <span>// 提取css到单独的文件中并压缩。</span>
        loader<span>:</span> ExtractTextWebpackPlugin<span>.</span><span>extract</span><span>(</span><span>{</span>
          <span>// fallback 表示如果当css没有被css-loader所处理那么就用style-loader来处理</span>
          fallback<span>:</span> <span>"style-loader"</span><span>,</span>
          use<span>:</span> <span>[</span>
            <span>{</span>
              loader<span>:</span> <span>'css-loader'</span><span>,</span>
              options<span>:</span> <span>{</span>
                minimize<span>:</span> <span>true</span>
              <span>}</span>
            <span>}</span>
          <span>]</span>
        <span>}</span><span>)</span><span>,</span>
      <span>}</span>
    <span>]</span>
  <span>}</span><span>,</span>
  plugins<span>:</span> <span>[</span>
    <span>new</span> <span>ExtractTextWebpackPlugin</span><span>(</span><span>{</span>
      <span>// 输出的文件名加8为hash值</span>
      <span>// filename: `[name]_[contenthash:8].css`</span>
      filename<span>:</span> <span><span>`</span><span>[name].css</span><span>`</span></span>
    <span>}</span><span>)</span>
  <span>]</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><blockquote>
<p>此时我们再执行打包命令，那么会在dist文件中多一个main.css文件，这个便是提取出来的文件，然后把提取出来的文件引入到html文件中。</p>
</blockquote>
</li>
<li>
<p>考虑到<code>css-loader</code>在1.0版本后去掉了压缩功能，所以我们需要另外的插件来代替它，<a href="https://www.npmjs.com/package/optimize-css-assets-webpack-plugin" target="_blank" rel="noopener noreferrer">下载</a></p>
<div><pre><code><span># 解决了extract-text-webpack-plugin CSS重复问题</span>
<span># 它将在Webpack构建期间搜索CSS资源，并将优化\最小化CSS（默认情况下，它使用cssnano，但可以指定自定义CSS处理器）。</span>
<span>npm</span> i -D optimize-css-assets-webpack-plugin
<span>npm</span> i -D cssnano
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><blockquote>
<p>注意：对于webpack v3或更低版本，请使用optimize-css-assets-webpack-plugin@3.2.0。 optimize-css-assets-webpack-plugin@4.0.0及以上版本支持webpack v4。</p>
</blockquote>
<div><pre><code><span>// 导入path 模块</span>
<span>const</span> path <span>=</span> <span>require</span><span>(</span><span>'path'</span><span>)</span>
<span>// 提取css到单独的文件中；</span>
<span>const</span> ExtractTextPlugin <span>=</span> <span>require</span><span>(</span><span>'extract-text-webpack-plugin'</span><span>)</span>
<span>// css 代码压缩</span>
<span>const</span> OptimizeCssAssetsPlugin <span>=</span> <span>require</span><span>(</span><span>'optimize-css-assets-webpack-plugin'</span><span>)</span>

module<span>.</span>exports <span>=</span> <span>{</span>
  <span>// 设置webpack在寻找相对路径时以 context为 根目录进行查找</span>
  context<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'src'</span><span>)</span><span>,</span>
  <span>// 若指定了 context 则入口文件会从指定的目录：src 中查找 main.js 文件；</span>
  entry<span>:</span> <span>'./main.js'</span><span>,</span>
  output<span>:</span> <span>{</span>
    <span>// 将所有依赖的模块合并输出到一个[name].js文件</span>
    <span>// 若不指定静态的文件名则的默认的name为：main；</span>
    <span>// filename: '[name]_[id]_[hash:8].js',</span>
    filename<span>:</span> <span>'[name].js'</span><span>,</span>
    <span>// 将输出文件都放在dist目录下；</span>
    path<span>:</span> path<span>.</span><span>resolve</span><span>(</span>__dirname<span>,</span> <span>'./dist'</span><span>)</span>
  <span>}</span><span>,</span>
  module<span>:</span> <span>{</span>
    rules<span>:</span> <span>[</span>
      <span>{</span>
        test<span>:</span> <span><span>/</span><span>\.css$</span><span>/</span></span><span>,</span>
        <span>// 提取css到单独的文件中</span>
        use<span>:</span> ExtractTextPlugin<span>.</span><span>extract</span><span>(</span><span>{</span>
          <span>// 用于当css没有被提取时</span>
          fallback<span>:</span> <span>'style-loader'</span><span>,</span>
          <span>// 编译文件</span>
          use<span>:</span> <span>'css-loader'</span>
        <span>}</span><span>)</span>
      <span>}</span>
    <span>]</span>
  <span>}</span><span>,</span>
  plugins<span>:</span> <span>[</span>
    <span>// 配置提取的css文件的文件名</span>
    <span>new</span> <span>ExtractTextPlugin</span><span>(</span><span>{</span>
      <span>// filename: '[name]_[id]_[contenthash:8].min.css'</span>
      filename<span>:</span> <span>'[name].css'</span>
    <span>}</span><span>)</span><span>,</span>

<span>+</span>    <span>new</span> <span>OptimizeCssAssetsPlugin</span><span>(</span><span>{</span>
<span>+</span>      <span>// 匹配需要优化或者压缩的资源名</span>
<span>+</span>      assetNameRegExp<span>:</span> <span><span>/</span><span>\.css$</span><span>/</span><span>g</span></span><span>,</span>
<span>+</span>      <span>// 用于压缩和优化CSS 的处理器，默认是 cssnano 这是一个函数</span>
<span>+</span>      cssProcessor<span>:</span> <span>require</span><span>(</span><span>'cssnano'</span><span>)</span><span>,</span>
<span>+</span>      cssProcessorPluginOptions<span>:</span> <span>{</span>
<span>+</span>        <span>// 设置预设值 并传递给 cssProcessor 用于删除所有的注释信息，</span>
<span>+</span>        preset<span>:</span> <span>[</span><span>'default'</span><span>,</span> <span>{</span> discardComments<span>:</span> <span>{</span> removeAll<span>:</span> <span>true</span> <span>}</span> <span>}</span><span>]</span>
<span>+</span>      <span>}</span><span>,</span>
<span>+</span>      <span>// 表示插件能够在console中打印信息，默认值是true</span>
<span>+</span>      canPrint<span>:</span> <span>true</span>
<span>+</span>    <span>}</span><span>)</span>
<span>+</span>  <span>]</span>
<span>+</span><span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br></div></div><blockquote>
<p>此时你便可以升级css-loader的插件到最新版本了3.5版本了。css会根据插件配置进行压缩和优化</p>
</blockquote>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/interviewQuestion/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>面试题</category>
      <pubDate>Tue, 15 Jun 2021 22:37:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些自己平时遇到或见到的一些面试题；</p>
</blockquote>
<h2 id="目录"> 目录</h2>
<ol>
<li><a href="./question-note-01.html">浏览器采用多进程架构有什么优势和劣势</a></li>
<li><a href="./question-note-02.html">为什么不建议采用定时器实现动画？requestAnimationFrame有哪些优势</a></li>
<li><a href="./question-note-03.html">谈谈你对vue的理解</a></li>
<li><a href="./question-note-04.html">异步执行顺序问题</a></li>
<li><a href="./question-note-05.html">微任务执行问题</a></li>
<li><a href="./question-note-06.html">this指向问题</a></li>
<li><a href="./question-note-07.html">promise执行问题</a></li>
<li><a href="./question-note-08.html">promise解决并发请求</a></li>
<li><a href="./question-note-09.html">跨域问题</a></li>
<li><a href="./question-note-10.html">deno相关问题</a></li>
<li><a href="./question-note-11.html">sourceMap相关</a></li>
<li><a href="./question-note-15.html">Vue 响应式原理</a></li>
<li><a href="./question-note-20.html">computed 的实现原理</a></li>
<li><a href="./question-note-25.html">v-if和v-for哪个优先级更高</a></li>
<li><a href="./question-note-30.html">Vue组件data为什么必须是个函数而Vue的根实例则没有此限制？</a></li>
<li><a href="./question-note-35.html">你知道vue中key的作用和工作原理吗？说说你对它的理解</a></li>
<li><a href="./question-note-40.html">你怎么理解vue中的diff算法</a></li>
<li><a href="./question-note-45.html">谈一谈对vue组件化的理解</a></li>
<li><a href="./question-note-50.html">谈一谈对vue设计原则的理解</a></li>
<li><a href="./question-note-55.html">谈谈你对MVC、MVP和MVVM的理解？</a></li>
<li><a href="./question-note-60.html">你了解哪些Vue性能优化方法</a></li>
<li><a href="./question-note-65.html">你对Vue3.0的新特性有没有了解？</a></li>
<li><a href="./question-note-70.html">简单说一说vuex使用及其理解？</a></li>
<li><a href="./question-note-75.html">vue中组件之间的通信方式？</a></li>
<li><a href="./question-note-80.html">vue-router 中的导航钩子由那些？</a></li>
<li><a href="./question-note-85.html">什么是递归组件？</a></li>
<li><a href="./question-note-90.html">说一说vue响应式理解？</a></li>
<li><a href="./question-note-95.html"> vue如果想要扩展某个现有组件时怎么做？</a></li>
<li><a href="./question-note-100.html">watch和computed的区别以及怎么选用?</a></li>
<li><a href="./question-note-105.html">你知道nextTick的原理吗?</a></li>
<li><a href="./question-note-110.html">简单说一说vue生命周期的理解?</a></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>浏览器采用多进程架构有什么优势和劣势？</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-01/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-01/</guid>
      <source url="https://wangyawei.top/rss.xml">浏览器采用多进程架构有什么优势和劣势？</source>
      <category>面试题</category>
      <pubDate>Tue, 15 Jun 2021 22:37:23 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="优点"> 优点</h2>
<ol>
<li>可以增加响应速度以及安全性同时也会有良好的体验性 比如听歌的同时可以打开编译器敲代码 又比如当一个网页挂掉后不会影响其他网页；</li>
<li>第三方插件崩溃也不会影响到整个浏览器；</li>
<li>多进程可以充分利用现代 CPU 多核的优势；</li>
<li>方便使用沙盒模型隔离插件等进程,提高浏览器的稳定性；</li>
</ol>
<h2 id="缺点"> 缺点</h2>
<ol>
<li>系统需要为浏览器新开的进程分配内存、CPU 等资源，所以内存和 CPU 的资源消耗也会更大；</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>为什么不建议采用定时器实现动画？requestAnimationFrame有哪些优势？</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-02/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-02/</guid>
      <source url="https://wangyawei.top/rss.xml">为什么不建议采用定时器实现动画？requestAnimationFrame有哪些优势？</source>
      <category>面试题</category>
      <pubDate>Tue, 15 Jun 2021 22:40:23 GMT</pubDate>
      <content:encoded><![CDATA[<p><strong>为什么不建议采用定时器实现动画？</strong></p>
<ol>
<li>定时器可能不会按时触发 还会有丢帧现象;</li>
<li>通过定时器修改元素位置属性，会导致频繁的重排和重绘，从而影响到性能。</li>
</ol>
<p><strong>requestAnimationFrame有哪些优势？</strong></p>
<ol>
<li>requestAnimationFrame最大的优势是由浏览器来决定回调函数的执行时机，即紧跟浏览器的刷新步调。 不会引起动画丢帧卡顿;</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>谈谈你对vue的理解？</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-03/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-03/</guid>
      <source url="https://wangyawei.top/rss.xml">谈谈你对vue的理解？</source>
      <category>面试题</category>
      <pubDate>Sun, 20 Jun 2021 22:03:23 GMT</pubDate>
    </item>
    <item>
      <title>异步执行顺序问题？</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-04/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-04/</guid>
      <source url="https://wangyawei.top/rss.xml">异步执行顺序问题？</source>
      <category>面试题</category>
      <pubDate>Sat, 26 Jun 2021 13:19:23 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="例1"> 例1</h2>
<blockquote>
<p>请阅读下面代码，我们只考虑浏览器环境下的输出结果，写出它们结果打印的先后顺序，并分析出原因！</p>
</blockquote>
<div><pre><code>console<span>.</span><span>log</span><span>(</span><span>'AAAA'</span><span>)</span>
<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span><span>'BBBB'</span><span>)</span><span>,</span> <span>1</span><span>)</span>
<span>const</span> start <span>=</span> <span>new</span> <span>Date</span><span>(</span><span>)</span>
<span>while</span> <span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span> <span>-</span> start <span>&lt;</span> <span>3000</span><span>)</span> <span>{</span><span>}</span>
console<span>.</span><span>log</span><span>(</span><span>'CCCC'</span><span>)</span>
<span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span><span>'DDDD'</span><span>)</span><span>,</span> <span>0</span><span>)</span>
<span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'EEEE'</span><span>)</span>
  foo<span>.</span><span>bar</span><span>(</span><span>100</span><span>)</span>
<span>}</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span><span>'FFFF'</span><span>)</span><span>)</span>
  <span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span><span>'GGGG'</span><span>)</span><span>)</span>
  <span>.</span><span>catch</span><span>(</span><span>(</span><span>)</span> <span>=></span> console<span>.</span><span>log</span><span>(</span><span>'HHHH'</span><span>)</span><span>)</span>
console<span>.</span><span>log</span><span>(</span><span>'IIII'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code><span># 输出结果</span>
AAAA
CCCC
EEEE
IIII
HHHH
BBBB
DDDD
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p>答案解析：这道题考察重点是  js 异步执行 宏任务 微任务。</p>
</blockquote>
<ol>
<li>==第一行==代码执行，输出<code>AAAA</code>。</li>
<li>==第二行==代码开启一个计时器t1，这是一个异步任务且是<strong>宏任务</strong>，需要等到1秒后提交。</li>
<li>==第四行==是个while语句，需要等待3秒后才能执行下面的代码,<strong>这里有个问题，就是3秒后上一个计时器t1的提交时间已经过了，但是线程上的任务还没有执行结束，所以暂时不能打印结果</strong>，所以它排在宏任务的最前面了。</li>
<li>==第五行==又输出<code>CCCC</code>。</li>
<li>==第六行==又开启一个计时器t2，它提交的时间是0秒（其实每个浏览器器有默认最小时间的，暂时忽略），但是之前的t1任务还没有执行，还在等待，所以t2就排在t1的后面。（t2排在t1后面的原因是while造成的）都还需要等待，因为线程上的任务还没执行完毕。</li>
<li>==第七行==<code>new Promise</code>将执行promise函数，它参数是一个回调函数，这个回调函数内的代码是同步的，它的异步核心在于resolve和reject，<strong>同时这个异步任务在任务队列中属于微任务，是优先于宏任务执行的，(不管宏任务有多急，反正我是VIP)</strong>。所以先直接打印输出同步代码<code>EEEE</code>。==第九行==中的代码是个不存在的对象，这个错误要抛给reject这个状态，也就是catch去处理，但是它是异步的且是微任务，只有等到线程上的任务执行完毕，立马执行它，不管宏任务（计时器，ajax等）等待多久了。</li>
<li>==第十四行==，这是线程上的最后一个任务，打印输出	<code>IIII</code></li>
</ol>
<p>由以上分析结果：</p>
<ul>
<li>线程上的同步代码结果依次为：AAAA  CCCC  EEEE IIII</li>
<li>异步任务中的微任务结果为： HHHH</li>
<li>异步中的所有宏任务：BBBB DDDD</li>
</ul>
<div><p>提示</p>
<p>所以综上结果是：  AAAA  CCCC  EEEE  IIII  HHHH BBBB DDDD</p>
</div>
<h2 id="例2"> 例2</h2>
<blockquote>
<p>阅读下面代码，我们只考虑浏览器环境下的输出结果，写出它们结果打印的先后顺序，并分析出原因，</p>
</blockquote>
<div><pre><code><span>async</span> <span>function</span> <span>async1</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'AAAA'</span><span>)</span>
  <span>async2</span><span>(</span><span>)</span>
  console<span>.</span><span>log</span><span>(</span><span>'BBBB'</span><span>)</span>
<span>}</span>
<span>async</span> <span>function</span> <span>async2</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'CCCC'</span><span>)</span>
<span>}</span>
console<span>.</span><span>log</span><span>(</span><span>'DDDD'</span><span>)</span>
<span>setTimeout</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'FFFF'</span><span>)</span>
<span>}</span><span>,</span> <span>0</span><span>)</span>
<span>async1</span><span>(</span><span>)</span>
<span>new</span> <span>Promise</span><span>(</span><span>function</span><span>(</span><span>resolve</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'GGGG'</span><span>)</span>
  <span>resolve</span><span>(</span><span>)</span>
<span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>function</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>'HHHH'</span><span>)</span>
<span>}</span><span>)</span>
console<span>.</span><span>log</span><span>(</span><span>'IIII'</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><div><pre><code><span># 输出结果</span>
DDDD
AAAA
CCCC
BBBB
GGGG
IIII
HHHH
FFFF
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>
<p>答案解析：这道题考察重点是  js 异步执行 宏任务 微任务。</p>
</blockquote>
<ol>
<li>这道题的起始代码在==第9行==，输出<code>DDDD</code></li>
<li>==第10行==计时器开启一个异步任务t1，这个任务且为<strong>宏任务</strong>。</li>
<li>==第13行==函数<code>async1</code>执行，这个函数内没有await 所以它其实就是一个<strong>纯同步函数</strong>，打印输出<code>AAAA</code>,</li>
<li>在<code>async1</code>中执行<code>async2</code>函数，因为<code>async2</code>的内部也没有await，所以它也是个纯同步函数，打印输出<code>CCCC</code></li>
<li>紧接着打印输出<code>BBBB</code>。</li>
<li>==第14行==new Promise执行里面的代码也是同步的,所以打印输出<code>GGGG</code>,resolve()调用的时候开启一个异步任务，且这个任务是微任务，它的执行交给then()中的第一个回调函数执行，且优先级高于宏任务（t1）执行。</li>
<li>==第20行==打印输出<code>IIII</code>,此时线程上的同步任务全部执行结束。</li>
<li>在执行任务队列中的异步任务时，微任务优先于宏任务执行，所以先执行微任务打印输出 <code>HHHH</code>,然后执行宏任务 t1 打印输出 <code>FFFF</code></li>
</ol>
<div><p>提示</p>
<p>所以综上 结果输出是 DDDD AAAA CCCC BBBB  GGGG IIII HHHH FFFF</p>
</div>
<div><p>注意</p>
<p>这道题的坑就在于 async中如果没有await，那么它就是一个纯同步函数。</p>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>微任务执行问题</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-05/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-05/</guid>
      <source url="https://wangyawei.top/rss.xml">微任务执行问题</source>
      <category>面试题</category>
      <pubDate>Sat, 26 Jun 2021 13:44:23 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="例1"> 例1</h2>
<div><pre><code><span>async</span> <span>function</span> <span>t1</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> a <span>=</span> <span>await</span> <span>"lagou"</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span> <span>// lagou</span>
<span>}</span>
<span>t1</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>
<p>问题解析：<code>await</code>是一个表达式，如果后面不是一个promise对象，就直接返回对应的值。所以问题可以理解为：</p>
</blockquote>
<div><pre><code><span>async</span> <span>function</span> <span>t1</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> a <span>=</span> <span>"lagou"</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span> <span>// lagou</span>
<span>}</span>
<span>t1</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="例2"> 例2</h2>
<div><pre><code><span>async</span> <span>function</span> <span>t2</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> a <span>=</span> <span>await</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>)</span> <span>=></span> <span>{</span><span>}</span><span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span><span>//</span>
<span>}</span>
<span>t2</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><blockquote>
<p>问题解析：<code>await</code>后面如果跟一个promise对象，await将等待这个promise对象的resolve状态的值value，且将这个值返回给前面的变量，题中的promise对象的状态是一个pending状态，没有resolve状态值，所以什么也打印不了。</p>
</blockquote>
<h2 id="例3"> 例3</h2>
<div><pre><code><span>async</span> <span>function</span> <span>t3</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> a <span>=</span> <span>await</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>)</span> <span>=></span> <span>{</span>
    <span>resolve</span><span>(</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span><span>// undefined</span>
<span>}</span>
<span>t3</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>
<p>问题解析：<code>await</code>后面如果跟一个promise对象，await将等待这个promise对象的resolve状态的值value，且将这个值返回给前面的变量，题中的promise对象的状态是一个resolve状态，但是它的状态值是undefined，所以打印出undefined。</p>
</blockquote>
<h2 id="例4"> 例4</h2>
<div><pre><code><span>async</span> <span>function</span> <span>t4</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> a <span>=</span> <span>await</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>)</span> <span>=></span> <span>{</span>
    <span>resolve</span><span>(</span><span>"hello"</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span><span>// hello</span>
<span>}</span>
<span>t4</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>
<p>问题解析：<code>await</code>后面如果跟一个promise对象，await将等待这个promise对象的resolve状态的值，且将这个值返回给前面的变量，题中的promise对象的状态是一个resolve状态，它的状态值是hello，所以打印出hello。</p>
</blockquote>
<h2 id="例5"> 例5</h2>
<div><pre><code><span>async</span> <span>function</span> <span>t5</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> a <span>=</span> <span>await</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>)</span> <span>=></span> <span>{</span>
    <span>resolve</span><span>(</span><span>"hello"</span><span>)</span><span>;</span>
  <span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
    <span>return</span> <span>"lala"</span><span>;</span>
  <span>}</span><span>)</span><span>;</span>
  console<span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span><span>// lala</span>
<span>}</span>
<span>t5</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>
<p>问题解析：<code>await</code>后面如果跟一个promise对象，await将等待这个promise对象的resolve状态的值，且将这个值返回给前面的变量，题中的promise对象的状态是一个resolve状态，它的状态值是hello，紧接着后面又执行了一个then方法，then方法又会返回一个全新的promise对象，且这个then方法中的返回值会作为这个全新的promise中resolve的值，所以最终的结果是lala。</p>
</blockquote>
<h2 id="例6"> 例6</h2>
<div><pre><code><span>async</span> <span>function</span> <span>t6</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> a <span>=</span> <span>await</span> <span>fn</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>res</span><span>)</span><span>=></span><span>{</span><span>return</span> res<span>}</span><span>)</span>
  console<span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span><span>//undefined</span>
<span>}</span>
<span>async</span> <span>function</span> <span>fn</span><span>(</span><span>)</span><span>{</span>
    <span>await</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>)</span><span>=></span><span>{</span>
        <span>resolve</span><span>(</span><span>"lagou"</span><span>)</span>
    <span>}</span><span>)</span>
<span>}</span>
<span>t6</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>问题解析：<code>async</code>函数执行返回一个<code>promise</code>对象,且<code>async</code>函数内部的返回值会当作这个promise对象resolve状态的值；</p>
<div><pre><code><span>async</span> <span>function</span> <span>fn</span><span>(</span><span>)</span> <span>{</span>
  <span>return</span> <span>"la"</span><span>;</span>
<span>}</span>
<span>var</span> p <span>=</span> <span>fn</span><span>(</span><span>)</span><span>;</span>
console<span>.</span><span>log</span><span>(</span>p<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code>Promise <span>{</span><span>&lt;</span>fulfilled<span>></span>: <span>"la"</span><span>}</span>
  __proto__: Promise
  <span>[</span><span>[</span>PromiseState<span>]</span><span>]</span>: <span>"fulfilled"</span>
  <span>[</span><span>[</span>PromiseResult<span>]</span><span>]</span>: <span>"la"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>题中首先考虑 <code>fn()</code> 执行返回一个promise对象，因为fn执行没有返回值，所以这个promise对象的状态resolve的值是undefined，且将这个undefined当作下一个then中回调函数的参数，所以打印的结果是undefined</p>
</blockquote>
<h2 id="例7"> 例7</h2>
<div><pre><code><span>async</span> <span>function</span> <span>t7</span><span>(</span><span>)</span> <span>{</span>
  <span>let</span> a <span>=</span> <span>await</span> <span>fn</span><span>(</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>res</span><span>)</span><span>=></span><span>{</span><span>return</span> res<span>}</span><span>)</span>
  console<span>.</span><span>log</span><span>(</span>a<span>)</span><span>;</span> <span>// lala</span>
<span>}</span>
<span>async</span> <span>function</span> <span>fn</span><span>(</span><span>)</span><span>{</span>
    <span>await</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve</span><span>)</span><span>=></span><span>{</span>
        <span>resolve</span><span>(</span><span>"lagou"</span><span>)</span>
    <span>}</span><span>)</span>
    <span>return</span> <span>"lala"</span>
<span>}</span>
<span>t7</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>
<p>问题解析：首先考虑 <code>fn()</code> 执行返回一个promise对象，因为<code>fn()</code>执行有返回值lala，所以这个promise对象的状态resolve的值是lala，且将这个lala当作下一个then中回调函数的参数，所以打印的结果是lala。</p>
</blockquote>
<div><p>提示</p>
<ul>
<li>
<p>async函数执行的返回结果是一个promise对象，这个函数的返回值是这个promise状态值resolve的值</p>
</li>
<li>
<p>await后面如果不是一个promise对象，将直接返回这个值</p>
</li>
<li>
<p>await后面如果是一个promise对象，将会把这个promise的状态resolve的值返回出去。</p>
<p>以上没有考虑reject状态。</p>
</li>
</ul>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>this指向问题</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-06/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-06/</guid>
      <source url="https://wangyawei.top/rss.xml">this指向问题</source>
      <category>面试题</category>
      <pubDate>Sat, 26 Jun 2021 14:44:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>以下示例是在浏览器环境下执行了，nodejs下，结果会有所不同</p>
</blockquote>
<div><pre><code><span>function</span> <span>Foo</span><span>(</span><span>)</span> <span>{</span>
  <span>getName</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>1</span><span>)</span><span>;</span>
  <span>}</span><span>;</span>
  <span>return</span> <span>this</span><span>;</span>
<span>}</span>
Foo<span>.</span><span>getName</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>2</span><span>)</span><span>;</span>
<span>}</span><span>;</span>
<span>Foo</span><span>.</span>prototype<span>.</span><span>getName</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>3</span><span>)</span><span>;</span>
<span>}</span><span>;</span>
<span>var</span> <span>getName</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>4</span><span>)</span><span>;</span>
<span>}</span><span>;</span>
<span>function</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span><span>5</span><span>)</span><span>;</span>
<span>}</span>
Foo<span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>
<span>Foo</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>
<span>getName</span><span>(</span><span>)</span><span>;</span>
<span>new</span> <span>Foo<span>.</span>getName</span><span>(</span><span>)</span><span>;</span>
<span>new</span> <span>Foo</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>
<span>new</span> <span>new</span> <span>Foo</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><div><pre><code><span># 输出结果</span>
<span>2</span>
<span>1</span>
<span>1</span>
<span>2</span>
<span>3</span>
<span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>
<p>问题解析：</p>
<ul>
<li><code>Foo.getName()</code>：调用Foo的静态方法，所以，打印2</li>
<li><code>Foo().getName()</code>：Foo()就是普通函数调用，返回的this是window，后面调用window.getName()而window下的getName在Foo()调用时getName被重新赋值,所以,打印1</li>
<li><code>getName()</code>：在执行过Foo().getName()的基础上，所以getName=function(){console.log(1)}，所以打印1，==如果getName()放在Foo().getName()上先执行则打印结果为4==</li>
<li><code>new Foo.getName()</code>：构造器私有属性的getName()，所以打印2</li>
<li><code>new Foo().getName()</code>：原型上的getName()，打印3</li>
<li><code>new new Foo().getName()</code>：
<ul>
<li>首先new  Foo()得到一个空对象{}</li>
<li>向空对象中添加一个属性getName，值为一个函数</li>
<li>new {}.getName()</li>
</ul>
</li>
</ul>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>promise执行问题</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-07/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-07/</guid>
      <source url="https://wangyawei.top/rss.xml">promise执行问题</source>
      <category>面试题</category>
      <pubDate>Sat, 26 Jun 2021 17:39:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>谈一谈下列两种写法的区别</p>
</blockquote>
<div><pre><code><span>//第一种</span>
promise<span>.</span><span>then</span><span>(</span><span>(</span><span>res</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'then:'</span><span>,</span> res<span>)</span><span>;</span>
<span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'catch:'</span><span>,</span> err<span>)</span><span>;</span>
<span>}</span><span>)</span>
<span>//第二种</span>
promise<span>.</span><span>then</span><span>(</span><span>(</span><span>res</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'then:'</span><span>,</span> res<span>)</span><span>;</span>
<span>}</span><span>,</span> <span>(</span><span>err</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>'catch:'</span><span>,</span> err<span>)</span><span>;</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>
<p>问题解析：</p>
<ol>
<li>第一种 catch 方法可以捕获到 catch 之前整条 promise 链路上所有抛出的异常。</li>
<li>第二种 then 方法的第二个参数捕获的异常依赖于上一个 Promise 对象的执行结果。</li>
</ol>
</blockquote>
<div><p>提示</p>
<ol>
<li>promise.then(successCb, faildCd) 接收两个函数作为参数，来处理上一个promise 对象的结果。then 方法返回的是 promise 对象。第一种链式写法，使用catch，相当于给前面一个then方法返回的promise 注册回调，可以捕获到前面then没有被处理的异常。第二种是回调函数写法，<strong>仅为上一个promise 注册异常回调</strong>。</li>
<li>如果是promise内部报错 reject 抛出错误后，then 的第二个参数就能捕获得到，如果then的第二个参数不存在，则catch方法会捕获到。</li>
<li>如果是then的第一个参数函数 resolve 中抛出了异常，即成功回调函数出现异常后，then的第二个参数reject 捕获捕获不到，catch方法可以捕获到。</li>
</ol>
</div>
]]></content:encoded>
    </item>
    <item>
      <title>promise解决并发请求</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-08/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-08/</guid>
      <source url="https://wangyawei.top/rss.xml">promise解决并发请求</source>
      <category>面试题</category>
      <pubDate>Thu, 29 Jul 2021 23:12:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>任意时刻，同时下载的链接数量不可以超过 3 个，要求尽可能快速地将所有接口中的数据得到。</p>
</blockquote>
<h2 id="代码示例"> 代码示例</h2>
<div><pre><code><span>var</span> urls <span>=</span> <span>[</span>
  <span>'http://jsonplaceholder.typicode.com/posts/1'</span><span>,</span>
  <span>'http://jsonplaceholder.typicode.com/posts/2'</span><span>,</span> 
  <span>'http://jsonplaceholder.typicode.com/posts/3'</span><span>,</span> 
  <span>'http://jsonplaceholder.typicode.com/posts/4'</span><span>,</span>
  <span>'http://jsonplaceholder.typicode.com/posts/5'</span><span>,</span> 
  <span>'http://jsonplaceholder.typicode.com/posts/6'</span><span>,</span> 
  <span>'http://jsonplaceholder.typicode.com/posts/7'</span><span>,</span> 
  <span>'http://jsonplaceholder.typicode.com/posts/8'</span><span>,</span>
  <span>'http://jsonplaceholder.typicode.com/posts/9'</span><span>,</span> 
  <span>'http://jsonplaceholder.typicode.com/posts/10'</span>
<span>]</span>

<span>function</span> <span>loadDate</span> <span>(</span><span>url</span><span>)</span> <span>{</span>
  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> xhr <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span>
    xhr<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>resolve</span><span>(</span>xhr<span>.</span>responseText<span>)</span>
    <span>}</span>
    xhr<span>.</span><span>open</span><span>(</span><span>'GET'</span><span>,</span> url<span>)</span>
    xhr<span>.</span><span>send</span><span>(</span><span>)</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><blockquote>
<p>在 <code>urls</code> 数组中存放了 10 个接口地址。同时还定义了一个 <code>loadDate</code> 函数，这个函数接受一个 <code>url</code> 参数，返回一个 <code>Promise</code> 对象，该 <code>Promise</code> 在接口调用成功时返回 <code>resolve</code>，失败时返回 <code>reject</code>。</p>
</blockquote>
<h2 id="问题分析"> 问题分析：</h2>
<blockquote>
<p>按照题意我们可以这样做，首先并发请求 3 个 <code>url</code> 中的数据，当其中一条 <code>url</code> 请求得到数据后，立即发起对一条新 <code>url</code> 上数据的请求，我们要始终让并发数保持在 3 个，直到所有需要加载数据的 <code>url</code> 全部都完成请求并得到数据。</p>
</blockquote>
<p><strong>实现思路：</strong></p>
<p>首先并发请求3个  <code>url</code> ，得到 3 个 <code>Promise</code> ，然后组成一个叫  <code>promises</code> 的数组。再不断的调用 <code>Promise.race</code> 来返回最快改变状态的 <code>Promise</code> ，然后从数组<code>promises</code>中删掉这个 <code>Promise</code> 对象，再加入一个新的 <code>Promise</code>，直到所有的 <code>url</code> 被取完，最后再使用 <code>Promise.all</code> 来处理一遍数组<code>promises</code>中没有改变状态的 <code>Promise</code>。代码如下：</p>
<div><pre><code><span>&lt;</span><span>!</span><span>DOCTYPE</span> html<span>></span>
<span>&lt;</span>html lang<span>=</span><span>"en"</span><span>></span>
<span>&lt;</span>meta charset<span>=</span><span>"UTF-8"</span> <span>/</span><span>></span>
<span>&lt;</span>script<span>></span>

<span>const</span> urls <span>=</span> <span>[</span>
  <span>'http://jsonplaceholder.typicode.com/posts/1'</span><span>,</span>
  <span>'http://jsonplaceholder.typicode.com/posts/2'</span><span>,</span> 
  <span>'http://jsonplaceholder.typicode.com/posts/3'</span><span>,</span> 
  <span>'http://jsonplaceholder.typicode.com/posts/4'</span><span>,</span>
  <span>'http://jsonplaceholder.typicode.com/posts/5'</span><span>,</span> 
  <span>'http://jsonplaceholder.typicode.com/posts/6'</span><span>,</span> 
  <span>'http://jsonplaceholder.typicode.com/posts/7'</span><span>,</span> 
  <span>'http://jsonplaceholder.typicode.com/posts/8'</span><span>,</span>
  <span>'http://jsonplaceholder.typicode.com/posts/9'</span><span>,</span> 
  <span>'http://jsonplaceholder.typicode.com/posts/10'</span>
<span>]</span>

<span>// 保存请求结果</span>
<span>const</span> result <span>=</span> <span>[</span><span>]</span><span>;</span>

<span>function</span> <span>loadDate</span> <span>(</span><span>url</span><span>)</span> <span>{</span>
  <span>return</span> <span>new</span> <span>Promise</span><span>(</span><span>(</span><span>resolve<span>,</span> reject</span><span>)</span> <span>=></span> <span>{</span>
    <span>const</span> xhr <span>=</span> <span>new</span> <span>XMLHttpRequest</span><span>(</span><span>)</span>
    xhr<span>.</span><span>onload</span> <span>=</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
      <span>// 响应到结果保存到数组中；</span>
      result<span>.</span><span>push</span><span>(</span>Promise<span>.</span><span>resolve</span><span>(</span>xhr<span>.</span>responseText<span>)</span><span>)</span>
      <span>resolve</span><span>(</span>xhr<span>.</span>responseText<span>)</span>
    <span>}</span>
    xhr<span>.</span><span>open</span><span>(</span><span>'GET'</span><span>,</span> url<span>)</span>
    xhr<span>.</span><span>send</span><span>(</span><span>)</span>
  <span>}</span><span>)</span>
<span>}</span>

<span>function</span> <span>limitLoad</span><span>(</span><span>urls<span>,</span> handler<span>,</span> limit</span><span>)</span> <span>{</span>
    <span>// 对数组进行一个拷贝</span>
    <span>const</span> sequence <span>=</span> <span>[</span><span>]</span><span>.</span><span>concat</span><span>(</span>urls<span>)</span>
    <span>let</span> promises <span>=</span> <span>[</span><span>]</span><span>;</span>

    <span>//实现并发请求达到最大值</span>
    promises <span>=</span> sequence<span>.</span><span>splice</span><span>(</span><span>0</span><span>,</span> limit<span>)</span><span>.</span><span>map</span><span>(</span><span>(</span><span>url<span>,</span> index</span><span>)</span> <span>=></span> <span>{</span>
        <span>// 这里返回的 index 是任务在数组 promises 的下标</span>
        <span>// 获取完成的请求的下标</span>
        <span>return</span> <span>handler</span><span>(</span>url<span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> index<span>)</span><span>;</span> 
    <span>}</span><span>)</span><span>;</span>

    <span>// 利用数组的 reduce 方法来以队列的形式执行</span>
    <span>return</span> sequence<span>.</span><span>reduce</span><span>(</span><span>(</span><span>last<span>,</span> url<span>,</span> currentIndex</span><span>)</span> <span>=></span> <span>{</span>
        <span>return</span> last<span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
            <span>// 返回最快改变状态的 Promise</span>
            <span>return</span> Promise<span>.</span><span>race</span><span>(</span>promises<span>)</span>
        <span>}</span><span>)</span><span>.</span><span>catch</span><span>(</span><span>err</span> <span>=></span> <span>{</span>
            <span>// 这里的 catch 不仅用来捕获前面 then 方法抛出的错误</span>
            <span>// 更重要的是防止中断整个链式调用</span>
            console<span>.</span><span>error</span><span>(</span>err<span>)</span>
        <span>}</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>res</span><span>)</span> <span>=></span> <span>{</span>
            <span>// 用新的 Promise 替换掉最快改变状态的 Promise</span>
            promises<span>[</span>res<span>]</span> <span>=</span> <span>handler</span><span>(</span>sequence<span>[</span>currentIndex<span>]</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> res<span>)</span><span>;</span>
        <span>}</span><span>)</span>
    <span>}</span><span>,</span> Promise<span>.</span><span>resolve</span><span>(</span><span>)</span><span>)</span>
    <span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
      <span>// 处理一遍没有改变状态的 Promise。</span>
      <span>return</span> Promise<span>.</span><span>all</span><span>(</span>promises<span>)</span>
    <span>}</span><span>)</span>
<span>}</span>
<span>limitLoad</span><span>(</span>urls<span>,</span> loadDate<span>,</span> <span>3</span><span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
  Promise<span>.</span><span>all</span><span>(</span>result<span>)</span><span>.</span><span>then</span><span>(</span><span>(</span><span>res</span><span>)</span> <span>=></span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>res<span>)</span><span>;</span>
  <span>}</span><span>)</span>
<span>}</span><span>)</span>
<span>&lt;</span><span>/</span>script<span>></span>

<span>&lt;</span><span>/</span>html<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br></div></div><h2 id="场景"> 场景</h2>
<blockquote>
<p>之所以要解决并发请求，是因为浏览器有并发请求限制大约6~8个，多于这个数请求就会被阻塞，用户就会等待，影响体验。</p>
</blockquote>
<ul>
<li>可视化图表类，需要同时请求很多接口，此时可以使用这种方式，避免并发请求。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>跨域问题</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-09/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-09/</guid>
      <source url="https://wangyawei.top/rss.xml">跨域问题</source>
      <category>面试题</category>
      <pubDate>Wed, 28 Jul 2021 17:39:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>​	当一个请求url的<strong>协议、域名、端口</strong>三者之间任意一个与当前页面url不同即为跨域；</p>
</blockquote>
<ol>
<li>API跨域可以通过服务器上nginx反向代理；</li>
<li>本地webpack dev server可以设置 proxy；</li>
<li>new Image, 设src 的时候，图片需要设置Cors
cors需要后台配合设置HTTP响应头，如果请求不是简单请求（1. method：get，post，2. content-type：三种表单自带的content-type，3. 没有自定义的HTTP header），浏览器会先发送option预检请求，后端需要响应option请求，然后浏览器才会发送正式请求，cors通过白名单的形式允许指定的域发送请求；</li>
<li>jsonp是浏览器会放过 img script标签引入资源的方式。所以可以通过后端返回一段执行js函数的脚本，将数据作为参数传入。然后在前端执行这段脚本。双方约定一个函数的名称。
联调的时候会需要跨域，线上前端站点域和后台接口不一致也需要跨域，开发时跨域可以通过代理服务器来转发请求，因为跨域本身是浏览器对请求的限制，常见的跨域处理还有JSONP和cors，jsonp是利用脚本资源请求本身就可以跨域的特性，通过与请求一起发送回调函数名，后台返回script脚本直接执行回调，但是由于资源请求是get类型，请求参数长度有限制，也不能进行post请求。cors需要后台配合设置HTTP响应头，如果请求不是简单请求（1. method：get，post，2. content-type：三种表单自带的content-type，3. 没有自定义的HTTP header），浏览器会先发送option预检请求，后端需要响应option请求，然后浏览器才会发送正式请求，cors通过白名单的形式允许指定的域发送请求
同源策略只是浏览器客户端的防护机制，当发现非同源HTTP请求时会拦截响应，但服务器依然处理了这个请求。
服务器端不拦截，所以在同源服务器下做代理，可以实现跨域。
我之前这么看的node中间层处理跨域。</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>deno相关问题</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-10/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-10/</guid>
      <source url="https://wangyawei.top/rss.xml">deno相关问题</source>
      <category>面试题</category>
      <pubDate>Wed, 28 Jul 2021 17:39:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Deno发公告说要把部分ts代码重构为js。 你觉得这是什么原因？</p>
</blockquote>
<h2 id="官方回答"> 官方回答</h2>
<blockquote>
<p>在使用 TypeScript 编写内部代码时，Deno 团队遇到了以下几个现实问题：
在变更文件时，TypeScript 往往需要几分钟的编译时间，这就导致连续编译过程变得非常缓慢；
在创建 Deno 可执行文件以及面向用户的 API 源文件时，TypeScript 结构会引发一系列运行时性能问题；
TypeScript 本身对于 Deno 代码的组织工作毫无帮助，反而增强了代码组织负担。Deno 团队提出的一大现实问题，是 TypeScript 会在两个位置复制相互独立的 Body 类；
https://github.com/denoland/deno/issues/4748
由于 TypeScript 编译器无法帮助开发者生成 d.ts 文件，内部代码与运行时 TypeScript 声明必须以手动方式保持同步；
他们维护着两台 TS 编译器主机：一台用于内部 Deno 代码，另一台用于外部用户代码，但二者的作用其实非常相似。</p>
</blockquote>
<h2 id="扩展链接"> 扩展链接</h2>
<p>https://mp.weixin.qq.com/s/h1ZNewMZZC20o80P37KqsQ</p>
]]></content:encoded>
    </item>
    <item>
      <title>watch和computed的区别以及怎么选用?</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-100/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-100/</guid>
      <source url="https://wangyawei.top/rss.xml">watch和computed的区别以及怎么选用?</source>
      <category>面试题</category>
      <pubDate>Tue, 21 Sep 2021 13:17:34 GMT</pubDate>
      <content:encoded><![CDATA[<ul>
<li>
<p>定义/语义区别</p>
</li>
<li>
<p>功能区别</p>
<p>watch更通用，computed派生功能都能实现，计算属性底层来自于watch，但做了更多，例如缓存</p>
</li>
<li>
<p>用法区别</p>
<ul>
<li>computed更简单/更高效，优先使用</li>
<li>有些必须watch，比如值变化要和后端交互</li>
</ul>
</li>
<li>
<p>使用场景</p>
<ul>
<li>watch需要在数据变化时执行异步或开销较大的操作时使用，简单讲，当一条数据影响多条数据的时候，例如 搜索数据</li>
<li>对于任何复杂逻辑或一个数据属性在它所依赖的属性发生变化时，也要发生变化，简单讲。当一个属性受多个属性影响的时候，例如 购物车商品结算时</li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>你知道nextTick的原理吗?</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-105/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-105/</guid>
      <source url="https://wangyawei.top/rss.xml">你知道nextTick的原理吗?</source>
      <category>面试题</category>
      <pubDate>Tue, 21 Sep 2021 13:27:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>nextTick官方文档的解释，它可以在DOM更新完毕之后执行一个回调</p>
</blockquote>
<p>尽管MVVM框架并不推荐访问DOM，但有时候确实会有这样的需求，尤其是和第三方插件进行配合的时候，免不了要进行DOM操作。而nextTick就提供了一个桥梁，确保我们操作的是更新后的DOM。</p>
<p>MutationObserver是HTML5新增的属性，用于监听DOM修改事件，能够监听到节点的属性、文本内容、子节点等的改动，是一个功能强大的利器</p>
<p>vue用MutationObserver是想利用它的microtask特性，而不是想做DOM监听。核心是microtask，用不用MutationObserver都行的。事实上，vue在2.5版本中已经删去了MutationObserver相关的代码，因为它是HTML5新增的特性，在iOS上尚有bug。那么最优的microtask策略就是Promise了，而令人尴尬的是，Promise是ES6新增的东西，也存在兼容问题呀。所以vue就面临一个降级策略。</p>
<p>队列控制的最佳选择是microtask，而microtask的最佳选择是Promise.但如果当前环境不支持Promise，vue就不得不降级macrotask来做队列控制了。macrotask有哪些可选的方案呢？前面提到了setTimeout是一种，但它不是理想的方案。因为setTimeout执行的最小时间间隔是约4ms的样子，略微有点延迟。在vue2.5的源码中，macrotask降级的方案依次是：setImmediate、MessageChannel、setTimeout.setImmediate是最理想的方案了，可惜的是只有IE和nodejs支持。MessageChannel的onmessage回调也是microtask，但也是个新API，面临兼容性的尴尬。所以最后的兜底方案就是setTimeout了，尽管它有执行延迟，可能造成多次渲染，算是没有办法的办法
了。</p>
]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>javascript</category>
      <pubDate>Sun, 08 Aug 2021 15:07:22 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些自己平时学习javascript的一些相关的知识；</p>
</blockquote>
<h2 id="目录"> 目录</h2>
<ul>
<li><a href="./javascript-note-000.html">基础</a></li>
<li><a href="./javascript-note-19.html">js数据类型</a></li>
<li><a href="./javascript-note-20.html">变量的复制</a></li>
<li><a href="./javascript-note-21.html">类型转换</a></li>
<li><a href="./javascript-note-22.html">类型检测</a></li>
<li><a href="./javascript-note-26.html">声明提升</a></li>
<li><a href="./javascript-note-53.html">创建和访问对象</a></li>
<li>高级
<ul>
<li><a href="./javascript-note-01.html">javascript高级</a></li>
<li><a href="./javascript-note-02.html">对象拷贝</a></li>
<li><a href="./javascript-note-05.html">函数继承</a></li>
<li><a href="./javascript-note-25.html">什么是作用域</a></li>
<li><a href="./javascript-note-28.html">作用域链</a></li>
<li><a href="./javascript-note-29.html">作用域链延长</a></li>
<li><a href="./javascript-note-30.html">原型</a></li>
<li><a href="./javascript-note-31.html">深拷贝与浅拷贝</a></li>
<li><a href="./javascript-note-32.html">this对象</a></li>
</ul>
</li>
<li>ES6相关
<ul>
<li><a href="./javascript-note-00.html">ES6</a></li>
<li><a href="./javascript-note-06.html">Async 函数</a></li>
<li><a href="./javascript-note-23.html">模板字符串</a></li>
<li><a href="./javascript-note-24.html">Symbol</a></li>
<li><a href="./javascript-note-27.html">变量声明</a></li>
</ul>
</li>
<li>进阶
<ul>
<li><a href="./javascript-note-03.html">函数防抖</a></li>
<li><a href="./javascript-note-04.html">函数节流</a></li>
<li><a href="./javascript-note-07.html">jsonp跨域的实现原理</a></li>
<li><a href="./javascript-note-08.html">new的实现原理</a></li>
<li><a href="./javascript-note-09.html">什么是Promise</a></li>
<li><a href="./javascript-note-11.html">javascript内存管理</a></li>
<li><a href="./javascript-note-12.html">单元测试</a></li>
<li><a href="./javascript-note-13.html">提高代码可靠性</a></li>
<li><a href="./javascript-note-18.html">链表数据结构</a></li>
<li><a href="./javascript-note-33.html">尾调用优化</a></li>
<li><a href="./javascript-note-39.html">同步与异步</a></li>
<li><a href="./javascript-note-40.html">javascript单线程</a></li>
<li><a href="./javascript-note-41.html">定时器</a></li>
<li><a href="./javascript-note-43.html">Event Loop机制</a></li>
<li><a href="./javascript-note-44.html">发布订阅</a></li>
<li><a href="./javascript-note-45.html">深入理解Promise</a></li>
<li><a href="./javascript-note-46.html">Generator函数及其异步应用</a></li>
<li><a href="./javascript-note-47.html">Generator函数的实现原理</a></li>
<li><a href="./javascript-note-48.html">co模块源码分析</a></li>
<li><a href="./javascript-note-49.html">深入理解async/await</a></li>
<li><a href="./javascript-note-50.html">async函数实现原理</a></li>
<li><a href="./javascript-note-51.html">promise A+规范</a></li>
<li><a href="./javascript-note-52.html">手写promise</a></li>
<li><a href="./javascript-note-54.html">编译原理</a></li>
<li><a href="./javascript-note-55.html">chunk函数及其应用</a></li>
<li><a href="./javascript-note-56.html">Rxjs</a></li>
<li><a href="./javascript-note-57.html">Web Workers</a></li>
<li><a href="./defineProperty-58.html">defineProperty</a></li>
</ul>
</li>
<li>函数应用
<ul>
<li><a href="./javascript-note-34.html">立即执行函数(IIFE)</a></li>
<li><a href="./javascript-note-35.html">闭包</a></li>
<li><a href="./javascript-note-36.html">递归</a></li>
<li><a href="./javascript-note-37.html">回调</a></li>
<li><a href="./javascript-note-38.html">柯里化</a></li>
<li><a href="./javascript-note-14.html">compose函数和pipe函数</a></li>
<li><a href="./javascript-note-15.html">高阶函数</a></li>
<li><a href="./javascript-note-16.html">常用函数</a></li>
</ul>
</li>
<li>其他
<ul>
<li><a href="./javascript-note-10.html">打包及本地预览</a></li>
<li><a href="./javascript-note-42.html">js实现复制粘贴</a></li>
</ul>
</li>
</ul>
<h2 id="参考资料"> 参考资料</h2>
<ul>
<li>CDN官方文档；</li>
<li>javascript权威指南；</li>
<li>你不知道的javascript系列；</li>
<li>博客园网站；</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>sourceMap相关</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-11/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-11/</guid>
      <source url="https://wangyawei.top/rss.xml">sourceMap相关</source>
      <category>面试题</category>
      <pubDate>Wed, 28 Jul 2021 17:39:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Sourcemap是什么？有什么作用？在生产环境怎么用？</p>
</blockquote>
<p><code>Sourcemap</code> 本质上是一个信息文件，里面储存着代码转换前后的对应位置信息。它记录了转换压缩后的代码所对应的转换前的源代码位置，是源代码和生产代码的映射。 <code>Sourcemap</code> 解决了在打包过程中，代码经过压缩，去空格以及 <code>babel</code> 编译转化后，由于代码之间差异性过大，造成无法<code>debug</code>的问题，简单说 <code>Sourcemap</code> 构建了处理前以及处理后的代码之间的一座桥梁，方便定位生产环境中出现 <code>bug</code> 的位置。因为现在的前端开发都是模块化、组件化的方式，在上线前对 js 和 css 文件进行合并压缩容易造成混淆。如果对这样的线上代码进行调试，肯定不切实际，<code>sourceMap</code> 的作用就是能够让浏览器的调试面版将生成后的代码映射到源码文件当中，开发者可以在源码文件中 debug，这样就会让程序员调试轻松、简单很多。</p>
<p><code>Sourcemap</code> 的种类有很多， 在生产环境下可以用<code>process.env</code>判断一下。  <code>webpack</code>中可以在<code>devtool</code>中设置, 在开发环境中可以配置<code>devtool</code>为<code>cheap-module-source-map</code>，方便调试。生产环境下建议采用<code>none</code>的方式，这样做不暴露源代码。或者是<code>nosources-source-map</code> 的方式，既可以定位源代码位置，又不暴露源代码。</p>
]]></content:encoded>
    </item>
    <item>
      <title>简单说一说vue生命周期的理解?</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-110/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-110/</guid>
      <source url="https://wangyawei.top/rss.xml">简单说一说vue生命周期的理解?</source>
      <category>面试题</category>
      <pubDate>Tue, 21 Sep 2021 13:27:34 GMT</pubDate>
      <content:encoded><![CDATA[<p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="vue生命周期" /></p>
<h2 id="实例化"> 实例化</h2>
<p>Vue的本质就是一个 function , new Vue 的过程就是初始化参数、生命周期、事件等一系列过程</p>
<h2 id="初始化事件-生命周期函数"> 初始化事件 生命周期函数</h2>
<p>这时候，这个对象身上只有默认一些生命周期函数和默认的事件，其他的东西都未创建。</p>
<h2 id="beforecreate创建前"> beforeCreate创建前</h2>
<p>接着就是 beforeCreate（创建前） 执行。但是这个时候拿不到 data 里边的数据。data和methods中的数据都还没初始化。</p>
<h2 id="注射响应"> 注射响应</h2>
<p>injections(注射器) reactivity(响应) 给数据添加观察者。</p>
<h2 id="created创建后"> created创建后</h2>
<p>created创建后 执行。因为上边给数据添加了观察者，所以现在就可以访问到 data 里的数据了。这个钩子也是常用的，可以请求数据了。如果要调用methods中的方法或者操作data中数据，要在created里操作。要因为请求数据是异步的，所以发送请求宜早不宜迟，通常在这个时候发送请求。</p>
<h2 id="是否存在-el"> 是否存在 el</h2>
<p>el 指明挂载目标。这个步骤就是判断一下是否有写 el ，如果没有就判断有没有调用实例上的$mount('') 方法调用。也就是下一张图</p>
<h2 id="判断是否有-template"> 判断是否有 template</h2>
<p>如果有 template 则渲染 template 里的内容。  如果没有 则渲染 el 指明的挂载对象里的内容。</p>
<h2 id="beforemount挂载前"> beforeMount挂载前</h2>
<h2 id="替换-el"> 替换 el</h2>
<p>这个时候会在实例上创建一个 el ，替换掉原来的 el 。也是真正的挂载。</p>
<h2 id="mounted挂载后"> mounted挂载后</h2>
<p>mounted挂载后 执行。这个时候 DOM 已经加载完成了，可以操作 DOM 了。只要执行完了mounted，就表示整个vue实例已经初始化完毕了。这个也是常用的钩子。一般操作 DOM 都是在这里</p>
<h2 id="datachange"> dataChange</h2>
<p>当数据有变动时，会触发下面这两个钩子。</p>
<p>在 beforeUpdate更新前 和 updated更新后 之间会进行 DOM 的重新渲染和补全。  接着是 updated 更新后</p>
<h2 id="calldestroy"> callDestroy</h2>
<p>beforeDestroy销毁前 和 destroy销毁后 这两个钩子是需要我们手动调用实例上的 $destroy 方法才会触发的。
当 $destroy 方法调用后。
beforeDestroy 销毁前触发</p>
<p>移除数据劫持、事件监听、子组件属性 所有的东西还保留 只是不能修改</p>
<div><p>提示</p>
<p>新增钩子</p>
<ul>
<li>activated：keep-alive 组件激活时调用。
类似 created 没有真正创建，只是激活</li>
<li>deactivated：keep-alive 组件停用时调用。
类似 destroyed 没有真正移除，只是禁用</li>
<li>在 2.2.0 及其更高版本中，activated 和 deactivated 将会在 树内的所有嵌套组件中触发。</li>
</ul>
</div>
<h2 id="总结"> 总结</h2>
<ol>
<li>beforeCreate：在实例初始化之后，数据观测（data observe）和event/watcher事件配置之前被调
用，这时无法访问data及props等数据；</li>
<li>created：在实例创建完成后被立即调用，此时实例已完成数据观测（data observer），属性和方法
的运算，watch/event事件回调，挂载阶段还没开始， $el 尚不可用。</li>
<li>beforemount:在挂载开始之前被调用，相关的render函数首次被调用。</li>
<li>mounted：实例被挂载后调用，这时el被新创建的vm. $el 替换，若根实例挂载到了文档上的元素
上，当mounted被调用时vm.$el也在文档内。注意mounted不会保证所有子组件一起挂载。</li>
<li>beforeupdata：数据更新时调用，发生在虚拟dom打补丁前，这时适合在更新前访问现有dom，如
手动移除已添加的事件监听器。</li>
<li>updated：在数据变更导致的虚拟dom重新渲染和打补丁后，调用该钩子。当这个钩子被调用时，组
件dom已更新，可执行依赖于dom的操作。多数情况下应在此期间更改状态。 如需改变，最好使用
watcher或计算属性取代。注意updated不会保证所有的子组件都能一起被重绘。</li>
<li>beforedestory：在实例销毁之前调用。在这时，实例仍可用。</li>
<li>destroyed：实例销毁后调用，这时vue实例的所有指令都被解绑，所有事件监听器被移除，所有子实
例也被销毁。</li>
</ol>
]]></content:encoded>
      <enclosure url="https://cn.vuejs.org/images/lifecycle.png" type="image/png"/>
    </item>
    <item>
      <title>Vue 响应式原理</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-15/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-15/</guid>
      <source url="https://wangyawei.top/rss.xml">Vue 响应式原理</source>
      <category>面试题</category>
      <pubDate>Wed, 15 Sep 2021 23:39:23 GMT</pubDate>
      <content:encoded><![CDATA[<p><img src="https://img.php.cn/upload/image/762/873/541/1594627762299440.png" alt="图片" /></p>
<blockquote>
<p>当创建 Vue 实例时,vue 会遍历 data 选项的属性,利用 Object.defineProperty 为属性添加 getter 和 setter 对数据的读取进行劫持（getter 用来依赖收集,setter 用来派发更新）,并且在内部追踪依赖,在属性被访问和修改时通知变化。
每个组件实例会有相应的 watcher 实例,会在组件渲染的过程中记录依赖的所有数据属性（进行依赖收集,还有 computed watcher,user watcher 实例）,之后依赖项被改动时,setter 方法会通知依赖与此 data 的 watcher 实例重新计算（派发更新）,从而使它关联的组件重新渲染。</p>
</blockquote>
<p>一句话总结:</p>
<p>vue.js 采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter,getter,在数据变动时发布消息给订阅者,触发响应的监听回调;</p>
<p><a href="https://www.php.cn/js-tutorial-455048.html" target="_blank" rel="noopener noreferrer">阅读原文</a></p>
]]></content:encoded>
      <enclosure url="https://img.php.cn/upload/image/762/873/541/1594627762299440.png" type="image/png"/>
    </item>
    <item>
      <title>computed 的实现原理</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-20/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-20/</guid>
      <source url="https://wangyawei.top/rss.xml">computed 的实现原理</source>
      <category>面试题</category>
      <pubDate>Wed, 15 Sep 2021 23:39:23 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>computed 本质是一个惰性求值的观察者，具有缓存的功能。数据如果不发生变化则每次获取不再做计算。</p>
</blockquote>
<p>一句话总结:</p>
<p>vue.js 采用数据劫持结合发布-订阅模式,通过 Object.defineproperty 来劫持各个属性的 setter,getter,在数据变动时发布消息给订阅者,触发响应的监听回调;</p>
<p><a href="https://www.php.cn/js-tutorial-455048.html" target="_blank" rel="noopener noreferrer">阅读原文</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>v-if和v-for哪个优先级更高？</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-25/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-25/</guid>
      <source url="https://wangyawei.top/rss.xml">v-if和v-for哪个优先级更高？</source>
      <category>面试题</category>
      <pubDate>Mon, 20 Sep 2021 17:07:59 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>原问：v-if和v-for哪个优先级更高？如果两个同时出现，应该怎么优化得到更好的性能？</p>
</blockquote>
<p>解答这个问题的话，我们需要一些依据，那么最好的解答方式就是直接源码中解答：在源码：<code>compiler/codegen/index.js</code>中：</p>
<div><pre><code><span>export</span> <span>function</span> <span>genElement</span> <span>(</span><span>el<span>:</span> ASTElement<span>,</span> state<span>:</span> CodegenState</span><span>)</span><span>:</span> string <span>{</span>
 
  <span>if</span> <span>(</span>el<span>.</span>staticRoot <span>&amp;&amp;</span> <span>!</span>el<span>.</span>staticProcessed<span>)</span> <span>{</span>
    <span>return</span> <span>genStatic</span><span>(</span>el<span>,</span> state<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>el<span>.</span>once <span>&amp;&amp;</span> <span>!</span>el<span>.</span>onceProcessed<span>)</span> <span>{</span>
    <span>return</span> <span>genOnce</span><span>(</span>el<span>,</span> state<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>el<span>.</span>for <span>&amp;&amp;</span> <span>!</span>el<span>.</span>forProcessed<span>)</span> <span>{</span>
    <span>return</span> <span>genFor</span><span>(</span>el<span>,</span> state<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>el<span>.</span>if <span>&amp;&amp;</span> <span>!</span>el<span>.</span>ifProcessed<span>)</span> <span>{</span>
    <span>return</span> <span>genIf</span><span>(</span>el<span>,</span> state<span>)</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>el<span>.</span>tag <span>===</span> <span>'template'</span> <span>&amp;&amp;</span> <span>!</span>el<span>.</span>slotTarget <span>&amp;&amp;</span> <span>!</span>state<span>.</span>pre<span>)</span> <span>{</span>
    <span>return</span> <span>genChildren</span><span>(</span>el<span>,</span> state<span>)</span> <span>||</span> <span>'void 0'</span>
  <span>}</span> <span>else</span> <span>if</span> <span>(</span>el<span>.</span>tag <span>===</span> <span>'slot'</span><span>)</span> <span>{</span>
    <span>return</span> <span>genSlot</span><span>(</span>el<span>,</span> state<span>)</span>
  <span>}</span> <span>else</span> <span>{</span>
    <span>// component or element</span>
    <span>let</span> code
    <span>if</span> <span>(</span>el<span>.</span>component<span>)</span> <span>{</span>
      code <span>=</span> <span>genComponent</span><span>(</span>el<span>.</span>component<span>,</span> el<span>,</span> state<span>)</span>
    <span>}</span> <span>else</span> <span>{</span>
      <span>let</span> data
      <span>if</span> <span>(</span><span>!</span>el<span>.</span>plain <span>||</span> <span>(</span>el<span>.</span>pre <span>&amp;&amp;</span> state<span>.</span><span>maybeComponent</span><span>(</span>el<span>)</span><span>)</span><span>)</span> <span>{</span>
        data <span>=</span> <span>genData</span><span>(</span>el<span>,</span> state<span>)</span>
      <span>}</span>

      <span>const</span> children <span>=</span> el<span>.</span>inlineTemplate <span>?</span> <span>null</span> <span>:</span> <span>genChildren</span><span>(</span>el<span>,</span> state<span>,</span> <span>true</span><span>)</span>
      code <span>=</span> <span><span>`</span><span>_c('</span><span><span>${</span>el<span>.</span>tag<span>}</span></span><span>'</span><span><span>${</span>
        data <span>?</span> <span><span>`</span><span>,</span><span><span>${</span>data<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span> <span>// data</span>
      <span>}</span></span><span><span>${</span>
        children <span>?</span> <span><span>`</span><span>,</span><span><span>${</span>children<span>}</span></span><span>`</span></span> <span>:</span> <span>''</span> <span>// children</span>
      <span>}</span></span><span>)</span><span>`</span></span>
    <span>}</span>
    <span>// module transforms</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> state<span>.</span>transforms<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      code <span>=</span> state<span>.</span>transforms<span>[</span>i<span>]</span><span>(</span>el<span>,</span> code<span>)</span>
    <span>}</span>
    <span>return</span> code
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br></div></div><blockquote>
<p>以上这段是由AST生成渲染函数的部分代码，通过代码我们可以看到if判断逻辑先执行的是for循环，然后是if，这就说明了我们的问题: <code>v-for</code>的优先级比<code>v-if</code>高。</p>
</blockquote>
<p>如果两个同时出现，应该怎么优化得到更好的性能？</p>
<ul>
<li>最先要确定的是不要同时在一个标签上使用<code>v-for</code>和<code>v-if</code>。因为如果不这样做那么循环和判断都不可避免，浪费性能。</li>
<li>可以把<code>v-if</code>放在<code>v-for</code>的里面，这样就可以避免每次<code>v-for</code>的时候都执行一遍<code>v-if</code>，同时又肯定了if不成立循环不执行。</li>
<li>如果条件出现在循环内部，可通过计算属性提前过滤掉那些不需要显示的项或自己把数据先处理好，保证在渲染的时候就是自己真实要显示的数据。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Vue组件data为什么必须是个函数而Vue的根实例则没有此限制？</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-30/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-30/</guid>
      <source url="https://wangyawei.top/rss.xml">Vue组件data为什么必须是个函数而Vue的根实例则没有此限制？</source>
      <category>面试题</category>
      <pubDate>Mon, 20 Sep 2021 17:34:59 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>不知道看到题目的你有没有想过这个事情，下面就解释为什么？</p>
</blockquote>
<p>同样的最好的答案就是查看源码，以下是一段vue的源码：</p>
<div><pre><code><span>// src\core\instance\state.js - initData()</span>
<span>function</span> <span>initData</span> <span>(</span><span>vm<span>:</span> Component</span><span>)</span> <span>{</span>
  <span>let</span> data <span>=</span> vm<span>.</span>$options<span>.</span>data
  data <span>=</span> vm<span>.</span>_data <span>=</span> <span>typeof</span> data <span>===</span> <span>'function'</span>
    <span>?</span> <span>getData</span><span>(</span>data<span>,</span> vm<span>)</span>
    <span>:</span> data <span>||</span> <span>{</span><span>}</span>
 <span>...</span>省略
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p>可能突然看到上面的一小段代码也不知道要说明什么，那么我们可以简单的从组件化说起，在vue的项目中我们常常会封装很多业务组件然后在很多其他的页面中使用，但是你需要解决的问题是数据的独立性，各个页面中的组件数据应该是独立的，那么这一点vue给我们解决了，解决的方法就是返回一个全新的对象来保证数据的独立性。上面的这段代码我们可以看到当data是函数时返回的是函数的调用结果，而当data是对象的时候则直接返回。</p>
</blockquote>
<div><p>提示</p>
<p>当你强行返回一个对象时，vue会给出如下警告：</p>
<p><img src="./assets/image-20210920173314251.png" alt="image-20210920173314251" /></p>
</div>
<p><strong>解答：</strong></p>
<p>Vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例，这是不合理的；采用函数形式定义，在initData时会将其作为工厂函数返回全新data对象，有效规避多实例之间状态污染问题。而在Vue根实例创建过程中则不存在该限制，也是因为根实例只能有一个，不需要担心这种情况。</p>
]]></content:encoded>
    </item>
    <item>
      <title>你知道vue中key的作用和工作原理吗？说说你对它的理解</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-35/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-35/</guid>
      <source url="https://wangyawei.top/rss.xml">你知道vue中key的作用和工作原理吗？说说你对它的理解</source>
      <category>面试题</category>
      <pubDate>Mon, 20 Sep 2021 20:05:34 GMT</pubDate>
      <content:encoded><![CDATA[<p>最有力的说明就是源码，咱直接上源码：</p>
<div><pre><code><span>// src\core\vdom\patch.js - updateChildren()</span>
<span>function</span> <span>updateChildren</span> <span>(</span><span>parentElm<span>,</span> oldCh<span>,</span> newCh<span>,</span> insertedVnodeQueue<span>,</span> removeOnly</span><span>)</span> <span>{</span>
	<span>...</span>省略
    <span>while</span> <span>(</span>oldStartIdx <span>&lt;=</span> oldEndIdx <span>&amp;&amp;</span> newStartIdx <span>&lt;=</span> newEndIdx<span>)</span> <span>{</span>
      <span>if</span> <span>(</span><span>isUndef</span><span>(</span>oldStartVnode<span>)</span><span>)</span> <span>{</span>
        oldStartVnode <span>=</span> oldCh<span>[</span><span>++</span>oldStartIdx<span>]</span> <span>// Vnode has been moved left</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>isUndef</span><span>(</span>oldEndVnode<span>)</span><span>)</span> <span>{</span>
        oldEndVnode <span>=</span> oldCh<span>[</span><span>--</span>oldEndIdx<span>]</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>sameVnode</span><span>(</span>oldStartVnode<span>,</span> newStartVnode<span>)</span><span>)</span> <span>{</span>
        <span>patchVnode</span><span>(</span>oldStartVnode<span>,</span> newStartVnode<span>,</span> insertedVnodeQueue<span>,</span> newCh<span>,</span> newStartIdx<span>)</span>
        oldStartVnode <span>=</span> oldCh<span>[</span><span>++</span>oldStartIdx<span>]</span>
        newStartVnode <span>=</span> newCh<span>[</span><span>++</span>newStartIdx<span>]</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>sameVnode</span><span>(</span>oldEndVnode<span>,</span> newEndVnode<span>)</span><span>)</span> <span>{</span>
        <span>patchVnode</span><span>(</span>oldEndVnode<span>,</span> newEndVnode<span>,</span> insertedVnodeQueue<span>,</span> newCh<span>,</span> newEndIdx<span>)</span>
        oldEndVnode <span>=</span> oldCh<span>[</span><span>--</span>oldEndIdx<span>]</span>
        newEndVnode <span>=</span> newCh<span>[</span><span>--</span>newEndIdx<span>]</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>sameVnode</span><span>(</span>oldStartVnode<span>,</span> newEndVnode<span>)</span><span>)</span> <span>{</span> <span>// Vnode moved right</span>
        <span>patchVnode</span><span>(</span>oldStartVnode<span>,</span> newEndVnode<span>,</span> insertedVnodeQueue<span>,</span> newCh<span>,</span> newEndIdx<span>)</span>
        canMove <span>&amp;&amp;</span> nodeOps<span>.</span><span>insertBefore</span><span>(</span>parentElm<span>,</span> oldStartVnode<span>.</span>elm<span>,</span> nodeOps<span>.</span><span>nextSibling</span><span>(</span>oldEndVnode<span>.</span>elm<span>)</span><span>)</span>
        oldStartVnode <span>=</span> oldCh<span>[</span><span>++</span>oldStartIdx<span>]</span>
        newEndVnode <span>=</span> newCh<span>[</span><span>--</span>newEndIdx<span>]</span>
      <span>}</span> <span>else</span> <span>if</span> <span>(</span><span>sameVnode</span><span>(</span>oldEndVnode<span>,</span> newStartVnode<span>)</span><span>)</span> <span>{</span> <span>// Vnode moved left</span>
        <span>patchVnode</span><span>(</span>oldEndVnode<span>,</span> newStartVnode<span>,</span> insertedVnodeQueue<span>,</span> newCh<span>,</span> newStartIdx<span>)</span>
        canMove <span>&amp;&amp;</span> nodeOps<span>.</span><span>insertBefore</span><span>(</span>parentElm<span>,</span> oldEndVnode<span>.</span>elm<span>,</span> oldStartVnode<span>.</span>elm<span>)</span>
        oldEndVnode <span>=</span> oldCh<span>[</span><span>--</span>oldEndIdx<span>]</span>
        newStartVnode <span>=</span> newCh<span>[</span><span>++</span>newStartIdx<span>]</span>
      <span>}</span> <span>else</span> <span>{</span>
        <span>...</span>省略
      <span>}</span>
    <span>}</span>
    <span>if</span> <span>(</span>oldStartIdx <span>></span> oldEndIdx<span>)</span> <span>{</span>
      refElm <span>=</span> <span>isUndef</span><span>(</span>newCh<span>[</span>newEndIdx <span>+</span> <span>1</span><span>]</span><span>)</span> <span>?</span> <span>null</span> <span>:</span> newCh<span>[</span>newEndIdx <span>+</span> <span>1</span><span>]</span><span>.</span>elm
      <span>addVnodes</span><span>(</span>parentElm<span>,</span> refElm<span>,</span> newCh<span>,</span> newStartIdx<span>,</span> newEndIdx<span>,</span> insertedVnodeQueue<span>)</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>newStartIdx <span>></span> newEndIdx<span>)</span> <span>{</span>
      <span>removeVnodes</span><span>(</span>oldCh<span>,</span> oldStartIdx<span>,</span> oldEndIdx<span>)</span>
    <span>}</span>
  <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><blockquote>
<p>上面的代码你或许看不懂，所以咱举个例子</p>
</blockquote>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>demo<span>"</span></span><span>></span></span>
  <span><span><span>&lt;</span>p</span> <span>v-for</span><span><span>=</span><span>"</span>item in items<span>"</span></span> <span>:key</span><span><span>=</span><span>"</span>item<span>"</span></span><span>></span></span>{{item}}<span><span><span>&lt;/</span>p</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>../../dist/vue.js<span>"</span></span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
  <span>// 创建实例</span>
  <span>const</span> app <span>=</span> <span>new</span> <span>Vue</span><span>(</span><span>{</span>
    el<span>:</span> <span>'#demo'</span><span>,</span>
    data<span>:</span> <span>{</span> items<span>:</span> <span>[</span><span>'a'</span><span>,</span> <span>'b'</span><span>,</span> <span>'c'</span><span>,</span> <span>'d'</span><span>,</span> <span>'e'</span><span>]</span> <span>}</span><span>,</span>
    <span>mounted</span> <span>(</span><span>)</span> <span>{</span>
      <span>setTimeout</span><span>(</span><span>(</span><span>)</span> <span>=></span> <span>{</span>
        <span>this</span><span>.</span>items<span>.</span><span>splice</span><span>(</span><span>2</span><span>,</span> <span>0</span><span>,</span> <span>'f'</span><span>)</span>
      <span>}</span><span>,</span> <span>2000</span><span>)</span><span>;</span>
    <span>}</span><span>,</span>
  <span>}</span><span>)</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><blockquote>
<p>上面案例我们渲染一个数组中的数据，并在2s后插入一条数据到该数组中，那么在使用key和不使用key的情况如下所示。</p>
</blockquote>
<p><strong>不适用key：</strong></p>
<p><img src="./assets/image-20210920175234170.png" alt="image-20210920175234170" /></p>
<p><strong>使用key:</strong></p>
<p><img src="./assets/image-20210920175306583.png" alt="image-20210920175306583" /></p>
<div><pre><code><span>// 首次循环patch A</span>
<span>A</span> <span>B</span> <span>C</span> <span>D</span> <span>E</span>
<span>A</span> <span>B</span> <span>F</span> <span>C</span> <span>D</span> <span>E</span>
<span>// 第2次循环patch B</span>
<span>B</span> <span>C</span> <span>D</span> <span>E</span>
<span>B</span> <span>F</span> <span>C</span> <span>D</span> <span>E</span>
<span>// 第3次循环patch E</span>
<span>C</span> <span>D</span> <span>E</span>
<span>F</span> <span>C</span> <span>D</span> <span>E</span>
<span>// 第4次循环patch D</span>
<span>C</span> <span>D</span>
<span>F</span> <span>C</span> <span>D</span>
<span>// 第5次循环patch C</span>
<span>C</span> <span>F</span>
<span>C</span>
<span>// oldCh全部处理结束，newCh中剩下的F，创建F并插入到C前面</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>通过上面的过程我们可以看出使用key和不使用key在dom的更新策略上其实是有很大区别的，那么下面就间述下dom的更新过程。</p>
<p>说到更新这里要提到一个diff算法，上面的更新过程就是diff算法的一部分。vue在更新视图之前会进行虚拟dom比较也就是diff算法。</p>
<ol>
<li>
<p>不使用key:</p>
<p>如果不使用key值，那么vue就依次更新abcde，也就是说，从c开始就会一直覆盖式更新，最后创建一个e。</p>
</li>
<li>
<p>使用key：</p>
<p>如果使用key值，那么vue在进行c f对比的时候就会使用优化策略，按照【新前与旧前，新后与旧后，新后与旧前，新前与旧后】的方式依次进行对比。最后只会执行dom e的插入操作。这样以来就大大提升了我们的web性能。减少了不必要的性能消耗。</p>
</li>
<li>
<p>另外，若不设置key还可能在列表更新时引发一些隐蔽的bug ,<a href="https://codesandbox.io/s/vue-template-forked-kivn6?file=/src/App.vue" target="_blank" rel="noopener noreferrer">案例</a></p>
</li>
</ol>
<blockquote>
<p>key的作用主要是为了高效的更新虚拟DOM，其原理是vue在patch过程中通过key可以精准判断两个节点是否是同一个，从而避免频繁更新不同元素，使得整个patch过程更加高效，减少DOM操作量，提高性能。</p>
</blockquote>
<p>参考博文：https://www.zhihu.com/question/61064119</p>
]]></content:encoded>
    </item>
    <item>
      <title>你怎么理解vue中的diff算法</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-40/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-40/</guid>
      <source url="https://wangyawei.top/rss.xml">你怎么理解vue中的diff算法</source>
      <category>面试题</category>
      <pubDate>Mon, 20 Sep 2021 20:54:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里先说明下：diff算法是虚拟DOM技术的必然产物，它不是vue专用。</p>
</blockquote>
<p>我感觉可以从3个角度来理解diff算法：</p>
<ol>
<li>
<p>必要性</p>
<ul>
<li>在vue中视图要想得到更新，有两种方式，一种是比较暴力的直接覆盖，另一种是只更新状态变化的地方，那么这显然就需要一个算法来找出那么需要更新的地方。</li>
</ul>
</li>
<li>
<p>执行方式</p>
<ul>
<li>在vue中为了降低Watcher粒度，数据的监听是组件级别的，vue在进行比对的时候有一个整体策略：深度优先，同层比较，两个节点之间比较会根据它们是否拥有子节点或者文本节点做不同操作；但是比对想要精确就必然需要一套也就是算法，通过算法来进行dom比对从而找出那些需要更新的节点进行视图更新。</li>
</ul>
</li>
<li>
<p>高效性</p>
<ul>
<li>
<p>diff算法的直接操作对象是js，js的执行速度远高于直接操作dom元素。</p>
</li>
<li>
<p>diff算法有一套自己的比对优化策略，可以更高效去找出那些需要更新的地方。</p>
</li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>谈一谈对vue组件化的理解</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-45/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-45/</guid>
      <source url="https://wangyawei.top/rss.xml">谈一谈对vue组件化的理解</source>
      <category>面试题</category>
      <pubDate>Mon, 20 Sep 2021 20:58:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>答题思路：组件化定义、优点、使用场景和注意事项等方面展开陈述，同时要强调vue中组件化的一些特点</p>
</blockquote>
<ol>
<li>组件是独立和可复用的代码组织单元。组件系统是 Vue 核心特性之一，它使开发者使用小型、独
立和通常可复用的组件构建大型应用；</li>
<li>组件化开发能大幅提高应用开发效率、测试性、复用性等；</li>
<li>组件使用按分类有：页面组件、业务组件、通用组件；</li>
<li>vue的组件是基于配置的，我们通常编写的组件是组件配置而非组件，框架后续会生成其构造函
数，它们基于VueComponent，扩展于Vue；</li>
<li>vue中常见组件化技术有：属性prop，自定义事件，插槽等，它们主要用于组件通信、扩展等；</li>
<li>合理的划分组件，有助于提升应用性能；</li>
<li>组件应该是高内聚、低耦合的；</li>
<li>遵循单向数据流的原则。</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>谈一谈对vue设计原则的理解</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-50/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-50/</guid>
      <source url="https://wangyawei.top/rss.xml">谈一谈对vue设计原则的理解</source>
      <category>面试题</category>
      <pubDate>Mon, 20 Sep 2021 21:07:34 GMT</pubDate>
      <content:encoded><![CDATA[<ol>
<li>
<p>渐进式JavaScript框架</p>
<p>与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动</p>
</li>
<li>
<p>易用性</p>
<p>vue提供数据响应式、声明式模板语法和基于配置的组件系统等核心特性。这些使我们只需要关注应用的核心业务即可，只要会写js、html和css就能轻松编写vue应用。</p>
</li>
<li>
<p>灵活性</p>
<p>渐进式框架的最大优点就是灵活性，如果应用足够小，我们可能仅需要vue核心特性即可完成功能；随着应用规模不断扩大，我们才可能逐渐引入路由、状态管理、vue-cli等库和工具，不管是应用体积还是学习难度都是一个逐渐增加的平和曲线。</p>
</li>
<li>
<p>高效性</p>
<p>超快的虚拟 DOM 和 diff 算法使我们的应用拥有最佳的性能表现。追求高效的过程还在继续，vue3中引入Proxy对数据响应式改进以及编译器中对于静态内容编译的改进都会让vue更加高效。</p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>谈谈你对MVC、MVP和MVVM的理解？</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-55/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-55/</guid>
      <source url="https://wangyawei.top/rss.xml">谈谈你对MVC、MVP和MVVM的理解？</source>
      <category>面试题</category>
      <pubDate>Mon, 20 Sep 2021 21:07:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>答题思路：此题涉及知识点很多，很难说清、说透，因为mvc、mvp这些我们前端程序员自己甚至都没用过。但是恰恰反映了前端这些年从无到有，从有到优的变迁过程，因此沿此思路回答将十分清楚。</p>
</blockquote>
<h2 id="web1-0时代"> Web1.0时代</h2>
<blockquote>
<p>在web1.0时代，并没有前端的概念。开发一个web应用多数采用ASP.NET/Java/PHP编写，项目通常由多个aspx/jsp/php文件构成，每个文件中同时包含了HTML、CSS、JavaScript、C#/Java/PHP代码，系统整体架构可能是这样子的：</p>
</blockquote>
<p><img src="./assets/image-20210920232610990.png" alt="image-20210920232610990" /></p>
<blockquote>
<p>这种架构的好处是简单快捷，但是，缺点也非常明显：JSP代码难以维护</p>
</blockquote>
<p>为了让开发更加便捷，代码更易维护，前后端职责更清晰。便衍生出MVC开发模式和框架，前端展示以
模板的形式出现。典型的框架就是Spring、Structs、Hibernate。整体框架如图所示：</p>
<p><img src="./assets/image-20210920232727674.png" alt="image-20210920232727674" /></p>
<blockquote>
<p>使用这种分层架构，职责清晰，代码易维护。但这里的MVC仅限于后端，前后端形成了一定的分离，前端只完成了后端开发中的view层。</p>
</blockquote>
<p>但是，同样的这种模式存在着一些：</p>
<ul>
<li>前端页面开发效率不高;</li>
<li>前后端职责不清</li>
</ul>
<h2 id="web-2-0时代"> web 2.0时代</h2>
<blockquote>
<p>自从Gmail的出现，ajax技术开始风靡全球。有了ajax之后，前后端的职责就更加清晰了。因为前端可以通过Ajax与后端进行数据交互，因此，整体的架构图也变化成了下面这幅图：</p>
</blockquote>
<p><img src="./assets/image-20210920232926180.png" alt="image-20210920232926180" /></p>
<p>通过ajax与后台服务器进行数据交换，前端开发人员，只需要开发页面这部分内容，数据可由后台进行提供。而且ajax可以使得页面实现部分刷新，减少了服务端负载和流量消耗，用户体验也更佳。这时，才开始有专职的前端工程师。同时前端的类库也慢慢的开始发展，最著名的就是jQuery了。当然，此架构也存在问题：缺乏可行的开发模式承载更复杂的业务需求，页面内容都杂糅在一起，一旦应用规模增大，就会导致难以维护了。因此，前端的MVC也随之而来。</p>
<h2 id="前后端分离后的架构演变"> 前后端分离后的架构演变</h2>
<h3 id="mvc"> MVC</h3>
<p>前端的MVC与后端类似，具备着View、Controller和Model。</p>
<ul>
<li>Model：负责保存应用数据，与后端数据进行同步。</li>
<li>Controller：负责业务逻辑，根据用户行为对Model数据进行修改。</li>
<li>View：负责视图展示，将model中的数据可视化出来。</li>
</ul>
<p>三者形成了一个如图所示的模型：</p>
<p><img src="./assets/image-20210920233231424.png" alt="image-20210920233231424" /></p>
<blockquote>
<p>这样的模型，在理论上是可行的。但往往在实际开发中，并不会这样操作。因为开发过程并不灵活。例如，一个小小的事件操作，都必须经过这样的一个流程，那么开发就不再便捷了。</p>
</blockquote>
<p>在实际场景中，我们往往会看到另一种模式，如图：</p>
<p><img src="./assets/image-20210920233352269.png" alt="image-20210920233352269" /></p>
<p>这种模式在开发中更加的灵活，backbone.js框架就是这种的模式。</p>
<p>但是，这种灵活可能导致严重的问题：</p>
<ul>
<li>
<p>数据流混乱。如下图：</p>
<p><img src="./assets/image-20210920233445893.png" alt="image-20210920233445893" /></p>
</li>
<li>
<p>View比较庞大，而Controller比较单薄：由于很多的开发者都会在view中写一些逻辑代码，逐渐的就导致view中的内容越来越庞大，而controller变得越来越单薄。</p>
</li>
</ul>
<blockquote>
<p>既然有缺陷，就会有变革。前端的变化中，似乎少了MVP的这种模式，是因为AngularJS早早地将MVVM框架模式带入了前端。MVP模式虽然前端开发并不常见，但是在安卓等原生开发中，开发者还是会考虑到它。</p>
</blockquote>
<h3 id="mvp"> MVP</h3>
<p>MVP与MVC很接近，P指的是Presenter，presenter可以理解为一个中间人，它负责着View和Model之间的数据流动，防止View和Model之间直接交流。我们可以看一下图示：</p>
<p><img src="./assets/image-20210920233621378.png" alt="image-20210920233621378" /></p>
<p>我们可以通过看到，presenter负责和Model进行双向交互，还和View进行双向交互。这种交互方式，相对于MVC来说少了一些灵活，VIew变成了被动视图，并且本身变得很小。虽然它分离了View和Model。但是应用逐渐变大之后，导致presenter的体积增大，难以维护。要解决这个问题，或许可以从MVVM的思想中找到答案。</p>
<h3 id="mvvm"> MVVM</h3>
<p>首先，何为MVVM呢？MVVM可以分解成(Model-View-VIewModel)。ViewModel可以理解为在presenter基础上的进阶版。如图所示：</p>
<p><img src="./assets/image-20210920233720019.png" alt="image-20210920233720019" /></p>
<p>ViewModel通过实现一套数据响应式机制自动响应Model中数据变化；同时Viewmodel会实现一套更新策略自动将数据变化转换为视图更新；通过事件监听响应View中用户交互修改Model中数据。这样在ViewModel中就减少了大量DOM操作代码。MVVM在保持View和Model松耦合的同时，还减少了维护它们关系的代码，使用户专注于业务逻辑，兼顾开发效率和可维护性。</p>
<h2 id="总结"> 总结</h2>
<ul>
<li>这三者都是框架模式，它们设计的目标都是为了解决Model和View的耦合问题。</li>
<li>MVC模式出现较早主要应用在后端，如Spring MVC、ASP.NET MVC等，在前端领域的早期也有应
用，如Backbone.js。它的优点是分层清晰，缺点是数据流混乱，灵活性带来的维护性问题。</li>
<li>MVP模式在是MVC的进化形式，Presenter作为中间层负责MV通信，解决了两者耦合问题，但P层
过于臃肿会导致维护问题。</li>
<li>MVVM模式在前端领域有广泛应用，它不仅解决MV耦合问题，还同时解决了维护两者映射关系的
大量繁杂代码和DOM操作代码，在提高开发效率、可读性同时还保持了优越的性能表现。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>你了解哪些Vue性能优化方法</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-60/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-60/</guid>
      <source url="https://wangyawei.top/rss.xml">你了解哪些Vue性能优化方法</source>
      <category>面试题</category>
      <pubDate>Tue, 21 Sep 2021 00:24:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>答题思路：根据题目描述，这里主要探讨Vue代码层面的优化</p>
</blockquote>
<ol>
<li>
<p>路由懒加载</p>
<div><pre><code><span>const</span> router <span>=</span> <span>new</span> <span>VueRouter</span><span>(</span><span>{</span>
    routes<span>:</span> <span>[</span>
    	<span>{</span> path<span>:</span> <span>'/foo'</span><span>,</span> <span>component</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>import</span><span>(</span><span>'./Foo.vue'</span><span>)</span> <span>}</span>
    <span>]</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>keep-alive缓存页面</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>id</span><span><span>=</span><span>"</span>app<span>"</span></span><span>></span></span>
        <span><span><span>&lt;</span>keep-alive</span><span>></span></span>
            <span><span><span>&lt;</span>router-view</span><span>/></span></span>
        <span><span><span>&lt;/</span>keep-alive</span><span>></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></li>
<li>
<p>使用v-show复用DOM</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>
<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>cell<span>"</span></span><span>></span></span>
    <span>&lt;!--这种情况用v-show复用DOM，比v-if效果好--></span>
    <span><span><span>&lt;</span>div</span> <span>v-show</span><span><span>=</span><span>"</span>value<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>on<span>"</span></span><span>></span></span>
    	<span><span><span>&lt;</span>Heavy</span> <span>:n</span><span><span>=</span><span>"</span>10000<span>"</span></span><span>/></span></span>
    <span><span><span>&lt;/</span>div</span><span>></span></span>
    <span><span><span>&lt;</span>section</span> <span>v-show</span><span><span>=</span><span>"</span>!value<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>off<span>"</span></span><span>></span></span>
    	<span><span><span>&lt;</span>Heavy</span> <span>:n</span><span><span>=</span><span>"</span>10000<span>"</span></span><span>/></span></span>
    <span><span><span>&lt;/</span>section</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
<li>
<p>v-for 遍历避免同时使用 v-if</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>
<span><span><span>&lt;</span>ul</span><span>></span></span>
    <span><span><span>&lt;</span>li</span>
    	<span>v-for</span><span><span>=</span><span>"</span>user in activeUsers<span>"</span></span>
    	<span>:key</span><span><span>=</span><span>"</span>user.id<span>"</span></span><span>></span></span>
    	{{ user.name }}
    <span><span><span>&lt;/</span>li</span><span>></span></span>
<span><span><span>&lt;/</span>ul</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
    computed<span>:</span> <span>{</span>
        <span>activeUsers</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
            <span>return</span> <span>this</span><span>.</span>users<span>.</span><span>filter</span><span>(</span><span>function</span> <span>(</span><span>user</span><span>)</span> <span>{</span>
            	<span>return</span> user<span>.</span>isActive
            <span>}</span><span>)</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div></li>
<li>
<p>长列表性能优化</p>
<p>如果列表是纯粹的数据展示，不会有任何改变，就不需要做响应化</p>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
    <span>data</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>(</span><span>{</span>
        users<span>:</span> <span>[</span><span>]</span>
    <span>}</span><span>)</span><span>,</span>
    <span>async</span> <span>created</span><span>(</span><span>)</span> <span>{</span>
    	<span>const</span> users <span>=</span> <span>await</span> axios<span>.</span><span>get</span><span>(</span><span>"/api/users"</span><span>)</span><span>;</span>
    	<span>this</span><span>.</span>users <span>=</span> Object<span>.</span><span>freeze</span><span>(</span>users<span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>如果是大数据长列表，可采用虚拟滚动，只渲染少部分区域的内容</p>
<div><pre><code><span><span><span>&lt;</span>recycle-scroller</span>
	<span>class</span><span><span>=</span><span>"</span>items<span>"</span></span>
	<span>:items</span><span><span>=</span><span>"</span>items<span>"</span></span>
	<span>:item-size</span><span><span>=</span><span>"</span>24<span>"</span></span>
<span>></span></span>
<span><span><span>&lt;</span>template</span> <span>v-slot</span><span><span>=</span><span>"</span>{ item }<span>"</span></span><span>></span></span>
    <span><span><span>&lt;</span>FetchItemView</span>
    	<span>:item</span><span><span>=</span><span>"</span>item<span>"</span></span>
    	<span>@vote</span><span><span>=</span><span>"</span>voteItem(item)<span>"</span></span>
    <span>/></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;/</span>recycle-scroller</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div></li>
<li>
<p>事件的销毁</p>
<p>Vue 组件销毁时，会自动解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。</p>
<div><pre><code><span>created</span><span>(</span><span>)</span> <span>{</span>
	<span>this</span><span>.</span>timer <span>=</span> <span>setInterval</span><span>(</span><span>this</span><span>.</span>refresh<span>,</span> <span>2000</span><span>)</span>
<span>}</span><span>,</span>
<span>beforeDestroy</span><span>(</span><span>)</span> <span>{</span>
	<span>clearInterval</span><span>(</span><span>this</span><span>.</span>timer<span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>图片懒加载</p>
<p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。</p>
<div><pre><code><span>&lt;</span>img v<span>-</span>lazy<span>=</span><span>"/static/img/1.png"</span><span>></span>
<span>// 参考项目：vue-lazyload</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>第三方插件按需引入</p>
<p>像element-ui这样的第三方组件库可以按需引入避免体积太大。</p>
<div><pre><code><span>import</span> Vue <span>from</span> <span>'vue'</span><span>;</span>
<span>import</span> <span>{</span> Button<span>,</span> Select <span>}</span> <span>from</span> <span>'element-ui'</span><span>;</span>
Vue<span>.</span><span>use</span><span>(</span>Button<span>)</span>
Vue<span>.</span><span>use</span><span>(</span>Select<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>无状态的组件标记为函数式组件</p>
<div><pre><code><span><span><span>&lt;</span>template</span> <span>functional</span><span>></span></span>
	<span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>cell<span>"</span></span><span>></span></span>
	<span><span><span>&lt;</span>div</span> <span>v-if</span><span><span>=</span><span>"</span>props.value<span>"</span></span> <span>class</span><span><span>=</span><span>"</span>on<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>div</span><span>></span></span>
	<span><span><span>&lt;</span>section</span> <span>v-else</span> <span>class</span><span><span>=</span><span>"</span>off<span>"</span></span><span>></span></span><span><span><span>&lt;/</span>section</span><span>></span></span>
<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
	props<span>:</span> <span>[</span><span>'value'</span><span>]</span>
<span>}</span> 
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
<li>
<p>子组件分割</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>
	<span><span><span>&lt;</span>div</span><span>></span></span>
		<span><span><span>&lt;</span>ChildComp</span><span>/></span></span>
	<span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
    components<span>:</span> <span>{</span>
    	ChildComp<span>:</span> <span>{</span>
            methods<span>:</span> <span>{</span>
                <span>heavy</span> <span>(</span><span>)</span> <span>{</span> <span>/* 耗时任务 */</span> <span>}</span>
            <span>}</span><span>,</span>
            <span>render</span> <span>(</span><span>h</span><span>)</span> <span>{</span>
                <span>return</span> <span>h</span><span>(</span><span>'div'</span><span>,</span> <span>this</span><span>.</span><span>heavy</span><span>(</span><span>)</span><span>)</span>
            <span>}</span>
    	<span>}</span>
    <span>}</span>
<span>}</span> 
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div></li>
<li>
<p>变量本地化</p>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>
    <span><span><span>&lt;</span>div</span> <span>:style</span><span><span>=</span><span>"</span>{ opacity: start / 300 }<span>"</span></span><span>></span></span>
    {{ result }}
    <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>import</span> <span>{</span> heavy <span>}</span> <span>from</span> <span>'@/utils'</span>
<span>export</span> <span>default</span> <span>{</span>
    props<span>:</span> <span>[</span><span>'start'</span><span>]</span><span>,</span>
    computed<span>:</span> <span>{</span>
    	<span>base</span> <span>(</span><span>)</span> <span>{</span> <span>return</span> <span>42</span> <span>}</span><span>,</span>
    	<span>result</span> <span>(</span><span>)</span> <span>{</span>
            <span>const</span> base <span>=</span> <span>this</span><span>.</span>base <span>// 不要频繁引用this.base</span>
            <span>let</span> result <span>=</span> <span>this</span><span>.</span>start
            <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>1000</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
                result <span>+=</span> <span>heavy</span><span>(</span>base<span>)</span>
            <span>}</span> 
            <span>return</span> result
        <span>}</span>
    <span>}</span>
<span>}</span> 
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div></li>
<li>
<p>SSR</p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>你对Vue3.0的新特性有没有了解？</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-65/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-65/</guid>
      <source url="https://wangyawei.top/rss.xml">你对Vue3.0的新特性有没有了解？</source>
      <category>面试题</category>
      <pubDate>Tue, 21 Sep 2021 00:32:34 GMT</pubDate>
      <content:encoded><![CDATA[<p>Vue3.0改进主要在以下几点：</p>
<ul>
<li>更快
<ul>
<li>虚拟DOM重写</li>
<li>优化slots的生成</li>
<li>静态树提升</li>
<li>静态属性提升</li>
<li>基于Proxy的响应式系统</li>
</ul>
</li>
<li>更小：通过摇树优化核心库体积</li>
<li>更容易维护：TypeScript + 模块化</li>
<li>更加友好
<ul>
<li>跨平台：编译器核心和运行时核心与平台无关，使得Vue更容易与任何平台（Web、Android、iOS）一起使用</li>
</ul>
</li>
<li>更容易使用
<ul>
<li>改进的TypeScript支持，编辑器能提供强有力的类型检查和错误及警告</li>
<li>更好的调试支持</li>
<li>独立的响应化模块</li>
<li>Composition API</li>
</ul>
</li>
</ul>
<h2 id="虚拟-dom-重写"> 虚拟 DOM 重写</h2>
<blockquote>
<p>期待更多的编译时提示来减少运行时开销，使用更有效的代码来创建虚拟节点。组件快速路径+单个调用+子节点类型检测</p>
</blockquote>
<ul>
<li>跳过不必要的条件分支</li>
<li>JS引擎更容易优化</li>
</ul>
<h2 id="优化slots生成"> 优化slots生成</h2>
<blockquote>
<p>vue3中可以单独重新渲染父级和子级</p>
</blockquote>
<ul>
<li>确保实例正确的跟踪依赖关系</li>
<li>避免不必要的父子组件重新渲染</li>
</ul>
<h2 id="静态树提升-static-tree-hoisting"> 静态树提升(Static Tree Hoisting)</h2>
<blockquote>
<p>使用静态树提升，这意味着 Vue 3 的编译器将能够检测到什么是静态的，然后将其提升，从而降低了渲染成本</p>
</blockquote>
<ul>
<li>跳过修补整棵树，从而降低渲染成本</li>
<li>即使多次出现也能正常工作</li>
</ul>
<h2 id="静态属性提升"> 静态属性提升</h2>
<blockquote>
<p>使用静态属性提升，Vue 3打补丁时将跳过这些属性不会改变的节点。</p>
</blockquote>
<h2 id="基于-proxy-的数据响应式"> 基于 Proxy 的数据响应式</h2>
<blockquote>
<p>Vue 2的响应式系统使用 Object.defineProperty 的getter 和 setter。Vue 3 将使用 ES2015 Proxy 作为其观察机制，这将会带来如下变化：</p>
</blockquote>
<ul>
<li>组件实例初始化的速度提高100％</li>
<li>使用Proxy节省以前一半的内存开销，加快速度，但是存在低浏览器版本的不兼容</li>
<li>为了继续支持 IE11，Vue 3 将发布一个支持旧观察者机制和新 Proxy 版本的构建</li>
</ul>
<h2 id="高可维护性"> 高可维护性</h2>
<blockquote>
<p>Vue 3 将带来更可维护的源代码。它不仅会使用 TypeScript，而且许多包被解耦，更加模块化。</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>简单说一说vuex使用及其理解？</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-70/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-70/</guid>
      <source url="https://wangyawei.top/rss.xml">简单说一说vuex使用及其理解？</source>
      <category>面试题</category>
      <pubDate>Tue, 21 Sep 2021 11:42:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>vue中状态管理（登陆验证，购物车，播放器等）</p>
</blockquote>
<h2 id="vuex-介绍"> vuex 介绍</h2>
<p>vuex 实现了一个单向数据流，在全局拥有一个 State 存放数据，当组件要更改 State 中的数据时，必须通过 Mutation 提交修改信息， Mutation 同时提供了订阅者模式供外部插件调用获取 State 数据的更新。而当所有异步操作(常见于调用后端接口异步获取更新数据)或批量的同步操作需要走 Action ，但 Action 也是无法直接修改 State 的，还是需要通过Mutation 来修改State的数据。最后，根据 State 的变化，渲染到视图上。</p>
<h2 id="vuex-中核心概念"> vuex 中核心概念</h2>
<h3 id="state"> state：</h3>
<p>vuex 的唯一数据源，如果获取多个 state ,可以使用 ...mapState 。</p>
<div><pre><code><span>export</span> <span>const</span> store <span>=</span> <span>new</span> <span>Vuex<span>.</span>Store</span><span>(</span><span>{</span>
<span>// 注意Store的S大写</span>
<span>&lt;</span><span>!</span><span>--</span> 状态储存 <span>--</span><span>></span>
    state<span>:</span> <span>{</span>
    	productList<span>:</span> <span>[</span>
            <span>{</span> 
                name<span>:</span> <span>'goods 1'</span><span>,</span>
                price<span>:</span> <span>100</span>
            <span>}</span>
        <span>]</span>
    <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="getter"> getter</h3>
<p>可以将 getter 理解为计算属性， getter 的返回值根据他的依赖缓存起来，依赖发生变化才会被重新计算。</p>
<div><pre><code><span>import</span> Vue <span>from</span> <span>'vue'</span>
<span>import</span> Vuex <span>from</span> <span>'vuex'</span><span>;</span>
Vue<span>.</span><span>use</span><span>(</span>Vuex<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>export</span> <span>const</span> store <span>=</span> <span>new</span> <span>Vuex<span>.</span>Store</span><span>(</span><span>{</span>
  state<span>:</span> <span>{</span>
    productList<span>:</span> <span>[</span>
      <span>{</span>
        name<span>:</span> <span>'goods 1'</span><span>,</span>
        price<span>:</span> <span>100</span><span>,</span>
      <span>}</span><span>,</span>
    <span>]</span><span>,</span>
  <span>}</span><span>,</span>
<span>// 辅助对象 mapGetter</span>
  getters<span>:</span> <span>{</span>
    <span>getSaledPrice</span><span>:</span> <span>(</span><span>state</span><span>)</span> <span>=></span> <span>{</span>
      <span>let</span> saleProduct <span>=</span> state<span>.</span>productList<span>.</span><span>map</span><span>(</span><span>(</span><span>item</span><span>)</span> <span>=></span> <span>{</span>
        <span>return</span> <span>{</span>
          name<span>:</span> <span>'**'</span> <span>+</span> item<span>.</span>name <span>+</span> <span>'**'</span><span>,</span>
          price<span>:</span> item<span>.</span>price <span>/</span> <span>2</span><span>,</span>
        <span>}</span>
      <span>}</span><span>)</span>
      <span>return</span> saleProduct<span>;</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><div><pre><code><span>// 获取getter计算后的值</span>
<span>export</span> <span>default</span> <span>{</span>
  <span>data</span> <span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      productList <span>:</span> <span>this</span><span>.</span>$store<span>.</span>getters<span>.</span>getSaledPrice
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="mutation"> mutation</h3>
<p>更改 state 中唯一的方法是提交 mutation 都有一个字符串和一个回调函数。回调函数就是使劲进行状态修改的地方。并且会接收 state 作为第一个参数 payload 为第二个参数， payload 为自定义函数， mutation 必须是同步函数。</p>
<div><pre><code>
<span>// 辅助对象 mapMutations</span>
mutations<span>:</span> <span>{</span>
  <span>// payload 为自定义函数名</span>
  <span>reducePrice</span><span>:</span> <span>(</span><span>state<span>,</span> payload</span><span>)</span> <span>=></span> <span>{</span>
    <span>return</span> state<span>.</span>productList<span>.</span><span>forEach</span><span>(</span><span>(</span><span>product</span><span>)</span> <span>=></span> <span>{</span>
      product<span>.</span>price <span>-=</span> payload<span>;</span>
    <span>}</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><div><pre><code><span>&lt;</span><span>!</span><span>--</span> 页面使用 <span>--</span><span>></span>
methods<span>:</span> <span>{</span>
  <span>reducePrice</span><span>(</span><span>)</span><span>{</span>
    <span>this</span><span>.</span>$store<span>.</span><span>commit</span><span>(</span><span>'reducePrice'</span><span>,</span> <span>4</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="action"> action</h3>
<p>action 类似 mutation 都是修改状态，不同之处。</p>
<ul>
<li>action 提交的 mutation 不是直接修改状态</li>
<li>action 可以包含异步操作，而 mutation 不行</li>
<li>action 中的回调函数第一个参数是 context ，是一个与 store 实例具有相同属性的
方法的对象</li>
<li>action 通过 store.dispatch 触发， mutation 通过 store.commit 提交</li>
</ul>
<div><pre><code>actions<span>:</span> <span>{</span>
<span>// 提交的是mutation，可以包含异步操作</span>
  <span>reducePriceAsync</span><span>:</span> <span>(</span><span>context<span>,</span> payload</span><span>)</span> <span>=></span> <span>{</span>
    <span>setTimeout</span><span>(</span><span>(</span><span>)</span><span>=></span> <span>{</span>
      context<span>.</span><span>commit</span><span>(</span><span>'reducePrice'</span><span>,</span> payload<span>)</span><span>;</span> 
      <span>// reducePrice为上一步mutation中的属性</span>
    <span>}</span><span>,</span><span>2000</span><span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code><span>&lt;</span><span>!</span><span>--</span> 页面使用 <span>--</span><span>></span>
<span>// 辅助对象 mapActions</span>
methods<span>:</span> <span>{</span>
  <span>reducePriceAsync</span><span>(</span><span>)</span><span>{</span>
    <span>this</span><span>.</span>$store<span>.</span><span>dispatch</span><span>(</span><span>'reducePriceAsync'</span><span>,</span> <span>2</span><span>)</span>
  <span>}</span><span>,</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="module"> module</h3>
<p>由于是使用单一状态树，应用的所有状态集中到比较大的对象，当应用变得非常复杂是， store 对象就有可能变得相当臃肿。为了解决以上问题， vuex 允许我们将 store分割成模块，每个模块拥有自己的 state,mutation,action,getter ,甚至是嵌套子模块从上至下进行同样方式分割。</p>
<div><pre><code><span>const</span> moduleA <span>=</span> <span>{</span>
  state<span>:</span> <span>{</span><span>...</span><span>}</span><span>,</span>
  mutations<span>:</span> <span>{</span><span>...</span><span>}</span><span>,</span>
  actions<span>:</span> <span>{</span><span>...</span><span>}</span><span>,</span>
  getters<span>:</span> <span>{</span><span>...</span><span>}</span>
<span>}</span> 
<span>const</span> moduleB <span>=</span> <span>{</span>
  state<span>:</span> <span>{</span><span>...</span><span>}</span><span>,</span>
  mutations<span>:</span> <span>{</span><span>...</span><span>}</span><span>,</span>
  actions<span>:</span> <span>{</span><span>...</span><span>}</span><span>,</span>
  getters<span>:</span> <span>{</span><span>...</span><span>}</span>
<span>}</span> 
<span>const</span> store <span>=</span> <span>new</span> <span>Vuex<span>.</span>Store</span><span>(</span><span>{</span>
  a<span>:</span> moduleA<span>,</span>
  b<span>:</span> moduleB
<span>}</span><span>)</span>
store<span>.</span>state<span>.</span>a
store<span>.</span>state<span>.</span>b
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h2 id="vuex-中数据存储-localstorage"> vuex 中数据存储 localStorage</h2>
<blockquote>
<p>vuex 是 vue 的状态管理器，存储的数据是响应式的。但是并不会保存起来，刷新之后就回到了初始状态，具体做法应该在 vuex 里数据改变的时候把数据拷贝一份保存到 localStorage 里面，刷新之后，如果localStorage 里有保存的数据，取出来再替换 store 里的 state。</p>
</blockquote>
<div><pre><code><span>let</span> defaultCity <span>=</span> <span>"上海"</span>
<span>try</span> <span>{</span>
<span>// 用户关闭了本地存储功能，此时在外层加个try...catch</span>
  <span>if</span> <span>(</span><span>!</span>defaultCity<span>)</span><span>{</span>
<span>// f复制一份</span>
    defaultCity <span>=</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span>window<span>.</span>localStorage<span>.</span><span>getItem</span><span>(</span><span>'defaultCity'</span><span>)</span><span>)</span>
  <span>}</span>
<span>}</span><span>catch</span><span>(</span>e<span>)</span><span>{</span>
  console<span>.</span><span>log</span><span>(</span>e<span>)</span>
<span>}</span>
<span>export</span> <span>default</span> <span>new</span> <span>Vuex<span>.</span>Store</span><span>(</span><span>{</span>
  state<span>:</span> <span>{</span>
    city<span>:</span> defaultCity
  <span>}</span><span>,</span>
  mutations<span>:</span> <span>{</span>
    <span>changeCity</span><span>(</span><span>state<span>,</span> city</span><span>)</span> <span>{</span>
      state<span>.</span>city <span>=</span> city
      <span>try</span> <span>{</span>
        window<span>.</span>localStorage<span>.</span><span>setItem</span><span>(</span><span>'defaultCity'</span><span>,</span>
          <span>JSON</span><span>.</span><span>stringify</span><span>(</span>state<span>.</span>city<span>)</span><span>)</span><span>;</span>
        <span>// 数据改变的时候把数据拷贝一份保存到localStorage里面</span>
      <span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span><span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><div><p>提示</p>
<p>注意： vuex 里保存的状态，都是数组，而 localStorage 只支持字符串。</p>
</div>
<h2 id="总结"> 总结</h2>
<ul>
<li>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所
有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。</li>
<li>vuex核心概念 重点同步异步实现 action mutation</li>
<li>vuex中做数据存储 --------- local storage</li>
<li>如何选用vuex</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>vue中组件之间的通信方式？</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-75/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-75/</guid>
      <source url="https://wangyawei.top/rss.xml">vue中组件之间的通信方式？</source>
      <category>面试题</category>
      <pubDate>Tue, 21 Sep 2021 11:42:34 GMT</pubDate>
      <content:encoded><![CDATA[<p>常见组件通信可以分为三类：</p>
<ul>
<li>父子组件通信</li>
<li>兄弟组件通信</li>
<li>跨层组件通信</li>
</ul>
<p>常见的通信方式有以下几种：</p>
<ul>
<li>props ：父组件通过props向下传递数据给子组件。</li>
<li>$emit/$on ：子组件通过events给父组件发送消息，实际上就是子组件把自己的数据发送到父组件。</li>
<li>vuex：全局状态管理，数据可以全局使用。</li>
<li>$parent/$children：这两种都是直接得到组件实例，使用后可以直接调用组件的方法或访问数据。</li>
<li>provide/inject  ：主要解决了跨级组件间的通信问题，不过它的使用场景，主要是子组件获取上级组件的状态，跨级组件间建立了一种主动提供与依赖注入的关系。</li>
<li>$attrs/$listeners  ：$attrs与$listeners 是两个对象， $attrs 里存放的是父组件中绑定的非 Props 属性，$listeners 里存放的是父组件中绑定的非原生事件。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>vue-router 中的导航钩子由那些？</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-80/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-80/</guid>
      <source url="https://wangyawei.top/rss.xml">vue-router 中的导航钩子由那些？</source>
      <category>面试题</category>
      <pubDate>Tue, 21 Sep 2021 12:21:34 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="全局钩子函数"> 全局钩子函数</h2>
<ul>
<li>beforeEach (to，from，next) 路由改变前调用 ,常用验证用户权限。
<ul>
<li>参数</li>
<li>to ：即将要进入的目标路由对象</li>
<li>from：当前正要离开的路由对象</li>
<li>next：路由控制参数
<ul>
<li>next()：如果一切正常，则调用这个方法进入下一个钩子</li>
<li>next(false)：取消导航（即路由不发生改变）</li>
<li>next('/login')：当前导航被中断，然后进行一个新的导航</li>
<li>next(error)：如果一个Error实例，则导航会被终止且该错误会被传递给 router.onError ()</li>
</ul>
</li>
</ul>
</li>
<li>afterEach (to，from) 路由改变后的钩子
<ul>
<li>常用自动让页面返回最顶端</li>
<li>用法相似，少了next参数</li>
</ul>
</li>
</ul>
<h2 id="路由配置中的导航钩子"> 路由配置中的导航钩子</h2>
<ul>
<li>
<p>beforeEnter (to，from，next)</p>
<div><pre><code><span>const</span> router <span>=</span> <span>new</span> <span>VueRouter</span><span>(</span><span>{</span>
  routes<span>:</span> <span>[</span>
    <span>{</span>
      path<span>:</span> <span>'/foo'</span><span>,</span>
      component<span>:</span> Foo<span>,</span>
      <span>beforeEnter</span><span>:</span> <span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
        <span>// ...</span>
      <span>}</span><span>,</span>
      <span>beforeEnter</span><span>:</span> <span>(</span><span>route</span><span>)</span> <span>=></span> <span>{</span>
        <span>// ...</span>
      <span>}</span>
    <span>}</span>
  <span>]</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></li>
</ul>
<h2 id="组件内的钩子函数"> 组件内的钩子函数</h2>
<ul>
<li>
<p>beforeRouteEnter (to,from,next)</p>
<ul>
<li>该组件的对应路由被 comfirm 前调用。</li>
<li>此时实例还没被创建，所以不能获取实例（this）</li>
</ul>
</li>
<li>
<p>beforeRouteUpdate (to,from,next)</p>
<ul>
<li>当前路由改变，但改组件被复用时候调用</li>
<li>该函数内可以访问组件实例(this)</li>
</ul>
</li>
<li>
<p>beforeRouteLeave (to,from,next)</p>
<ul>
<li>当导航离开组件的对应路由时调用。</li>
<li>该函数内可以访问获取组件实例（this）</li>
</ul>
<div><pre><code><span>const</span> Foo <span>=</span> <span>{</span>
  template<span>:</span> <span><span>`</span><span>...</span><span>`</span></span><span>,</span>
  <span>beforeRouteEnter</span> <span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>{</span>
  <span>// 在渲染该组件的对应路由被 confirm 前调用</span>
  <span>// 不！能！获取组件实例 `this`</span>
  <span>// 因为当钩子执行前，组件实例还没被创建</span>
  <span>}</span><span>,</span>
  <span>beforeRouteUpdate</span> <span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>{</span>
  <span>// 在当前路由改变，但是该组件被复用时调用</span>
  <span>// 举例来说，对于一个带有动态参数的路径 /foo/:id，在 /foo/1 和 /foo/2 之间跳转的时候，</span>

  <span>// 由于会渲染同样的 Foo 组件，因此组件实例会被复用。而这个钩子就会在这个情况下被调用。</span>

  <span>// 可以访问组件实例 `this`</span>
  <span>}</span><span>,</span>
  <span>beforeRouteLeave</span> <span>(</span><span>to<span>,</span> from<span>,</span> next</span><span>)</span> <span>{</span>
  <span>// 导航离开该组件的对应路由时调用</span>
  <span>// 可以访问组件实例 `this`</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div></li>
</ul>
<h2 id="路由监测变化"> 路由监测变化</h2>
<p>监听到路由对象发生变化，从而对路由变化做出响应</p>
<div><pre><code><span>const</span> user <span>=</span> <span>{</span>
  template<span>:</span> <span>'&lt;div>&lt;/div>'</span><span>,</span>
  watch<span>:</span> <span>{</span>
    <span>'$route'</span><span>(</span>to<span>,</span> from<span>)</span> <span>{</span>
    <span>// 对路由做出响应</span>
    <span>// to , from 分别表示从哪跳转到哪，都是一个对象</span>
    <span>// to.path ( 表示的是要跳转到的路由的地址 eg: /home );</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span>
<span>// 多了一个watch，这会带来依赖追踪的内存开销，</span>
<span>// 修改</span>
<span>const</span> user <span>=</span> <span>{</span>
  template<span>:</span> <span>'&lt;div>&lt;/div>'</span><span>,</span>
  watch<span>:</span> <span>{</span>
    <span>'$route.query.id'</span> <span>{</span>
      <span>// 请求个人描述</span>
    <span>}</span><span>,</span>
    <span>'$route.query.page'</span> <span>{</span>
      <span>// 请求列表</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="总结"> 总结</h2>
<p>路由中的导航钩子有三种</p>
<ul>
<li>全局</li>
<li>组件</li>
<li>路由配置</li>
</ul>
<p>监听路由变化怎么做</p>
<ul>
<li>使用watch 来对$route 监听</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>什么是递归组件？</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-85/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-85/</guid>
      <source url="https://wangyawei.top/rss.xml">什么是递归组件？</source>
      <category>面试题</category>
      <pubDate>Tue, 21 Sep 2021 12:34:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>组件是可以在它们自己的模板中调用自身的。</p>
</blockquote>
<p>递归组件，一定要有一个结束的条件，否则就会使组件循环引用，最终出现的错误，我们可以使用vif=&quot;false&quot;作为递归组件的结束条件。当遇到v-if为false时，组件将不会再进行渲染。既然要用递归组件，那么对我们的数据格式肯定是需要满足递归的条件的。ta它需要是一个树状的递归数据。</p>
<div><pre><code><span>// tree组件数据</span>
list<span>:</span><span>[</span>
  <span>{</span>
    <span>"name"</span><span>:</span> <span>"web1"</span><span>,</span>
    cList<span>:</span> <span>[</span>
      <span>{</span><span>"name"</span><span>:</span> <span>"vue"</span> <span>}</span><span>,</span>
      <span>{</span>
        <span>"name"</span><span>:</span> <span>"react"</span><span>,</span>
        cList<span>:</span> <span>[</span>
          <span>{</span>
            <span>"name"</span><span>:</span> <span>'javascrict'</span><span>,</span>
            cList<span>:</span> <span>[</span><span>{</span> <span>"name"</span><span>:</span> <span>"css"</span><span>}</span><span>]</span>
          <span>}</span>
        <span>]</span>
      <span>}</span>
    <span>]</span>
  <span>}</span><span>,</span>
  <span>{</span> <span>"name"</span><span>:</span> <span>"web2"</span> <span>}</span><span>,</span>
  <span>{</span>
    <span>"name"</span><span>:</span> <span>"web3"</span><span>,</span>
    cList<span>:</span> <span>[</span>
      <span>{</span> <span>"name"</span><span>:</span> <span>"javascript"</span> <span>}</span><span>,</span>
      <span>{</span> <span>"name"</span><span>:</span> <span>"css"</span> <span>}</span>
    <span>]</span>
  <span>}</span><span>,</span>
<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><div><pre><code><span>&lt;</span>template<span>></span>
  <span>&lt;</span>div<span>></span>
    <span>&lt;</span>ul<span>></span>
      <span>&lt;</span>li v<span>-</span><span>for</span><span>=</span><span>"(item,index) in list "</span> <span>:</span>key<span>=</span><span>"index"</span><span>></span>
        <span>&lt;</span>p<span>></span><span>{</span><span>{</span>item<span>.</span>name<span>}</span><span>}</span><span>&lt;</span><span>/</span>p<span>></span>
        <span>&lt;</span>tree<span>-</span>muen <span>:</span>list<span>=</span><span>'list'</span><span>/</span><span>></span>
      <span>&lt;</span><span>/</span>li<span>></span>
    <span>&lt;</span><span>/</span>ul<span>></span>
  <span>&lt;</span><span>/</span>div<span>></span>
<span>&lt;</span><span>/</span>template<span>></span>
<span>&lt;</span>script<span>></span>
<span>export</span> <span>default</span> <span>{</span>
  components<span>:</span> <span>{</span>
    treeMuen
  <span>}</span><span>,</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      list
    <span>}</span>
  <span>}</span>
<span>}</span>
<span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>总结</p>
<p>通过props从父组件拿到数据，递归组件每次进行递归的时候都会tree-menus组件传递下一级treeList数据，整个过程结束之后，递归也就完成了，对于折叠树状菜单来说，我们一般只会去渲染一级的数据，当点击一级菜单时，再去渲染一级菜单下的结构，如此往复。那么v-if就可以实现我们的这个需求，当v-if设置为false时，递归组件将不会再进行渲染，设置为true时，继续渲染。</p>
<p>使用递归组件可以封装折叠菜单，可以有效的避免写更多的嵌套html</p>
]]></content:encoded>
    </item>
    <item>
      <title>说一说vue响应式理解？</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-90/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-90/</guid>
      <source url="https://wangyawei.top/rss.xml">说一说vue响应式理解？</source>
      <category>面试题</category>
      <pubDate>Tue, 21 Sep 2021 12:55:34 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>vue是使用object.defineProperty来实现响应式的。</p>
</blockquote>
<p><img src="./assets/image-20210921124458257.png" alt="image-20210921124458257" /></p>
<p><strong>observer类</strong></p>
<div><pre><code><span>/* observer 类会附加到每一个被侦测的object上
* 一旦被附加上，observer会被object的所有属性转换为getter/setter的形式
* 当属性发生变化时候及时通知依赖
*/</span>
<span>// Observer 实例</span>
<span>export</span> <span>class</span> <span>Observer</span> <span>{</span>
  <span>constructor</span><span>(</span><span>value</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>value <span>=</span> value
    <span>if</span> <span>(</span><span>!</span>Array<span>.</span><span>isArray</span><span>(</span>value<span>)</span><span>)</span> <span>{</span> <span>// 判断是否是数组</span>
      <span>this</span><span>.</span><span>walk</span><span>(</span>value<span>)</span> <span>// 劫持对象</span>
    <span>}</span>
  <span>}</span>

  <span>walk</span><span>(</span><span>obj</span><span>)</span> <span>{</span> <span>// 将会每一个属性转换为getter/setter 形式来侦测数据变化</span>
    <span>const</span> keys <span>=</span> Object<span>.</span><span>keys</span><span>(</span>obj<span>)</span>
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> keys<span>.</span>length<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      <span>defineReactive</span><span>(</span>obj<span>,</span> keys<span>[</span>i<span>]</span><span>,</span> obj<span>[</span>keys<span>[</span>i<span>]</span><span>]</span><span>)</span> <span>// 数据劫持方法</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
<span>function</span> <span>defineReactive</span><span>(</span><span>data<span>,</span>key<span>,</span>val</span><span>)</span><span>{</span>
  <span>// 递归属性</span>
  <span>if</span><span>(</span><span>typeof</span> val <span>===</span><span>'object'</span><span>)</span><span>{</span>
    <span>new</span> <span>Obeserve</span><span>(</span>val<span>)</span>
  <span>}</span>
  <span>let</span> dep <span>=</span> <span>new</span> <span>Dep</span><span>(</span><span>)</span>
  Object<span>.</span><span>defineProperty</span><span>(</span>data<span>,</span>key<span>,</span><span>{</span>
    enumerable<span>:</span><span>true</span><span>,</span>
    configurable<span>:</span><span>true</span><span>,</span>
    <span>get</span><span>:</span><span>function</span><span>(</span><span>)</span><span>{</span>
      dep<span>.</span><span>depend</span><span>(</span><span>)</span>
      <span>return</span> val
    <span>}</span><span>,</span>
    <span>set</span><span>:</span><span>function</span><span>(</span><span>newVal</span><span>)</span><span>{</span>
      <span>if</span><span>(</span>val<span>===</span>newVal<span>)</span><span>{</span>
        <span>return</span>
      <span>}</span> 
      val <span>=</span> newVal
      dep<span>.</span><span>notify</span><span>(</span><span>)</span>
    <span>}</span>
  <span>}</span><span>)</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><blockquote>
<p>定义了 observer类，用来将一个正常的object转换成被侦测的object 然后判断数据类型，只有object类型才会调用walk将每一个属性转换成getter/setter的形式来侦测变化，最后在 defineReactive 中新增new Observer（val）来递归子属性，当data中的属性变化时，与这个属性对应的依赖就会接收通知。</p>
</blockquote>
<p><strong>dep依赖收集</strong></p>
<p>getter中收集依赖，那么这些依赖收集到那？</p>
<div><pre><code>
<span>export</span> <span>default</span> <span>class</span> <span>Dep</span> <span>{</span>
  <span>constructor</span> <span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>subs <span>=</span> <span>[</span><span>]</span> <span>// 观察者集合</span>
  <span>}</span>
<span>// 添加观察者</span>
  <span>addSub</span> <span>(</span><span>sub</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>subs<span>.</span><span>push</span><span>(</span>sub<span>)</span>
  <span>}</span>
<span>// 移除观察者</span>
  <span>removeSub</span> <span>(</span><span>sub</span><span>)</span> <span>{</span>
    <span>remove</span><span>(</span><span>this</span><span>.</span>subs<span>,</span> sub<span>)</span>
  <span>}</span> 
  <span>depend</span> <span>(</span><span>)</span> <span>{</span> <span>// 核心，如果存在 ，则进行依赖收集操作</span>
    <span>if</span> <span>(</span>window<span>.</span>target<span>)</span> <span>{</span>
      <span>this</span><span>.</span><span>addDep</span><span>(</span>window<span>.</span>target<span>)</span>
    <span>}</span>
  <span>}</span> 
  <span>notify</span> <span>(</span><span>)</span> <span>{</span>
    <span>const</span> subs <span>=</span> <span>this</span><span>.</span>subs<span>.</span><span>slice</span><span>(</span><span>)</span> <span>// 避免污染原来的集合</span>
<span>// 如果不是异步执行，先进行排序，保证观察者执行顺序</span>
    <span>if</span> <span>(</span>process<span>.</span>env<span>.</span><span>NODE_ENV</span> <span>!==</span> <span>'production'</span> <span>&amp;&amp;</span> <span>!</span>config<span>.</span>async<span>)</span> <span>{</span>
      subs<span>.</span><span>sort</span><span>(</span><span>(</span><span>a<span>,</span> b</span><span>)</span> <span>=></span> a<span>.</span>id <span>-</span> b<span>.</span>id<span>)</span>
    <span>}</span> 
    <span>for</span> <span>(</span><span>let</span> i <span>=</span> <span>0</span><span>,</span> l <span>=</span> subs<span>.</span>length<span>;</span> i <span>&lt;</span> l<span>;</span> i<span>++</span><span>)</span> <span>{</span>
      subs<span>[</span>i<span>]</span><span>.</span><span>update</span><span>(</span><span>)</span> <span>// 发布执行</span>
    <span>}</span>
  <span>}</span>
<span>}</span> 
<span>function</span> <span>remove</span><span>(</span><span>arr<span>,</span>item</span><span>)</span><span>{</span>
  <span>if</span><span>(</span>arr<span>.</span>length<span>)</span><span>{</span>
    <span>const</span> index <span>=</span> arr<span>.</span><span>indexOf</span><span>(</span>item<span>)</span>
    <span>if</span><span>(</span>index <span>></span> <span>-</span><span>1</span><span>)</span><span>{</span>
      <span>return</span> arr<span>.</span><span>splice</span><span>(</span>index<span>,</span><span>1</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><blockquote>
<p>收集的依赖时 window.target ,他到以是什么？当属性变化时候我们通知谁？</p>
</blockquote>
<p><strong>watcher</strong></p>
<p>是一个中介的角色，数据发生变化时通知它，然后它再去通知其他地方</p>
<div><pre><code><span>export</span> <span>default</span> <span>class</span> <span>Watcher</span> <span>{</span>
  <span>constructor</span> <span>(</span><span>vm<span>,</span>expOrFn<span>,</span>cb</span><span>)</span> <span>{</span>
    <span>// 组件实例对象</span>
    <span>// 要观察的表达式，函数，或者字符串，只要能触发取值操作</span>
    <span>// 被观察者发生变化后的回调</span>
    <span>this</span><span>.</span>vm <span>=</span> vm <span>// Watcher有一个 vm 属性，表明它是属于哪个组件的</span>
    <span>// 执行this.getter()及时读取数据</span>
    <span>this</span><span>.</span>getter <span>=</span> <span>parsePath</span><span>(</span>expOrFn<span>)</span>
    <span>this</span><span>.</span>cb <span>=</span> cb
    <span>this</span><span>.</span>value <span>=</span> <span>this</span><span>.</span><span>get</span><span>(</span><span>)</span>
  <span>}</span>
  <span>get</span><span>(</span><span>)</span><span>{</span>
    window<span>.</span>target <span>=</span> <span>this</span>
    <span>let</span> value <span>=</span> <span>this</span><span>.</span><span>getter</span><span>.</span><span>call</span><span>(</span><span>this</span><span>.</span>vm<span>,</span><span>this</span><span>.</span>vm<span>)</span>
    window<span>.</span>target <span>=</span> <span>undefined</span>
    <span>return</span> value
  <span>}</span> u
  <span>pdate</span><span>(</span><span>)</span><span>{</span>
    <span>const</span> oldValue <span>=</span> <span>this</span><span>.</span>value
    <span>this</span><span>.</span>value <span>=</span> <span>this</span><span>.</span><span>get</span><span>(</span><span>)</span>
    <span>this</span><span>.</span><span>cb</span><span>.</span><span>call</span><span>(</span><span>this</span><span>.</span>vm<span>,</span><span>this</span><span>.</span>value<span>,</span>oldValue<span>)</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="总结"> 总结</h2>
<p>data通过Observer转换成了getter/setter的形式来追踪变化当外界通过Watcher读取数据的，会触发getter从而将watcher添加到依赖中
当数据变化时，会触发setter从而向Dep中的依赖（watcher）发送通知watcher接收通知后，会向外界发送通知，变化通知到外界后可能会触发视图更新，也有可能触发用户的某个回调函数等</p>
]]></content:encoded>
    </item>
    <item>
      <title>vue如果想要扩展某个现有组件时怎么做？</title>
      <link>https://wangyawei.top/views/interviewQuestion/question-note-95/</link>
      <guid>https://wangyawei.top/views/interviewQuestion/question-note-95/</guid>
      <source url="https://wangyawei.top/rss.xml">vue如果想要扩展某个现有组件时怎么做？</source>
      <category>面试题</category>
      <pubDate>Tue, 21 Sep 2021 13:08:34 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="使用vue-mixin全局混入"> 使用Vue.mixin全局混入</h2>
<blockquote>
<p>混入 (mixins) 是一种分发 Vue 组件中可复用功能的非常灵活的方式。混入对象可以包含任意组件选项。当组件使用混入对象时，所有混入对象的选项将被混入该组件本身的选项。mixins 选项接受一个混合对象的数组。</p>
</blockquote>
<div><pre><code>Vue<span>.</span><span>mixin</span><span>(</span><span>{</span><span>// 全局注册一个混入，影响注册之后所有创建的每个 Vue 实例</span>
  <span>updated</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span><span>"我是全局的混入"</span><span>)</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>mixins的调用顺序:</strong></p>
<p>混入对象的钩子将在组件自身钩子之前调用，如果遇到全局混入(Vue.mixin)，全局混入的执行顺序要前于混入和组件里的方法。</p>
<h2 id="加slot扩展"> 加slot扩展</h2>
<blockquote>
<p>slot用来获取组件中的原内容，可以分为默认插槽和匿名插槽、作用域插槽</p>
</blockquote>
<h2 id="总结"> 总结</h2>
<ul>
<li>使用mixin全局混入</li>
<li>使用slot扩展</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/issues/</link>
      <guid>https://wangyawei.top/views/issues/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>issues</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些自己平时遇到的bug或问题点，并提供一种解决方式，供自己以后参考；</p>
</blockquote>
<h2 id="目录"> 目录</h2>
<ul>
<li><a href="./issues-13.html">vue跨域解决方案</a></li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>axios发delete请求，后台收不到参数</title>
      <link>https://wangyawei.top/views/issues/issues-01/</link>
      <guid>https://wangyawei.top/views/issues/issues-01/</guid>
      <source url="https://wangyawei.top/rss.xml">axios发delete请求，后台收不到参数</source>
      <category>issues</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1、问题"> 1、问题；</h2>
<blockquote>
<p><code>vue</code>项目前台用<code>axios</code>发请求；由于之前也是一直用<code>axios</code>发请求，所以这一次遇到问题一脸懵逼；</p>
</blockquote>
<ul>
<li>
<p>请求方式：<code>delete</code>;请求头类型：<code>'application/json;charset=utf-8'</code></p>
<blockquote>
<p>后台我用的是<code>nodejs</code>和<code>express</code></p>
</blockquote>
</li>
<li>
<p>解决：<code>axios</code>的请求头设置错误；</p>
<ul>
<li>
<p>错的设置；</p>
<div><pre><code><span>const</span> _Axios <span>=</span> axios<span>.</span><span>create</span><span>(</span><span>{</span>
  headers<span>:</span> <span>{</span>
    <span>'Content-Type'</span><span>:</span> <span>'application/json,charset=utf-8'</span>
  <span>}</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>正确的设置；</p>
<div><pre><code></code></pre>
<div></div></div></li>
</ul>
<p>const _Axios = axios.create({
headers: {
'Content-Type': 'application/json;charset=utf-8'
}
})
// 或者
axios.defaults.headers.post['Content-Type'] = 'application/json;charset=utf-8'</p>
<div><pre><code>
&gt; 修改`application/json，charset=utf-8`后的`，`为`;`就可以了，后台就成功收到参数了；
&gt;
&gt; 不设置也是可以的，因为默认就是`application/json;charset=utf-8`

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>扩展：</p>
<div><pre><code>1、get请求：GET 请求不存在请求实体部分，键值对参数放置在 URL 尾部，浏览器把form数据转换成一个字串（name1=value1&amp;name2=value2...），然后把这个字串追加到url后面用?分割，加载这个新的url。因此请求头不需要设置 Content-Type 字段。
2、post请求：headers中有content-type这个字段一般包括：application/x-www-form-urlencoded、multipart/form-data、application/json、text/xml。
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
<h2 id="_2、express接受参数"> 2、express接受参数；</h2>
<p>如果是用<code>express.router()</code>的方式设计路由，那么你在接受参数时:</p>
<ol>
<li>
<p>对于get请求来说可以在<code>req.query</code>中获取url后面的参数:</p>
<div><pre><code>router<span>.</span><span>get</span><span>(</span><span>'/note'</span><span>,</span> <span>(</span><span>request<span>,</span> response<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>request<span>.</span>query<span>)</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>对于post请求来说，在不使用其它插件的情况下，只能采用原生获取参数的方法；</p>
<div><pre><code><span>// 'Content-Type': 'application/json;charset=utf-8'</span>
router<span>.</span><span>post</span><span>(</span><span><span>/</span><span>\/(add|import)</span><span>/</span></span><span>,</span> <span>(</span><span>request<span>,</span> response<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
  <span>let</span> body <span>=</span> <span>''</span>
  request<span>.</span><span>on</span><span>(</span><span>'data'</span><span>,</span> <span>function</span> <span>(</span><span>chunk</span><span>)</span> <span>{</span>
    body <span>+=</span> chunk <span>// chunk是二进制数据</span>
  <span>}</span><span>)</span>
  request<span>.</span><span>on</span><span>(</span><span>'end'</span><span>,</span> <span>function</span> <span>(</span><span>result</span><span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>result<span>,</span> <span>'===='</span><span>,</span> body<span>,</span> <span>JSON</span><span>.</span><span>parse</span><span>(</span>body<span>)</span><span>)</span> <span>// 转化为对象</span>
  <span>}</span><span>)</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>body就是获取的参数，然后y用JSON.parse(body)进行解析。</p>
</blockquote>
</li>
<li>
<p>使用插件<code>body-parser</code></p>
<div><pre><code><span>const</span> bodyParser <span>=</span> <span>require</span><span>(</span><span>'body-parser'</span><span>)</span>
<span>const</span> app <span>=</span> <span>new</span> <span>express</span><span>(</span><span>)</span><span>;</span>
app<span>.</span><span>use</span><span>(</span>bodyParser<span>.</span><span>json</span><span>(</span><span>)</span><span>)</span>	
<span>...</span>

router<span>.</span><span>post</span><span>(</span><span>'/note'</span><span>,</span> <span>(</span><span>request<span>,</span> response<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>request<span>.</span>body<span>)</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p>然后就直接可以在<code>req.body</code>中来获取请求过来的参数了。</p>
</blockquote>
</li>
<li>
<p><code>req.params</code></p>
<div><pre><code><span>// 适合获取production后的id：http://localhost:3000/production/id</span>
router<span>.</span><span>get</span><span>(</span><span>'/note'</span><span>,</span> <span>(</span><span>request<span>,</span> response<span>,</span> next</span><span>)</span> <span>=></span> <span>{</span>
  console<span>.</span><span>log</span><span>(</span>request<span>.</span>params<span>)</span>
<span>}</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>pm2 command not found</title>
      <link>https://wangyawei.top/views/issues/issues-02/</link>
      <guid>https://wangyawei.top/views/issues/issues-02/</guid>
      <source url="https://wangyawei.top/rss.xml">pm2 command not found</source>
      <category>issues</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="tmp-jenkins5751570293012104226-sh-line-8-pm2-command-not-found"> <code>/tmp/jenkins5751570293012104226.sh: line 8: pm2: command not found</code></h2>
<blockquote>
<p>使用jenkins部署的时候，原来好好的，但是今天突然就不好使了(我移动了pm2的安装目录)报如下错误；</p>
</blockquote>
<div><pre><code><span>..</span><span>..</span>.
<span>[</span>heroList<span>]</span> $ /bin/sh -xe /tmp/jenkins1733537390543316955.sh
<span>[</span>heroList<span>]</span> $ /bin/sh -xe /tmp/jenkins5751570293012104226.sh
+ pm2 restart <span>npm</span> -- run dev
/tmp/jenkins5751570293012104226.sh: line <span>8</span>: pm2: <span>command</span> not found
Build step <span>'Execute shell'</span> marked build as failure
Finished: FAILURE
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="_1、原因分析"> 1、原因分析；</h3>
<ul>
<li>
<p>我首先想到的是，在系统中看pm2还可以使用不，但是我发现可以使用；</p>
</li>
<li>
<p>查看<code>/bin</code>目录下的软连接是否还可以使用；</p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># cd bin/</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ bin<span>]</span><span># ls -l</span>
total <span>317580</span>
<span>..</span><span>..</span><span>..</span>
-rwxr-xr-x    <span>1</span> root root      <span>40720</span> May <span>11</span>  <span>2020</span> plymouth
<span># 查看此处pm2所对应的安装目录是否是你的pm2的目录</span>
lrwxrwxrwx    <span>1</span> root root         <span>55</span> Apr <span>12</span> <span>22</span>:58 pm2 -<span>></span> /home/local/application/node-v12.18.2-linux-x64/bin/pm2 
-rwxr-xr-x    <span>1</span> root root      <span>28272</span> May <span>11</span>  <span>2020</span> pmap
<span>..</span><span>..</span><span>..</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ bin<span>]</span><span># </span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>
<p>pm2 -&gt; /home/local/application/node-v12.18.2-linux-x64/bin/pm2   表示我的pm2在bin目录下</p>
</blockquote>
</li>
</ul>
<h3 id="_2、解决方法"> 2、解决方法；</h3>
<ul>
<li>如果你的pm2所对应的与你的安装目录不一样，那么你就修改成一样的。</li>
<li>如果没有你就创建一个。(<strong>就是创建软连接</strong>)</li>
</ul>
<h3 id="_3、验证"> 3、验证：</h3>
<div><pre><code><span>..</span><span>..</span>
<span>[</span>heroList<span>]</span> $ /bin/sh -xe /tmp/jenkins1503992813040784551.sh
<span>[</span>heroList<span>]</span> $ /bin/sh -xe /tmp/jenkins2178596476171231682.sh
+ pm2 -v
<span>4.5</span>.1
Finished: SUCCESS
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>jenkins构建项目失败</title>
      <link>https://wangyawei.top/views/issues/issues-03/</link>
      <guid>https://wangyawei.top/views/issues/issues-03/</guid>
      <source url="https://wangyawei.top/rss.xml">jenkins构建项目失败</source>
      <category>issues</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>目的很简单，就是想自己实现一个<code>web</code>项目的全自动化部署；</p>
<p>但是现实总是残酷的，在搭建到用<code>jenkins</code>的过程中遇到了很多的坑；</p>
<p>本人的系统： aliyun liunx</p>
</blockquote>
<p>从网上看了很多的教程顺利完成了安装，登录和创建项目，但是在构建时，总是不成功；</p>
<p><img src="./assets/1596265240727.png" alt="1596265240727" /></p>
<p>每次打包都是上面的这个错误，在网上找了很多的资料，都没有单独对这个问题的说明解答；</p>
<p>所以在这里就单独对这个问题做解答；</p>
<ul>
<li>
<p>我是打包完成了，只是想要切换路径进入tomcat目录，但是死活进不去，提示没有这样的目录。</p>
</li>
<li>
<p>最后的解决方案是用户权限的问题；</p>
</li>
<li>
<p>打开<code>jenkins</code>配置文件:</p>
</li>
</ul>
<div><pre><code>vim /etc/sysconfig/jenkins
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>将原来的<code>jenkins</code>用户修改为 <code>root</code>用户。</li>
</ul>
<div><pre><code>$JENKINS_USER=&quot;root&quot;
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>
<p>修改<code>Jenkins</code>相关文件夹用户权限</p>
<div><pre><code>chown -R root:root /var/lib/jenkins
chown -R root:root /var/cache/jenkins
chown -R root:root /var/log/jenkins
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>重启Jenkins</p>
<div><pre><code>systemctl restart jenkins
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>查看Jenkins进程所属用户</p>
<div><pre><code>ps -ef | grep jenkins
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1596265662379.png" alt="1596265662379" /></p>
</li>
<li>
<p>重新执行构建；</p>
</li>
</ul>
<p><img src="./assets/1596265758450.png" alt="1596265758450" /></p>
<p>转载： https://blog.csdn.net/jeikerxiao/article/details/80768949</p>
]]></content:encoded>
    </item>
    <item>
      <title>linux-nodejs启动报错</title>
      <link>https://wangyawei.top/views/issues/issues-04/</link>
      <guid>https://wangyawei.top/views/issues/issues-04/</guid>
      <source url="https://wangyawei.top/rss.xml">linux-nodejs启动报错</source>
      <category>issues</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>在测试上执行<code>npm run serve</code>时报错；</p>
</blockquote>
<p><img src="./assets/1594656712548.png" alt="1594656712548" /></p>
<div><pre><code>主要原因就是：3000端口被占用了
</code></pre>
<div><span>1</span><br></div></div><h2 id="解决"> 解决；</h2>
<ul>
<li>
<p>查看端口;</p>
<div><pre><code>执行命令：`netstat -tunlp|grep 3000`查看端口被哪一个进程所占用；
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594656900946.png" alt="1594656900946" /></p>
</li>
<li>
<p>中止被占用的进程；</p>
<div><pre><code>执行命令：`kill -s 9 17235`
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594656974877.png" alt="1594656974877" /></p>
</li>
</ul>
<h2 id="重新启动"> 重新启动；</h2>
<p><img src="./assets/1594657233290.png" alt="1594657233290" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>vite启动报错：Cannot call write after a stream was destroyed</title>
      <link>https://wangyawei.top/views/issues/issues-05/</link>
      <guid>https://wangyawei.top/views/issues/issues-05/</guid>
      <source url="https://wangyawei.top/rss.xml">vite启动报错：Cannot call write after a stream was destroyed</source>
      <category>issues</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="vite启动报错-cannot-call-write-after-a-stream-was-destroyed"> vite启动报错：Cannot call write after a stream was destroyed</h2>
<blockquote>
<p>vue3.0和vite也算是出来一段时间了，有些公司项目也已经开始使用了(我猜的)，于是自己打算学习一下，结果在启动项目的时候就给我报了一个错误，一天都无头绪，网上也找不到解决的方法，可是呢后面的测试中误打误撞的给解决的，在这里记录一下。</p>
</blockquote>
<ol>
<li>
<p>安装；</p>
<div><pre><code><span># npm</span>
<span>npm</span> init @vitejs/app myVite

<span># yarn</span>
<span>yarn</span> create @vitejs/app

或通过附加的命令行选项直接指定项目名称和你想要使用的模板。例如，要构建一个 Vite + Vue 项目，运行:

<span># npm 6.x</span>
<span>npm</span> init @vitejs/app my-vue-app --template vue

<span># npm 7+, 需要额外的双横线：</span>
<span>npm</span> init @vitejs/app my-vue-app -- --template vue

<span># yarn</span>
<span>yarn</span> create @vitejs/app my-vue-app --template vue
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><blockquote>
<p>我执行的是 <code>npm init @vitejs/app myVite_three</code>，项目成功的创建。</p>
</blockquote>
</li>
<li>
<p>安装依赖；进入项目的根目录中执行以下命令：</p>
<div><pre><code><span>npm</span> <span>install</span>
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>启动服务：</p>
<div><pre><code><span>npm</span> run dev
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>报错详情：</p>
<div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/vue.3.0/viteee/myVite_three
$ <span>npm</span> run dev

<span>></span> myvite-three@0.0.0 dev
<span>></span> vite

failed to load config from C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>vue.3.0<span>\</span>viteee<span>\</span>myVite_three<span>\</span>vite.config.js
error when starting dev server:
Error <span>[</span>ERR_STREAM_DESTROYED<span>]</span>: Cannot call <span>write</span> after a stream was destroyed
    at doWrite <span>(</span>_stream_writable.js:399:19<span>)</span>
    at writeOrBuffer <span>(</span>_stream_writable.js:387:5<span>)</span>
    at Socket.Writable.write <span>(</span>_stream_writable.js:318:11<span>)</span>
    at Object.writeToStdin <span>(</span>C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>vue.3.0<span>\</span>viteee<span>\</span>myVite_three<span>\</span>node_modules<span>\</span>esbuild<span>\</span>lib<span>\</span>main.js:1413:19<span>)</span>
    at sendRequest <span>(</span>C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>vue.3.0<span>\</span>viteee<span>\</span>myVite_three<span>\</span>node_modules<span>\</span>esbuild<span>\</span>lib<span>\</span>main.js:576:14<span>)</span>
    at Object.buildOrServe <span>(</span>C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>vue.3.0<span>\</span>viteee<span>\</span>myVite_three<span>\</span>node_modules<span>\</span>esbuild<span>\</span>lib<span>\</span>main.js:1044:11<span>)</span>
    at C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>vue.3.0<span>\</span>viteee<span>\</span>myVite_three<span>\</span>node_modules<span>\</span>esbuild<span>\</span>lib<span>\</span>main.js:1444:17
    at new Promise <span>(</span><span>&lt;</span>anonymous<span>></span><span>)</span>
    at Object.build <span>(</span>C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>vue.3.0<span>\</span>viteee<span>\</span>myVite_three<span>\</span>node_modules<span>\</span>esbuild<span>\</span>lib<span>\</span>main.js:1443:14<span>)</span>
    at Object.build <span>(</span>C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>vue.3.0<span>\</span>viteee<span>\</span>myVite_three<span>\</span>node_modules<span>\</span>esbuild<span>\</span>lib<span>\</span>main.js:1334:51<span>)</span>
<span>npm</span> ERR<span>!</span> code <span>1</span>
<span>npm</span> ERR<span>!</span> path C:<span>\</span>Users<span>\</span>ASUS<span>\</span>Desktop<span>\</span>vue.3.0<span>\</span>viteee<span>\</span>myVite_three
<span>npm</span> ERR<span>!</span> <span>command</span> failed
<span>npm</span> ERR<span>!</span> <span>command</span> C:<span>\</span>WINDOWS<span>\</span>system32<span>\</span>cmd.exe /d /s /c vite

<span>npm</span> ERR<span>!</span> A complete log of this run can be found in:
<span>npm</span> ERR<span>!</span>     C:<span>\</span>Users<span>\</span>ASUS<span>\</span>AppData<span>\</span>Local<span>\</span>npm-cache<span>\</span>_logs<span>\</span><span>2021</span>-04-04T06_57_46_748Z-debug.log

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><blockquote>
<p>刚开始出现错误的时候还好，关键问题是找遍全网没有找到答案，心里就慌了。</p>
</blockquote>
</li>
<li>
<p>解决：</p>
<blockquote>
<p>在看到官方的另外一种创建项目的方法后(yarn)我果断又重新创建了一个项目，然后成功启动。然后就想npm和yarn的区别就是yarn的下载速度快，也就是下载源不一样，于是我就查看了下自己的npm下载源，果然不是官方的。因为我个人比较喜欢用npm 和官方的下载源，但是下载源不知道什么被设置成了http://r.cnpmjs.org/，随后我就修改为了官方的下载源；</p>
</blockquote>
<div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/vue.3.0/viteee/myVite_three
$ <span>npm</span> config get registry
http://r.cnpmjs.org/

ASUS@yaweidediannao MINGW64 ~/Desktop/vue.3.0/viteee/myVite_three
$ <span>npm</span> config <span>set</span> registry https://registry.npmjs.org/

ASUS@yaweidediannao MINGW64 ~/Desktop/vue.3.0/viteee/myVite_three
$ <span>npm</span> config get registry
https://registry.npmjs.org/

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
<li>
<p>使用修改后的下载源重新创建项目(步骤1、2、3)。</p>
</li>
<li>
<p>成功启动服务。</p>
<div><pre><code>ASUS@yaweidediannao MINGW64 ~/Desktop/vue.3.0/viteee/myVite
$ <span>npm</span> run dev

<span>></span> myvite@0.0.0 dev
<span>></span> vite


  vite v2.1.5 dev server running at:

  <span>></span> Network:  http://192.168.137.1:3000/
  <span>></span> Network:  http://192.168.2.3:3000/
  <span>></span> Local:    http://localhost:3000/

  ready <span>in</span> 590ms.

<span>[</span>@vue/compiler-sfc<span>]</span> <span>&lt;</span>script setup<span>></span> is still an experimental proposal.
Follow its status at https://github.com/vuejs/rfcs/pull/227.

<span>[</span>@vue/compiler-sfc<span>]</span> When using experimental features,
it is recommended to pin your vue dependencies to exact versions to avoid breakage.

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></li>
<li>
<p>遗留问题：</p>
<p>虽然下载源不一样，但是下载的版本都一样，而且下载的依赖也没有报错，不明白为什么cnpm的下载源，启动服务会出错。</p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>启动webpack-dev-server报错</title>
      <link>https://wangyawei.top/views/issues/issues-06/</link>
      <guid>https://wangyawei.top/views/issues/issues-06/</guid>
      <source url="https://wangyawei.top/rss.xml">启动webpack-dev-server报错</source>
      <category>issues</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="cannot-find-module-webpack-cli-bin-config-yargs"> <code>Cannot find module 'webpack-cli/bin/config-yargs'</code></h2>
<h3 id="方法一、"> 方法一、</h3>
<ul>
<li>
<p>版本：</p>
<div><pre><code>&quot;webpack&quot;: &quot;^5.24.2&quot;,
&quot;webpack-cli&quot;: &quot;^4.5.0&quot;,
&quot;webpack-dev-server&quot;: &quot;^3.11.2&quot;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>启动：<code>webpack-dev-server</code></p>
</li>
<li>
<p>报错信息：</p>
<div><pre><code>Cannot find module &#39;webpack-cli/bin/config-yargs&#39;
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>报错原因：<code>webpack-dev-server</code>依赖于<code>webpack-cli</code>里面的<code>config-yargs</code>文件。然而 在webpack-cli 版本4以后删除了 config-yargs文件 ，</p>
<div><pre><code><span>// 在webpack-dev-server.js中我们可以看到以下一段代码。用来加载 config-yargs 文件，</span>

<span>// webpack-cli@3.3 path : 'webpack-cli/bin/config/config-yargs'</span>
<span>let</span> configYargsPath<span>;</span>
<span>try</span> <span>{</span>
  require<span>.</span><span>resolve</span><span>(</span><span>'webpack-cli/bin/config/config-yargs'</span><span>)</span><span>;</span>
  configYargsPath <span>=</span> <span>'webpack-cli/bin/config/config-yargs'</span><span>;</span>
<span>}</span> <span>catch</span> <span>(</span>e<span>)</span> <span>{</span>
  configYargsPath <span>=</span> <span>'webpack-cli/bin/config-yargs'</span><span>;</span>
<span>}</span>
<span>// eslint-disable-next-line import/no-extraneous-dependencies</span>
<span>// eslint-disable-next-line import/no-dynamic-require</span>
<span>require</span><span>(</span>configYargsPath<span>)</span><span>(</span>yargs<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></li>
<li>
<p>试错：</p>
<ul>
<li>
<p>安装低版本；</p>
<div><pre><code>npm install webpack-cli@3.3.10
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>错误信息：</p>
<div><pre><code>npm ERR! Could not resolve dependency:
npm ERR! peer webpack@&quot;4.x.x&quot; from webpack-cli@3.3.10
npm ERR! node_modules/webpack-cli
npm ERR!   webpack-cli@&quot;3.3.10&quot; from the root project

翻译：webpack-cli@3.3.10需要一个webpack@4.x.x的对等点
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
<li>
<p>解决：</p>
<ul>
<li>安装webpack@4.46</li>
<li>安装<code>webpack-cli@3.3.10</code></li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="方法二、"> 方法二、</h3>
<ul>
<li>
<p>直接配置<code>script</code>脚本直接启动。不需要进行降级处理</p>
<div><pre><code>  <span>"scripts"</span><span>:</span> <span>{</span>
    <span>"test"</span><span>:</span> <span>"echo \"Error: no test specified\" &amp;&amp; exit 1"</span><span>,</span>
    <span>"server"</span><span>:</span> <span>"webpack serve --mode=development"</span><span>,</span>
  <span>}</span><span>,</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
</ul>
<p><a href="https://blog.csdn.net/weixin_40599109/article/details/109582365" target="_blank" rel="noopener noreferrer">查看原文</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>permission denied 127.0.0.1:8888</title>
      <link>https://wangyawei.top/views/issues/issues-08/</link>
      <guid>https://wangyawei.top/views/issues/issues-08/</guid>
      <source url="https://wangyawei.top/rss.xml">permission denied 127.0.0.1:8888</source>
      <category>issues</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="error-listen-eacces-permission-denied-127-0-0-1-8888"> <code>Error: listen EACCES: permission denied 127.0.0.1:8888</code></h2>
<blockquote>
<p>出现这个问题的场景是在我使用<code>webpack-bundle-analyzer</code>的时候，结果出现了以下报错信息；</p>
</blockquote>
<div><pre><code><span>"C:\Program Files<span title="\n">\n</span>odejs<span title="\n">\n</span>ode.exe"</span> <span>"C:\Program Files<span title="\n">\n</span>odejs<span title="\n">\n</span>ode_modules<span title="\n">\n</span>pm<span title="\b">\b</span>in<span title="\n">\n</span>pm-cli.js"</span> run build --scripts-prepend-node-path<span>=</span>auto

<span>></span> webnode@1.0.0 build
<span>></span> cross-env <span>NODE_ENV</span><span>=</span>production <span>DEBUG</span><span>=</span>app:* node bin/build.js

Build completed <span>in</span> <span>9</span>.233s

events.js:292
      throw er<span>;</span> // Unhandled <span>'error'</span> event
      ^

Error: listen EACCES: permission denied <span>127.0</span>.0.1:8888
    at Server.setupListenHandle <span>[</span>as _listen2<span>]</span> <span>(</span>net.js:1296:21<span>)</span>
    at listenInCluster <span>(</span>net.js:1361:12<span>)</span>
    at doListen <span>(</span>net.js:1498:7<span>)</span>
    at processTicksAndRejections <span>(</span>internal/process/task_queues.js:85:21<span>)</span>
Emitted <span>'error'</span> event on Server instance at:
    at emitErrorNT <span>(</span>net.js:1340:8<span>)</span>
    at processTicksAndRejections <span>(</span>internal/process/task_queues.js:84:21<span>)</span> <span>{</span>
  code: <span>'EACCES'</span>,
  errno: <span>'EACCES'</span>,
  syscall: <span>'listen'</span>,
  address: <span>'127.0.0.1'</span>,
  port: <span>8888</span>
<span>}</span>
<span>npm</span> ERR<span>!</span> code <span>1</span>
<span>npm</span> ERR<span>!</span> path E:<span>\</span>webNode
<span>npm</span> ERR<span>!</span> <span>command</span> failed
<span>npm</span> ERR<span>!</span> <span>command</span> C:<span>\</span>WINDOWS<span>\</span>system32<span>\</span>cmd.exe /d /s /c cross-env <span>NODE_ENV</span><span>=</span>production <span>DEBUG</span><span>=</span>app:* node bin/bui
ld.js

<span>npm</span> ERR<span>!</span> A complete log of this run can be found in:
<span>npm</span> ERR<span>!</span>     C:<span>\</span>Users<span>\</span>ASUS<span>\</span>AppData<span>\</span>Local<span>\</span>npm-cache<span>\</span>_logs<span>\</span><span>2021</span>-04-05T14_29_00_634Z-debug.log

Process finished with <span>exit</span> code <span>1</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><ol>
<li>
<p>报错解释：没有权限，拒绝访问，然后我就在网上找了相关问题的回答，大多数的回答所对应的问题是：<code>listen EACCES 127.0.0.1:8000</code>的问题，没有关于权限的问题，所以我就试了下，结果好使。</p>
</li>
<li>
<p>查看端口是否占用：</p>
<div><pre><code>ASUS@yaweidediannao MINGW64 /e/webNode <span>(</span>master<span>)</span>
$ <span>netstat</span> -ano <span>|</span> findstr <span>"8888"</span>
  TCP    <span>0.0</span>.0.0:8888           <span>0.0</span>.0.0:0              LISTENING       <span>6460</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>查看进程ID所对应的服务；</p>
<div><pre><code>ASUS@yaweidediannao MINGW64 /e/webNode <span>(</span>master<span>)</span>
$ tasklist <span>|</span>findstr <span>"6460"</span>
python.exe                    <span>6460</span> Services                   <span>0</span>      <span>3,444</span> K

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>解决：</p>
<ul>
<li>
<p>杀死占用8888端口的应用；</p>
<div><pre><code><span># 未验证，自己斟酌</span>
taskkill -PID <span>6460</span> -F
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>更换自己的服务端口号(<strong>我才用的是这种</strong>)</p>
</li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>git clone 错误</title>
      <link>https://wangyawei.top/views/issues/issues-09/</link>
      <guid>https://wangyawei.top/views/issues/issues-09/</guid>
      <source url="https://wangyawei.top/rss.xml">git clone 错误</source>
      <category>issues</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="fatal-unable-to-access-https-github-com-wyw-s-patient-git-encountered-end-of-file"> <code>fatal: unable to access 'https://github.com/wyw-s/patient.git/': Encountered end of file</code></h2>
<blockquote>
<p>在liunx上克隆项目时出现的错误，</p>
</blockquote>
<p>1、出现原因：git clone ...</p>
<div><pre><code><span>[</span>root@xxxx156pkpio44mis76wmxZ www<span>]</span><span># git clone https://github.com/xxx/patient.git</span>
Cloning into <span>'patient'</span><span>..</span>.
fatal: unable to access <span>'https://github.com/wyw-s/patient.git/'</span><span>:</span> Encountered end of <span>file</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>2、解决：输入以下命令</p>
<div><pre><code><span>[</span>root@xxxx156pkpio44mis76wmxZ www<span>]</span><span># git config --global http.sslVerify "false"</span>
</code></pre>
<div><span>1</span><br></div></div><p>3、验证；</p>
<div><pre><code><span>[</span>root@xxxx156pkpio44mis76wmxZ www<span>]</span><span># git config --global http.sslVerify "false"</span>
<span>[</span>root@xxxx156pkpio44mis76wmxZ www<span>]</span><span># git clone https://github.com/xxx/patient.git</span>
Cloning into <span>'patient'</span><span>..</span>.
remote: Enumerating objects: <span>507</span>, done.
remote: Counting objects: <span>100</span>% <span>(</span><span>507</span>/507<span>)</span>, done.
remote: Compressing objects: <span>100</span>% <span>(</span><span>285</span>/285<span>)</span>, done.
remote: Total <span>507</span> <span>(</span>delta <span>213</span><span>)</span>, reused <span>423</span> <span>(</span>delta <span>138</span><span>)</span>, pack-reused <span>0</span>
Receiving objects: <span>100</span>% <span>(</span><span>507</span>/507<span>)</span>, <span>3.37</span> MiB <span>|</span> <span>22.00</span> KiB/s, done.
Resolving deltas: <span>100</span>% <span>(</span><span>213</span>/213<span>)</span>, done.
<span>[</span>root@iZbp156pkpio44mis76wmxZ www<span>]</span><span># </span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><blockquote>
<p>如果不成功可以在尝试一次，</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>vue项目使用require引入图片不能不显示</title>
      <link>https://wangyawei.top/views/issues/issues-07/</link>
      <guid>https://wangyawei.top/views/issues/issues-07/</guid>
      <source url="https://wangyawei.top/rss.xml">vue项目使用require引入图片不能不显示</source>
      <category>issues</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="使用require引入图片不显示"> 使用require引入图片不显示</h2>
<blockquote>
<p>简述：本人在<code>vue</code>项目中使用<code>require</code>引入图片后，页面不显示加载的图片，控制台报错结果如下。</p>
</blockquote>
<div><pre><code>GET http://localhost:8080/[object%20Module] 404 (Not Found)
</code></pre>
<div><span>1</span><br></div></div><ol>
<li>
<p>报错场景：在vue文件中使用<code>require</code>加载图片。</p>
<div><pre><code><span>export</span> <span>default</span> <span>{</span>
  name<span>:</span> <span>'tag'</span><span>,</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      login<span>:</span> <span>require</span><span>(</span><span>'@/assets/login.jpg'</span><span>)</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
<li>
<p>问题原因：在<code>url-loader</code>的<strong>4.1</strong>版本中，有一个属性<code>esModule</code></p>
<p>根据<a href="https://www.npmjs.com/package/url-loader#esmodule" target="_blank" rel="noopener noreferrer">官方文档</a>的介绍意思是：默认情况下，文件加载器会使用ES模块语法，在某些情况下，使用ES模块是有益的，不过你也可以将`esModule的属性设置为关闭，来启用commonJS模块的语法。</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  module<span>:</span> <span>{</span>
    rules<span>:</span> <span>[</span>
      <span>{</span>
        test<span>:</span> <span><span>/</span><span>\.css$</span><span>/</span></span><span>,</span>
        use<span>:</span> <span>[</span>
          <span>{</span>
            loader<span>:</span> <span>'url-loader'</span><span>,</span>
            options<span>:</span> <span>{</span>
              esModule<span>:</span> <span>false</span><span>,</span>
            <span>}</span><span>,</span>
          <span>}</span><span>,</span>
        <span>]</span><span>,</span>
      <span>}</span><span>,</span>
    <span>]</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div></li>
<li>
<p>解决方法：</p>
<ul>
<li>
<p><code>esModule：false</code>时使用<code>require</code>引入图片；</p>
</li>
<li>
<p><code>esModule：true</code>时使用<code>import</code>引入图片；</p>
<div><pre><code><span>&lt;</span>script<span>></span>
<span>import</span> login <span>from</span> <span>'@/assets/login.jpg'</span>
<span>export</span> <span>default</span> <span>{</span>
  name<span>:</span> <span>'tag'</span><span>,</span>
  <span>data</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>{</span>
      login<span>:</span> login
    <span>}</span>
  <span>}</span>
<span>}</span>
<span>&lt;</span><span>/</span>script<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></li>
</ul>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>Failed to start LSB Jenkins Automation Server</title>
      <link>https://wangyawei.top/views/issues/issues-10/</link>
      <guid>https://wangyawei.top/views/issues/issues-10/</guid>
      <source url="https://wangyawei.top/rss.xml">Failed to start LSB Jenkins Automation Server</source>
      <category>issues</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="场景"> 场景；</h2>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># service jenkins start</span>
Starting jenkins <span>(</span>via systemctl<span>)</span>:  Job <span>for</span> jenkins.service failed because the control process exited with error code. See <span>"systemctl status jenkins.service"</span> and <span>"journalctl -xe"</span> <span>for</span> details.
                                                           <span>[</span>FAILED<span>]</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># systemctl -l status jenkins.service 查看更多的详情信息</span>
● jenkins.service - LSB: Jenkins Automation Server
   Loaded: loaded <span>(</span>/etc/rc.d/init.d/jenkins<span>;</span> bad<span>;</span> vendor preset: disabled<span>)</span>
   Active: failed <span>(</span>Result: exit-code<span>)</span> since Sun <span>2021</span>-05-02 <span>23</span>:34:57 CST<span>;</span> 2min 5s ago
     Docs: man:systemd-sysv-generator<span>(</span><span>8</span><span>)</span>
  Process: <span>29311</span> <span>ExecStart</span><span>=</span>/etc/rc.d/init.d/jenkins start <span>(</span>code<span>=</span>exited, <span>status</span><span>=</span><span>1</span>/FAILURE<span>)</span>

May 02 <span>23</span>:34:57 iZbp156pkpio44mis76wmxZ systemd<span>[</span><span>1</span><span>]</span>: Starting LSB: Jenkins Automation Server<span>..</span>.
May 02 <span>23</span>:34:57 iZbp156pkpio44mis76wmxZ runuser<span>[</span><span>29316</span><span>]</span>: pam_unix<span>(</span>runuser:session<span>)</span>: session opened <span>for</span> user root by <span>(</span>uid<span>=</span><span>0</span><span>)</span>
May 02 <span>23</span>:34:57 iZbp156pkpio44mis76wmxZ jenkins<span>[</span><span>29311</span><span>]</span>: Starting Jenkins bash: /home/local/JDK/jdk1.8.0_251/bin/java: No such <span>file</span> or directory <span># 此处问题点！！！</span>
May 02 <span>23</span>:34:57 iZbp156pkpio44mis76wmxZ jenkins<span>[</span><span>29311</span><span>]</span>: <span>[</span>FAILED<span>]</span>
May 02 <span>23</span>:34:57 iZbp156pkpio44mis76wmxZ systemd<span>[</span><span>1</span><span>]</span>: jenkins.service: control process exited, <span>code</span><span>=</span>exited <span>status</span><span>=</span><span>1</span>
May 02 <span>23</span>:34:57 iZbp156pkpio44mis76wmxZ systemd<span>[</span><span>1</span><span>]</span>: Failed to start LSB: Jenkins Automation Server.
May 02 <span>23</span>:34:57 iZbp156pkpio44mis76wmxZ systemd<span>[</span><span>1</span><span>]</span>: Unit jenkins.service entered failed state.
May 02 <span>23</span>:34:57 iZbp156pkpio44mis76wmxZ systemd<span>[</span><span>1</span><span>]</span>: jenkins.service failed.
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># </span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id="分析"> 分析；</h2>
<blockquote>
<p>通过上面的信息我们可以看到有一行： Starting Jenkins bash: /home/local/JDK/jdk1.8.0_251/bin/java: No such file or directory；</p>
<p>说明我们的jdk位置不对（这个是由于我自己手动移动过jdk的安装位置）</p>
</blockquote>
<h2 id="解决"> 解决；</h2>
<blockquote>
<p>查找我们的jdk安装位置，然后找到jenkins的配置文件修改jdk的指向路径；</p>
</blockquote>
<ol>
<li>
<p>查找jdk安装路径；</p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># find / -name java</span>
/etc/pki/java
/etc/pki/ca-trust/extracted/java
/home/local/webview/documents/view/backEnd/java
/home/local/application/jdk1.8.0_251/jre/bin/java
/home/local/application/jdk1.8.0_251/bin/java  <span># 我的jdk的安装路径</span>
/usr/java
<span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># </span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>
<p>很明显和我们刚刚报错给出的路径是不样的；</p>
</blockquote>
</li>
<li>
<p>修改jenkins的配置文件；</p>
<div><pre><code><span>[</span>root@iZbp156pkpio44mis76wmxZ /<span>]</span><span># cd etc/init.d/</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ init.d<span>]</span><span># vim jenkins </span>

<span># see http://www.nabble.com/guinea-pigs-wanted-----Hudson-RPM-for-RedHat-Linux-td25673707.html</span>
<span>candidates</span><span>=</span><span>"
/etc/alternatives/java
......省略

/usr/bin/java
/home/local/JDK/jdk1.8.0_251/bin/java # 修改为：/home/local/application/jdk1.8.0_251/bin/java
"</span>
<span>..</span><span>..</span><span>..</span>省略
<span>"jenkins"</span> 184L, 6484C 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div></li>
<li>
<p>保存并退出；</p>
</li>
<li>
<p>重启jenkins</p>
<div><pre><code><span># 重新加载</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ init.d<span>]</span><span># systemctl daemon-reload</span>
<span># 启动</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ init.d<span>]</span><span># systemctl start jenkins</span>
<span># 查看状态</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ init.d<span>]</span><span># systemctl status jenkins</span>
● jenkins.service - LSB: Jenkins Automation Server
   Loaded: loaded <span>(</span>/etc/rc.d/init.d/jenkins<span>;</span> bad<span>;</span> vendor preset: disabled<span>)</span>
   Active: active <span>(</span>running<span>)</span> since Mon <span>2021</span>-05-03 00:12:45 CST<span>;</span> 1min 31s ago
     Docs: man:systemd-sysv-generator<span>(</span><span>8</span><span>)</span>
   CGroup: /system.slice/jenkins.service
           └─31247 /home/local/application/jdk1.8.0_251/bin/java -Dcom.sun.akuma.Daemon<span>=</span>daemonized -Djav<span>..</span>.

May 03 00:12:45 iZbp156pkpio44mis76wmxZ systemd<span>[</span><span>1</span><span>]</span>: Starting LSB: Jenkins Automation Server<span>..</span>.
May 03 00:12:45 iZbp156pkpio44mis76wmxZ runuser<span>[</span><span>31233</span><span>]</span>: pam_unix<span>(</span>runuser:session<span>)</span>: session opened for<span>..</span>.<span>=</span><span>0</span><span>)</span>
May 03 00:12:45 iZbp156pkpio44mis76wmxZ jenkins<span>[</span><span>31228</span><span>]</span>: Starting Jenkins <span>[</span>  OK  <span>]</span>
May 03 00:12:45 iZbp156pkpio44mis76wmxZ systemd<span>[</span><span>1</span><span>]</span>: Started LSB: Jenkins Automation Server.
Hint: Some lines were ellipsized, use -l to show <span>in</span> full.
<span>[</span>root@iZbp156pkpio44mis76wmxZ init.d<span>]</span><span># </span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div></li>
<li>
<p>启动成功</p>
</li>
</ol>
<p><a href="https://www.freesion.com/article/1255771646/" target="_blank" rel="noopener noreferrer">阅读原文</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>mysql启动错误</title>
      <link>https://wangyawei.top/views/issues/issues-11/</link>
      <guid>https://wangyawei.top/views/issues/issues-11/</guid>
      <source url="https://wangyawei.top/rss.xml">mysql启动错误</source>
      <category>issues</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="can-t-start-server-can-t-check-pid-filepath-no-such-file-or-directory"> <code>Can't start server: can't check PID filepath: No such file or directory</code></h2>
<blockquote>
<p>我出现这种错误的原因是由于服务器强制关机，导致的。或许还有其他的情况导致的，在这里先记录一下。</p>
</blockquote>
<ol>
<li>
<p>出错原因： 一般是由于服务器强制关机导致pid文件丢失。</p>
</li>
<li>
<p>错误重现：</p>
<div><pre><code><span># 启动Mysql</span>
<span>service</span> mysqld start
<span># 错误信息： Can't connect to local MySQL server through socket '/var/lib/mysql/mysql.sock' (111)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>其实一开始的报错是上面这样的，但是在网上找不到确切的解决办法。</p>
</li>
<li>
<p>查看错误日志；</p>
<div><pre><code><span>cat</span> /var/log/mysqld.log
<span># 查看错误日志里面会有一句这样的错误信息；</span>
<span>[</span>ERROR<span>]</span> Can<span>'t start server: can'</span>t check PID filepath: No such <span>file</span> or directory
<span># 告诉我们没有PID文件或目录；</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></li>
<li>
<p>解决：</p>
<ol>
<li>
<p>在/etc/my.cnf 中查看pid-file的位置 ，</p>
<div><pre><code><span>cat</span> /etc/my.cnf
 
<span># 我的：pid-file=/var/run/mysqld/mysqld.pid</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
<li>
<p>创建对应的目录并修改权限 ，</p>
<div><pre><code><span>mkdir</span> -p /var/run/mysqld
<span>chown</span> mysql.mysql /var/run/mysqld
<span># 这时可以尝试重启mysql了，如果还不行继续第三步</span>

<span># 启动</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ mysql<span>]</span><span># service mysqld start</span>
Starting mysqld <span>(</span>via systemctl<span>)</span>:                           <span>[</span>  OK  <span>]</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ mysql<span>]</span><span>#</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></li>
<li>
<p>创建一个pid文件并修改权限 .</p>
<ul>
<li><strong>下面的这种的方式没有实践过</strong>。</li>
</ul>
<div><pre><code><span>touch</span> /var/run/mysql/mysqld.pid
<span>chown</span> mysql.mysql /var/run/mysql/mysqld.pid
<span># 再启动MySQL应该就没问题了。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></li>
</ol>
<p>原文地址：https://blog.csdn.net/qq_31977125/article/details/84318745</p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>failed to run command ‘java’ No such file or directory</title>
      <link>https://wangyawei.top/views/issues/issues-12/</link>
      <guid>https://wangyawei.top/views/issues/issues-12/</guid>
      <source url="https://wangyawei.top/rss.xml">failed to run command ‘java’ No such file or directory</source>
      <category>issues</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>场景：执行java包的时候；nohup java -jar xxx.jar 2 &gt;&amp;1 &amp;</p>
</blockquote>
<ol>
<li>
<p>分析；</p>
<div><pre><code><span># 查看JAVA_HOME 确认是否和自己的安装路径一样</span>
<span>echo</span> <span>$JAVA_HOME</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>本人的是 设置的环境变量和自己的安装路径不一样，</p>
</blockquote>
</li>
<li>
<p>解决；</p>
<div><pre><code><span># 编辑 profile 文件，并修改JAVA_HOME的变量值；</span>
<span>vim</span> /etc/profile
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>后台持续运行 java服务；</p>
<div><pre><code><span>nohup</span> java -jar customer.jar <span><span>1</span>>></span>/etc/null <span><span>2</span>></span> /etc/null $
</code></pre>
<div><span>1</span><br></div></div></li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>vue跨域解决方案</title>
      <link>https://wangyawei.top/views/issues/issues-13/</link>
      <guid>https://wangyawei.top/views/issues/issues-13/</guid>
      <source url="https://wangyawei.top/rss.xml">vue跨域解决方案</source>
      <category>issues</category>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="_1、问题概述"> 1、问题概述；</h2>
<blockquote>
<p>在项目中我们时常会遇到跨域，比如下面的这种情况；</p>
</blockquote>
<p><img src="./assets/1594785600774.png" alt="1594785600774" /></p>
<blockquote>
<p>注：项目的后台我是用<code>nodejs</code>写的；</p>
</blockquote>
<h2 id="_2、解决"> 2、解决；</h2>
<h3 id="_2-1、方法一"> 2-1、方法一；</h3>
<ul>
<li>
<p>就是直接在后台的代码里，添加 <code>Access-Control-Allow-Origin</code>响应头；<strong>前端无需任何配置</strong>；</p>
<div><pre><code><span>// response.header('Access-Control-Allow-Origin', "*")</span>
</code></pre>
<div><span>1</span><br></div></div><p><img src="./assets/1594785832204.png" alt="1594785832204" /></p>
</li>
</ul>
<h3 id="_2-2、方法二、"> 2-2、方法二、</h3>
<ul>
<li>
<p>利用<code>vue</code>的<code>proxy</code>代理，来解决跨域；</p>
<div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  devServer<span>:</span> <span>{</span>
    host<span>:</span> <span>'localhost'</span><span>,</span> <span>// 指定本地运行的ip</span>
    port<span>:</span> <span>8085</span><span>,</span> <span>// 自定义本地运行的端口</span>
    open<span>:</span> <span>true</span><span>,</span> <span>// 自动打开浏览器</span>
    proxy<span>:</span> <span>{</span>
      <span>// '/':为所有的请求都会被代理 若为 '/api'：则只有被匹配到的接口会被代理；</span>
      <span>'/api'</span><span>:</span> <span>{</span>
        target<span>:</span> <span>'http://47.114.139.71:3000'</span> <span>// 要代理的第三方接口地址</span>
        <span>/**
         * 路径重定向：可以不设置此值，下面的意思是：
         * 如果你的请求的路径是：http://localhost:8085/api/add
         * 那么被重定向后：http://47.114.139.71:3000/add
         */</span>
        pathRewrite<span>:</span> <span>{</span>
           <span>'^/api'</span><span>:</span> <span>''</span>
        <span>}</span>
      <span>}</span>
    <span>}</span>
  <span>}</span>
<span>}</span>
<span>// 设置`proxy`完毕后便可解决跨域；</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><blockquote>
<p>注：使用<code>proxy</code>代理解决跨域，则<code>axios</code>的默认基地址不能设置，否则不生效；</p>
</blockquote>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/other/</link>
      <guid>https://wangyawei.top/views/other/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>other</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里的内容自己没想清楚到底该归类到哪里，所以就索性直接放到其它好了，主要记录一些与技术无关的事情吧；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>博客园主题</title>
      <link>https://wangyawei.top/views/other/blogTheme/</link>
      <guid>https://wangyawei.top/views/other/blogTheme/</guid>
      <source url="https://wangyawei.top/rss.xml">博客园主题</source>
      <pubDate>Fri, 24 Sep 2021 17:25:21 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="博客主题"> 博客主题</h2>
<blockquote>
<p>无意中看到别人的主题是那么的好看，炸一看自己的主题好丑，所以就找了下，在这里记录下来。</p>
</blockquote>
<ol>
<li>
<p>下载<code>githup</code>源码，<a href="https://github.com/BNDong/Cnblogs-Theme-SimpleMemory" target="_blank" rel="noopener noreferrer">传送门</a>。</p>
<div><pre><code><span>git</span> clone https://github.com/BNDong/Cnblogs-Theme-SimpleMemory.git
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>登录博客园进入设置页面，</p>
</li>
<li>
<p>设置页面定制CSS代码。</p>
<ul>
<li>在克隆下来的项目中根据路径找到==base.min.css==，路径：<code>/src/style/base.min.css</code></li>
<li>拷贝此文件代码至<strong>页面定制CSS代码</strong>文本框处。</li>
<li>选中页面定制CSS代码文本框下面的禁用模板默认CSS。</li>
</ul>
</li>
<li>
<p>在侧边栏HTML代码中设置以下代码：</p>
<div><pre><code><span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>"</span>text/javascript<span>"</span></span><span>></span></span><span><span>
    window<span>.</span>cnblogsConfig <span>=</span> <span>{</span>
        GhVersions    <span>:</span> <span>'v1.3.3'</span><span>,</span> <span>// 版本</span>
        blogUser      <span>:</span> <span>"userName"</span><span>,</span> <span>// 用户名</span>
        blogAvatar    <span>:</span> <span>"https://xxxx.png"</span><span>,</span> <span>// 用户头像</span>
        blogStartDate <span>:</span> <span>"2016-11-17"</span><span>,</span> <span>// 入园时间，年-月-日。入园时间查看方法：鼠标停留园龄时间上，会显示入园时间</span>
    <span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>https://cdn.jsdelivr.net/gh/BNDong/Cnblogs-Theme-SimpleMemory@v1.3.3/src/script/simpleMemory.min.js<span>"</span></span> <span>defer</span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><blockquote>
<p>注意：引入的文件 simpleMemory.min.js 版本需要与配置 window.cnblogsConfig.GhVersions 一致！</p>
</blockquote>
</li>
<li>
<p>我的设置html设置：</p>
<div><pre><code><span><span><span>&lt;</span>script</span> <span>type</span><span><span>=</span><span>"</span>text/javascript<span>"</span></span><span>></span></span><span><span>
    window<span>.</span>cnblogsConfig <span>=</span> <span>{</span>
        GhVersions    <span>:</span> <span>'v1.3.3'</span><span>,</span> <span>// 版本</span>
        blogUser      <span>:</span> <span>"棉花糖"</span><span>,</span> <span>// 用户名</span>
        blogAvatar    <span>:</span> <span>"https://pic.cnblogs.com/face/1943640/20200220233654.png"</span><span>,</span> <span>// 用户头像</span>
        blogStartDate <span>:</span> <span>"2020-02-15"</span><span>,</span> <span>// 入园时间，年-月-日。入园时间查看方法：鼠标停留园龄时间上，会显示入园时间</span>
       essaySuffix<span>:</span> <span>{</span>
             aboutHtml<span>:</span> <span>"千里之行始于足下"</span><span>,</span>
       <span>}</span><span>,</span>
       essayCodeHighlightingType<span>:</span> <span>"highlightjs"</span><span>,</span>
       essayCodeHighlighting<span>:</span> <span>"an-old-hope"</span><span>,</span>
       codeLineNumber<span>:</span> <span>true</span><span>,</span>
       homeTopAnimation<span>:</span> <span>{</span>
             color   <span>:</span> <span>'random'</span><span>,</span>
       <span>}</span><span>,</span>
       essayTopImg<span>:</span> <span>[</span>
      <span>"https://images.cnblogs.com/cnblogs_com/ywnh/1651535/o_2101021010123572c8d948621b095a21f1c965fa514c.jpeg"</span><span>,</span>
      <span>"https://images.cnblogs.com/cnblogs_com/ywnh/1651535/o_210102102759QQ图片20170615224034.jpg"</span><span>,</span>
      <span>"https://images.cnblogs.com/cnblogs_com/ywnh/1651535/o_210102101045223c544afd087a6b995ac9bff1796173.jpeg"</span><span>,</span>
      <span>"https://images.cnblogs.com/cnblogs_com/ywnh/1651535/o_2101021042236c7f4475ac8380235d898d3e316aacd6.jpg"</span>
    <span>]</span><span>,</span>
    homeTopImg<span>:</span> <span>[</span>
      <span>"https://images.cnblogs.com/cnblogs_com/ywnh/1651535/o_210102103036qw.jpg"</span><span>,</span>
      <span>"https://images.cnblogs.com/cnblogs_com/ywnh/1651535/o_210102103211582930f5da76f77b187c0df7.jpg"</span><span>,</span>
      <span>"https://images.cnblogs.com/cnblogs_com/ywnh/1651535/o_2101021034485841e26e9a1aa37b1d8b0d91.jpg"</span><span>,</span>
      <span>"https://images.cnblogs.com/cnblogs_com/ywnh/1651535/o_210102103619580b100d94e5cc414f7a5bd5.jpg"</span><span>,</span>
      <span>"https://images.cnblogs.com/cnblogs_com/ywnh/1651535/o_2101021042565c0689edaefaac39a434f34716f392aa.jpg"</span>
    <span>]</span><span>,</span>
    <span>}</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;</span>script</span> <span>src</span><span><span>=</span><span>"</span>https://cdn.jsdelivr.net/gh/BNDong/Cnblogs-Theme-SimpleMemory@v1.3.3/src/script/simpleMemory.min.js<span>"</span></span> <span>defer</span><span>></span></span><span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div></li>
<li>
<p><code>1.0版本说明文档</code>https://bndong.github.io/Cnblogs-Theme-SimpleMemory/v1.0/#/</p>
</li>
<li>
<p>主题开发者：<a href="https://www.cnblogs.com/bndong/p/9132439.html" target="_blank" rel="noopener noreferrer">传送门</a></p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>什么是 wsl</title>
      <link>https://wangyawei.top/views/other/other-note-01/</link>
      <guid>https://wangyawei.top/views/other/other-note-01/</guid>
      <source url="https://wangyawei.top/rss.xml">什么是 wsl</source>
      <category>other</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>适用于 Linux 的 Windows 子系统可让开发人员直接在 Windows 上按原样运行 GNU/Linux 环境（包括大多数命令行工具、实用工具和应用程序），且不会产生传统虚拟机或双启动设置开销。</p>
</blockquote>
<p>您可以：</p>
<ul>
<li><a href="https://aka.ms/wslstore" target="_blank" rel="noopener noreferrer">在 Microsoft Store</a> 中选择你偏好的 GNU/Linux 分发版。</li>
<li>运行常用的命令行软件工具（例如 <code>grep</code>、<code>sed</code>、<code>awk</code>）或其他 ELF-64 二进制文件。</li>
<li>运行 Bash shell 脚本和 GNU/Linux 命令行应用程序，包括：
<ul>
<li>工具：vim、emacs、tmux</li>
<li>语言：<a href="https://docs.microsoft.com/zh-cn/windows/nodejs/setup-on-wsl2" target="_blank" rel="noopener noreferrer">NodeJS</a>、Javascript、<a href="https://docs.microsoft.com/zh-cn/windows/python/web-frameworks" target="_blank" rel="noopener noreferrer">Python</a>、Ruby、C/ C++、C# 与 F#、Rust、Go 等。</li>
<li>服务：SSHD、<a href="https://docs.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-database" target="_blank" rel="noopener noreferrer">MySQL</a>、Apache、lighttpd、<a href="https://docs.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-database" target="_blank" rel="noopener noreferrer">MongoDB</a>、<a href="https://docs.microsoft.com/zh-cn/windows/wsl/tutorials/wsl-database" target="_blank" rel="noopener noreferrer">PostgreSQL</a>。</li>
</ul>
</li>
<li>使用自己的 GNU/Linux 分发包管理器安装其他软件。</li>
<li>使用类似于 Unix 的命令行 shell 调用 Windows 应用程序。</li>
<li>在 Windows 上调用 GNU/Linux 应用程序。</li>
</ul>
<h2 id="安装"> 安装；</h2>
<blockquote>
<p>需要先启用“适用于 Linux 的 Windows 子系统”可选功能，然后才能在 Windows 上安装 Linux 分发。这里安装 <code>wsl2</code>为例；</p>
</blockquote>
<ol>
<li>
<p>以管理员身份打开 PowerShell 并运行;</p>
<div><pre><code>dism.exe /online /enable-feature /featurename:Microsoft-Windows-Subsystem-Linux /all /norestart
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p>必须启用“虚拟机平台”可选功能。</p>
<div><pre><code>dism.exe /online /enable-feature /featurename:VirtualMachinePlatform /all /norestart
</code></pre>
<div><span>1</span><br></div></div></li>
<li>
<p><strong>重新启动</strong> 计算机，安装完成；</p>
</li>
<li>
<p>下载 Linux <a href="https://wslstorestorage.blob.core.windows.net/wslblob/wsl_update_x64.msi" target="_blank" rel="noopener noreferrer">内核更新包</a>：</p>
</li>
<li>
<p>安装所选的 Linux 分发；</p>
<ul>
<li>打开 <a href="https://aka.ms/wslstore" target="_blank" rel="noopener noreferrer">Microsoft Store</a>，并选择你偏好的 Linux 分发版。</li>
<li>在分发版的页面中，选择“获取”。</li>
<li>首次启动新安装的 Linux 分发版时，将打开一个控制台窗口，系统会要求你等待一分钟或两分钟，以便文件解压缩并存储到电脑上。 未来的所有启动时间应不到一秒。</li>
<li>然后，需要<a href="https://docs.microsoft.com/zh-cn/windows/wsl/user-support" target="_blank" rel="noopener noreferrer">为新的 Linux 分发版创建用户帐户和密码</a>。</li>
<li><strong>祝贺你！现已成功安装并设置了与 Windows 操作系统完全集成的 Linux 分发！</strong></li>
</ul>
</li>
<li>
<p>点击【开始】点击【ubantu】，即启动ubantu终端命令，现在你可以做任何事情了例：安装nginx mysql等；</p>
</li>
</ol>
<p><a href="https://docs.microsoft.com/zh-cn/windows/wsl/" target="_blank" rel="noopener noreferrer">官方文档</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>win10 使用hyper-v</title>
      <link>https://wangyawei.top/views/other/other-note-02/</link>
      <guid>https://wangyawei.top/views/other/other-note-02/</guid>
      <source url="https://wangyawei.top/rss.xml">win10 使用hyper-v</source>
      <category>other</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>Hyper-V 提供硬件虚拟化，Hyper-V 可以让你在 Windows 上以虚拟机形式<strong>运行多个完全独立的操作系统</strong>，其中包括各种版本的 Linux、FreeBSD 和 Windows。这意味着每个虚拟机都在虚拟硬件上运行。 Hyper-V 允许你创建虚拟硬盘驱动器、虚拟交换机以及许多其他虚拟设备，所有这些都可以添加到虚拟机中。Windows 上的 Hyper-V 支持虚拟机中的许多不同操作系统，</p>
</blockquote>
<h2 id="使用虚拟化的原因"> 使用虚拟化的原因</h2>
<p>虚拟化允许你：</p>
<ul>
<li>运行需要早期版本的 Windows 操作系统或非 Windows 操作系统的软件。</li>
<li>实验其他操作系统。 通过 Hyper-V，可轻松创建和删除不同的操作系统。</li>
<li>使用多个虚拟机在多个操作系统上测试软件。 通过 Hyper-V，可以在一部台式机或便携式计算机上运行所有内容。 可以将这些虚拟机导出并随后导入到任何其他 Hyper-V 系统中，包括 Azure。</li>
</ul>
<blockquote>
<p>Hyper-V 可用于 64 位 Windows 10 专业版、企业版和教育版。 <strong>它无法用于家庭版。</strong></p>
</blockquote>
<p>本人电脑信息；
<img src="./assets/image-20210605195931476.png" alt="image-20210605195931476.png" /></p>
<h2 id="安装-hyper-v"> 安装 Hyper-V</h2>
<blockquote>
<p>启用 Hyper-V 以在 Windows 10 上创建虚拟机。可以通过多种方式启用 Hyper-V，包括使用 Windows 10 控制面板、PowerShell 或使用部署映像服务和管理工具 (DISM)。<strong>要求：Windows 10 企业版、专业版或教育版</strong></p>
</blockquote>
<div><p>提示</p>
<p>Hyper-V 作为可选功能内置于 Windows -- 无需下载 Hyper-V。</p>
<p><strong>请勿</strong>在 Windows 10 家庭版上安装 Hyper-V 角色。</p>
</div>
<h3 id="通过-设置-启用-hyper-v-角色"> 通过“设置”启用 Hyper-V 角色</h3>
<ol>
<li>右键单击 Windows 按钮并选择“应用和功能”。</li>
<li>选择相关设置下右侧的“程序和功能”。</li>
<li>选择“<strong>打开或关闭 Windows 功能</strong>”。</li>
<li>选择“<strong>Hyper-V</strong>”，然后单击“<strong>确定</strong>”。
<img src="./assets/image-20210605192832984.png" alt="image-20210605192832984" /></li>
</ol>
<p>安装完成后，系统会提示你重启计算机。</p>
<h2 id="创建虚拟机"> 创建虚拟机</h2>
<blockquote>
<p>Windows 10 版本 1709 及更高版本；</p>
</blockquote>
<ol>
<li></li>
<li>
<p><img src="./assets/image-20210605193207701.png" alt="image-20210605193207701" /></p>
</li>
<li>
<p>选择一个操作系统或者或使用本地安装源选择你自己的操作系统。
<img src="./assets/image-20210605193404834.png" alt="image-20210605193404834" /></p>
</li>
<li>
<p>点击创建虚拟机；
<img src="./assets/image-20210605193726004.png" alt="image-20210605193726004" />
<img src="./assets/image-20210605194332608.png" alt="image-20210605194332608" />
<img src="./assets/image-20210605194423030.png" alt="image-20210605194423030" /></p>
<p>点击启动然后，跟着提示，一直往下走，
<img src="./assets/image-20210605195045957.png" alt="image-20210605195045957" /></p>
<p>恭喜你，ubantu系统虚拟机创建成功；</p>
</li>
</ol>
<p><a href="https://docs.microsoft.com/zh-cn/virtualization/hyper-v-on-windows/quick-start/quick-create-virtual-machine" target="_blank" rel="noopener noreferrer">官方文档</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>使用hyper-v管理虚拟机</title>
      <link>https://wangyawei.top/views/other/other-note-03/</link>
      <guid>https://wangyawei.top/views/other/other-note-03/</guid>
      <source url="https://wangyawei.top/rss.xml">使用hyper-v管理虚拟机</source>
      <category>other</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>当我们创建多个虚拟主机的时候，很显然我们不方便管理，那么win给我们提供了hyper-v管理虚拟机;</p>
</blockquote>
<ol>
<li>
<p>从“开始”菜单中打开“Hyper-V 管理器”。
<img src="./assets/image-20210605193207701.png" alt="image-20210605193207701" /></p>
</li>
<li>
<p>查看自己创建的虚拟主机；这里我创建了三个，你也可以点击右侧菜单的【快速创建】来创建一个虚拟主机；
<img src="./assets/image-20210605200806038.png" alt="image-20210605200806038" /></p>
</li>
<li>
<p>启动；可以直接双击启动，也可以选中后，点击启动命令启动；
<img src="./assets/image-20210605200919889.png" alt="image-20210605200919889" /></p>
</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>wsl与hyper的关系</title>
      <link>https://wangyawei.top/views/other/other-note-04/</link>
      <guid>https://wangyawei.top/views/other/other-note-04/</guid>
      <source url="https://wangyawei.top/rss.xml">wsl与hyper的关系</source>
      <category>other</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<ol>
<li>HyperV是一个真正的虚拟机，有完整的硬件模拟，能把整个完整的linux塞进去;</li>
<li>最新版本（wsl2）的 WSL 使用 Hyper-V 体系结构来实现其虚拟化。 此体系结构将在“虚拟机平台”可选组件中提供。</li>
<li>wsl主要是一种面向开发人员的工具，尤其是 web 开发人员、在开源项目中工作或部署到 Linux 服务器环境的工具。WSL 使你能够使用选择的分发 (Ubuntu、Debian、OpenSUSE、Kali、Alpine 等) 在 Bash shell 中运行 Linux。 使用 Bash 可以运行命令行 Linux 工具和应用。</li>
</ol>
]]></content:encoded>
    </item>
    <item>
      <title>wind终端添加右键菜单</title>
      <link>https://wangyawei.top/views/other/other-note-05/</link>
      <guid>https://wangyawei.top/views/other/other-note-05/</guid>
      <source url="https://wangyawei.top/rss.xml">wind终端添加右键菜单</source>
      <category>other</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<ol>
<li>
<p>检查常量;</p>
<div><pre><code><span># 正常会打印 C:\Users\[username]</span>
<span>echo</span> %USERPROFILE%

<span># 正常会打印 C:\Users\[username]\AppData\Local</span>
<span>echo</span> %LOCALAPPDATA%
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></li>
<li>
<p>获取图标；主要是右键的时候可以显示一个图标而已，自己选择；</p>
<ul>
<li>
<p>新建文件夹；<code>Terminal</code>;</p>
<div><pre><code><span># 如果你创建不了文件夹，那就自己手动创建一个；例：C:\Users\[username]\AppData\Local\Terminal</span>
<span>mkdir</span> <span>"%USERPROFILE%\AppData\Local\Terminal"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p><a href="https://gitee.com/Jioho/img/raw/master/wsl/terminal.ico" target="_blank" rel="noopener noreferrer">下载图标</a></p>
</li>
<li>
<p>把图片放入你创建的文件中；</p>
</li>
</ul>
</li>
<li>
<p>新建文件，内容如下;</p>
<div><pre><code>@echo off

 reg.exe <span>add</span> <span>"HKEY_CLASSES_ROOT\Directory\Background\shell\wt"</span> /f /ve /d <span>"Windows Terminal here"</span>
 reg.exe <span>add</span> <span>"HKEY_CLASSES_ROOT\Directory\Background\shell\wt"</span> /f /v <span>"Icon"</span> /t REG_EXPAND_SZ /d <span>"%USERPROFILE%\AppData\Local\Terminal<span title="\t">\t</span>erminal.ico"</span>
 reg.exe <span>add</span> <span>"HKEY_CLASSES_ROOT\Directory\Background\shell\wt<span title="\c">\c</span>ommand"</span> /f /ve /t REG_EXPAND_SZ /d "%LOCALAPPDATA%<span>\</span>Microsoft<span>\</span>WindowsApps<span>\</span>wt.exe
 
 pause
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><blockquote>
<p>步骤一不打印时：</p>
<ol>
<li>%USERPROFILE%：修改为：<code>C:\Users\[username]</code>;</li>
<li>%LOCALAPPDATA%: 修改为：<code>C:\Users\[username]\AppData\Local\</code></li>
</ol>
</blockquote>
</li>
<li>
<p>保存文件，并修改文件名为：xx.bat</p>
</li>
<li>
<p>双击执行文件；</p>
</li>
<li>
<p>检查右键菜单；</p>
</li>
<li>
<p>当前文件夹内启动终端定位到，文件夹位置；</p>
<ul>
<li>打开设置文件；</li>
<li>修改配置信息；</li>
</ul>
<div><pre><code> .....
<span>"profiles"</span><span>:</span> 
    <span>{</span>
        <span>"defaults"</span><span>:</span> <span>{</span><span>}</span><span>,</span>
        <span>"list"</span><span>:</span> 
        <span>[</span>
            <span>{</span>
                <span>"commandline"</span><span>:</span> <span>"powershell.exe"</span><span>,</span>
                <span>"guid"</span><span>:</span> <span>"{61c54bbd-c2c6-5271-96e7-009a87ff44bf}"</span><span>,</span>
                <span>"hidden"</span><span>:</span> <span>false</span><span>,</span>
                <span>"name"</span><span>:</span> <span>"Windows PowerShell"</span><span>,</span>
					 <span>"startingDirectory"</span><span>:</span> <span>null</span>   <span>// 添加此项</span>
            <span>}</span><span>,</span>
......
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div></li>
<li>
<p>注册表位置：计算机\HKEY_CLASSES_ROOT\Directory\background\shell\wt</p>
</li>
</ol>
<p>原文链接：</p>
<p>https://blog.csdn.net/Jioho_chen/article/details/101159291</p>
<p>https://blog.csdn.net/willingtolove/article/details/109167629</p>
]]></content:encoded>
    </item>
    <item>
      <title>win终端添加gitBash</title>
      <link>https://wangyawei.top/views/other/other-note-06/</link>
      <guid>https://wangyawei.top/views/other/other-note-06/</guid>
      <source url="https://wangyawei.top/rss.xml">win终端添加gitBash</source>
      <category>other</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<ol>
<li>
<p>打开windows terminal;</p>
</li>
<li>
<p>点击设置;</p>
</li>
<li>
<p>打开JSON文件，修改配置；</p>
<ul>
<li>找到 <code>profiles–&gt;list</code></li>
</ul>
<div><pre><code><span>{</span>
	<span>"commandline"</span> <span>:</span> <span>"C:\\Program Files\\Git\\bin\\bash.exe"</span>                <span>,</span>
	<span>"guid"</span> <span>:</span> <span>"{f263b0f3-4e4d-d630-298c-605384d8fa48}"</span><span>,</span>
	<span>"icon"</span> <span>:</span> <span>"C:\\Program Files\\Git\\mingw64\\share\\git\\git-for-windows.ico"</span><span>,</span>
	<span>"name"</span> <span>:</span> <span>"Git Bash"</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></li>
</ol>
<p><a href="https://blog.csdn.net/qq754772661/article/details/112829606" target="_blank" rel="noopener noreferrer">原文链接</a></p>
]]></content:encoded>
    </item>
    <item>
      <title>linux与window分隔符问题</title>
      <link>https://wangyawei.top/views/other/other-note-07/</link>
      <guid>https://wangyawei.top/views/other/other-note-07/</guid>
      <source url="https://wangyawei.top/rss.xml">linux与window分隔符问题</source>
      <category>other</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>遇到这个问题还是由于前端使用nodejs压缩打包文件，然后上传到linux服务器上，本想着解压完成就完事了，结果没那么简单。</p>
</blockquote>
<h2 id="历史由来"> 历史由来：</h2>
<blockquote>
<p>Windows 用反斜杠（“\”）的历史来自 DOS，而 DOS 的另一个传统是用斜杠（“/”）表示命令行参数，比如：
cd %SystemDrive% dir /s /b shell32.dll。而在 UNIX 环境中，我们用减号（“-”）和双减号（“--”）表示命令行参数。 用斜杠表示命令行参数是兼容性原因。这个问题最初起源自 IBM。IBM 在最初加入 DOS 开发时贡献了大批工具，它们都是用斜杠处理命令行参数的。而这个传统源自于 DEC/IBM，比如当年的 VMS 就是用斜杠处理命令行参数，它的目录分隔符是美元符（“$”）。顺便说一句，这个传统也被部分地继承进了 DOS 和 Windows 体系，日文版的 Windows 就把反斜杠在屏幕上显示为“¥”，虽然实际上还是反斜杠。
<strong>如今的 Windows 内核在处理路径时确实可以同时支持斜杠和反斜杠</strong>。很多时候我们看到用斜杠时出错，是因为应用程序层面的原因。比如 cmd.exe 就不支持用斜杠表示路径，而PowerShell.exe 支持，也正因为这个原因，PowerShell 开始转而使用减号作为命令行参数的起始符。</p>
</blockquote>
<h2 id="问题由来"> <strong>问题由来:</strong></h2>
<p>我使用的Nodejs的<code>jszip</code>第三方包，来压缩我的静态资源，文件确实可以压缩，也可以正常打开，一点问题没有。但是上传到服务器上的解压缩的时候就有问题了，见下图：</p>
<p><img src="./assets/image-20210613234930301.png" alt="image-20210613234930301" /></p>
<p><img src="./assets/image-20210613235038819.png" alt="image-20210613235038819" /></p>
<p>很显然路径出错了，瞬间懵逼了，不过当我尝试直接修改文件名的时候，也就是把<code>\</code>修改为<code>/</code>，结果是正常的，文件夹会自动分层。这样问题就更加清楚了。</p>
<h2 id="解决方案"> <strong>解决方案：</strong></h2>
<blockquote>
<p>在我们进行压缩的时候直接把需要用到的文件路径中的<code>\</code>替换为<code>/</code>就好了。</p>
</blockquote>
<p><strong>nodeejs官方说明；</strong></p>
<blockquote>
<p>The default operation of the <code>path</code> module varies based on the operating system on which a Node.js application is running. Specifically, when running on a Windows operating system, the <code>path</code> module will assume that Windows-style paths are being used.</p>
</blockquote>
<p>可以看到在Node下默认的路径是与操作系统保持一致的，因此出现了 <code>\</code>。为了要获取到符合 <code>/</code> 格式的路径，我们可以使用 <code>PATH</code> 模块提供的 <code>path.sep</code> <a href="https://link.zhihu.com/?target=https%3A//nodejs.org/dist/latest-v12.x/docs/api/path.html%23path_path_sep" target="_blank" rel="noopener noreferrer">接口</a>进行字符串匹配截取，接口会根据系统环境的不同进行匹配截取。</p>
<p>例：</p>
<div><pre><code><span># window</span>
PS E:<span>\</span>documents<span>></span> node
Welcome to Node.js v12.20.0.
Type <span>".help"</span> <span>for</span> <span>more</span> information.
<span>></span> <span>'foo\\bar\\baz'</span>.split<span>(</span>path.sep<span>)</span><span>;</span>
<span>[</span> <span>'foo'</span>, <span>'bar'</span>, <span>'baz'</span> <span>]</span>
<span>></span>

<span># linux</span>
<span>[</span>root@iZbp156pkpio44mis76wmxZ documents<span>]</span><span># node</span>
Welcome to Node.js v12.18.2.
Type <span>".help"</span> <span>for</span> <span>more</span> information.
<span>></span> <span>'foo/bar/baz'</span>.split<span>(</span>path.sep<span>)</span><span>;</span>
<span>[</span> <span>'foo'</span>, <span>'bar'</span>, <span>'baz'</span> <span>]</span>
<span>></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="参考链接"> 参考链接；</h3>
<p>https://zhuanlan.zhihu.com/p/115746564</p>
]]></content:encoded>
    </item>
    <item>
      <title>介绍</title>
      <link>https://wangyawei.top/views/tools/git/</link>
      <guid>https://wangyawei.top/views/tools/git/</guid>
      <source url="https://wangyawei.top/rss.xml">介绍</source>
      <category>GIT</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>这里主要记录一些自己平时学习<strong>git</strong>的一些相关的知识；</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>git基础</title>
      <link>https://wangyawei.top/views/tools/git/git-note-00/</link>
      <guid>https://wangyawei.top/views/tools/git/git-note-00/</guid>
      <source url="https://wangyawei.top/rss.xml">git基础</source>
      <category>GIT</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h4 id="集中式"> 集中式</h4>
<ul>
<li>
<p>集中式版本控制系统，版本库是集中存放在中央服务器的，而干活的时候，用的都是自己的电脑，所以要先从中央服务器取得最新的版本，然后开始干活，干完活了，再把自己的活推送给中央服务器。</p>
</li>
<li>
<p>集中式版本控制系统最大的毛病就是必须联网才能工作。</p>
</li>
<li>
<p>集中式版本管理的代表：</p>
<ul>
<li>SVN（Subversion）</li>
</ul>
</li>
</ul>
<h4 id="分布式"> 分布式；</h4>
<ul>
<li>分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库。
<ul>
<li>比方说你在自己电脑上改了文件A，你的同事也在他的电脑上改了文件A，这时，你们俩之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。</li>
</ul>
</li>
<li>和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多。</li>
<li>分布式版本控制系统通常也有一台充当“中央服务器”的电脑，其作用仅仅是用来方便“交换”大家的修改。</li>
</ul>
<h2 id="资源连接"> 资源连接</h2>
<ul>
<li><a href="https://git-scm.com/" target="_blank" rel="noopener noreferrer">Git 官网</a></li>
<li><a href="https://git-scm.com/docs" target="_blank" rel="noopener noreferrer">官方文档</a></li>
<li><a href="https://github.github.com/training-kit/downloads/github-git-cheat-sheet.pdf" target="_blank" rel="noopener noreferrer">GitHub Cheat Sheet</a></li>
<li><a href="http://ndpsoftware.com/git-cheatsheet.html" target="_blank" rel="noopener noreferrer">Visual Git Cheat Sheet</a></li>
<li><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener noreferrer">一个国人写的Git 教程</a></li>
<li><strong><a href="https://git-scm.com/book/zh/v2" target="_blank" rel="noopener noreferrer">Pro Git</a></strong></li>
<li><a href="https://backlog.com/git-tutorial/cn/" target="_blank" rel="noopener noreferrer">猴子都能懂得 GIT 入门</a></li>
<li><a href="https://rogerdudler.github.io/git-guide/index.zh.html" target="_blank" rel="noopener noreferrer">git 简明指南</a></li>
<li>...</li>
</ul>
<h2 id="安装-git"> 安装 Git</h2>
<ul>
<li>下载地址：https://git-scm.com/downloads</li>
<li>安装
<ul>
<li>一路next安装即可。</li>
</ul>
</li>
</ul>
<p>在命令行中输入以下命令查看 Git 是否安装成功。</p>
<div><pre><code>$ <span>git</span> --version

<span># 如果看到类似 git version 2.21.0.windows.1 ，表示安装成功了</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="git三种区域及工作流程"> Git三种区域及工作流程</h2>
<ul>
<li>工作目录
<ul>
<li>工作目录是对项目的某个版本独立提取出来的内容。 这些从 Git 仓库的压缩数据库中提取出来的文件，放在磁盘上供你使用或修改。</li>
</ul>
</li>
<li>暂存区域
<ul>
<li>暂存区域是一个文件，保存了下次将提交的文件列表信息，一般在 Git 仓库目录中。 有时候也被称作`‘索引’'，不过一般说法还是叫暂存区域。</li>
</ul>
</li>
<li>Git 仓库
<ul>
<li>Git 仓库目录是 Git 用来保存项目的原数据和对象数据库的地方。 这是 Git 中最重要的部分，从其它计算机克隆仓库时，拷贝的就是这里的数据。</li>
</ul>
</li>
</ul>
<blockquote>
<p>注：工作区新建的文件和Git没有任何关系；文件被添加到暂存区，才叫做被Git管理过代码不能越过暂存区而直		接从工作区提交到仓库区；</p>
</blockquote>
<h2 id="使用git管理自己的代码"> 使用Git管理自己的代码</h2>
<ul>
<li>在你写代码的文件夹，右键，选择 <code>Git Bash Here</code> ，这个写代码文件夹就是工作区</li>
<li>在弹出的黑色窗口中，执行 <code>git init</code> ，进行初始化
<ul>
<li>初始化之后，会在当前目录生成一个隐藏文件 <code>.git</code></li>
</ul>
</li>
<li>然后就可以新建文件写代码了，此时文件在工作区</li>
<li>在黑色窗口中，执行 <code>git add 文件名称</code> ，表示将工作区的文件添加到暂存区</li>
<li>在黑色窗口中，执行 <code>git commit -m &quot;提交日志&quot;</code> ，表示将暂存区的文件提交到仓库</li>
</ul>
<blockquote>
<p>注：初次使用Git，会让我们配置用户的信息，配置方式如下：</p>
</blockquote>
<div><pre><code><span># --global 会将配置项保存到用户配置</span>
$ <span>git</span> config --global user.name <span>"xxx"</span>
$ <span>git</span> config --global user.email <span>"xxx"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果没有这个提示，是因为你之前已经使用过并配置过Git了。如果想恢复到初始的状态，我们可以打开Git的配置文件（C:\Users\你的用户名\.gitconfig），将[user]信息删除掉。</p>
<p>使用的命令如下：</p>
<div><pre><code><span># 初始化 git 仓库</span>
$ <span>git</span> init

<span># 将工作区的文件添加到暂存区</span>
$ <span>git</span> <span>add</span> 文件名

<span># 提交暂存区到仓库区形成历史记录</span>
$ <span>git</span> commit -m <span>"提交日志"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="文件的状态"> 文件的状态</h3>
<p>执行 <code>git status</code> 命令，可以查看到文件的状态</p>
<ul>
<li>未跟踪</li>
<li>已暂存</li>
<li>已修改</li>
<li>已提交（没有提示）</li>
</ul>
<p><strong>未跟踪（Untracked files）</strong>，表示还没有被 Git 管理过，既没有进入过暂存区，更没有进入过仓库区。</p>
<p><img src="./assets/1566700991061.png" alt="1566700991061" /></p>
<p><strong>已暂存（staged）</strong>，表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中</p>
<p><img src="./assets/1566701129660.png" alt="1566701129660" /></p>
<p>已修改（modified），文件被添加到暂存区，但是没有提交到仓库，然后在工作区对文件进行了修改。</p>
<p><img src="./assets/1566701786300.png" alt="1566701786300" /></p>
<p>已提交（committed），表示数据已经安全的保存在本地数据库中。</p>
<p><img src="./assets/1563869484112.png" alt="1563869484112" /></p>
<h3 id="添加文件到暂存区"> 添加文件到暂存区</h3>
<div><pre><code><span># 添加指定文件到暂存区</span>
$ <span>git</span> <span>add</span> 文件名

<span># 以空格隔开可以一次 add 多个文件</span>
$ <span>git</span> <span>add</span> <span>[</span>file1<span>]</span> <span>[</span>file2<span>]</span> <span>..</span>.

<span># 添加指定目录到暂存区，包括子目录</span>
$ <span>git</span> <span>add</span> <span>[</span>dir<span>]</span> <span>[</span>file<span>]</span> <span>[</span>dir<span>]</span> <span>[</span>file<span>]</span> <span>[</span>file<span>]</span> <span>..</span>.

<span># 添加当前目录的所有文件到暂存区，包括子目录</span>
$ <span>git</span> <span>add</span> <span>.</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="提交文件到仓库"> 提交文件到仓库</h3>
<div><pre><code><span># 提交暂存区到仓库区</span>
$ <span>git</span> commit -m <span>[</span>message<span>]</span>

<span># 提交暂存区的指定文件到仓库区</span>
$ <span>git</span> commit <span>[</span>file1<span>]</span> <span>[</span>file2<span>]</span> <span>..</span>. -m <span>[</span>message<span>]</span>

<span># 提交工作区和暂存区自上次commit之后的变化，直接到仓库区</span>
<span># 注意：不包括未跟踪文件，即不包含没有被GIt管理过的文件</span>
$ <span>git</span> commit -a -m <span>"提交日志"</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="查看状态"> 查看状态</h3>
<div><pre><code><span># 最好用的是 gitk</span>
$ gitk

<span># 显示有变更的文件</span>
$ <span>git</span> status

<span># 显示当前分支的版本历史</span>
$ <span>git</span> log

<span># 简略查看历史版本</span>
$ <span>git</span> log --oneline

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><img src="./assets/1566705494327.png" alt="1566705494327" /></p>
<h3 id="撤销操作"> 撤销操作</h3>
<div><pre><code><span># 恢复暂存区的指定文件到工作区</span>
$ <span>git</span> checkout <span>[</span>file<span>]</span>

<span># 恢复暂存区的所有文件到工作区</span>
$ <span>git</span> checkout <span>.</span>

<span># 恢复某个commit的指定文件到暂存区和工作区</span>
$ <span>git</span> checkout <span>[</span>commit版本号<span>]</span> <span>[</span>file<span>]</span>

<span># 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变</span>
$ <span>git</span> reset <span>[</span>file<span>]</span>

<span># 重置暂存区与工作区，与上一次commit保持一致</span>
$ <span>git</span> reset --hard

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h2 id="分支"> 分支</h2>
<h3 id="分支的新建与合并"> 分支的新建与合并</h3>
<p>你已经知道，每次提交，Git都把它们串成一条时间线，这条时间线就是一个分支。截止到目前，只有一条时间线，在Git里，这个分支叫主分支，即 <code>master</code> 分支。</p>
<p><code>HEAD</code> 可以理解为一个指针，指针指向哪里，就表示当前正在这里开发。所以，<code>HEAD</code> 指向的就是当前分支。</p>
<p>一开始的时候，<code>master</code>分支是一条线，Git 用 <code>master</code> 指向最新的提交，再用 <code>HEAD</code> 指向 <code>master</code>，就能确定当前分支，以及当前分支的提交点：</p>
<p><img src="./assets/0-1560036977779.png" alt="git-br-initial" /></p>
<p>每次提交，<code>master</code> 分支都会向前移动一步，这样，随着你不断提交，<code>master</code> 分支的线也越来越长。</p>
<p>当我们创建新的分支，例如 <code>dev</code> 时，Git 新建了一个指针叫 <code>dev</code>，指向 <code>master</code> 相同的提交，再把 <code>HEAD</code> 指向 <code>dev</code>，就表示当前分支在 <code>dev</code> 上：</p>
<p><img src="./assets/0-1560036977789.png" alt="git-br-create" /></p>
<p>你看，Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化！</p>
<p>不过，从现在开始，对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p>
<p><img src="./assets/0-1560036977801.png" alt="git-br-dev-fd" /></p>
<p>假如我们在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并呢？最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p>
<p><img src="./assets/0-1560036977763.png" alt="git-br-ff-merge" /></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后，我们就剩下了一条<code>master</code>分支：</p>
<p><img src="./assets/0-1560036977771.png" alt="git-br-rm" /></p>
<p>真是太神奇了，你看得出来有些提交是通过分支完成的吗？</p>
<p>下面开始实战。</p>
<p>首先，我们创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p>
<div><pre><code><span># 创建一个分支，名字叫做dev</span>
$ <span>git</span> branch dev

<span># 切换分支命令；切换到dev分支上</span>
$ <span>git</span> checkout dev

<span># 也可以使用下面的命令，代替上面两个命令；下面的命令表示创建并切换分支到dev上</span>
$ <span>git</span> checkout -b dev

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>可以用 <code>git branch</code> 命令查看当前分支，命令如下：</p>
<div><pre><code>$ <span>git</span> branch
<span># 会看到类似下面的结果，前面标注*的，表示当前分支</span>
<span># * dev</span>
<span>#   master</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>git branch</code> 命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p>
<p>然后，我们就可以在 <code>dev</code> 分支上进行开发了，比如增加或改动几个文件</p>
<p>然后提交</p>
<p>现在，<code>dev</code> 分支的工作完成，我们就可以切换回 <code>master</code> 分支：</p>
<div><pre><code>$ <span>git</span> checkout master
</code></pre>
<div><span>1</span><br></div></div><p>我们把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p>
<div><pre><code>$ <span>git</span> merge dev
</code></pre>
<div><span>1</span><br></div></div><p><code>git merge</code>命令用于合并指定分支到当前分支。</p>
<p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p>
<div><pre><code>$ <span>git</span> branch -d dev
</code></pre>
<div><span>1</span><br></div></div><p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p>
<div><pre><code>$ <span>git</span> branch
* master
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>因为创建、合并和删除分支非常快，所以Git鼓励你使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p>
<p><strong>小结：</strong></p>
<p>Git鼓励大量使用分支：</p>
<div><pre><code><span># 查看分支</span>
<span>git</span> branch

<span># 创建分支</span>
$ <span>git</span> branch <span>&lt;</span>name<span>></span>

<span># 切换分支</span>
$ <span>git</span> checkout <span>&lt;</span>name<span>></span>

<span># 创建+切换分支</span>
$ <span>git</span> checkout -b <span>&lt;</span>name<span>></span>

<span># 合并某分支到当前分支</span>
$ <span>git</span> merge <span>&lt;</span>name<span>></span>

<span># 删除分支</span>
$ <span>git</span> branch -d <span>&lt;</span>name<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="合并分支"> 合并分支</h3>
<h4 id="快进模式合并"> 快进模式合并</h4>
<p>如果 dev 分支包含 master 分支最新提交，那么当你合并 dev 到 master 的时候，会执行快进模式合并</p>
<p>快速模块就是直接指向最新提交</p>
<h4 id="合并模式提交"> 合并模式提交</h4>
<p>如果两个分支都进行了新的提交，那么在合并的时候就执行合并模式，Git 会自动将两个分支的不同提交的改动尝试自动合并，如果合并的过程没有冲突，则直接进入 bi 编辑模式让你输入提交日志完成合并提交。</p>
<p>合并模式会生成一次新的提交记录。</p>
<p>合并的时候，如果出现下面的画面：</p>
<p><img src="./assets/1563873852307.png" alt="1563873852307" /></p>
<h3 id="解决冲突"> 解决冲突</h3>
<p>如果在合并分支的时候，产生了冲突，则需要解决冲突</p>
<p>如果产生冲突，会在合并代码的时候，给出提示：</p>
<p><img src="./assets/1563853287184.png" alt="1563853287184" /></p>
<p>当前显示aa.js有冲突，在代码中，会看到：</p>
<p><img src="./assets/1563874529679.png" alt="1563874529679" /></p>
<p>把写master分支和dev分支的两个程序员叫到一起，一起研究并解决冲突。比如经过两个程序员的讨论，决定两个改动都保留，则删除提示：</p>
<p><img src="./assets/1563874667997.png" alt="1563874667997" /></p>
<p>最后回到命令行窗口，执行add和commit提交即可。</p>
<p><img src="./assets/1563853529228.png" alt="1563853529228" /></p>
<h2 id="远程仓库"> 远程仓库</h2>
<p>除了GitHib，还有很多第三方远程仓库托管服务：</p>
<ul>
<li>GitHub</li>
<li>码云（gitee）</li>
<li>coding</li>
<li>Gitlab
<ul>
<li>一个开源的类似于 GitHub 的 Git 仓库托管服务</li>
<li>支持自行搭建</li>
</ul>
</li>
</ul>
<h3 id="创建github账号"> 创建GitHub账号</h3>
<h3 id="基本使用"> 基本使用</h3>
<h4 id="将本地仓库放到线上"> 将本地仓库放到线上</h4>
<p>开发都是在本地开发，当做好一个功能后，我们就需要将本地代码推送到远程仓库</p>
<ol>
<li>
<p>在GitHub远程创建一个新的仓库</p>
<p><img src="./assets/1563854559890.png" alt="1563854559890" /></p>
<p>填写信息并创建仓库。</p>
<p><img src="./assets/1563854825144.png" alt="1563854825144" /></p>
</li>
<li>
<p>在本地仓库下执行命令进行推送，将本地仓库的代码推送到远程</p>
<ul>
<li>
<p>创建远程仓库的时候，先不要勾选README</p>
</li>
<li>
<p>第1次推送：</p>
<div><pre><code><span># 别名我们通常喜欢使用 origin 作为默认仓库的别名</span>
$ <span>git</span> remote <span>add</span> 别名 远程仓库地址

<span># 当本地分支和远程分支名字一样的时候，可以简写只写一个</span>
<span># -u 的作用是记住本次的 push 地址和分支信息</span>
<span># 如果不加 -u，则下一次 push 的时候，还需要使用完整的命令</span>
$ <span>git</span> push -u 远程仓库地址别名 本地分支:远程分支

如果要推送的本地分支和远端分支已有，可以简写为
<span>git</span> push origin 分支
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></li>
<li>
<p>之后有了新的历史记录的时候，直接 ：</p>
<div><pre><code><span>git</span> push
</code></pre>
<div><span>1</span><br></div></div></li>
</ul>
</li>
</ol>
<h4 id="从线上克隆仓库"> 从线上克隆仓库</h4>
<p>如果你到公司去，公司的项目已经在GitHub上了，我们就需要将项目文件从远程仓库克隆到本地，然后进行开发。</p>
<ol>
<li>找到远程仓库地址</li>
<li>执行 <code>git clone 远程仓库地址</code> 命令，即可将远程仓库的代码拉取到本地</li>
</ol>
<div><pre><code><span># clone 下来的仓库会自动创建一个名字叫 origin 的 remote 远端地址</span>
<span># 并且自动和 origin master 建立关系</span>
<span># 所以你这里可以直接 git push</span>
<span>git</span> push
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>但是，如果你要推送别的分支代码，你还得：</p>
<div><pre><code><span>git</span> push -u 仓库地址别名 本地分支:远程分支
</code></pre>
<div><span>1</span><br></div></div><h4 id="拉取和更新"> 拉取和更新</h4>
<p>多人协作的情况下，我们会经常将其他人的写的代码拉取到自己的本地，完成代码或功能的合并工作，拉取远端的内容，执行下面的命令即可。</p>
<div><pre><code><span># 拉取远程代码到当前分支，并和本地分支合并</span>
$ <span>git</span> pull
<span># 取回远程仓库的变化，并与本地指定分支合并</span>
$ <span>git</span> pull <span>[</span>remote<span>]</span> <span>[</span>branch<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="其它环境中的-git"> 其它环境中的 Git</h2>
<h3 id="图形界面"> 图形界面</h3>
<p>Git 官网收录推荐的第三方图形客户端软件：https://git-scm.com/downloads/guis</p>
<ul>
<li>SourceTree</li>
<li>GitHub Desktop</li>
<li>Tortoise Git</li>
<li>Git Extensions</li>
<li>SmartGit</li>
</ul>
<h1 id="总结"> 总结</h1>
<blockquote>
<p>首次推送代码到远程仓库的时候，会有一个弹出框，让你输入你的GitHub的账号和密码。</p>
</blockquote>
<p>添加、提交、推送：</p>
<p><img src="./assets/1566723641911.png" alt="1566723641911" /></p>
<p>回退：</p>
<p><img src="./assets/1566723710527.png" alt="1566723710527" /></p>
<p>分支创建及合并：</p>
<p><img src="./assets/1566723710527.png" alt="1566723710527" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>GET相关命令</title>
      <link>https://wangyawei.top/views/tools/git/git-note-01/</link>
      <guid>https://wangyawei.top/views/tools/git/git-note-01/</guid>
      <source url="https://wangyawei.top/rss.xml">GET相关命令</source>
      <category>GIT</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="初始化"> 初始化；</h2>
<div><pre><code><span># 初始化 git 仓库</span>
$ <span>git</span> init

<span># 将工作区的文件添加到暂存区</span>
$ <span>git</span> <span>add</span> 文件名    <span># git add a.txt</span>

<span># 提交暂存区到仓库区形成历史记录</span>
$ <span>git</span> commit -m <span>"提交日志"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="文件的状态"> 文件的状态；</h2>
<div><pre><code><span># 执行 git status 命令，可以查看到文件的状态</span>
$ <span>git</span> status
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="添加文件到暂存区"> 添加文件到暂存区</h2>
<div><pre><code><span># 添加指定文件到暂存区</span>
$ <span>git</span> <span>add</span> 文件名

<span># 以空格隔开可以一次 add 多个文件</span>
$ <span>git</span> <span>add</span> <span>[</span>file1<span>]</span> <span>[</span>file2<span>]</span> <span>..</span>.

<span># 添加指定目录到暂存区，包括子目录</span>
$ <span>git</span> <span>add</span> <span>[</span>dir<span>]</span> <span>[</span>file<span>]</span> <span>[</span>dir<span>]</span> <span>[</span>file<span>]</span> <span>[</span>file<span>]</span> <span>..</span>.

<span># 添加当前目录的所有文件到暂存区，包括子目录</span>
$ <span>git</span> <span>add</span> <span>.</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="提交文件到仓库"> 提交文件到仓库</h2>
<div><pre><code><span># 提交暂存区到仓库区</span>
$ <span>git</span> commit -m <span>[</span>message<span>]</span>

<span># 提交暂存区的指定文件到仓库区</span>
$ <span>git</span> commit <span>[</span>file1<span>]</span> <span>[</span>file2<span>]</span> <span>..</span>. -m <span>[</span>message<span>]</span>

<span># 提交工作区和暂存区自上次commit之后的变化，直接到仓库区</span>
<span># 注意：不包括未跟踪文件，即不包含没有被GIt管理过的文件</span>
$ <span>git</span> commit -a -m <span>"提交日志"</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h2 id="查看状态"> 查看状态</h2>
<div><pre><code><span># 最好用的是 gitk</span>
$ gitk

<span># 显示有变更的文件</span>
$ <span>git</span> status

<span># 显示当前分支的版本历史</span>
$ <span>git</span> log

<span># 简略查看历史版本</span>
$ <span>git</span> log --oneline
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="撤销操作"> 撤销操作</h2>
<div><pre><code><span># 恢复暂存区的指定文件到工作区</span>
$ <span>git</span> checkout <span>[</span>file<span>]</span>

<span># 恢复暂存区的所有文件到工作区</span>
$ <span>git</span> checkout <span>.</span>

<span># 恢复某个commit的指定文件到暂存区和工作区</span>
$ <span>git</span> checkout <span>[</span>commit版本号<span>]</span> <span>[</span>file<span>]</span>

<span># 重置暂存区的指定文件，与上一次 commit 保持一致，但工作区不变</span>
$ <span>git</span> reset <span>[</span>file<span>]</span>

<span># 重置暂存区与工作区，与上一次commit保持一致</span>
$ <span>git</span> reset --hard
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="创建分支"> 创建分支；</h2>
<div><pre><code><span># 创建一个分支，名字叫做dev</span>
$ <span>git</span> branch dev

<span># 切换分支命令；切换到dev分支上</span>
$ <span>git</span> checkout dev

<span># 也可以使用下面的命令，代替上面两个命令；下面的命令表示创建并切换分支到dev上</span>
$ <span>git</span> checkout -b dev
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h2 id="查看当前分支"> 查看当前分支</h2>
<div><pre><code><span># 列出所有分支，当前分支前面会标一个`*`号。</span>
$ <span>git</span> branch
<span># 会看到类似下面的结果，前面标注*的，表示当前分支</span>
<span># * dev</span>
<span>#   master</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="切换、合并与删除分支"> 切换、合并与删除分支；</h2>
<div><pre><code><span># 查看分支</span>
<span>git</span> branch

<span># 创建分支   $ git branch dev</span>
$ <span>git</span> branch <span>&lt;</span>name<span>></span>

<span># 切换分支  $ git checkout master</span>
$ <span>git</span> checkout <span>&lt;</span>name<span>></span>  

<span># 创建+切换分支</span>
$ <span>git</span> checkout -b <span>&lt;</span>name<span>></span>

<span># 合并某分支到当前分支  $ git merge dev</span>
$ <span>git</span> merge <span>&lt;</span>name<span>></span>

<span># 删除分支  $ git branch -d dev</span>
$ <span>git</span> branch -d <span>&lt;</span>name<span>></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><blockquote>
<div><pre><code><span># 要把dev分支合并到master主分支上，需要先切回master</span>
$ <span>git</span> checkout master

<span># 执行下面的命令，将dev分支合并到master上</span>
$ <span>git</span> merge dev
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></blockquote>
<h2 id="远程仓库推送"> 远程仓库推送；</h2>
<div><pre><code><span># 别名我们通常喜欢使用 origin 作为默认仓库的别名</span>
$ <span>git</span> remote <span>add</span> 别名 远程仓库地址

<span># 当本地分支和远程分支名字一样的时候，可以简写只写一个</span>
<span># -u 的作用是记住本次的 push 地址和分支信息</span>
<span># 如果不加 -u，则下一次 push 的时候，还需要使用完整的命令</span>
$ <span>git</span> push -u 远程仓库地址别名 本地分支:远程分支

如果要推送的本地分支和远端分支已有，可以简写为
<span>git</span> push origin 分支

<span># 之后有了新的历史记录的时候，直接 ：</span>
<span>git</span> push
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="线上克隆仓库"> 线上克隆仓库</h2>
<div><pre><code><span># 执行命令，即可将远程仓库的代码拉取到本地</span>
$ <span>git</span> clone 远程仓库地址

<span># clone 下来的仓库会自动创建一个名字叫 origin 的 remote 远端地址</span>
<span># 并且自动和 origin master 建立关系</span>
<span># 所以你这里可以直接 git push</span>
$ <span>git</span> push

<span># 如果你要推送别的分支代码</span>
$ <span>git</span> push -u 仓库地址别名 本地分支:远程分支
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="拉取和更新"> 拉取和更新</h2>
<div><pre><code><span># 拉取远程代码到当前分支，并和本地分支合并</span>
$ <span>git</span> pull

<span># 取回远程仓库的变化，并与本地指定分支合并</span>
$ <span>git</span> pull <span>[</span>remote<span>]</span> <span>[</span>branch<span>]</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="npm-和-yarn-常用命令对照表"> npm 和 yarn 常用命令对照表：</h2>
<div><pre><code><span># yarn init</span>
<span>npm</span> init

<span># yarn add 包名</span>
<span>npm</span> <span>install</span> 包名

<span># yarn install 或者直接 yarn</span>
<span>npm</span> <span>install</span>

<span># yarn add -D 包名</span>
<span>npm</span> <span>install</span> -D 包名

<span># yarn remove 包名</span>
<span>npm</span> uninstall 包名

<span># yarn global add 包名</span>
<span>npm</span> <span>install</span> --global 包名

<span># yarn global remove 包名</span>
<span>npm</span> uninstall --global 包名
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id="清除npm缓存"> 清除<code>npm</code>缓存</h2>
<div><pre><code>$ <span>npm</span> cache clean --force
</code></pre>
<div><span>1</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>gitignore规则简介</title>
      <link>https://wangyawei.top/views/tools/git/git-note-02/</link>
      <guid>https://wangyawei.top/views/tools/git/git-note-02/</guid>
      <source url="https://wangyawei.top/rss.xml">gitignore规则简介</source>
      <category>GIT</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="介绍"> 介绍；</h2>
<blockquote>
<p>概述：<code>git</code>版本管理工具大家都用过，但时有时候我们不需要提交所有的文件到版本管理中，比如：<code>node_modules</code>等；</p>
<p>​				这时我们便会用到<code>.gitignore</code>文件，来配置规则以忽略我们不需要追踪的文件；</p>
</blockquote>
<h2 id="规则说明"> 规则说明；</h2>
<ol>
<li>
<p>空行不匹配任何文件，因此可以用作分隔符以提高可读性 ；</p>
</li>
<li>
<p>以<code>＃</code>开头的行用作注释。</p>
</li>
<li>
<p>斜杠<code>/</code>用作目录分隔符。分隔符可能出现在开始，中间或结尾。</p>
</li>
<li>
<p>如果开头或中间（或两者都有）有分隔符，则该匹配是相对于特定<code>.gitignore</code>文件本身的<strong>目录级别</strong>的。</p>
</li>
</ol>
<ul>
<li>
<p><code>/bar/foo</code>和（<code>bar/foo</code>同等效果）仅匹配和``.gitignore<code>同级的根目录下的</code>/bar/foo<code>,不匹配</code>/bar/foo.text`。</p>
</li>
<li>
<p><code>/foo/bar.*</code>匹配和``.gitignore<code>同级的根目录下的</code>/foo/bar<code>和</code>/foo/bar.text`。</p>
</li>
<li>
<p><code>foo.*</code>仅匹配同级目录下的所有<code>foo.*</code>文件。例：<code>foo.text</code></p>
</li>
<li>
<p><code>bar/</code>和<code>bar</code>同等效果：匹配同级目录下的所有<code>bar</code><strong>文件夹</strong>。</p>
</li>
<li>
<p><code>/bar</code>仅匹配同级根目录下<code>bar</code>文件。</p>
</li>
<li>
<p><code>foo/*</code>匹配<code>foo/test.json</code>（常规文件）和<code>foo/bar</code>（目录），但不匹配<code>foo / bar / hello.c</code>。</p>
</li>
</ul>
<ol start="5">
<li>前导 <code>**</code>后跟斜杠表示在所有目录中均匹配。</li>
</ol>
<ul>
<li><code>**/foo</code>与文件 <code>foo</code>相同的任何位置都匹配文件夹 <code>foo</code>。 <code>**/foo/bar</code> <code>bar</code>会在目录 <code>foo</code> 正下方的任何位置匹配文件夹。</li>
</ul>
<ol start="6">
<li>
<p>尾部的“ <code>/**</code>”与内部的所有内容匹配。例如，“ <code>abc/**</code>”将目录“ <code>abc</code>” 内的所有文件（相对于<code>.gitignore</code>文件位置）以无限深度进行匹配。</p>
</li>
<li>
<p>斜杠后跟两个连续的星号，然后斜杠匹配零个或多个目录</p>
</li>
</ol>
<ul>
<li>例如，“ <code>a/**/b</code>”匹配“ <code>a/b</code>”，“ <code>a/x/b</code>”，“ <code>a/x/y/b</code>”等。</li>
</ul>
<ol start="8">
<li>
<p><strong>例子</strong>：</p>
<ul>
<li><code>hello.*</code>匹配名称以<code>hello</code>开头的任何文件。如果只想将此限制于目录而不是其子目录，则可以在模式前面加上斜杠，即<code>/hello.*</code>；模式现在匹配<code>hello.txt</code>，<code>hello.c</code>但是不 匹配<code>a/hello.java</code>。</li>
</ul>
</li>
</ol>
<h2 id="使用"> 使用；</h2>
<ol>
<li>新建：<code>.gitignore</code>文件；</li>
<li>配置规则；</li>
</ol>
<div><pre><code>.DS_Store
node_modules
/dist

<span># local env files</span>
.env.local
.env.*.local

<span># Log files</span>
npm-debug.log*
yarn-debug.log*
yarn-error.log*

<span># Editor directories and files</span>
.idea
.vscode
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>HTML基础总结</title>
      <link>https://wangyawei.top/views/frontEnd/html/html-note-00/</link>
      <guid>https://wangyawei.top/views/frontEnd/html/html-note-00/</guid>
      <source url="https://wangyawei.top/rss.xml">HTML基础总结</source>
      <category>HTML</category>
      <pubDate>Sun, 02 May 2021 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="开发工具"> 开发工具</h2>
<p>我们主要用的 开发工具有   chrome  、  sublime 、  photoshop</p>
<h2 id="常见浏览器内核介绍"> 常见浏览器内核介绍</h2>
<div><pre><code>浏览器是网页运行的平台，常用的浏览器有IE、火狐（Firefox）、谷歌（Chrome）、Safari和Opera等。我们平时称为五大浏览器。
</code></pre>
<div><span>1</span><br></div></div><h2 id="浏览器内核-理解"> 浏览器内核（理解）</h2>
<div><pre><code>浏览器内核又可以分成两部分：渲染引擎(layout engineer 或者 Rendering Engine)和 JS 引擎。
渲染引擎 它负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入 CSS 等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。
JS 引擎 则是解析 Javascript 语言，执行 javascript语言来实现网页的动态效果。

最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。有一个网页标准计划小组制作了一个 ACID 来测试引擎的兼容性和性能。内核的种类很多，如加上没什么人使用的非商业的免费内核，可能会有10多种，但是常见的浏览器内核可以分这四种：Trident、Gecko、Blink、Webkit。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>（1）Trident(IE内核)</p>
<p>国内很多的双核浏览器的其中一核便是 Trident，美其名曰 &quot;兼容模式&quot;。</p>
<p>代表： IE、傲游、世界之窗浏览器、Avant、腾讯TT、猎豹安全浏览器、360极速浏览器、百度浏览器等。</p>
<p>Window10 发布后，IE 将其内置浏览器命名为 Edge，Edge 最显著的特点就是新内核 EdgeHTML。</p>
<p>（2）Gecko(firefox)</p>
<p>Gecko(Firefox 内核)： Mozilla FireFox(火狐浏览器) 采用该内核，Gecko 的特点是代码完全公开，因此，其可开发程度很高，全世界的程序员都可以为其编写代码，增加功能。 可惜这几年已经没落了， 比如 打开速度慢、升级频繁、猪一样的队友flash、神一样的对手chrome。</p>
<p>（3） webkit(Safari)</p>
<p>Safari 是苹果公司开发的浏览器，所用浏览器内核的名称是大名鼎鼎的 WebKit。</p>
<p>现在很多人错误地把 webkit 叫做 chrome内核（即使 chrome内核已经是 blink 了），苹果感觉像被别人抢了媳妇，都哭晕再厕所里面了。</p>
<p>代表浏览器：傲游浏览器3、 Apple Safari (Win/Mac/iPhone/iPad)、Symbian手机浏览器、Android 默认浏览器，</p>
<p>（4） Chromium/Blink(chrome)</p>
<p>在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。Blink 其实是 WebKit 的分支。</p>
<p>​     大部分国产浏览器最新版都采用Blink内核。二次开发</p>
<p>（5） Presto(Opera)</p>
<p>Presto（已经废弃） 是挪威产浏览器 opera 的 &quot;前任&quot; 内核，为何说是 &quot;前任&quot;，因为最新的 opera 浏览器早已将之抛弃从而投入到了谷歌怀抱了。</p>
<p>移动端的浏览器内核主要说的是系统内置浏览器的内核。</p>
<p>Android手机而言，使用率最高的就是Webkit内核，大部分国产浏览器宣称的自己的内核，基本上也是属于webkit二次开发。</p>
<p>iOS以及WP7平台上，由于系统原因，系统大部分自带浏览器内核，一般是Safari或者IE内核Trident的</p>
<h1 id="web标准-重点"> Web标准（重点）</h1>
<p>通过以上浏览器的内核不同，我们知道他们工作原理、解析肯定不同，显示就会有差别。</p>
<h2 id="web-标准的好处"> Web 标准的好处</h2>
<p><em>1</em>、让Web的发展前景更广阔
<em>2</em>、内容能被更广泛的设备访问
<em>3</em>、更容易被搜寻引擎搜索
<em>4</em>、降低网站流量费用
<em>5</em>、使网站更易于维护
<em>6</em>、提高页面浏览速度</p>
<h2 id="web-标准构成"> Web 标准构成</h2>
<p>Web标准不是某一个标准，而是由W3C和其他标准化组织制定的一系列标准的集合。</p>
<p>主要包括结构（Structure）、表现（Presentation）和行为（Behavior）三个方面。</p>
<div><pre><code>结构标准：结构用于对网页元素进行整理和分类，咱们主要学的是HTML。 最重要
表现标准：表现用于设置网页元素的版式、颜色、大小等外观样式，主要指的是CSS。
行为标准：行为是指网页模型的定义及交互的编写，咱们主要学的是 Javascript
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>理想状态我们的源码： .HTML    .css   .js</p>
<h1 id="html-初识"> HTML 初识</h1>
<p>HTML（英文Hyper Text Markup Language的缩写）中文译为“超文本标签语言”。是用来描述网页的一种语言。</p>
<p>所谓超文本，因为它可以加入图片、声音、动画、多媒体等内容，不仅如此，它还可以从一个文件跳转到另一个文件，与世界各地主机的文件连接。</p>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span> 我是一个大标题 <span><span><span>&lt;/</span>h1</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>注意：   体会 文本    标签    语言   几个词语</p>
<ul>
<li>HTML 指的是超文本标记语言 (<strong>H</strong>yper <strong>T</strong>ext <strong>M</strong>arkup <strong>L</strong>anguage)</li>
<li>HTML 不是一种编程语言，而是一种标记语言 (markup language)</li>
<li>标记语言是一套标记标签 (markup tag)</li>
</ul>
<p>总结： HTML 作用就是用标记标签来描述网页，把网页内容在浏览器中展示出来。</p>
<p>用文字来描述网页标签</p>
<h2 id="html骨架格式"> HTML骨架格式</h2>
<p>同理：HTML 有自己的语言语法骨架格式：</p>
<div><pre><code><span><span><span>&lt;</span>HTML</span><span>></span></span>   
    <span><span><span>&lt;</span>head</span><span>></span></span>     
        <span><span><span>&lt;</span>title</span><span>></span></span><span><span><span>&lt;/</span>title</span><span>></span></span>
    <span><span><span>&lt;/</span>head</span><span>></span></span>
    <span><span><span>&lt;</span>body</span><span>></span></span>
    <span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>HTML</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><div><pre><code>1 HTML标签：

作用所有HTML中标签的一个根节点。 最大的标签   根标签

2 head标签： 文档的头部

文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。

注意在head标签中我们必须要设置的标签是title

3.title标签： 文档的标题

作用：让页面拥有一个属于自己的标题。

4.body标签：文档的主体  以后我们的页面内容 基本都是放到body里面的

body 元素包含文档的所有内容（比如文本、超链接、图像、表格和列表等等。）
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h2 id="html标签分类"> HTML标签分类</h2>
<p>在HTML页面中，带有“&lt; &gt;”符号的元素被称为HTML标签，如上面提到的 &lt;HTML&gt;、&lt;head&gt;、&lt;body&gt;都是HTML骨架结构标签。所谓标签就是放在“&lt; &gt;” 标签符中表示某个功能的编码命令，也称为HTML标签或 HTML元素</p>
<p>1.双标签</p>
<div><pre><code><span><span><span>&lt;</span>标签名</span><span>></span></span> 内容 <span><span><span>&lt;/</span>标签名</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>该语法中“&lt;标签名&gt;”表示该标签的作用开始，一般称为“开始标签（start tag）”，“&lt;/标签名&gt;” 表示该标签的作用结束，一般称为“结束标签（end tag）”。和开始标签相比，结束标签只是在前面加了一个关闭符“/”。</p>
<blockquote>
<div><pre><code>比如 <span><span><span>&lt;</span>body</span><span>></span></span>我是文字  <span><span><span>&lt;/</span>body</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div></blockquote>
<p>2.单标签</p>
<div><pre><code><span><span><span>&lt;</span>标签名</span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>单标签也称空标签，是指用一个标签符号即可完整地描述某个功能的标签。</p>
<blockquote>
<div><pre><code>比如  <span><span><span>&lt;</span>br</span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div></blockquote>
<h2 id="html标签关系"> HTML标签关系</h2>
<p>标签的相互关系就分为两种：</p>
<p>1.嵌套关系</p>
<div><pre><code><span><span><span>&lt;</span>head</span><span>></span></span>  <span><span><span>&lt;</span>title</span><span>></span></span> <span><span><span>&lt;/</span>title</span><span>></span></span>  <span><span><span>&lt;/</span>head</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>2.并列关系</p>
<div><pre><code><span><span><span>&lt;</span>head</span><span>></span></span><span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span><span><span><span>&lt;/</span>body</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>倡议： 如果两个标签之间的关系是嵌套关系，子元素最好缩进一个tab键的身位。如果是并列关系，最好上下对齐。</p>
<div><pre><code>再页面中输入 以下2个单词
1.  html: 5   
2.  !
   在sublime里面然后按下tab键盘即可生成HTML骨架
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h1 id="文档类型-doctype"> 文档类型&lt;!DOCTYPE&gt;</h1>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span> 
</code></pre>
<div><span>1</span><br></div></div><p>这句话就是告诉我们使用哪个html版本？  我们使用的是 html 5 的版本。  html有很多版本，那我们应该告诉用户和浏览器我们使用的版本号。</p>
<!DOCTYPE> 标签位于文档的最前面，用于向浏览器说明当前文档使用哪种 HTML 或 XHTML 标准规范，必需在开头处使用<!DOCTYPE>标签为所有的XHTML文档指定XHTML版本和类型，只有这样浏览器才能按指定的文档类型进行解析。
<p>注意：  一些老网站可能用的还是老版本的文档类型比如 XHTML之类的，但是我们学的是HTML5,而且HTML5的文档类型兼容很好(向下兼容的原则)，所以大家放心的使用HTML5的文档类型就好了。</p>
<h1 id="字符集"> 字符集</h1>
<div><pre><code><span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>utf-8是目前最常用的字符集编码方式，常用的字符集编码方式还有gbk和gb2312。</p>
<p>gb2312 简单中文  包括6763个汉字</p>
<p>BIG5   繁体中文 港澳台等用</p>
<p>GBK包含全部中文字符    是GB2312的扩展，加入对繁体字的支持，兼容GB2312</p>
<p>UTF-8则包含全世界所有国家需要用到的字符</p>
<div><pre><code>记住一点，以后我们统统使用UTF-8 字符集, 这样就避免出现字符集不统一而引起乱码的情况了。
</code></pre>
<div><span>1</span><br></div></div><h1 id="html标签的语义化"> HTML标签的语义化</h1>
<p>白话： 所谓标签语义化，就是指标签的含义。</p>
<h2 id="为什么要有语义化标签"> 为什么要有语义化标签</h2>
<ol>
<li>
<p>方便代码的阅读和维护</p>
</li>
<li>
<p>同时让浏览器或是网络爬虫可以很好地解析，从而更好分析其中的内容</p>
</li>
<li>
<p>使用语义化标签会具有更好地搜索引擎优化</p>
</li>
</ol>
<p>核心：合适的地方给一个最为合理的标签。</p>
<p>语义是否良好： 当我们去掉CSS之后，网页结构依然组织有序，并且有良好的可读性。</p>
<p>白话，一眼看去，就知道那个是重点，结构是什么，知道每块的内容是干啥的。</p>
<p>遵循的原则：先确定语义的HTML ，再选合适的CSS。</p>
<h1 id="html常用标签"> HTML常用标签</h1>
<p>首先 HTML和CSS是两种完全不同的语言，我们学的是结构，就只写HTML标签，认识标签就可以了。 不会再给结构标签指定样式了。</p>
<p>HTML标签有很多，这里我们学习最为常用的，后面有些较少用的，我们可以查下手册就可以了。</p>
<h2 id="排版标签"> 排版标签</h2>
<p>排版标签主要和css搭配使用，显示网页结构的标签，是网页布局最常用的标签。</p>
<h3 id="标题标签-熟记"> 标题标签 (熟记)</h3>
<p>单词缩写：  head   头部. 标题     title  文档标题</p>
<p>为了使网页更具有语义化，我们经常会在页面中用到标题标签，HTML提供了6个等级的标题，即</p>
<div><pre><code> <span><span><span>&lt;</span>h1</span><span>></span></span>、<span><span><span>&lt;</span>h2</span><span>></span></span>、<span><span><span>&lt;</span>h3</span><span>></span></span>、<span><span><span>&lt;</span>h4</span><span>></span></span>、<span><span><span>&lt;</span>h5</span><span>></span></span>和<span><span><span>&lt;</span>h6</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><div><pre><code>标题标签语义：  作为标题使用，并且依据重要性递减
</code></pre>
<div><span>1</span><br></div></div><p>其基本语法格式如下：</p>
<div><pre><code><span><span><span>&lt;</span>hn</span><span>></span></span>   标题文本   <span><span><span>&lt;/</span>hn</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><blockquote>
<p>注意：  h1 标签因为重要，尽量少用，不要动不动就向你扔了一个h1。 一般h1 都是给logo使用，或者页面中最重要标题信息。</p>
</blockquote>
<h3 id="段落标签-熟记"> 段落标签( 熟记)</h3>
<p>单词缩写：  paragraph  段落  [ˈpærəgræf]    无须记这个单词</p>
<p>在网页中要把文字有条理地显示出来，离不开段落标签，就如同我们平常写文章一样，整个网页也可以分为若干个段落，而段落的标签就是</p>
<div><pre><code><span><span><span>&lt;</span>p</span><span>></span></span>  文本内容  <span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>是HTML文档中最常见的标签，默认情况下，文本在一个段落中会根据浏览器窗口的大小自动换行。</p>
<h3 id="水平线标签-认识"> 水平线标签(认识)</h3>
<p>单词缩写：  horizontal  横线    [ˌhɔrəˈzɑntl]    同上</p>
<p>在网页中常常看到一些水平线将段落与段落之间隔开，使得文档结构清晰，层次分明。这些水平线可以通过插入图片实现，也可以简单地通过标签来完成，<hr />就是创建横跨网页水平线的标签。其基本语法格式如下：</p>
<div><pre><code><span><span><span>&lt;</span>hr</span> <span>/></span></span>是单标签
</code></pre>
<div><span>1</span><br></div></div><p>在网页中显示默认样式的水平线。</p>
<h3 id="换行标签-熟记"> 换行标签(熟记)</h3>
<p>单词缩写：  break   打断 ,换行</p>
<p>在HTML中，一个段落中的文字会从左到右依次排列，直到浏览器窗口的右端，然后自动换行。如果希望某段文本强制换行显示，就需要使用换行标签</p>
<div><pre><code><span><span><span>&lt;</span>br</span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>这时如果还像在word中直接敲回车键换行就不起作用了。</p>
<h3 id="div-span标签-重点"> div span标签(重点)</h3>
<p>div  span    是没有语义的     是我们网页布局主要的2个盒子     css+div</p>
<p>div 就是  division  的缩写   分割， 分区的意思  其实有很多div 来组合网页。</p>
<p>span, 跨度，跨距；范围</p>
<p>语法格式：</p>
<div><pre><code><span><span><span>&lt;</span>div</span><span>></span></span> 这是头部 <span><span><span>&lt;/</span>div</span><span>></span></span>    <span><span><span>&lt;</span>span</span><span>></span></span>今日价格<span><span><span>&lt;/</span>span</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="文本格式化标签-熟记"> 文本格式化标签(熟记)</h2>
<p>在网页中，有时需要为文字设置粗体、斜体或下划线效果，这时就需要用到HTML中的文本格式化标签，使文字以特殊的方式显示。</p>
<p>b  i  s  u   只有使用 没有 强调的意思       strong   em  del   ins  语义更强烈</p>
<h2 id="标签属性"> 标签属性</h2>
<p>属性就是特性 比如 手机的颜色 手机的尺寸 ，总结就是手机的。。</p>
<p>手机的颜色是黑色   手机的尺寸是 8寸</p>
<p>水平线的长度是 200</p>
<p>图片的宽度 是  300    键  值对</p>
<p>使用HTML制作网页时，如果想让HTML标签提供更多的信息，可以使用HTML标签的属性加以设置。其基本语法格式如下：</p>
<div><pre><code><span><span><span>&lt;</span>标签名</span> <span>属性1</span><span><span>=</span><span>"</span>属性值1<span>"</span></span> <span>属性2</span><span><span>=</span><span>"</span>属性值2<span>"</span></span> <span>…</span><span>></span></span> 内容 <span><span><span>&lt;/</span>标签名</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>在上面的语法中，</p>
<p>1.标签可以拥有多个属性，必须写在开始标签中，位于标签名后面。</p>
<p>2.属性之间不分先后顺序，标签名与属性、属性与属性之间均以空格分开。</p>
<p>3.任何标签的属性都有默认值，省略该属性则取默认值。</p>
<p>采取  键值对 的格式   key=&quot;value&quot;  的格式</p>
<p>比如:</p>
<div><pre><code><span><span><span>&lt;</span>hr</span> <span>width</span><span><span>=</span><span>"</span>400<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>属性  是 宽度</p>
<p>值    是 400</p>
<p>提倡：   尽量不使用 样式属性。   <img src="media/sm.jpg" /></p>
<h2 id="图像标签img-重点"> 图像标签img (重点)</h2>
<p>单词缩写：   image  图像</p>
<p>HTML网页中任何元素的实现都要依靠HTML标签，要想在网页中显示图像就需要使用图像标签，接下来将详细介绍图像标签<img />以及和他相关的属性。其基本语法格式如下：</p>
<p>该语法中src属性用于指定图像文件的路径和文件名，他是img标签的必需属性。</p>
<div><pre><code><span><span><span>&lt;</span>img</span> <span>src</span><span><span>=</span><span>"</span>图像URL<span>"</span></span> <span>/></span></span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>当网页显示图片时,鼠标滑上图片显示文字描述是以下哪个属性</strong>****</p>
<p>(A) 设置alt属性</p>
<p>(B) 设置title属性</p>
<p>(C) 设置href 属性</p>
<p>(D) 设置src 属性</p>
<h2 id="链接标签-重点"> 链接标签(重点)</h2>
<p>单词缩写：  anchor 的缩写  [ˈæŋkə(r)] 。基本解释 锚, 铁锚 的</p>
<p>在HTML中创建超链接非常简单，只需用标签环绕需要被链接的对象即可，其基本语法格式如下：</p>
<div><pre><code><span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>跳转目标<span>"</span></span> <span>target</span><span><span>=</span><span>"</span>目标窗口的弹出方式<span>"</span></span><span>></span></span>文本或图像<span><span><span>&lt;/</span>a</span><span>></span></span>
</code></pre>
<div><span>1</span><br></div></div><p>href：用于指定链接目标的url地址，当为标签应用href属性时，它就具有了超链接的功能。  Hypertext Reference的缩写。意思是超文本引用</p>
<p>target：用于指定链接页面的打开方式，其取值有_self和_blank两种，其中_self为默认值，_blank为在新窗口中打开方式。</p>
<p>注意：</p>
<p>1.外部链接 需要添加 http:// www.baidu.com</p>
<p>2.内部链接 直接链接内部页面名称即可 比如 &lt; a href=&quot;index.html&quot;&gt; 首页 </a ></p>
<p>3.如果当时没有确定链接目标时，通常将链接标签的href属性值定义为“#”(即href=&quot;#&quot;)，表示该链接暂时为一个空链接。</p>
<p>4.不仅可以创建文本超链接，在网页中各种网页元素，如图像、表格、音频、视频等都可以添加超链接。</p>
<h3 id="锚点定位-难点"> 锚点定位 （难点）</h3>
<p>通过创建锚点链接，用户能够快速定位到目标内容。
创建锚点链接分为两步：</p>
<div><pre><code>1.使用“a href=”#id名>“链接文本"<span><span><span>&lt;/</span>a</span><span>></span></span>创建链接文本（被点击的）
  <span><span><span>&lt;</span>a</span> <span>href</span><span><span>=</span><span>"</span>#two<span>"</span></span><span>></span></span>   

2.使用相应的id名标注跳转目标的位置。
  <span><span><span>&lt;</span>h3</span> <span>id</span><span><span>=</span><span>"</span>two<span>"</span></span><span>></span></span>第2集<span><span><span>&lt;/</span>h3</span><span>></span></span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="base-标签-基本的"> base 标签   基本的</h3>
<p>base 可以设置整体链接的打开状态</p>
<p>base 写到  <head>  </head>  之间</p>
<p>把所有的连接 都默认添加 target=&quot;_blank&quot;</p>
<h2 id="注释标签"> 注释标签</h2>
<p>在HTML中还有一种特殊的标签——注释标签。如果需要在HTML文档中添加一些便于阅读和理解但又不需要显示在页面中的注释文字，就需要使用注释标签。其基本语法格式如下：
​</p>
<div><pre><code>    <span>&lt;!-- 注释语句 --></span>   ctrl + /       或者 ctrl +shift + / 
</code></pre>
<div><span>1</span><br></div></div><p>注释内容不会显示在浏览器窗口中，但是作为HTML文档内容的一部分，也会被下载到用户的计算机上，查看源代码时就可以看到。</p>
<h1 id="列表标签"> 列表标签</h1>
<p>列表最大的特点就是  整齐 、整洁、 有序</p>
<h2 id="无序列表-ul-重点"> 无序列表 ul （重点）</h2>
<p>无序列表的各个列表项之间没有顺序级别之分，是并列的。其基本语法格式如下：</p>
<div><pre><code><span><span><span>&lt;</span>ul</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>列表项1<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>列表项2<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>列表项3<span><span><span>&lt;/</span>li</span><span>></span></span>
  ......
<span><span><span>&lt;/</span>ul</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>比如下面这些，新闻是没有顺序的，不用排队，先到先得，后发布先显示。</p>
<p>脚下留心：</p>
<div><pre><code> 1. &lt;ul&gt;&lt;/ul&gt;中只能嵌套&lt;li&gt;&lt;/li&gt;，直接在&lt;ul&gt;&lt;/ul&gt;标签中输入其他标签或者文字的做法是不被允许的。
 2. &lt;li&gt;与&lt;/li&gt;之间相当于一个容器，可以容纳所有元素。
 3. 无序列表会带有自己样式属性，放下那个样式，一会让CSS来！
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="有序列表-ol-了解"> 有序列表 ol （了解）</h2>
<p>有序列表即为有排列顺序的列表，其各个列表项按照一定的顺序排列定义，有序列表的基本语法格式如下：</p>
<div><pre><code><span><span><span>&lt;</span>ol</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>列表项1<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>列表项2<span><span><span>&lt;/</span>li</span><span>></span></span>
  <span><span><span>&lt;</span>li</span><span>></span></span>列表项3<span><span><span>&lt;/</span>li</span><span>></span></span>
  ......
<span><span><span>&lt;/</span>ol</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>所有特性基本与ul 一致。</p>
<p>但是实际工作中， 较少用 ol img src=&quot;media/1.jpg&quot; /&gt;</p>
<h2 id="自定义列表-理解"> 自定义列表（理解）</h2>
<p>定义列表常用于对术语或名词进行解释和描述，定义列表的列表项前没有任何项目符号。其基本语法如下：</p>
<div><pre><code><span><span><span>&lt;</span>dl</span><span>></span></span>
  <span><span><span>&lt;</span>dt</span><span>></span></span>名词1<span><span><span>&lt;/</span>dt</span><span>></span></span>
  <span><span><span>&lt;</span>dd</span><span>></span></span>名词1解释1<span><span><span>&lt;/</span>dd</span><span>></span></span>
  <span><span><span>&lt;</span>dd</span><span>></span></span>名词1解释2<span><span><span>&lt;/</span>dd</span><span>></span></span>
  ...
  <span><span><span>&lt;</span>dt</span><span>></span></span>名词2<span><span><span>&lt;/</span>dt</span><span>></span></span>
  <span><span><span>&lt;</span>dd</span><span>></span></span>名词2解释1<span><span><span>&lt;/</span>dd</span><span>></span></span>
  <span><span><span>&lt;</span>dd</span><span>></span></span>名词2解释2<span><span><span>&lt;/</span>dd</span><span>></span></span>
  ...
<span><span><span>&lt;/</span>dl</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h1 id="表格-table-会使用"> 表格 table(会使用)</h1>
<p>存在即是合理的。  表格的现在还是较为常用的一种标签，但不是用来布局，常见处理、显示表格式数据</p>
<h2 id="创建表格"> 创建表格</h2>
<p>在HTML网页中，要想创建表格，就需要使用表格相关的标签。创建表格的基本语法格式如下：</p>
<div><pre><code><span><span><span>&lt;</span>table</span><span>></span></span>
  <span><span><span>&lt;</span>tr</span><span>></span></span>
    <span><span><span>&lt;</span>td</span><span>></span></span>单元格内的文字<span><span><span>&lt;/</span>td</span><span>></span></span>
    ...
  <span><span><span>&lt;/</span>tr</span><span>></span></span>
  ...
<span><span><span>&lt;/</span>table</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>在上面的语法中包含三对HTML标签，分别为 &lt;table&gt;&lt;/table&gt;、&lt;tr&gt;&lt;/tr&gt;、&lt;td&gt;&lt;/td&gt;，他们是创建表格的基本标签，缺一不可，下面对他们进行具体地解释</p>
<div><pre><code>1.table用于定义一个表格。

2.tr 用于定义表格中的一行，必须嵌套在 table标签中，在 table中包含几对 tr，就有几行表格。

3.td /td：用于定义表格中的单元格，必须嵌套在&lt;tr&gt;&lt;/tr&gt;标签中，一对 &lt;tr&gt; &lt;/tr&gt;中包含几对&lt;td&gt;&lt;/td&gt;，就表示该行中有多少列（或多少个单元格）。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>注意：</p>
<div><pre><code>1. &lt;tr&gt;&lt;/tr&gt;中只能嵌套&lt;td&gt;&lt;/td&gt;
</code></pre>
<div><span>1</span><br></div></div><div><pre><code>2. &lt;td&gt;&lt;/td&gt;标签，他就像一个容器，可以容纳所有的元素
</code></pre>
<div><span>1</span><br></div></div><h2 id="表格属性"> 表格属性</h2>
<p>三参为0    border  cellpadding  cellspacing  为  0</p>
<h2 id="表头标签"> 表头标签</h2>
<p>表头单元格一般位于表格的第一行或第一列，其文本加粗居中，如下图所示，即为设置了表头的表格。设置表头非常简单，只需用表头标签&lt;th&gt;&lt;/th&gt;替代相应的单元格标签&lt;td&gt;&lt;/td&gt;即可。</p>
<h2 id="表格结构-了解"> 表格结构（了解）</h2>
<div><pre><code>在使用表格进行布局时，可以将表格划分为头部、主体和页脚（页脚因为有兼容性问题，我们不在赘述），具体 如下所示：

&lt;thead&gt;&lt;/thead&gt;：用于定义表格的头部。

必须位于&lt;table&gt;&lt;/table&gt; 标签中，一般包含网页的logo和导航等头部信息。


&lt;tbody&gt;&lt;/tbody&gt;：用于定义表格的主体。

位于&lt;table&gt;&lt;/table&gt;标签中，一般包含网页中除头部和底部之外的其他内容。
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h2 id="表格标题"> 表格标题</h2>
<p><strong>表格的标题： caption</strong></p>
<p><strong>定义和用法</strong></p>
<p>caption 元素定义表格标题。</p>
<div><pre><code><span><span><span>&lt;</span>table</span><span>></span></span>
   <span><span><span>&lt;</span>caption</span><span>></span></span>我是表格标题<span><span><span>&lt;/</span>caption</span><span>></span></span>
<span><span><span>&lt;/</span>table</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>caption 标签必须紧随 table 标签之后。</p>
<p>只存在 表格里面</p>
<p>您只能对每个表格定义一个标题。通常这个标题会被居中于表格之上。</p>
<h2 id="合并单元格-难点"> 合并单元格(难点)</h2>
<p>跨行合并：rowspan    跨列合并：colspan</p>
<p>合并单元格的思想：</p>
<p>​     将多个内容合并的时候，就会有多余的东西，把它删除。    例如 把 3个 td 合并成一个， 那就多余了2个，需要删除。</p>
<p>​     公式：  删除的个数  =  合并的个数  - 1</p>
<p>合并的顺序 先上 后下   先左  后右</p>
<ol>
<li>先确定是跨行还是跨列合并</li>
<li>根据 先上 后下   先左  后右的原则找到目标单元格</li>
<li>删除单元格   删除的个数  =  合并的个数  - 1</li>
</ol>
<h2 id="总结表格"> 总结表格</h2>
<ol>
<li>
<p>表格提供了HTML 中定义表格式数据的方法。</p>
</li>
<li>
<p>表格中由行中的单元格组成。</p>
</li>
<li>
<p>表格中没有列元素，列的个数取决于行的单元格个数。</p>
</li>
<li>
<p>表格不要纠结于外观，那是CSS 的作用。</p>
</li>
</ol>
<h1 id="表单标签-掌握"> 表单标签(掌握)</h1>
<p>表单控件：</p>
<p>​       包含了具体的表单功能项，如单行文本输入框、密码输入框、复选框、提交按钮、重置按钮等。</p>
<p>提示信息：</p>
<p>​        一个表单中通常还需要包含一些说明性的文字，提示用户进行填写和操作。</p>
<p>表单域：</p>
<p>​      他相当于一个容器，用来容纳所有的表单控件和提示信息，可以通过他定义处理表单数据所用程序的url地址，以及数据提交到服务器的方法。如果不定义表单域，表单中的数据就无法传送到后台服务器。</p>
<h2 id="input-控件-重点"> input 控件(重点)</h2>
<p>input 输入的意思</p>
<p>在上面的语法中，&lt;input /&gt;标签为单标签，type属性为其最基本的属性  类型 ，其取值有多种，用于指定不同的控件类型。除了type属性之外，&lt;input /&gt;标签还可以定义很多其他的属性，其常用属性如下表所示。</p>
<p>type  说明了属于那种表单</p>
<p>radio  如果是一组，我们必须给他们命名相同的名字 name   这样就可以多个选其中的一个啦</p>
<h2 id="label标签-理解"> label标签(理解)</h2>
<p>label 标签为 input 元素定义标注（标签）。</p>
<p>作用：  用于绑定一个表单元素, 当点击label标签的时候, 被绑定的表单元素就会获得输入焦点</p>
<p>for 属性规定 label 与哪个表单元素绑定。</p>
<div><pre><code><span><span><span>&lt;</span>label</span> <span>for</span><span><span>=</span><span>"</span>male<span>"</span></span><span>></span></span>Male<span><span><span>&lt;/</span>label</span><span>></span></span>
<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>radio<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>sex<span>"</span></span> <span>id</span><span><span>=</span><span>"</span>male<span>"</span></span> <span>value</span><span><span>=</span><span>"</span>male<span>"</span></span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="textarea控件-文本域"> textarea控件(文本域)</h2>
<p>text  文本框  只能写一行文本呢</p>
<p>textarea 文本域</p>
<p>如果需要输入大量的信息，就需要用到&lt;textarea&gt;&lt;/textarea&gt;标签。通过textarea控件可以轻松地创建多行文本输入框，其基本语法格式如下：</p>
<div><pre><code><span><span><span>&lt;</span>textarea</span> <span>cols</span><span><span>=</span><span>"</span>每行中的字符数<span>"</span></span> <span>rows</span><span><span>=</span><span>"</span>显示的行数<span>"</span></span><span>></span></span>
  文本内容
<span><span><span>&lt;/</span>textarea</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="下拉菜单"> 下拉菜单</h2>
<p>使用select控件定义下拉菜单的基本语法格式如下     select 选择</p>
<div><pre><code><span><span><span>&lt;</span>select</span><span>></span></span>
  <span><span><span>&lt;</span>option</span><span>></span></span>选项1<span><span><span>&lt;/</span>option</span><span>></span></span>
  <span><span><span>&lt;</span>option</span><span>></span></span>选项2<span><span><span>&lt;/</span>option</span><span>></span></span>
  <span><span><span>&lt;</span>option</span><span>></span></span>选项3<span><span><span>&lt;/</span>option</span><span>></span></span>
  ...
<span><span><span>&lt;/</span>select</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>注意：</p>
<ol>
<li>&lt;select&gt;&lt;/select&gt;中至少应包含一对&lt;option&gt;&lt;/option&gt;。</li>
<li>在option 中定义selected =&quot; selected &quot;时，当前项即为默认选中项。</li>
</ol>
<h2 id="表单域"> 表单域</h2>
<p>在HTML中，form标签被用于定义表单域，即创建一个表单，以实现用户信息的收集和传递，form中的所有内容都会被提交给服务器。创建表单的基本语法格式如下：</p>
<div><pre><code><span><span><span>&lt;</span>form</span> <span>action</span><span><span>=</span><span>"</span>url地址<span>"</span></span> <span>method</span><span><span>=</span><span>"</span>提交方式<span>"</span></span> <span>name</span><span><span>=</span><span>"</span>表单名称<span>"</span></span><span>></span></span>
  各种表单控件
<span><span><span>&lt;/</span>form</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>常用属性：</p>
<ol>
<li>Action
在表单收集到信息后，需要将信息传递给服务器进行处理，action属性用于指定接收并处理表单数据的服务器程序的url地址。</li>
<li>method
用于设置表单数据的提交方式，其取值为get或post。</li>
<li>name
用于指定表单的名称，以区分同一个页面中的多个表单。</li>
</ol>
<p>注意：  每个表单都应该有自己表单域。</p>
<h1 id="知识点小节"> 知识点小节：</h1>
<h5 id="超链接base技巧"> 超链接base技巧：</h5>
<ul>
<li>
<div><pre><code><span>&lt;!-- 在head标签里写, base标签决定了页面所有超链接的打开方式 --></span>
	<span><span><span>&lt;</span>base</span> <span>target</span><span><span>=</span><span>"</span>_blank<span>"</span></span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
</ul>
<h5 id="css继承性的特殊情况"> css继承性的特殊情况：</h5>
<div><pre><code><span>&lt;!--标题标签不会继承父元素的文字大小,a标签不会继承父元素的文字颜色--></span>
</code></pre>
<div><span>1</span><br></div></div><h5 id="清除轮廓线"> 清除轮廓线：</h5>
<div><pre><code><span>input</span> <span>{</span>
		<span>/*清除轮廓线*/</span>
		<span>outline</span><span>:</span> 0<span>;</span>
		<span>}</span>
<span>textarea</span> <span>{</span>
		<span>/*禁止文本域拖拽*/</span>
		<span>resize</span><span>:</span> none<span>;</span>
		<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h5 id="占位符"> 占位符：</h5>
<div><pre><code><span><span>&lt;!</span><span>DOCTYPE</span> <span>html</span><span>></span></span>
<span><span><span>&lt;</span>html</span> <span>lang</span><span><span>=</span><span>"</span>en<span>"</span></span><span>></span></span>
<span><span><span>&lt;</span>head</span><span>></span></span>
	<span><span><span>&lt;</span>meta</span> <span>charset</span><span><span>=</span><span>"</span>UTF-8<span>"</span></span><span>></span></span>
	<span><span><span>&lt;</span>title</span><span>></span></span>Document<span><span><span>&lt;/</span>title</span><span>></span></span>
	<span><span><span>&lt;</span>style</span><span>></span></span><span><span>
		<span>input</span> <span>{</span>
			<span>color</span><span>:</span> red<span>;</span>
		<span>}</span>
		<span>/*占位符选择器,修改占位符的样式*/</span>
		<span>input::placeholder</span> <span>{</span>
			<span>color</span><span>:</span> yellow<span>;</span>
		<span>}</span>
	</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
<span><span><span>&lt;/</span>head</span><span>></span></span>
<span><span><span>&lt;</span>body</span><span>></span></span>
     <span>&lt;!-- 占位符, 当输入内容的时候,占位符消失, 删除输入的内容,占位符出现 --></span>
	<span><span><span>&lt;</span>input</span> <span>type</span><span><span>=</span><span>"</span>text<span>"</span></span> <span>placeholder</span><span><span>=</span><span>"</span>金装大灰狼<span>"</span></span><span>></span></span>
<span><span><span>&lt;/</span>body</span><span>></span></span>
<span><span><span>&lt;/</span>html</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h1 id="查文档"> 查文档</h1>
<p>经常查阅文档是一个非常好的学习习惯。</p>
<p>W3C :  http://www.w3school.com.cn/</p>
<p>MDN: https://developer.mozilla.org/zh-CN/</p>
]]></content:encoded>
    </item>
    <item>
      <title>defineProperty</title>
      <link>https://wangyawei.top/views/frontEnd/javascript/defineProperty-58/</link>
      <guid>https://wangyawei.top/views/frontEnd/javascript/defineProperty-58/</guid>
      <source url="https://wangyawei.top/rss.xml">defineProperty</source>
      <category>javascript</category>
      <pubDate>Tue, 31 Aug 2021 08:09:22 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p><code>Object.defineProperty()</code> 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性，并返回此对象。</p>
</blockquote>
<div><p>提示</p>
<p>应当直接在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object" target="_blank" rel="noopener noreferrer"><code>Object</code></a> 构造器对象上调用此方法，而不是在任意一个 <code>Object</code> 类型的实例上调用。</p>
</div>
<h2 id="语法"> 语法</h2>
<div><pre><code>Object<span>.</span><span>defineProperty</span><span>(</span>obj<span>,</span> prop<span>,</span> descriptor<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>参数：</strong></p>
<ul>
<li>obj：要定义属性的对象。</li>
<li>prop：要定义或修改的属性的名称或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol" target="_blank" rel="noopener noreferrer"><code>Symbol</code></a> 。</li>
<li>descriptor：要定义或修改的属性描述符。</li>
<li>返回值：被传递给函数的对象。</li>
</ul>
<div><p>提示</p>
<p>在ES6中，由于 Symbol类型的特殊性，用Symbol类型的值来做对象的key与常规的定义或修改不同，而<code>Object.defineProperty</code> 是定义key为Symbol的属性的方法之一。</p>
</div>
<blockquote>
<p>该方法允许精确地添加或修改对象的属性。通过赋值操作添加的普通属性是可枚举的，在枚举对象属性时会被枚举到（<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in" target="_blank" rel="noopener noreferrer"><code>for...in</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="noopener noreferrer"><code>Object.keys</code></a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="noopener noreferrer"> </a>方法），可以改变这些属性的值，也可以<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/delete" target="_blank" rel="noopener noreferrer"><code>删除</code></a>这些属性。这个方法允许修改默认的额外选项（或配置）。默认情况下，使用 <code>Object.defineProperty()</code> 添加的属性值是不可修改（immutable）的。</p>
</blockquote>
<h2 id="描述符"> 描述符</h2>
<blockquote>
<p>对象里目前存在的属性描述符有两种主要形式：<em>数据描述符</em>和<em>存取描述符</em>。</p>
</blockquote>
<p><strong>数据描述符</strong>：是一个具有值的属性，该值可以是可写的，也可以是不可写的。</p>
<p><strong>存取描述符</strong>：是由 getter 函数和 setter 函数所描述的属性。</p>
<div><p>注意</p>
<p>一个描述符只能是这两者其中之一；不能同时是两者。</p>
</div>
<p>这两种描述符都是对象。它们共享以下可选键值（默认值是指在使用 <code>Object.defineProperty()</code> 定义属性时的默认值）：</p>
<ul>
<li><strong>configurable</strong>
<ul>
<li>当且仅当该属性的 <code>configurable</code> 键值为 <code>true</code> 时，该属性的描述符才能够被改变，同时该属性也能从对应的对象上被删除。</li>
<li><strong>默认为</strong> <strong><code>false</code></strong>。</li>
</ul>
</li>
<li><strong>enumerable</strong>
<ul>
<li>当且仅当该属性的 <code>enumerable</code> 键值为 <code>true</code> 时，该属性才会出现在对象的枚举属性中。（<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/for...in" target="_blank" rel="noopener noreferrer"><code>for...in</code></a> 或 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="noopener noreferrer"><code>Object.keys</code></a><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/keys" target="_blank" rel="noopener noreferrer"> </a>方法）</li>
<li><strong>默认为</strong> <strong><code>false</code></strong>。</li>
</ul>
</li>
<li>数据描述符具有以下可选键值：
<ul>
<li><strong>value</strong>
<ul>
<li>该属性对应的值。可以是任何有效的 JavaScript 值（数值，对象，函数等）。</li>
<li><strong>默认为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener noreferrer"><code>undefined</code></a></strong>。</li>
</ul>
</li>
<li><strong>writable</strong>
<ul>
<li>当且仅当该属性的 <code>writable</code> 键值为 <code>true</code> 时，属性的值，也就是上面的 <code>value</code>，才能被改变。</li>
<li><strong>默认为 <code>false</code>。</strong></li>
</ul>
</li>
</ul>
</li>
<li>存取描述符具有以下可选键值：
<ul>
<li><strong>get</strong>
<ul>
<li>属性的 getter 函数，如果没有 getter，则为 <code>undefined</code>。当访问该属性时，会调用此函数。执行时不传入任何参数，但是会传入 <code>this</code> 对象（由于继承关系，这里的<code>this</code>并不一定是定义该属性的对象）。该函数的返回值会被用作属性的值。</li>
<li><strong>默认为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener noreferrer"><code>undefined</code></a></strong>。</li>
</ul>
</li>
<li><strong>set</strong>
<ul>
<li>属性的 setter 函数，如果没有 setter，则为 <code>undefined</code>。当属性值被修改时，会调用此函数。该方法接受一个参数（也就是被赋予的新值），会传入赋值时的 <code>this</code> 对象。</li>
<li><strong>默认为 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener noreferrer"><code>undefined</code></a></strong>。</li>
</ul>
</li>
</ul>
</li>
<li>描述符默认值汇总：
<ul>
<li>拥有布尔值的键 <code>configurable</code>、<code>enumerable</code> 和 <code>writable</code> 的默认值都是 <code>false</code>。</li>
<li>属性值和函数的键 <code>value</code>、<code>get</code> 和 <code>set</code> 字段的默认值为 <code>undefined</code>。</li>
</ul>
</li>
</ul>
<p><strong>描述符可拥有的键值：</strong></p>
<table>
<thead>
<tr>
<th></th>
<th><code>configurable</code></th>
<th><code>enumerable</code></th>
<th><code>value</code></th>
<th><code>writable</code></th>
<th><code>get</code></th>
<th><code>set</code></th>
</tr>
</thead>
<tbody>
<tr>
<td>数据描述符</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
<td>可以</td>
<td>不可以</td>
<td>不可以</td>
</tr>
<tr>
<td>存取描述符</td>
<td>可以</td>
<td>可以</td>
<td>不可以</td>
<td>不可以</td>
<td>可以</td>
<td>可以</td>
</tr>
</tbody>
</table>
<div><p>提示</p>
<p>如果一个描述符不具有 <code>value</code>、<code>writable</code>、<code>get</code> 和 <code>set</code> 中的任意一个键，那么它将被认为是一个数据描述符。如果一个描述符同时拥有 <code>value</code> 或 <code>writable</code> 和 <code>get</code> 或 <code>set</code> 键，则会产生一个异常。</p>
</div>
<h2 id="示例"> 示例</h2>
<h3 id="数据描述符"> 数据描述符</h3>
<p><strong>特有</strong>的两个属性（value,writable）</p>
<div><pre><code><span>let</span> Person <span>=</span> <span>{</span><span>}</span>
Object<span>.</span><span>defineProperty</span><span>(</span>Person<span>,</span> <span>'name'</span><span>,</span> <span>{</span>
    value<span>:</span> <span>'jack'</span><span>,</span>
    writable<span>:</span> <span>false</span> <span>// 是否可写 默认值：false</span>
<span>}</span><span>)</span>

Person<span>.</span>name <span>=</span> <span>'rose'</span>
console<span>.</span><span>log</span><span>(</span>Person<span>.</span>name<span>)</span> <span>// jack</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code><span>let</span> Person <span>=</span> <span>{</span><span>}</span>
Object<span>.</span><span>defineProperty</span><span>(</span>Person<span>,</span> <span>'name'</span><span>,</span> <span>{</span>
    value<span>:</span> <span>'jack'</span><span>,</span>
    writable<span>:</span> <span>true</span> <span>// 是否可写 默认值：false</span>
<span>}</span><span>)</span>

Person<span>.</span>name <span>=</span> <span>'rose'</span>
console<span>.</span><span>log</span><span>(</span>Person<span>.</span>name<span>)</span> <span>// rose</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="存取描述符"> 存取描述符</h3>
<p>由一对 getter、setter 函数功能来描述的属性;</p>
<div><pre><code><span>let</span> Person <span>=</span> <span>{</span><span>}</span><span>;</span>
<span>let</span> temp <span>=</span> <span>null</span><span>;</span>

Object<span>.</span><span>defineProperty</span><span>(</span>Person<span>,</span> <span>'name'</span><span>,</span> <span>{</span>
    <span>get</span><span>:</span> <span>function</span> <span>(</span><span>)</span> <span>{</span>
        <span>return</span> temp<span>;</span>
    <span>}</span><span>,</span>
    <span>set</span><span>:</span> <span>function</span> <span>(</span><span>val</span><span>)</span> <span>{</span>
        temp <span>=</span> val<span>;</span>
    <span>}</span>
<span>}</span><span>)</span><span>;</span>

<span>// Person.name = '早上好';</span>
<span>// console.log(Person.name) // 早上好</span>

console<span>.</span><span>log</span><span>(</span>Person<span>.</span>name<span>)</span> <span>// null</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="共有的属性"> 共有的属性</h3>
<h4 id="configurable-属性"> Configurable 属性</h4>
<p><code>configurable</code> 特性表示对象的属性是否可以被删除，以及可否配置。</p>
<div><pre><code><span>'use strict'</span>
<span>let</span> Person <span>=</span> <span>{</span><span>}</span><span>;</span>
Object<span>.</span><span>defineProperty</span><span>(</span>Person<span>,</span> <span>'name'</span><span>,</span> <span>{</span>
    value<span>:</span> <span>'jack'</span><span>,</span>
    configurable<span>:</span> <span>false</span><span>,</span> <span>// 是否可配置，以及是否可删除</span>
<span>}</span><span>)</span><span>;</span>

<span>delete</span> Person<span>.</span>name <span>// Cannot delete property 'name' of #&lt;Object></span>

<span>// console.log(Person.name) // jack</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><blockquote>
<p>严格模式下删除属性会报错，非严格模式下无法删除。</p>
</blockquote>
<div><pre><code><span>let</span> Person <span>=</span> <span>{</span><span>}</span><span>;</span>

Object<span>.</span><span>defineProperty</span><span>(</span>Person<span>,</span> <span>'name'</span><span>,</span> <span>{</span>
    value<span>:</span> <span>'jack'</span><span>,</span>
    configurable<span>:</span> <span>false</span><span>,</span> <span>// 是否可配置，以及是否可删除</span>
<span>}</span><span>)</span><span>;</span>

Object<span>.</span><span>defineProperty</span><span>(</span>Person<span>,</span> <span>'name'</span><span>,</span> <span>{</span> <span>// Cannot redefine property: name</span>
    value<span>:</span> <span>'jack'</span><span>,</span>
    configurable<span>:</span> <span>false</span><span>,</span>
    writable<span>:</span> <span>true</span><span>,</span> <span>// 是否可写</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><div><pre><code><span>let</span> Person <span>=</span> <span>{</span><span>}</span><span>;</span>

Object<span>.</span><span>defineProperty</span><span>(</span>Person<span>,</span> <span>'name'</span><span>,</span> <span>{</span>
    <span>get</span><span>(</span><span>)</span> <span>{</span>
      <span>return</span> <span>'123'</span>
    <span>}</span><span>,</span>
    configurable<span>:</span> <span>false</span><span>,</span> <span>// 是否可配置，以及是否可删除</span>
<span>}</span><span>)</span><span>;</span>

Object<span>.</span><span>defineProperty</span><span>(</span>Person<span>,</span> <span>'name'</span><span>,</span> <span>{</span> <span>// Cannot redefine property: name</span>
    <span>get</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>'1'</span>
    <span>}</span><span>,</span>
    configurable<span>:</span> <span>false</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><p>总结</p>
<p>configurable: false 时，不能删除当前属性，且不能重新配置当前属性的描述符(有一个小小的意外：可以把writable的状态由true改为false,但是无法由false改为true),但是在writable: true的情况下，可以改变value的值</p>
<p>configurable: true时，可以删除当前属性，可以配置当前属性所有描述符。</p>
</div>
<h4 id="enumerable属性"> enumerable属性</h4>
<p>描述属性是否会出现在for in 或者 Object.keys()的遍历中；</p>
<div><pre><code><span>let</span> Person <span>=</span> <span>{</span><span>}</span><span>;</span>

Object<span>.</span><span>defineProperty</span><span>(</span>Person<span>,</span> <span>'name'</span><span>,</span> <span>{</span>
    value<span>:</span> <span>'jack'</span><span>,</span>
    enumerable<span>:</span> <span>true</span><span>,</span> <span>// 是否可枚举</span>
<span>}</span><span>)</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>keys</span><span>(</span>Person<span>)</span><span>)</span> <span>// ['name']</span>
<span>for</span> <span>(</span><span>const</span> personKey <span>in</span> Person<span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>personKey<span>)</span> <span>// name</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>let</span> Person <span>=</span> <span>{</span><span>}</span><span>;</span>

Object<span>.</span><span>defineProperty</span><span>(</span>Person<span>,</span> <span>'name'</span><span>,</span> <span>{</span>
    value<span>:</span> <span>'jack'</span><span>,</span>
    enumerable<span>:</span> <span>false</span><span>,</span> <span>// 是否可枚举</span>
<span>}</span><span>)</span><span>;</span>

console<span>.</span><span>log</span><span>(</span>Object<span>.</span><span>keys</span><span>(</span>Person<span>)</span><span>)</span> <span>// []</span>
<span>for</span> <span>(</span><span>const</span> personKey <span>in</span> Person<span>)</span> <span>{</span>
    console<span>.</span><span>log</span><span>(</span>personKey<span>)</span> <span>// </span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="和普通对象的差异"> 和普通对象的差异</h3>
<div><pre><code><span>let</span> Person <span>=</span> <span>{</span><span>}</span><span>;</span>
Person<span>.</span>name <span>=</span> <span>'jack'</span><span>;</span>

<span>// 等价于</span>

Object<span>.</span><span>defineProperty</span><span>(</span>Person<span>,</span> <span>'name'</span><span>,</span> <span>{</span>
    value<span>:</span> <span>'jack'</span><span>,</span>
    configurable<span>:</span> <span>true</span><span>,</span>
    enumerable<span>:</span> <span>true</span><span>,</span>
    writable<span>:</span> <span>true</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><div><pre><code><span>let</span> Person <span>=</span> <span>{</span><span>}</span><span>;</span>

Object<span>.</span><span>defineProperty</span><span>(</span>Person<span>,</span> <span>'name'</span><span>,</span> <span>{</span>
    value<span>:</span> <span>'jack'</span><span>,</span>
<span>}</span><span>)</span><span>;</span>

<span>// 等价于</span>

Object<span>.</span><span>defineProperty</span><span>(</span>Person<span>,</span> <span>'name'</span><span>,</span> <span>{</span>
    value<span>:</span> <span>'jack'</span><span>,</span>
    writable<span>:</span> <span>false</span><span>,</span>
    configurable<span>:</span> <span>false</span><span>,</span>
    enumerable<span>:</span> <span>false</span><span>,</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h2 id="参考博文"> 参考博文</h2>
<p>https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty</p>
<p>https://www.jianshu.com/p/8fe1382ba135</p>
]]></content:encoded>
    </item>
  </channel>
</rss>