---
title: 错误处理
category: GoLang
date: 2022-02-24
---



> 错误处理在程序中是必然的问题，因为错误会打断程序的正常执行。在Go语言中为了追求代码优雅，引入defer+recover机制处理错误。

recover:

```go
func recover() interface{}
```

内建函数recover允许程序管理恐慌过程中的Go程。在defer的函数中，执行recover调用会取回传至panic调用的错误值，恢复正常执行，停止恐慌过程。若recover在defer的函数之外被调用，它将不会停止恐慌过程序列。在此情况下，或当该Go程不在恐慌过程中时，或提供给panic的实参为nil时，recover就会返回nil。

看下面一段代码，10/0 实际会报出错误，程序会被中断，无法继续执行。

```go
package main

import "fmt"

func main() {
	test()
	fmt.Println("上面的除法操作执行成功")
}

func test() {
	num1 := 10
	num2 := 0
	result := num1 / num2
	fmt.Println(result)
}
```

```bash
panic: runtime error: integer divide by zero                             
                                                                         
goroutine 1 [running]:                                                   
main.test()                                                              
        E:/goProject/src/goCode/testProject01/unit2/main/main.go:15 +0x11
main.main()                                                              
        E:/goProject/src/goCode/testProject01/unit2/main/main.go:8 +0x19 

Process finished with the exit code 2
```

错误处理：

```go
package main

import "fmt"

func main() {
	test()
	fmt.Println("上面的除法操作执行成功")
}

func test() {
	defer func() {
		// 利用recover内置函数，可以捕获错误
		err := recover()
		// 如果没有捕获错误，返回值为零值：nil
		if err != nil {
			fmt.Println("错误已经捕获")
			fmt.Println("err是：", err)
		}
	}()
	num1 := 10
	num2 := 0
	result := num1 / num2
	fmt.Println(result)
}
```

```bash
错误已经捕获
err是： runtime error: integer divide by zero
上面的除法操作执行成功                       

Process finished with the exit code 0
```

> 通过错误处理我们可以提高程序的健壮性。