---
title: 缓存
category: 计算机网络
date: 2022-10-11
---

> 储存将被用到的数据，让数据访问更快。

## FIFO 缓存策略

> fifo的缓存策略是一种先进先出的缓存方式。核心原则：如果一个数据最先进入缓存中，则应该最早淘汰掉。

```javascript
function memory(f, maxSize = 10) {
  const cache = []

  return (...args) => {
    const hash = args.join(',')

    const item = cache.find(x => x.hash === hash)
    if(item) {
      return item.value
    }

    const result = f(...args)
    cache.push({
      hash,
      value: result
    })

    if(cache.length > maxSize) {
      cache.shift()
    }
    return result
  }
}

function fib(n) {
  if(n === 1 || n === 2) {
    return 1
  }
  return mfib(n-1) + mfib(n-2)
}

const mfib = memory(fib, 10)

console.log(fib(60))
```

在不使用缓存函数时，如果你执行 `fib(45)` 你会明显感觉到等待的时间。但是如果你使用缓存函数 `memory` 那么等待时间基本无感知。

## LRU 缓存策略

> LRU 表示以时间作为参考，淘汰最长时间未被使用的数据。其核心思想是：如果数据最近被访问过，那么将来被访问的几率也更高。

```javascript
function memory(f, maxSize = 10) {
  let cache = []

  return (...args) => {
    const hash = args.join(',')

    const item = cache.find(x => x.hash === hash)
    if(item) {
      item.time = new Date().getTime()
      return item.value
    }

    const result = f(...args)
    cache.push({
      hash,
      value: result,
      time: new Date().getTime()
    })

    if(cache.length > maxSize) {
      let min = Infinity
      let minItem = null
      for(let item of cache) {
        if(item.time <min) {
          min = item.time
          minItem = item
        }
      }
      cache = cache.filter(x => x !== minItem)
    }
    return result
  }

}

function fib(n) {
  if(n === 1 || n === 2) {
    return 1
  }
  return mfib(n-1) + mfib(n-2)
}
const mfib = memory(fib, 10)

console.log(fib(60))
```

## HTTP 缓存

